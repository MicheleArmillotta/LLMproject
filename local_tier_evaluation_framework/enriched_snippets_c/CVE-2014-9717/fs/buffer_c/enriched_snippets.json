[
  {
    "function_name": "recalc_bh_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "3310-3429",
    "snippet": "static void recalc_bh_state(void)\n{\n\tint i;\n\tint tot = 0;\n\n\tif (__this_cpu_inc_return(bh_accounting.ratelimit) - 1 < 4096)\n\t\treturn;\n\t__this_cpu_write(bh_accounting.ratelimit, 0);\n\tfor_each_online_cpu(i)\n\t\ttot += per_cpu(bh_accounting, i).nr;\n\tbuffer_heads_over_limit = (tot > max_buffer_heads);\n}\n\nstruct buffer_head *alloc_buffer_head(gfp_t gfp_flags)\n{\n\tstruct buffer_head *ret = kmem_cache_zalloc(bh_cachep, gfp_flags);\n\tif (ret) {\n\t\tINIT_LIST_HEAD(&ret->b_assoc_buffers);\n\t\tpreempt_disable();\n\t\t__this_cpu_inc(bh_accounting.nr);\n\t\trecalc_bh_state();\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(alloc_buffer_head);\n\nvoid free_buffer_head(struct buffer_head *bh)\n{\n\tBUG_ON(!list_empty(&bh->b_assoc_buffers));\n\tkmem_cache_free(bh_cachep, bh);\n\tpreempt_disable();\n\t__this_cpu_dec(bh_accounting.nr);\n\trecalc_bh_state();\n\tpreempt_enable();\n}\nEXPORT_SYMBOL(free_buffer_head);\n\nstatic void buffer_exit_cpu(int cpu)\n{\n\tint i;\n\tstruct bh_lru *b = &per_cpu(bh_lrus, cpu);\n\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tbrelse(b->bhs[i]);\n\t\tb->bhs[i] = NULL;\n\t}\n\tthis_cpu_add(bh_accounting.nr, per_cpu(bh_accounting, cpu).nr);\n\tper_cpu(bh_accounting, cpu).nr = 0;\n}\n\nstatic int buffer_cpu_notify(struct notifier_block *self,\n\t\t\t      unsigned long action, void *hcpu)\n{\n\tif (action == CPU_DEAD || action == CPU_DEAD_FROZEN)\n\t\tbuffer_exit_cpu((unsigned long)hcpu);\n\treturn NOTIFY_OK;\n}\n\n/**\n * bh_uptodate_or_lock - Test whether the buffer is uptodate\n * @bh: struct buffer_head\n *\n * Return true if the buffer is up-to-date and false,\n * with the buffer locked, if not.\n */\nint bh_uptodate_or_lock(struct buffer_head *bh)\n{\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\treturn 0;\n\t\tunlock_buffer(bh);\n\t}\n\treturn 1;\n}\nEXPORT_SYMBOL(bh_uptodate_or_lock);\n\n/**\n * bh_submit_read - Submit a locked buffer for reading\n * @bh: struct buffer_head\n *\n * Returns zero on success and -EIO on error.\n */\nint bh_submit_read(struct buffer_head *bh)\n{\n\tBUG_ON(!buffer_locked(bh));\n\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\tsubmit_bh(READ, bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn 0;\n\treturn -EIO;\n}\nEXPORT_SYMBOL(bh_submit_read);\n\nvoid __init buffer_init(void)\n{\n\tunsigned long nrpages;\n\n\tbh_cachep = kmem_cache_create(\"buffer_head\",\n\t\t\tsizeof(struct buffer_head), 0,\n\t\t\t\t(SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|\n\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\tNULL);\n\n\t/*\n\t * Limit the bh occupancy to 10% of ZONE_NORMAL\n\t */\n\tnrpages = (nr_free_buffer_pages() * 10) / 100;\n\tmax_buffer_heads = nrpages * (PAGE_SIZE / sizeof(struct buffer_head));\n\thotcpu_notifier(buffer_cpu_notify, 0);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BH_LRU_SIZE\t16"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};",
      "static unsigned long max_buffer_heads;",
      "int buffer_heads_over_limit;",
      "static DEFINE_PER_CPU(struct bh_accounting, bh_accounting) = {0, 0};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hotcpu_notifier",
          "args": [
            "buffer_cpu_notify",
            "0"
          ],
          "line": 3428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_free_buffer_pages",
          "args": [],
          "line": 3426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"buffer_head\"",
            "sizeof(struct buffer_head)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|\n\t\t\t\tSLAB_MEM_SPREAD)",
            "NULL"
          ],
          "line": 3417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPORT_SYMBOL",
          "args": [
            "bh_submit_read"
          ],
          "line": 3411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 3407
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 3406
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "READ",
            "bh"
          ],
          "line": 3405
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 3403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 3399
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_locked(bh)"
          ],
          "line": 3396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 3396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPORT_SYMBOL",
          "args": [
            "bh_uptodate_or_lock"
          ],
          "line": 3386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_exit_cpu",
          "args": [
            "(unsigned long)hcpu"
          ],
          "line": 3365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "bh_accounting",
            "cpu"
          ],
          "line": 3358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_add",
          "args": [
            "bh_accounting.nr",
            "per_cpu(bh_accounting, cpu).nr"
          ],
          "line": 3357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "bh_accounting",
            "cpu"
          ],
          "line": 3357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "b->bhs[i]"
          ],
          "line": 3354
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "bh_lrus",
            "cpu"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPORT_SYMBOL",
          "args": [
            "free_buffer_head"
          ],
          "line": 3346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 3344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recalc_bh_state",
          "args": [],
          "line": 3343
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_bh_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3310-3429",
          "snippet": "static void recalc_bh_state(void)\n{\n\tint i;\n\tint tot = 0;\n\n\tif (__this_cpu_inc_return(bh_accounting.ratelimit) - 1 < 4096)\n\t\treturn;\n\t__this_cpu_write(bh_accounting.ratelimit, 0);\n\tfor_each_online_cpu(i)\n\t\ttot += per_cpu(bh_accounting, i).nr;\n\tbuffer_heads_over_limit = (tot > max_buffer_heads);\n}\n\nstruct buffer_head *alloc_buffer_head(gfp_t gfp_flags)\n{\n\tstruct buffer_head *ret = kmem_cache_zalloc(bh_cachep, gfp_flags);\n\tif (ret) {\n\t\tINIT_LIST_HEAD(&ret->b_assoc_buffers);\n\t\tpreempt_disable();\n\t\t__this_cpu_inc(bh_accounting.nr);\n\t\trecalc_bh_state();\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(alloc_buffer_head);\n\nvoid free_buffer_head(struct buffer_head *bh)\n{\n\tBUG_ON(!list_empty(&bh->b_assoc_buffers));\n\tkmem_cache_free(bh_cachep, bh);\n\tpreempt_disable();\n\t__this_cpu_dec(bh_accounting.nr);\n\trecalc_bh_state();\n\tpreempt_enable();\n}\nEXPORT_SYMBOL(free_buffer_head);\n\nstatic void buffer_exit_cpu(int cpu)\n{\n\tint i;\n\tstruct bh_lru *b = &per_cpu(bh_lrus, cpu);\n\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tbrelse(b->bhs[i]);\n\t\tb->bhs[i] = NULL;\n\t}\n\tthis_cpu_add(bh_accounting.nr, per_cpu(bh_accounting, cpu).nr);\n\tper_cpu(bh_accounting, cpu).nr = 0;\n}\n\nstatic int buffer_cpu_notify(struct notifier_block *self,\n\t\t\t      unsigned long action, void *hcpu)\n{\n\tif (action == CPU_DEAD || action == CPU_DEAD_FROZEN)\n\t\tbuffer_exit_cpu((unsigned long)hcpu);\n\treturn NOTIFY_OK;\n}\n\n/**\n * bh_uptodate_or_lock - Test whether the buffer is uptodate\n * @bh: struct buffer_head\n *\n * Return true if the buffer is up-to-date and false,\n * with the buffer locked, if not.\n */\nint bh_uptodate_or_lock(struct buffer_head *bh)\n{\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\treturn 0;\n\t\tunlock_buffer(bh);\n\t}\n\treturn 1;\n}\nEXPORT_SYMBOL(bh_uptodate_or_lock);\n\n/**\n * bh_submit_read - Submit a locked buffer for reading\n * @bh: struct buffer_head\n *\n * Returns zero on success and -EIO on error.\n */\nint bh_submit_read(struct buffer_head *bh)\n{\n\tBUG_ON(!buffer_locked(bh));\n\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\tsubmit_bh(READ, bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn 0;\n\treturn -EIO;\n}\nEXPORT_SYMBOL(bh_submit_read);\n\nvoid __init buffer_init(void)\n{\n\tunsigned long nrpages;\n\n\tbh_cachep = kmem_cache_create(\"buffer_head\",\n\t\t\tsizeof(struct buffer_head), 0,\n\t\t\t\t(SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|\n\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\tNULL);\n\n\t/*\n\t * Limit the bh occupancy to 10% of ZONE_NORMAL\n\t */\n\tnrpages = (nr_free_buffer_pages() * 10) / 100;\n\tmax_buffer_heads = nrpages * (PAGE_SIZE / sizeof(struct buffer_head));\n\thotcpu_notifier(buffer_cpu_notify, 0);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "bh_accounting.nr"
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 3341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "bh_cachep",
            "bh"
          ],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&bh->b_assoc_buffers)"
          ],
          "line": 3339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&bh->b_assoc_buffers"
          ],
          "line": 3339
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPORT_SYMBOL",
          "args": [
            "alloc_buffer_head"
          ],
          "line": 3335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 3331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "bh_accounting.nr"
          ],
          "line": 3329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 3328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ret->b_assoc_buffers"
          ],
          "line": 3327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "bh_cachep",
            "gfp_flags"
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "bh_accounting.ratelimit",
            "0"
          ],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc_return",
          "args": [
            "bh_accounting.ratelimit"
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\n#define BH_LRU_SIZE\t16\n\nstatic DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};\nstatic unsigned long max_buffer_heads;\nint buffer_heads_over_limit;\nstatic DEFINE_PER_CPU(struct bh_accounting, bh_accounting) = {0, 0};\n\nstatic void recalc_bh_state(void)\n{\n\tint i;\n\tint tot = 0;\n\n\tif (__this_cpu_inc_return(bh_accounting.ratelimit) - 1 < 4096)\n\t\treturn;\n\t__this_cpu_write(bh_accounting.ratelimit, 0);\n\tfor_each_online_cpu(i)\n\t\ttot += per_cpu(bh_accounting, i).nr;\n\tbuffer_heads_over_limit = (tot > max_buffer_heads);\n}\n\nstruct buffer_head *alloc_buffer_head(gfp_t gfp_flags)\n{\n\tstruct buffer_head *ret = kmem_cache_zalloc(bh_cachep, gfp_flags);\n\tif (ret) {\n\t\tINIT_LIST_HEAD(&ret->b_assoc_buffers);\n\t\tpreempt_disable();\n\t\t__this_cpu_inc(bh_accounting.nr);\n\t\trecalc_bh_state();\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(alloc_buffer_head);\n\nvoid free_buffer_head(struct buffer_head *bh)\n{\n\tBUG_ON(!list_empty(&bh->b_assoc_buffers));\n\tkmem_cache_free(bh_cachep, bh);\n\tpreempt_disable();\n\t__this_cpu_dec(bh_accounting.nr);\n\trecalc_bh_state();\n\tpreempt_enable();\n}\nEXPORT_SYMBOL(free_buffer_head);\n\nstatic void buffer_exit_cpu(int cpu)\n{\n\tint i;\n\tstruct bh_lru *b = &per_cpu(bh_lrus, cpu);\n\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tbrelse(b->bhs[i]);\n\t\tb->bhs[i] = NULL;\n\t}\n\tthis_cpu_add(bh_accounting.nr, per_cpu(bh_accounting, cpu).nr);\n\tper_cpu(bh_accounting, cpu).nr = 0;\n}\n\nstatic int buffer_cpu_notify(struct notifier_block *self,\n\t\t\t      unsigned long action, void *hcpu)\n{\n\tif (action == CPU_DEAD || action == CPU_DEAD_FROZEN)\n\t\tbuffer_exit_cpu((unsigned long)hcpu);\n\treturn NOTIFY_OK;\n}\n\n/**\n * bh_uptodate_or_lock - Test whether the buffer is uptodate\n * @bh: struct buffer_head\n *\n * Return true if the buffer is up-to-date and false,\n * with the buffer locked, if not.\n */\nint bh_uptodate_or_lock(struct buffer_head *bh)\n{\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\treturn 0;\n\t\tunlock_buffer(bh);\n\t}\n\treturn 1;\n}\nEXPORT_SYMBOL(bh_uptodate_or_lock);\n\n/**\n * bh_submit_read - Submit a locked buffer for reading\n * @bh: struct buffer_head\n *\n * Returns zero on success and -EIO on error.\n */\nint bh_submit_read(struct buffer_head *bh)\n{\n\tBUG_ON(!buffer_locked(bh));\n\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\tsubmit_bh(READ, bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn 0;\n\treturn -EIO;\n}\nEXPORT_SYMBOL(bh_submit_read);\n\nvoid __init buffer_init(void)\n{\n\tunsigned long nrpages;\n\n\tbh_cachep = kmem_cache_create(\"buffer_head\",\n\t\t\tsizeof(struct buffer_head), 0,\n\t\t\t\t(SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|\n\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\tNULL);\n\n\t/*\n\t * Limit the bh occupancy to 10% of ZONE_NORMAL\n\t */\n\tnrpages = (nr_free_buffer_pages() * 10) / 100;\n\tmax_buffer_heads = nrpages * (PAGE_SIZE / sizeof(struct buffer_head));\n\thotcpu_notifier(buffer_cpu_notify, 0);\n}"
  },
  {
    "function_name": "try_to_free_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "3214-3260",
    "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_buffer_head",
          "args": [
            "bh"
          ],
          "line": 3255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 3248
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_dirty_page",
          "args": [
            "page",
            "PAGE_CACHE_SIZE"
          ],
          "line": 3247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_buffers",
          "args": [
            "page",
            "&buffers_to_free"
          ],
          "line": 3230
        },
        "resolved": true,
        "details": {
          "function_name": "drop_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3185-3212",
          "snippet": "static int\ndrop_buffers(struct page *page, struct buffer_head **buffers_to_free)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tstruct buffer_head *bh;\n\n\tbh = head;\n\tdo {\n\t\tif (buffer_write_io_error(bh) && page->mapping)\n\t\t\tset_bit(AS_EIO, &page->mapping->flags);\n\t\tif (buffer_busy(bh))\n\t\t\tgoto failed;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\n\t\tif (bh->b_assoc_map)\n\t\t\t__remove_assoc_queue(bh);\n\t\tbh = next;\n\t} while (bh != head);\n\t*buffers_to_free = head;\n\t__clear_page_buffers(page);\n\treturn 1;\nfailed:\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int\ndrop_buffers(struct page *page, struct buffer_head **buffers_to_free)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tstruct buffer_head *bh;\n\n\tbh = head;\n\tdo {\n\t\tif (buffer_write_io_error(bh) && page->mapping)\n\t\t\tset_bit(AS_EIO, &page->mapping->flags);\n\t\tif (buffer_busy(bh))\n\t\t\tgoto failed;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\n\t\tif (bh->b_assoc_map)\n\t\t\t__remove_assoc_queue(bh);\n\t\tbh = next;\n\t} while (bh != head);\n\t*buffers_to_free = head;\n\t__clear_page_buffers(page);\n\treturn 1;\nfailed:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 3229
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 3221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 3220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 3220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "drop_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "3185-3212",
    "snippet": "static int\ndrop_buffers(struct page *page, struct buffer_head **buffers_to_free)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tstruct buffer_head *bh;\n\n\tbh = head;\n\tdo {\n\t\tif (buffer_write_io_error(bh) && page->mapping)\n\t\t\tset_bit(AS_EIO, &page->mapping->flags);\n\t\tif (buffer_busy(bh))\n\t\t\tgoto failed;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\n\t\tif (bh->b_assoc_map)\n\t\t\t__remove_assoc_queue(bh);\n\t\tbh = next;\n\t} while (bh != head);\n\t*buffers_to_free = head;\n\t__clear_page_buffers(page);\n\treturn 1;\nfailed:\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_page_buffers",
          "args": [
            "page"
          ],
          "line": 3208
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__remove_assoc_queue",
          "args": [
            "bh"
          ],
          "line": 3204
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_assoc_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "479-486",
          "snippet": "static void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tif (buffer_write_io_error(bh))\n\t\tset_bit(AS_EIO, &bh->b_assoc_map->flags);\n\tbh->b_assoc_map = NULL;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tif (buffer_write_io_error(bh))\n\t\tset_bit(AS_EIO, &bh->b_assoc_map->flags);\n\tbh->b_assoc_map = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_busy",
          "args": [
            "bh"
          ],
          "line": 3195
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3179-3183",
          "snippet": "static inline int buffer_busy(struct buffer_head *bh)\n{\n\treturn atomic_read(&bh->b_count) |\n\t\t(bh->b_state & ((1 << BH_Dirty) | (1 << BH_Lock)));\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic inline int buffer_busy(struct buffer_head *bh)\n{\n\treturn atomic_read(&bh->b_count) |\n\t\t(bh->b_state & ((1 << BH_Dirty) | (1 << BH_Lock)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AS_EIO",
            "&page->mapping->flags"
          ],
          "line": 3194
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 3193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int\ndrop_buffers(struct page *page, struct buffer_head **buffers_to_free)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tstruct buffer_head *bh;\n\n\tbh = head;\n\tdo {\n\t\tif (buffer_write_io_error(bh) && page->mapping)\n\t\t\tset_bit(AS_EIO, &page->mapping->flags);\n\t\tif (buffer_busy(bh))\n\t\t\tgoto failed;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\n\t\tif (bh->b_assoc_map)\n\t\t\t__remove_assoc_queue(bh);\n\t\tbh = next;\n\t} while (bh != head);\n\t*buffers_to_free = head;\n\t__clear_page_buffers(page);\n\treturn 1;\nfailed:\n\treturn 0;\n}"
  },
  {
    "function_name": "buffer_busy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "3179-3183",
    "snippet": "static inline int buffer_busy(struct buffer_head *bh)\n{\n\treturn atomic_read(&bh->b_count) |\n\t\t(bh->b_state & ((1 << BH_Dirty) | (1 << BH_Lock)));\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bh->b_count"
          ],
          "line": 3181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic inline int buffer_busy(struct buffer_head *bh)\n{\n\treturn atomic_read(&bh->b_count) |\n\t\t(bh->b_state & ((1 << BH_Dirty) | (1 << BH_Lock)));\n}"
  },
  {
    "function_name": "sync_dirty_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "3153-3156",
    "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sync_dirty_buffer",
          "args": [
            "bh",
            "WRITE_SYNC"
          ],
          "line": 3155
        },
        "resolved": true,
        "details": {
          "function_name": "__sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3133-3150",
          "snippet": "int __sync_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tint ret = 0;\n\n\tWARN_ON(atomic_read(&bh->b_count) < 1);\n\tlock_buffer(bh);\n\tif (test_clear_buffer_dirty(bh)) {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_write_sync;\n\t\tret = submit_bh(rw, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!ret && !buffer_uptodate(bh))\n\t\t\tret = -EIO;\n\t} else {\n\t\tunlock_buffer(bh);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __sync_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tint ret = 0;\n\n\tWARN_ON(atomic_read(&bh->b_count) < 1);\n\tlock_buffer(bh);\n\tif (test_clear_buffer_dirty(bh)) {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_write_sync;\n\t\tret = submit_bh(rw, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!ret && !buffer_uptodate(bh))\n\t\t\tret = -EIO;\n\t} else {\n\t\tunlock_buffer(bh);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
  },
  {
    "function_name": "__sync_dirty_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "3133-3150",
    "snippet": "int __sync_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tint ret = 0;\n\n\tWARN_ON(atomic_read(&bh->b_count) < 1);\n\tlock_buffer(bh);\n\tif (test_clear_buffer_dirty(bh)) {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_write_sync;\n\t\tret = submit_bh(rw, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!ret && !buffer_uptodate(bh))\n\t\t\tret = -EIO;\n\t} else {\n\t\tunlock_buffer(bh);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 3147
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 3144
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "rw",
            "bh"
          ],
          "line": 3142
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 3140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 3139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&bh->b_count) < 1"
          ],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bh->b_count"
          ],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __sync_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tint ret = 0;\n\n\tWARN_ON(atomic_read(&bh->b_count) < 1);\n\tlock_buffer(bh);\n\tif (test_clear_buffer_dirty(bh)) {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_write_sync;\n\t\tret = submit_bh(rw, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!ret && !buffer_uptodate(bh))\n\t\t\tret = -EIO;\n\t} else {\n\t\tunlock_buffer(bh);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "write_dirty_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "3115-3125",
    "snippet": "void write_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(rw, bh);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "rw",
            "bh"
          ],
          "line": 3124
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 3123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 3119
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 3118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid write_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(rw, bh);\n}"
  },
  {
    "function_name": "ll_rw_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "3086-3112",
    "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 3110
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "rw",
            "bh"
          ],
          "line": 3106
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 3105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 3103
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 3096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_buffer",
          "args": [
            "bh"
          ],
          "line": 3093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
  },
  {
    "function_name": "submit_bh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "3055-3058",
    "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_submit_bh",
          "args": [
            "rw",
            "bh",
            "0"
          ],
          "line": 3057
        },
        "resolved": true,
        "details": {
          "function_name": "_submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3000-3052",
          "snippet": "int _submit_bh(int rw, struct buffer_head *bh, unsigned long bio_flags)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\n\tBUG_ON(!buffer_locked(bh));\n\tBUG_ON(!buffer_mapped(bh));\n\tBUG_ON(!bh->b_end_io);\n\tBUG_ON(buffer_delay(bh));\n\tBUG_ON(buffer_unwritten(bh));\n\n\t/*\n\t * Only clear out a write error when rewriting\n\t */\n\tif (test_set_buffer_req(bh) && (rw & WRITE))\n\t\tclear_buffer_write_io_error(bh);\n\n\t/*\n\t * from here on down, it's all bio -- do the initial mapping,\n\t * submit_bio -> generic_make_request may further map this bio around\n\t */\n\tbio = bio_alloc(GFP_NOIO, 1);\n\n\tbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\n\tbio->bi_bdev = bh->b_bdev;\n\tbio->bi_io_vec[0].bv_page = bh->b_page;\n\tbio->bi_io_vec[0].bv_len = bh->b_size;\n\tbio->bi_io_vec[0].bv_offset = bh_offset(bh);\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = bh->b_size;\n\n\tbio->bi_end_io = end_bio_bh_io_sync;\n\tbio->bi_private = bh;\n\tbio->bi_flags |= bio_flags;\n\n\t/* Take care of bh's that straddle the end of the device */\n\tguard_bio_eod(rw, bio);\n\n\tif (buffer_meta(bh))\n\t\trw |= REQ_META;\n\tif (buffer_prio(bh))\n\t\trw |= REQ_PRIO;\n\n\tbio_get(bio);\n\tsubmit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\n\tbio_put(bio);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint _submit_bh(int rw, struct buffer_head *bh, unsigned long bio_flags)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\n\tBUG_ON(!buffer_locked(bh));\n\tBUG_ON(!buffer_mapped(bh));\n\tBUG_ON(!bh->b_end_io);\n\tBUG_ON(buffer_delay(bh));\n\tBUG_ON(buffer_unwritten(bh));\n\n\t/*\n\t * Only clear out a write error when rewriting\n\t */\n\tif (test_set_buffer_req(bh) && (rw & WRITE))\n\t\tclear_buffer_write_io_error(bh);\n\n\t/*\n\t * from here on down, it's all bio -- do the initial mapping,\n\t * submit_bio -> generic_make_request may further map this bio around\n\t */\n\tbio = bio_alloc(GFP_NOIO, 1);\n\n\tbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\n\tbio->bi_bdev = bh->b_bdev;\n\tbio->bi_io_vec[0].bv_page = bh->b_page;\n\tbio->bi_io_vec[0].bv_len = bh->b_size;\n\tbio->bi_io_vec[0].bv_offset = bh_offset(bh);\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = bh->b_size;\n\n\tbio->bi_end_io = end_bio_bh_io_sync;\n\tbio->bi_private = bh;\n\tbio->bi_flags |= bio_flags;\n\n\t/* Take care of bh's that straddle the end of the device */\n\tguard_bio_eod(rw, bio);\n\n\tif (buffer_meta(bh))\n\t\trw |= REQ_META;\n\tif (buffer_prio(bh))\n\t\trw |= REQ_PRIO;\n\n\tbio_get(bio);\n\tsubmit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\n\tbio_put(bio);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
  },
  {
    "function_name": "_submit_bh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "3000-3052",
    "snippet": "int _submit_bh(int rw, struct buffer_head *bh, unsigned long bio_flags)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\n\tBUG_ON(!buffer_locked(bh));\n\tBUG_ON(!buffer_mapped(bh));\n\tBUG_ON(!bh->b_end_io);\n\tBUG_ON(buffer_delay(bh));\n\tBUG_ON(buffer_unwritten(bh));\n\n\t/*\n\t * Only clear out a write error when rewriting\n\t */\n\tif (test_set_buffer_req(bh) && (rw & WRITE))\n\t\tclear_buffer_write_io_error(bh);\n\n\t/*\n\t * from here on down, it's all bio -- do the initial mapping,\n\t * submit_bio -> generic_make_request may further map this bio around\n\t */\n\tbio = bio_alloc(GFP_NOIO, 1);\n\n\tbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\n\tbio->bi_bdev = bh->b_bdev;\n\tbio->bi_io_vec[0].bv_page = bh->b_page;\n\tbio->bi_io_vec[0].bv_len = bh->b_size;\n\tbio->bi_io_vec[0].bv_offset = bh_offset(bh);\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = bh->b_size;\n\n\tbio->bi_end_io = end_bio_bh_io_sync;\n\tbio->bi_private = bh;\n\tbio->bi_flags |= bio_flags;\n\n\t/* Take care of bh's that straddle the end of the device */\n\tguard_bio_eod(rw, bio);\n\n\tif (buffer_meta(bh))\n\t\trw |= REQ_META;\n\tif (buffer_prio(bh))\n\t\trw |= REQ_PRIO;\n\n\tbio_get(bio);\n\tsubmit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\n\tbio_put(bio);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 3050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_flagged",
          "args": [
            "bio",
            "BIO_EOPNOTSUPP"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "rw",
            "bio"
          ],
          "line": 3045
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-115",
          "snippet": "static struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_get",
          "args": [
            "bio"
          ],
          "line": 3044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_prio",
          "args": [
            "bh"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_meta",
          "args": [
            "bh"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guard_bio_eod",
          "args": [
            "rw",
            "bio"
          ],
          "line": 3037
        },
        "resolved": true,
        "details": {
          "function_name": "guard_bio_eod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2964-2998",
          "snippet": "void guard_bio_eod(int rw, struct bio *bio)\n{\n\tsector_t maxsector;\n\tstruct bio_vec *bvec = &bio->bi_io_vec[bio->bi_vcnt - 1];\n\tunsigned truncated_bytes;\n\n\tmaxsector = i_size_read(bio->bi_bdev->bd_inode) >> 9;\n\tif (!maxsector)\n\t\treturn;\n\n\t/*\n\t * If the *whole* IO is past the end of the device,\n\t * let it through, and the IO layer will turn it into\n\t * an EIO.\n\t */\n\tif (unlikely(bio->bi_iter.bi_sector >= maxsector))\n\t\treturn;\n\n\tmaxsector -= bio->bi_iter.bi_sector;\n\tif (likely((bio->bi_iter.bi_size >> 9) <= maxsector))\n\t\treturn;\n\n\t/* Uhhuh. We've got a bio that straddles the device size! */\n\ttruncated_bytes = bio->bi_iter.bi_size - (maxsector << 9);\n\n\t/* Truncate the bio.. */\n\tbio->bi_iter.bi_size -= truncated_bytes;\n\tbvec->bv_len -= truncated_bytes;\n\n\t/* ..and clear the end of the buffer for reads */\n\tif ((rw & RW_MASK) == READ) {\n\t\tzero_user(bvec->bv_page, bvec->bv_offset + bvec->bv_len,\n\t\t\t\ttruncated_bytes);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid guard_bio_eod(int rw, struct bio *bio)\n{\n\tsector_t maxsector;\n\tstruct bio_vec *bvec = &bio->bi_io_vec[bio->bi_vcnt - 1];\n\tunsigned truncated_bytes;\n\n\tmaxsector = i_size_read(bio->bi_bdev->bd_inode) >> 9;\n\tif (!maxsector)\n\t\treturn;\n\n\t/*\n\t * If the *whole* IO is past the end of the device,\n\t * let it through, and the IO layer will turn it into\n\t * an EIO.\n\t */\n\tif (unlikely(bio->bi_iter.bi_sector >= maxsector))\n\t\treturn;\n\n\tmaxsector -= bio->bi_iter.bi_sector;\n\tif (likely((bio->bi_iter.bi_size >> 9) <= maxsector))\n\t\treturn;\n\n\t/* Uhhuh. We've got a bio that straddles the device size! */\n\ttruncated_bytes = bio->bi_iter.bi_size - (maxsector << 9);\n\n\t/* Truncate the bio.. */\n\tbio->bi_iter.bi_size -= truncated_bytes;\n\tbvec->bv_len -= truncated_bytes;\n\n\t/* ..and clear the end of the buffer for reads */\n\tif ((rw & RW_MASK) == READ) {\n\t\tzero_user(bvec->bv_page, bvec->bv_offset + bvec->bv_len,\n\t\t\t\ttruncated_bytes);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_NOIO",
            "1"
          ],
          "line": 3021
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 3015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_set_buffer_req",
          "args": [
            "bh"
          ],
          "line": 3014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "buffer_unwritten(bh)"
          ],
          "line": 3009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 3009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "buffer_delay(bh)"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bh->b_end_io"
          ],
          "line": 3007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_mapped(bh)"
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_locked(bh)"
          ],
          "line": 3005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 3005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint _submit_bh(int rw, struct buffer_head *bh, unsigned long bio_flags)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\n\tBUG_ON(!buffer_locked(bh));\n\tBUG_ON(!buffer_mapped(bh));\n\tBUG_ON(!bh->b_end_io);\n\tBUG_ON(buffer_delay(bh));\n\tBUG_ON(buffer_unwritten(bh));\n\n\t/*\n\t * Only clear out a write error when rewriting\n\t */\n\tif (test_set_buffer_req(bh) && (rw & WRITE))\n\t\tclear_buffer_write_io_error(bh);\n\n\t/*\n\t * from here on down, it's all bio -- do the initial mapping,\n\t * submit_bio -> generic_make_request may further map this bio around\n\t */\n\tbio = bio_alloc(GFP_NOIO, 1);\n\n\tbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\n\tbio->bi_bdev = bh->b_bdev;\n\tbio->bi_io_vec[0].bv_page = bh->b_page;\n\tbio->bi_io_vec[0].bv_len = bh->b_size;\n\tbio->bi_io_vec[0].bv_offset = bh_offset(bh);\n\n\tbio->bi_vcnt = 1;\n\tbio->bi_iter.bi_size = bh->b_size;\n\n\tbio->bi_end_io = end_bio_bh_io_sync;\n\tbio->bi_private = bh;\n\tbio->bi_flags |= bio_flags;\n\n\t/* Take care of bh's that straddle the end of the device */\n\tguard_bio_eod(rw, bio);\n\n\tif (buffer_meta(bh))\n\t\trw |= REQ_META;\n\tif (buffer_prio(bh))\n\t\trw |= REQ_PRIO;\n\n\tbio_get(bio);\n\tsubmit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\n\tbio_put(bio);\n\treturn ret;\n}"
  },
  {
    "function_name": "guard_bio_eod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2964-2998",
    "snippet": "void guard_bio_eod(int rw, struct bio *bio)\n{\n\tsector_t maxsector;\n\tstruct bio_vec *bvec = &bio->bi_io_vec[bio->bi_vcnt - 1];\n\tunsigned truncated_bytes;\n\n\tmaxsector = i_size_read(bio->bi_bdev->bd_inode) >> 9;\n\tif (!maxsector)\n\t\treturn;\n\n\t/*\n\t * If the *whole* IO is past the end of the device,\n\t * let it through, and the IO layer will turn it into\n\t * an EIO.\n\t */\n\tif (unlikely(bio->bi_iter.bi_sector >= maxsector))\n\t\treturn;\n\n\tmaxsector -= bio->bi_iter.bi_sector;\n\tif (likely((bio->bi_iter.bi_size >> 9) <= maxsector))\n\t\treturn;\n\n\t/* Uhhuh. We've got a bio that straddles the device size! */\n\ttruncated_bytes = bio->bi_iter.bi_size - (maxsector << 9);\n\n\t/* Truncate the bio.. */\n\tbio->bi_iter.bi_size -= truncated_bytes;\n\tbvec->bv_len -= truncated_bytes;\n\n\t/* ..and clear the end of the buffer for reads */\n\tif ((rw & RW_MASK) == READ) {\n\t\tzero_user(bvec->bv_page, bvec->bv_offset + bvec->bv_len,\n\t\t\t\ttruncated_bytes);\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "bvec->bv_page",
            "bvec->bv_offset + bvec->bv_len",
            "truncated_bytes"
          ],
          "line": 2995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "(bio->bi_iter.bi_size >> 9) <= maxsector"
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bio->bi_iter.bi_sector >= maxsector"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "bio->bi_bdev->bd_inode"
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid guard_bio_eod(int rw, struct bio *bio)\n{\n\tsector_t maxsector;\n\tstruct bio_vec *bvec = &bio->bi_io_vec[bio->bi_vcnt - 1];\n\tunsigned truncated_bytes;\n\n\tmaxsector = i_size_read(bio->bi_bdev->bd_inode) >> 9;\n\tif (!maxsector)\n\t\treturn;\n\n\t/*\n\t * If the *whole* IO is past the end of the device,\n\t * let it through, and the IO layer will turn it into\n\t * an EIO.\n\t */\n\tif (unlikely(bio->bi_iter.bi_sector >= maxsector))\n\t\treturn;\n\n\tmaxsector -= bio->bi_iter.bi_sector;\n\tif (likely((bio->bi_iter.bi_size >> 9) <= maxsector))\n\t\treturn;\n\n\t/* Uhhuh. We've got a bio that straddles the device size! */\n\ttruncated_bytes = bio->bi_iter.bi_size - (maxsector << 9);\n\n\t/* Truncate the bio.. */\n\tbio->bi_iter.bi_size -= truncated_bytes;\n\tbvec->bv_len -= truncated_bytes;\n\n\t/* ..and clear the end of the buffer for reads */\n\tif ((rw & RW_MASK) == READ) {\n\t\tzero_user(bvec->bv_page, bvec->bv_offset + bvec->bv_len,\n\t\t\t\ttruncated_bytes);\n\t}\n}"
  },
  {
    "function_name": "end_bio_bh_io_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2937-2950",
    "snippet": "static void end_bio_bh_io_sync(struct bio *bio, int err)\n{\n\tstruct buffer_head *bh = bio->bi_private;\n\n\tif (err == -EOPNOTSUPP) {\n\t\tset_bit(BIO_EOPNOTSUPP, &bio->bi_flags);\n\t}\n\n\tif (unlikely (test_bit(BIO_QUIET,&bio->bi_flags)))\n\t\tset_bit(BH_Quiet, &bh->b_state);\n\n\tbh->b_end_io(bh, test_bit(BIO_UPTODATE, &bio->bi_flags));\n\tbio_put(bio);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh->b_end_io",
          "args": [
            "bh",
            "test_bit(BIO_UPTODATE, &bio->bi_flags)"
          ],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BIO_UPTODATE",
            "&bio->bi_flags"
          ],
          "line": 2948
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BH_Quiet",
            "&bh->b_state"
          ],
          "line": 2946
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_bit(BIO_QUIET,&bio->bi_flags)"
          ],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void end_bio_bh_io_sync(struct bio *bio, int err)\n{\n\tstruct buffer_head *bh = bio->bi_private;\n\n\tif (err == -EOPNOTSUPP) {\n\t\tset_bit(BIO_EOPNOTSUPP, &bio->bi_flags);\n\t}\n\n\tif (unlikely (test_bit(BIO_QUIET,&bio->bi_flags)))\n\t\tset_bit(BH_Quiet, &bh->b_state);\n\n\tbh->b_end_io(bh, test_bit(BIO_UPTODATE, &bio->bi_flags));\n\tbio_put(bio);\n}"
  },
  {
    "function_name": "generic_block_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2924-2934",
    "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_block",
          "args": [
            "inode",
            "block",
            "&tmp",
            "0"
          ],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "139-147",
          "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
  },
  {
    "function_name": "block_write_full_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2885-2921",
    "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__block_write_full_page",
          "args": [
            "inode",
            "page",
            "get_block",
            "wbc",
            "end_buffer_async_write"
          ],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1677-1838",
          "snippet": "static int __block_write_full_page(struct inode *inode, struct page *page,\n\t\t\tget_block_t *get_block, struct writeback_control *wbc,\n\t\t\tbh_end_io_t *handler)\n{\n\tint err;\n\tsector_t block;\n\tsector_t last_block;\n\tstruct buffer_head *bh, *head;\n\tunsigned int blocksize, bbits;\n\tint nr_underway = 0;\n\tint write_op = (wbc->sync_mode == WB_SYNC_ALL ?\n\t\t\tWRITE_SYNC : WRITE);\n\n\thead = create_page_buffers(page, inode,\n\t\t\t\t\t(1 << BH_Dirty)|(1 << BH_Uptodate));\n\n\t/*\n\t * Be very careful.  We have no exclusion from __set_page_dirty_buffers\n\t * here, and the (potentially unmapped) buffers may become dirty at\n\t * any time.  If a buffer becomes dirty here after we've inspected it\n\t * then we just miss that fact, and the page stays dirty.\n\t *\n\t * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;\n\t * handle that here by just cleaning them.\n\t */\n\n\tbh = head;\n\tblocksize = bh->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlast_block = (i_size_read(inode) - 1) >> bbits;\n\n\t/*\n\t * Get all the dirty buffers mapped to disk addresses and\n\t * handle any aliases from the underlying blockdev's mapping.\n\t */\n\tdo {\n\t\tif (block > last_block) {\n\t\t\t/*\n\t\t\t * mapped buffers outside i_size will occur, because\n\t\t\t * this page can be outside i_size when there is a\n\t\t\t * truncate in progress.\n\t\t\t */\n\t\t\t/*\n\t\t\t * The buffer was zeroed by block_write_full_page()\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t} else if ((!buffer_mapped(bh) || buffer_delay(bh)) &&\n\t\t\t   buffer_dirty(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tgoto recover;\n\t\t\tclear_buffer_delay(bh);\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\t/* blockdev mappings never come here */\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tblock++;\n\t} while (bh != head);\n\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tcontinue;\n\t\t/*\n\t\t * If it's a fully non-blocking write attempt and we cannot\n\t\t * lock the buffer then redirty the page.  Note that this can\n\t\t * potentially cause a busy-wait loop from writeback threads\n\t\t * and kswapd activity, but those code paths have their own\n\t\t * higher-level throttling.\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\tlock_buffer(bh);\n\t\t} else if (!trylock_buffer(bh)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tcontinue;\n\t\t}\n\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/*\n\t * The page and its buffers are protected by PageWriteback(), so we can\n\t * drop the bh refcounts early.\n\t */\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh(write_op, bh);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\n\terr = 0;\ndone:\n\tif (nr_underway == 0) {\n\t\t/*\n\t\t * The page was marked dirty, but the buffers were\n\t\t * clean.  Someone wrote them back by hand with\n\t\t * ll_rw_block/submit_bh.  A rare case.\n\t\t */\n\t\tend_page_writeback(page);\n\n\t\t/*\n\t\t * The page and buffer_heads can be released at any time from\n\t\t * here on.\n\t\t */\n\t}\n\treturn err;\n\nrecover:\n\t/*\n\t * ENOSPC, or some other error.  We may already have added some\n\t * blocks to the file, so we need to write these out to avoid\n\t * exposing stale data.\n\t * The page is currently locked and not marked for writeback\n\t */\n\tbh = head;\n\t/* Recovery: lock and submit the mapped buffers */\n\tdo {\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh) &&\n\t\t    !buffer_delay(bh)) {\n\t\t\tlock_buffer(bh);\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The buffer may have been set dirty during\n\t\t\t * attachment to a dirty page.\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\tSetPageError(page);\n\tBUG_ON(PageWriteback(page));\n\tmapping_set_error(page->mapping, err);\n\tset_page_writeback(page);\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tsubmit_bh(write_op, bh);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\tgoto done;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int __block_write_full_page(struct inode *inode, struct page *page,\n\t\t\tget_block_t *get_block, struct writeback_control *wbc,\n\t\t\tbh_end_io_t *handler)\n{\n\tint err;\n\tsector_t block;\n\tsector_t last_block;\n\tstruct buffer_head *bh, *head;\n\tunsigned int blocksize, bbits;\n\tint nr_underway = 0;\n\tint write_op = (wbc->sync_mode == WB_SYNC_ALL ?\n\t\t\tWRITE_SYNC : WRITE);\n\n\thead = create_page_buffers(page, inode,\n\t\t\t\t\t(1 << BH_Dirty)|(1 << BH_Uptodate));\n\n\t/*\n\t * Be very careful.  We have no exclusion from __set_page_dirty_buffers\n\t * here, and the (potentially unmapped) buffers may become dirty at\n\t * any time.  If a buffer becomes dirty here after we've inspected it\n\t * then we just miss that fact, and the page stays dirty.\n\t *\n\t * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;\n\t * handle that here by just cleaning them.\n\t */\n\n\tbh = head;\n\tblocksize = bh->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlast_block = (i_size_read(inode) - 1) >> bbits;\n\n\t/*\n\t * Get all the dirty buffers mapped to disk addresses and\n\t * handle any aliases from the underlying blockdev's mapping.\n\t */\n\tdo {\n\t\tif (block > last_block) {\n\t\t\t/*\n\t\t\t * mapped buffers outside i_size will occur, because\n\t\t\t * this page can be outside i_size when there is a\n\t\t\t * truncate in progress.\n\t\t\t */\n\t\t\t/*\n\t\t\t * The buffer was zeroed by block_write_full_page()\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t} else if ((!buffer_mapped(bh) || buffer_delay(bh)) &&\n\t\t\t   buffer_dirty(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tgoto recover;\n\t\t\tclear_buffer_delay(bh);\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\t/* blockdev mappings never come here */\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tblock++;\n\t} while (bh != head);\n\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tcontinue;\n\t\t/*\n\t\t * If it's a fully non-blocking write attempt and we cannot\n\t\t * lock the buffer then redirty the page.  Note that this can\n\t\t * potentially cause a busy-wait loop from writeback threads\n\t\t * and kswapd activity, but those code paths have their own\n\t\t * higher-level throttling.\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\tlock_buffer(bh);\n\t\t} else if (!trylock_buffer(bh)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tcontinue;\n\t\t}\n\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/*\n\t * The page and its buffers are protected by PageWriteback(), so we can\n\t * drop the bh refcounts early.\n\t */\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh(write_op, bh);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\n\terr = 0;\ndone:\n\tif (nr_underway == 0) {\n\t\t/*\n\t\t * The page was marked dirty, but the buffers were\n\t\t * clean.  Someone wrote them back by hand with\n\t\t * ll_rw_block/submit_bh.  A rare case.\n\t\t */\n\t\tend_page_writeback(page);\n\n\t\t/*\n\t\t * The page and buffer_heads can be released at any time from\n\t\t * here on.\n\t\t */\n\t}\n\treturn err;\n\nrecover:\n\t/*\n\t * ENOSPC, or some other error.  We may already have added some\n\t * blocks to the file, so we need to write these out to avoid\n\t * exposing stale data.\n\t * The page is currently locked and not marked for writeback\n\t */\n\tbh = head;\n\t/* Recovery: lock and submit the mapped buffers */\n\tdo {\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh) &&\n\t\t    !buffer_delay(bh)) {\n\t\t\tlock_buffer(bh);\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The buffer may have been set dirty during\n\t\t\t * attachment to a dirty page.\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\tSetPageError(page);\n\tBUG_ON(PageWriteback(page));\n\tmapping_set_error(page->mapping, err);\n\tset_page_writeback(page);\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tsubmit_bh(write_op, bh);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\tgoto done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "offset",
            "PAGE_CACHE_SIZE"
          ],
          "line": 2918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_invalidatepage",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
  },
  {
    "function_name": "block_truncate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2806-2879",
    "snippet": "int block_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (!buffer_mapped(bh)) {\n\t\tWARN_ON(bh->b_size != blocksize);\n\t\terr = get_block(inode, iblock, bh, 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh) && !buffer_delay(bh) && !buffer_unwritten(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tzero_user(page, offset, length);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2875
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "offset",
            "length"
          ],
          "line": 2870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2866
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 2864
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ",
            "1",
            "&bh"
          ],
          "line": 2863
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_block",
          "args": [
            "inode",
            "iblock",
            "bh",
            "0"
          ],
          "line": 2849
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "139-147",
          "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "bh->b_size != blocksize"
          ],
          "line": 2848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 2838
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "blocksize",
            "0"
          ],
          "line": 2835
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1564-1591",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (!buffer_mapped(bh)) {\n\t\tWARN_ON(bh->b_size != blocksize);\n\t\terr = get_block(inode, iblock, bh, 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh) && !buffer_delay(bh) && !buffer_unwritten(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tzero_user(page, offset, length);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "nobh_truncate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2728-2803",
    "snippet": "int nobh_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head map_bh;\n\tint err;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (page_has_buffers(page)) {\nhas_buffers:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn block_truncate_page(mapping, from, get_block);\n\t}\n\n\t/* Find the buffer that contains \"offset\" */\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\tmap_bh.b_size = blocksize;\n\tmap_bh.b_state = 0;\n\terr = get_block(inode, iblock, &map_bh, 0);\n\tif (err)\n\t\tgoto unlock;\n\t/* unmapped? It's a hole - nothing to do */\n\tif (!buffer_mapped(&map_bh))\n\t\tgoto unlock;\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (!PageUptodate(page)) {\n\t\terr = mapping->a_ops->readpage(NULL, page);\n\t\tif (err) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto out;\n\t\t}\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\terr = -EIO;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (page_has_buffers(page))\n\t\t\tgoto has_buffers;\n\t}\n\tzero_user(page, offset, length);\n\tset_page_dirty(page);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_dirty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "668-692",
          "snippet": "int __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\treturn newly_dirty;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\treturn newly_dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "offset",
            "length"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->readpage",
          "args": [
            "NULL",
            "page"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "&map_bh"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_block",
          "args": [
            "inode",
            "iblock",
            "&map_bh",
            "0"
          ],
          "line": 2772
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "139-147",
          "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_truncate_page",
          "args": [
            "mapping",
            "from",
            "get_block"
          ],
          "line": 2760
        },
        "resolved": true,
        "details": {
          "function_name": "block_truncate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2806-2879",
          "snippet": "int block_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (!buffer_mapped(bh)) {\n\t\tWARN_ON(bh->b_size != blocksize);\n\t\terr = get_block(inode, iblock, bh, 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh) && !buffer_delay(bh) && !buffer_unwritten(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tzero_user(page, offset, length);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (!buffer_mapped(bh)) {\n\t\tWARN_ON(bh->b_size != blocksize);\n\t\terr = get_block(inode, iblock, bh, 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh) && !buffer_delay(bh) && !buffer_unwritten(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tzero_user(page, offset, length);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint nobh_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head map_bh;\n\tint err;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (page_has_buffers(page)) {\nhas_buffers:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn block_truncate_page(mapping, from, get_block);\n\t}\n\n\t/* Find the buffer that contains \"offset\" */\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\tmap_bh.b_size = blocksize;\n\tmap_bh.b_state = 0;\n\terr = get_block(inode, iblock, &map_bh, 0);\n\tif (err)\n\t\tgoto unlock;\n\t/* unmapped? It's a hole - nothing to do */\n\tif (!buffer_mapped(&map_bh))\n\t\tgoto unlock;\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (!PageUptodate(page)) {\n\t\terr = mapping->a_ops->readpage(NULL, page);\n\t\tif (err) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto out;\n\t\t}\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\terr = -EIO;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (page_has_buffers(page))\n\t\t\tgoto has_buffers;\n\t}\n\tzero_user(page, offset, length);\n\tset_page_dirty(page);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "nobh_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2681-2725",
    "snippet": "int nobh_writepage(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\tint ret;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\tgoto out;\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n#if 0\n\t\t/* Not really sure about this  - do we need this ? */\n\t\tif (page->mapping->a_ops->invalidatepage)\n\t\t\tpage->mapping->a_ops->invalidatepage(page, offset);\n#endif\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\nout:\n\tret = mpage_writepage(page, get_block, wbc);\n\tif (ret == -EAGAIN)\n\t\tret = __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t      end_buffer_async_write);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__block_write_full_page",
          "args": [
            "inode",
            "page",
            "get_block",
            "wbc",
            "end_buffer_async_write"
          ],
          "line": 2722
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1677-1838",
          "snippet": "static int __block_write_full_page(struct inode *inode, struct page *page,\n\t\t\tget_block_t *get_block, struct writeback_control *wbc,\n\t\t\tbh_end_io_t *handler)\n{\n\tint err;\n\tsector_t block;\n\tsector_t last_block;\n\tstruct buffer_head *bh, *head;\n\tunsigned int blocksize, bbits;\n\tint nr_underway = 0;\n\tint write_op = (wbc->sync_mode == WB_SYNC_ALL ?\n\t\t\tWRITE_SYNC : WRITE);\n\n\thead = create_page_buffers(page, inode,\n\t\t\t\t\t(1 << BH_Dirty)|(1 << BH_Uptodate));\n\n\t/*\n\t * Be very careful.  We have no exclusion from __set_page_dirty_buffers\n\t * here, and the (potentially unmapped) buffers may become dirty at\n\t * any time.  If a buffer becomes dirty here after we've inspected it\n\t * then we just miss that fact, and the page stays dirty.\n\t *\n\t * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;\n\t * handle that here by just cleaning them.\n\t */\n\n\tbh = head;\n\tblocksize = bh->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlast_block = (i_size_read(inode) - 1) >> bbits;\n\n\t/*\n\t * Get all the dirty buffers mapped to disk addresses and\n\t * handle any aliases from the underlying blockdev's mapping.\n\t */\n\tdo {\n\t\tif (block > last_block) {\n\t\t\t/*\n\t\t\t * mapped buffers outside i_size will occur, because\n\t\t\t * this page can be outside i_size when there is a\n\t\t\t * truncate in progress.\n\t\t\t */\n\t\t\t/*\n\t\t\t * The buffer was zeroed by block_write_full_page()\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t} else if ((!buffer_mapped(bh) || buffer_delay(bh)) &&\n\t\t\t   buffer_dirty(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tgoto recover;\n\t\t\tclear_buffer_delay(bh);\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\t/* blockdev mappings never come here */\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tblock++;\n\t} while (bh != head);\n\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tcontinue;\n\t\t/*\n\t\t * If it's a fully non-blocking write attempt and we cannot\n\t\t * lock the buffer then redirty the page.  Note that this can\n\t\t * potentially cause a busy-wait loop from writeback threads\n\t\t * and kswapd activity, but those code paths have their own\n\t\t * higher-level throttling.\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\tlock_buffer(bh);\n\t\t} else if (!trylock_buffer(bh)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tcontinue;\n\t\t}\n\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/*\n\t * The page and its buffers are protected by PageWriteback(), so we can\n\t * drop the bh refcounts early.\n\t */\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh(write_op, bh);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\n\terr = 0;\ndone:\n\tif (nr_underway == 0) {\n\t\t/*\n\t\t * The page was marked dirty, but the buffers were\n\t\t * clean.  Someone wrote them back by hand with\n\t\t * ll_rw_block/submit_bh.  A rare case.\n\t\t */\n\t\tend_page_writeback(page);\n\n\t\t/*\n\t\t * The page and buffer_heads can be released at any time from\n\t\t * here on.\n\t\t */\n\t}\n\treturn err;\n\nrecover:\n\t/*\n\t * ENOSPC, or some other error.  We may already have added some\n\t * blocks to the file, so we need to write these out to avoid\n\t * exposing stale data.\n\t * The page is currently locked and not marked for writeback\n\t */\n\tbh = head;\n\t/* Recovery: lock and submit the mapped buffers */\n\tdo {\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh) &&\n\t\t    !buffer_delay(bh)) {\n\t\t\tlock_buffer(bh);\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The buffer may have been set dirty during\n\t\t\t * attachment to a dirty page.\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\tSetPageError(page);\n\tBUG_ON(PageWriteback(page));\n\tmapping_set_error(page->mapping, err);\n\tset_page_writeback(page);\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tsubmit_bh(write_op, bh);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\tgoto done;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int __block_write_full_page(struct inode *inode, struct page *page,\n\t\t\tget_block_t *get_block, struct writeback_control *wbc,\n\t\t\tbh_end_io_t *handler)\n{\n\tint err;\n\tsector_t block;\n\tsector_t last_block;\n\tstruct buffer_head *bh, *head;\n\tunsigned int blocksize, bbits;\n\tint nr_underway = 0;\n\tint write_op = (wbc->sync_mode == WB_SYNC_ALL ?\n\t\t\tWRITE_SYNC : WRITE);\n\n\thead = create_page_buffers(page, inode,\n\t\t\t\t\t(1 << BH_Dirty)|(1 << BH_Uptodate));\n\n\t/*\n\t * Be very careful.  We have no exclusion from __set_page_dirty_buffers\n\t * here, and the (potentially unmapped) buffers may become dirty at\n\t * any time.  If a buffer becomes dirty here after we've inspected it\n\t * then we just miss that fact, and the page stays dirty.\n\t *\n\t * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;\n\t * handle that here by just cleaning them.\n\t */\n\n\tbh = head;\n\tblocksize = bh->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlast_block = (i_size_read(inode) - 1) >> bbits;\n\n\t/*\n\t * Get all the dirty buffers mapped to disk addresses and\n\t * handle any aliases from the underlying blockdev's mapping.\n\t */\n\tdo {\n\t\tif (block > last_block) {\n\t\t\t/*\n\t\t\t * mapped buffers outside i_size will occur, because\n\t\t\t * this page can be outside i_size when there is a\n\t\t\t * truncate in progress.\n\t\t\t */\n\t\t\t/*\n\t\t\t * The buffer was zeroed by block_write_full_page()\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t} else if ((!buffer_mapped(bh) || buffer_delay(bh)) &&\n\t\t\t   buffer_dirty(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tgoto recover;\n\t\t\tclear_buffer_delay(bh);\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\t/* blockdev mappings never come here */\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tblock++;\n\t} while (bh != head);\n\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tcontinue;\n\t\t/*\n\t\t * If it's a fully non-blocking write attempt and we cannot\n\t\t * lock the buffer then redirty the page.  Note that this can\n\t\t * potentially cause a busy-wait loop from writeback threads\n\t\t * and kswapd activity, but those code paths have their own\n\t\t * higher-level throttling.\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\tlock_buffer(bh);\n\t\t} else if (!trylock_buffer(bh)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tcontinue;\n\t\t}\n\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/*\n\t * The page and its buffers are protected by PageWriteback(), so we can\n\t * drop the bh refcounts early.\n\t */\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh(write_op, bh);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\n\terr = 0;\ndone:\n\tif (nr_underway == 0) {\n\t\t/*\n\t\t * The page was marked dirty, but the buffers were\n\t\t * clean.  Someone wrote them back by hand with\n\t\t * ll_rw_block/submit_bh.  A rare case.\n\t\t */\n\t\tend_page_writeback(page);\n\n\t\t/*\n\t\t * The page and buffer_heads can be released at any time from\n\t\t * here on.\n\t\t */\n\t}\n\treturn err;\n\nrecover:\n\t/*\n\t * ENOSPC, or some other error.  We may already have added some\n\t * blocks to the file, so we need to write these out to avoid\n\t * exposing stale data.\n\t * The page is currently locked and not marked for writeback\n\t */\n\tbh = head;\n\t/* Recovery: lock and submit the mapped buffers */\n\tdo {\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh) &&\n\t\t    !buffer_delay(bh)) {\n\t\t\tlock_buffer(bh);\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The buffer may have been set dirty during\n\t\t\t * attachment to a dirty page.\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\tSetPageError(page);\n\tBUG_ON(PageWriteback(page));\n\tmapping_set_error(page->mapping, err);\n\tset_page_writeback(page);\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tsubmit_bh(write_op, bh);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\tgoto done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpage_writepage",
          "args": [
            "page",
            "get_block",
            "wbc"
          ],
          "line": 2720
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "703-716",
          "snippet": "int mpage_writepage(struct page *page, get_block_t get_block,\n\tstruct writeback_control *wbc)\n{\n\tstruct mpage_data mpd = {\n\t\t.bio = NULL,\n\t\t.last_block_in_bio = 0,\n\t\t.get_block = get_block,\n\t\t.use_writepage = 0,\n\t};\n\tint ret = __mpage_writepage(page, wbc, &mpd);\n\tif (mpd.bio)\n\t\tmpage_bio_submit(WRITE, mpd.bio);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint mpage_writepage(struct page *page, get_block_t get_block,\n\tstruct writeback_control *wbc)\n{\n\tstruct mpage_data mpd = {\n\t\t.bio = NULL,\n\t\t.last_block_in_bio = 0,\n\t\t.get_block = get_block,\n\t\t.use_writepage = 0,\n\t};\n\tint ret = __mpage_writepage(page, wbc, &mpd);\n\tif (mpd.bio)\n\t\tmpage_bio_submit(WRITE, mpd.bio);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "offset",
            "PAGE_CACHE_SIZE"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2707
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page->mapping->a_ops->invalidatepage",
          "args": [
            "page",
            "offset"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint nobh_writepage(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\tint ret;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\tgoto out;\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n#if 0\n\t\t/* Not really sure about this  - do we need this ? */\n\t\tif (page->mapping->a_ops->invalidatepage)\n\t\t\tpage->mapping->a_ops->invalidatepage(page, offset);\n#endif\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\nout:\n\tret = mpage_writepage(page, get_block, wbc);\n\tif (ret == -EAGAIN)\n\t\tret = __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t      end_buffer_async_write);\n\treturn ret;\n}"
  },
  {
    "function_name": "nobh_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2641-2673",
    "snippet": "int nobh_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *head = fsdata;\n\tstruct buffer_head *bh;\n\tBUG_ON(fsdata != NULL && page_has_buffers(page));\n\n\tif (unlikely(copied < len) && head)\n\t\tattach_nobh_buffers(page, head);\n\tif (page_has_buffers(page))\n\t\treturn generic_write_end(file, mapping, pos, len,\n\t\t\t\t\tcopied, page, fsdata);\n\n\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\twhile (head) {\n\t\tbh = head;\n\t\thead = head->b_this_page;\n\t\tfree_buffer_head(bh);\n\t}\n\n\treturn copied;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_buffer_head",
          "args": [
            "bh"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2663
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 2660
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "pos+copied"
          ],
          "line": 2659
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 2657
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_dirty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "668-692",
          "snippet": "int __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\treturn newly_dirty;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\treturn newly_dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "copied",
            "page",
            "fsdata"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "generic_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2067-2104",
          "snippet": "int generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint i_size_changed = 0;\n\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint i_size_changed = 0;\n\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attach_nobh_buffers",
          "args": [
            "page",
            "head"
          ],
          "line": 2651
        },
        "resolved": true,
        "details": {
          "function_name": "attach_nobh_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2476-2493",
          "snippet": "static void attach_nobh_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh;\n\n\tBUG_ON(!PageLocked(page));\n\n\tspin_lock(&page->mapping->private_lock);\n\tbh = head;\n\tdo {\n\t\tif (PageDirty(page))\n\t\t\tset_buffer_dirty(bh);\n\t\tif (!bh->b_this_page)\n\t\t\tbh->b_this_page = head;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void attach_nobh_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh;\n\n\tBUG_ON(!PageLocked(page));\n\n\tspin_lock(&page->mapping->private_lock);\n\tbh = head;\n\tdo {\n\t\tif (PageDirty(page))\n\t\t\tset_buffer_dirty(bh);\n\t\tif (!bh->b_this_page)\n\t\t\tbh->b_this_page = head;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copied < len"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "fsdata != NULL && page_has_buffers(page)"
          ],
          "line": 2648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint nobh_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *head = fsdata;\n\tstruct buffer_head *bh;\n\tBUG_ON(fsdata != NULL && page_has_buffers(page));\n\n\tif (unlikely(copied < len) && head)\n\t\tattach_nobh_buffers(page, head);\n\tif (page_has_buffers(page))\n\t\treturn generic_write_end(file, mapping, pos, len,\n\t\t\t\t\tcopied, page, fsdata);\n\n\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\twhile (head) {\n\t\tbh = head;\n\t\thead = head->b_this_page;\n\t\tfree_buffer_head(bh);\n\t}\n\n\treturn copied;\n}"
  },
  {
    "function_name": "nobh_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2500-2638",
    "snippet": "int nobh_write_begin(struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block)\n{\n\tstruct inode *inode = mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tstruct buffer_head *head, *bh;\n\tstruct page *page;\n\tpgoff_t index;\n\tunsigned from, to;\n\tunsigned block_in_page;\n\tunsigned block_start, block_end;\n\tsector_t block_in_file;\n\tint nr_reads = 0;\n\tint ret = 0;\n\tint is_mapped_to_disk = 1;\n\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + len;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\t*pagep = page;\n\t*fsdata = NULL;\n\n\tif (page_has_buffers(page)) {\n\t\tret = __block_write_begin(page, pos, len, get_block);\n\t\tif (unlikely(ret))\n\t\t\tgoto out_release;\n\t\treturn ret;\n\t}\n\n\tif (PageMappedToDisk(page))\n\t\treturn 0;\n\n\t/*\n\t * Allocate buffers so that we can keep track of state, and potentially\n\t * attach them to the page if an error occurs. In the common case of\n\t * no error, they will just be freed again without ever being attached\n\t * to the page (which is all OK, because we're under the page lock).\n\t *\n\t * Be careful: the buffer linked list is a NULL terminated one, rather\n\t * than the circular one we're used to.\n\t */\n\thead = alloc_page_buffers(page, blocksize, 0);\n\tif (!head) {\n\t\tret = -ENOMEM;\n\t\tgoto out_release;\n\t}\n\n\tblock_in_file = (sector_t)page->index << (PAGE_CACHE_SHIFT - blkbits);\n\n\t/*\n\t * We loop across all blocks in the page, whether or not they are\n\t * part of the affected region.  This is so we can discover if the\n\t * page is fully mapped-to-disk.\n\t */\n\tfor (block_start = 0, block_in_page = 0, bh = head;\n\t\t  block_start < PAGE_CACHE_SIZE;\n\t\t  block_in_page++, block_start += blocksize, bh = bh->b_this_page) {\n\t\tint create;\n\n\t\tblock_end = block_start + blocksize;\n\t\tbh->b_state = 0;\n\t\tcreate = 1;\n\t\tif (block_start >= to)\n\t\t\tcreate = 0;\n\t\tret = get_block(inode, block_in_file + block_in_page,\n\t\t\t\t\tbh, create);\n\t\tif (ret)\n\t\t\tgoto failed;\n\t\tif (!buffer_mapped(bh))\n\t\t\tis_mapped_to_disk = 0;\n\t\tif (buffer_new(bh))\n\t\t\tunmap_underlying_metadata(bh->b_bdev, bh->b_blocknr);\n\t\tif (PageUptodate(page)) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh) || !buffer_mapped(bh)) {\n\t\t\tzero_user_segments(page, block_start, from,\n\t\t\t\t\t\t\tto, block_end);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\t/* reiserfs does this */\n\t\tif (block_start < from || block_end > to) {\n\t\t\tlock_buffer(bh);\n\t\t\tbh->b_end_io = end_buffer_read_nobh;\n\t\t\tsubmit_bh(READ, bh);\n\t\t\tnr_reads++;\n\t\t}\n\t}\n\n\tif (nr_reads) {\n\t\t/*\n\t\t * The page is locked, so these buffers are protected from\n\t\t * any VM or truncate activity.  Hence we don't need to care\n\t\t * for the buffer_head refcounts.\n\t\t */\n\t\tfor (bh = head; bh; bh = bh->b_this_page) {\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tret = -EIO;\n\t\t}\n\t\tif (ret)\n\t\t\tgoto failed;\n\t}\n\n\tif (is_mapped_to_disk)\n\t\tSetPageMappedToDisk(page);\n\n\t*fsdata = head; /* to be released by nobh_write_end */\n\n\treturn 0;\n\nfailed:\n\tBUG_ON(!ret);\n\t/*\n\t * Error recovery is a bit difficult. We need to zero out blocks that\n\t * were newly allocated, and dirty them to ensure they get written out.\n\t * Buffers need to be attached to the page at this point, otherwise\n\t * the handling of potential IO errors during writeout would be hard\n\t * (could try doing synchronous writeout, but what if that fails too?)\n\t */\n\tattach_nobh_buffers(page, head);\n\tpage_zero_new_buffers(page, from, to);\n\nout_release:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\t*pagep = NULL;\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2633
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zero_new_buffers",
          "args": [
            "page",
            "from",
            "to"
          ],
          "line": 2630
        },
        "resolved": true,
        "details": {
          "function_name": "page_zero_new_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1845-1879",
          "snippet": "void page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "attach_nobh_buffers",
          "args": [
            "page",
            "head"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "attach_nobh_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2476-2493",
          "snippet": "static void attach_nobh_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh;\n\n\tBUG_ON(!PageLocked(page));\n\n\tspin_lock(&page->mapping->private_lock);\n\tbh = head;\n\tdo {\n\t\tif (PageDirty(page))\n\t\t\tset_buffer_dirty(bh);\n\t\tif (!bh->b_this_page)\n\t\t\tbh->b_this_page = head;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void attach_nobh_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh;\n\n\tBUG_ON(!PageLocked(page));\n\n\tspin_lock(&page->mapping->private_lock);\n\tbh = head;\n\tdo {\n\t\tif (PageDirty(page))\n\t\t\tset_buffer_dirty(bh);\n\t\tif (!bh->b_this_page)\n\t\t\tbh->b_this_page = head;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ret"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageMappedToDisk",
          "args": [
            "page"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2606
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 2605
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "READ",
            "bh"
          ],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 2591
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segments",
          "args": [
            "page",
            "block_start",
            "from",
            "to",
            "block_end"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_underlying_metadata",
          "args": [
            "bh->b_bdev",
            "bh->b_blocknr"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_underlying_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1610-1623",
          "snippet": "void unmap_underlying_metadata(struct block_device *bdev, sector_t block)\n{\n\tstruct buffer_head *old_bh;\n\n\tmight_sleep();\n\n\told_bh = __find_get_block_slow(bdev, block);\n\tif (old_bh) {\n\t\tclear_buffer_dirty(old_bh);\n\t\twait_on_buffer(old_bh);\n\t\tclear_buffer_req(old_bh);\n\t\t__brelse(old_bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unmap_underlying_metadata(struct block_device *bdev, sector_t block)\n{\n\tstruct buffer_head *old_bh;\n\n\tmight_sleep();\n\n\told_bh = __find_get_block_slow(bdev, block);\n\tif (old_bh) {\n\t\tclear_buffer_dirty(old_bh);\n\t\twait_on_buffer(old_bh);\n\t\tclear_buffer_req(old_bh);\n\t\t__brelse(old_bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_block",
          "args": [
            "inode",
            "block_in_file + block_in_page",
            "bh",
            "create"
          ],
          "line": 2571
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "139-147",
          "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page_buffers",
          "args": [
            "page",
            "blocksize",
            "0"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "855-908",
          "snippet": "struct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tint retry)\n{\n\tstruct buffer_head *bh, *head;\n\tlong offset;\n\ntry_again:\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(GFP_NOFS);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\t/*\n\t * Return failure for non-async IO requests.  Async IO requests\n\t * are not allowed to fail, so we have to wait until buffer heads\n\t * become available.  But we don't want tasks sleeping with \n\t * partially complete buffers, so all were released above.\n\t */\n\tif (!retry)\n\t\treturn NULL;\n\n\t/* We're _really_ low on memory. Now we just\n\t * wait for old buffer heads to become free due to\n\t * finishing IO.  Since this is an async request and\n\t * the reserve list is empty, we're sure there are \n\t * async buffer heads in use.\n\t */\n\tfree_more_memory();\n\tgoto try_again;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nstruct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tint retry)\n{\n\tstruct buffer_head *bh, *head;\n\tlong offset;\n\ntry_again:\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(GFP_NOFS);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\t/*\n\t * Return failure for non-async IO requests.  Async IO requests\n\t * are not allowed to fail, so we have to wait until buffer heads\n\t * become available.  But we don't want tasks sleeping with \n\t * partially complete buffers, so all were released above.\n\t */\n\tif (!retry)\n\t\treturn NULL;\n\n\t/* We're _really_ low on memory. Now we just\n\t * wait for old buffer heads to become free due to\n\t * finishing IO.  Since this is an async request and\n\t * the reserve list is empty, we're sure there are \n\t * async buffer heads in use.\n\t */\n\tfree_more_memory();\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageMappedToDisk",
          "args": [
            "page"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "pos",
            "len",
            "get_block"
          ],
          "line": 2530
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1882-1961",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nint nobh_write_begin(struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block)\n{\n\tstruct inode *inode = mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tstruct buffer_head *head, *bh;\n\tstruct page *page;\n\tpgoff_t index;\n\tunsigned from, to;\n\tunsigned block_in_page;\n\tunsigned block_start, block_end;\n\tsector_t block_in_file;\n\tint nr_reads = 0;\n\tint ret = 0;\n\tint is_mapped_to_disk = 1;\n\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + len;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\t*pagep = page;\n\t*fsdata = NULL;\n\n\tif (page_has_buffers(page)) {\n\t\tret = __block_write_begin(page, pos, len, get_block);\n\t\tif (unlikely(ret))\n\t\t\tgoto out_release;\n\t\treturn ret;\n\t}\n\n\tif (PageMappedToDisk(page))\n\t\treturn 0;\n\n\t/*\n\t * Allocate buffers so that we can keep track of state, and potentially\n\t * attach them to the page if an error occurs. In the common case of\n\t * no error, they will just be freed again without ever being attached\n\t * to the page (which is all OK, because we're under the page lock).\n\t *\n\t * Be careful: the buffer linked list is a NULL terminated one, rather\n\t * than the circular one we're used to.\n\t */\n\thead = alloc_page_buffers(page, blocksize, 0);\n\tif (!head) {\n\t\tret = -ENOMEM;\n\t\tgoto out_release;\n\t}\n\n\tblock_in_file = (sector_t)page->index << (PAGE_CACHE_SHIFT - blkbits);\n\n\t/*\n\t * We loop across all blocks in the page, whether or not they are\n\t * part of the affected region.  This is so we can discover if the\n\t * page is fully mapped-to-disk.\n\t */\n\tfor (block_start = 0, block_in_page = 0, bh = head;\n\t\t  block_start < PAGE_CACHE_SIZE;\n\t\t  block_in_page++, block_start += blocksize, bh = bh->b_this_page) {\n\t\tint create;\n\n\t\tblock_end = block_start + blocksize;\n\t\tbh->b_state = 0;\n\t\tcreate = 1;\n\t\tif (block_start >= to)\n\t\t\tcreate = 0;\n\t\tret = get_block(inode, block_in_file + block_in_page,\n\t\t\t\t\tbh, create);\n\t\tif (ret)\n\t\t\tgoto failed;\n\t\tif (!buffer_mapped(bh))\n\t\t\tis_mapped_to_disk = 0;\n\t\tif (buffer_new(bh))\n\t\t\tunmap_underlying_metadata(bh->b_bdev, bh->b_blocknr);\n\t\tif (PageUptodate(page)) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh) || !buffer_mapped(bh)) {\n\t\t\tzero_user_segments(page, block_start, from,\n\t\t\t\t\t\t\tto, block_end);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\t/* reiserfs does this */\n\t\tif (block_start < from || block_end > to) {\n\t\t\tlock_buffer(bh);\n\t\t\tbh->b_end_io = end_buffer_read_nobh;\n\t\t\tsubmit_bh(READ, bh);\n\t\t\tnr_reads++;\n\t\t}\n\t}\n\n\tif (nr_reads) {\n\t\t/*\n\t\t * The page is locked, so these buffers are protected from\n\t\t * any VM or truncate activity.  Hence we don't need to care\n\t\t * for the buffer_head refcounts.\n\t\t */\n\t\tfor (bh = head; bh; bh = bh->b_this_page) {\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tret = -EIO;\n\t\t}\n\t\tif (ret)\n\t\t\tgoto failed;\n\t}\n\n\tif (is_mapped_to_disk)\n\t\tSetPageMappedToDisk(page);\n\n\t*fsdata = head; /* to be released by nobh_write_end */\n\n\treturn 0;\n\nfailed:\n\tBUG_ON(!ret);\n\t/*\n\t * Error recovery is a bit difficult. We need to zero out blocks that\n\t * were newly allocated, and dirty them to ensure they get written out.\n\t * Buffers need to be attached to the page at this point, otherwise\n\t * the handling of potential IO errors during writeout would be hard\n\t * (could try doing synchronous writeout, but what if that fails too?)\n\t */\n\tattach_nobh_buffers(page, head);\n\tpage_zero_new_buffers(page, from, to);\n\nout_release:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\t*pagep = NULL;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "attach_nobh_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2476-2493",
    "snippet": "static void attach_nobh_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh;\n\n\tBUG_ON(!PageLocked(page));\n\n\tspin_lock(&page->mapping->private_lock);\n\tbh = head;\n\tdo {\n\t\tif (PageDirty(page))\n\t\t\tset_buffer_dirty(bh);\n\t\tif (!bh->b_this_page)\n\t\t\tbh->b_this_page = head;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&page->mapping->private_lock"
          ],
          "line": 2492
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "attach_page_buffers",
          "args": [
            "page",
            "head"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 2485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&page->mapping->private_lock"
          ],
          "line": 2482
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void attach_nobh_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh;\n\n\tBUG_ON(!PageLocked(page));\n\n\tspin_lock(&page->mapping->private_lock);\n\tbh = head;\n\tdo {\n\t\tif (PageDirty(page))\n\t\t\tset_buffer_dirty(bh);\n\t\tif (!bh->b_this_page)\n\t\t\tbh->b_this_page = head;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
  },
  {
    "function_name": "end_buffer_read_nobh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2466-2469",
    "snippet": "static void end_buffer_read_nobh(struct buffer_head *bh, int uptodate)\n{\n\t__end_buffer_read_notouch(bh, uptodate);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__end_buffer_read_notouch",
          "args": [
            "bh",
            "uptodate"
          ],
          "line": 2468
        },
        "resolved": true,
        "details": {
          "function_name": "__end_buffer_read_notouch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "150-159",
          "snippet": "static void __end_buffer_read_notouch(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\t/* This happens, due to failed READA attempts. */\n\t\tclear_buffer_uptodate(bh);\n\t}\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void __end_buffer_read_notouch(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\t/* This happens, due to failed READA attempts. */\n\t\tclear_buffer_uptodate(bh);\n\t}\n\tunlock_buffer(bh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void end_buffer_read_nobh(struct buffer_head *bh, int uptodate)\n{\n\t__end_buffer_read_notouch(bh, uptodate);\n}"
  },
  {
    "function_name": "block_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2441-2458",
    "snippet": "int block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t   get_block_t get_block)\n{\n\tint ret;\n\tstruct super_block *sb = file_inode(vma->vm_file)->i_sb;\n\n\tsb_start_pagefault(sb);\n\n\t/*\n\t * Update file times before taking page lock. We may end up failing the\n\t * fault so this update may be superfluous but who really cares...\n\t */\n\tfile_update_time(vma->vm_file);\n\n\tret = __block_page_mkwrite(vma, vmf, get_block);\n\tsb_end_pagefault(sb);\n\treturn block_page_mkwrite_return(ret);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_page_mkwrite_return",
          "args": [
            "ret"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_end_pagefault",
          "args": [
            "sb"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__block_page_mkwrite",
          "args": [
            "vma",
            "vmf",
            "get_block"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "__block_page_mkwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2402-2438",
          "snippet": "int __block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t\t get_block_t get_block)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tunsigned long end;\n\tloff_t size;\n\tint ret;\n\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\tif ((page->mapping != inode->i_mapping) ||\n\t    (page_offset(page) > size)) {\n\t\t/* We overload EFAULT to mean page got truncated */\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* page is wholly or partially inside EOF */\n\tif (((page->index + 1) << PAGE_CACHE_SHIFT) > size)\n\t\tend = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tend = PAGE_CACHE_SIZE;\n\n\tret = __block_write_begin(page, 0, end, get_block);\n\tif (!ret)\n\t\tret = block_commit_write(page, 0, end);\n\n\tif (unlikely(ret < 0))\n\t\tgoto out_unlock;\n\tset_page_dirty(page);\n\twait_for_stable_page(page);\n\treturn 0;\nout_unlock:\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t\t get_block_t get_block)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tunsigned long end;\n\tloff_t size;\n\tint ret;\n\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\tif ((page->mapping != inode->i_mapping) ||\n\t    (page_offset(page) > size)) {\n\t\t/* We overload EFAULT to mean page got truncated */\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* page is wholly or partially inside EOF */\n\tif (((page->index + 1) << PAGE_CACHE_SHIFT) > size)\n\t\tend = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tend = PAGE_CACHE_SIZE;\n\n\tret = __block_write_begin(page, 0, end, get_block);\n\tif (!ret)\n\t\tret = block_commit_write(page, 0, end);\n\n\tif (unlikely(ret < 0))\n\t\tgoto out_unlock;\n\tset_page_dirty(page);\n\twait_for_stable_page(page);\n\treturn 0;\nout_unlock:\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "vma->vm_file"
          ],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_pagefault",
          "args": [
            "sb"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 2445
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t   get_block_t get_block)\n{\n\tint ret;\n\tstruct super_block *sb = file_inode(vma->vm_file)->i_sb;\n\n\tsb_start_pagefault(sb);\n\n\t/*\n\t * Update file times before taking page lock. We may end up failing the\n\t * fault so this update may be superfluous but who really cares...\n\t */\n\tfile_update_time(vma->vm_file);\n\n\tret = __block_page_mkwrite(vma, vmf, get_block);\n\tsb_end_pagefault(sb);\n\treturn block_page_mkwrite_return(ret);\n}"
  },
  {
    "function_name": "__block_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2402-2438",
    "snippet": "int __block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t\t get_block_t get_block)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tunsigned long end;\n\tloff_t size;\n\tint ret;\n\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\tif ((page->mapping != inode->i_mapping) ||\n\t    (page_offset(page) > size)) {\n\t\t/* We overload EFAULT to mean page got truncated */\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* page is wholly or partially inside EOF */\n\tif (((page->index + 1) << PAGE_CACHE_SHIFT) > size)\n\t\tend = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tend = PAGE_CACHE_SIZE;\n\n\tret = __block_write_begin(page, 0, end, get_block);\n\tif (!ret)\n\t\tret = block_commit_write(page, 0, end);\n\n\tif (unlikely(ret < 0))\n\t\tgoto out_unlock;\n\tset_page_dirty(page);\n\twait_for_stable_page(page);\n\treturn 0;\nout_unlock:\n\tunlock_page(page);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2436
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_stable_page",
          "args": [
            "page"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_dirty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "668-692",
          "snippet": "int __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\treturn newly_dirty;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\treturn newly_dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_commit_write",
          "args": [
            "page",
            "0",
            "end"
          ],
          "line": 2428
        },
        "resolved": true,
        "details": {
          "function_name": "block_commit_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2376-2381",
          "snippet": "int block_commit_write(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\t__block_commit_write(inode,page,from,to);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_commit_write(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\t__block_commit_write(inode,page,from,to);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "0",
            "end",
            "get_block"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1882-1961",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t\t get_block_t get_block)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tunsigned long end;\n\tloff_t size;\n\tint ret;\n\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\tif ((page->mapping != inode->i_mapping) ||\n\t    (page_offset(page) > size)) {\n\t\t/* We overload EFAULT to mean page got truncated */\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* page is wholly or partially inside EOF */\n\tif (((page->index + 1) << PAGE_CACHE_SHIFT) > size)\n\t\tend = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tend = PAGE_CACHE_SIZE;\n\n\tret = __block_write_begin(page, 0, end, get_block);\n\tif (!ret)\n\t\tret = block_commit_write(page, 0, end);\n\n\tif (unlikely(ret < 0))\n\t\tgoto out_unlock;\n\tset_page_dirty(page);\n\twait_for_stable_page(page);\n\treturn 0;\nout_unlock:\n\tunlock_page(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "block_commit_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2376-2381",
    "snippet": "int block_commit_write(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\t__block_commit_write(inode,page,from,to);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__block_commit_write",
          "args": [
            "inode",
            "page",
            "from",
            "to"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "__block_commit_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1964-2000",
          "snippet": "static int __block_commit_write(struct inode *inode, struct page *page,\n\t\tunsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tint partial = 0;\n\tunsigned blocksize;\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tblocksize = bh->b_size;\n\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t} else {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\tclear_buffer_new(bh);\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * If this is a partial write which happened to make all buffers\n\t * uptodate then we can optimize away a bogus readpage() for\n\t * the next read(). Here we 'discover' whether the page went\n\t * uptodate as a result of this (potentially partial) write.\n\t */\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int __block_commit_write(struct inode *inode, struct page *page,\n\t\tunsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tint partial = 0;\n\tunsigned blocksize;\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tblocksize = bh->b_size;\n\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t} else {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\tclear_buffer_new(bh);\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * If this is a partial write which happened to make all buffers\n\t * uptodate then we can optimize away a bogus readpage() for\n\t * the next read(). Here we 'discover' whether the page went\n\t * uptodate as a result of this (potentially partial) write.\n\t */\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_commit_write(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\t__block_commit_write(inode,page,from,to);\n\treturn 0;\n}"
  },
  {
    "function_name": "cont_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2352-2373",
    "snippet": "int cont_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned blocksize = 1 << inode->i_blkbits;\n\tunsigned zerofrom;\n\tint err;\n\n\terr = cont_expand_zero(file, mapping, pos, bytes);\n\tif (err)\n\t\treturn err;\n\n\tzerofrom = *bytes & ~PAGE_CACHE_MASK;\n\tif (pos+len > *bytes && zerofrom & (blocksize-1)) {\n\t\t*bytes |= (blocksize-1);\n\t\t(*bytes)++;\n\t}\n\n\treturn block_write_begin(mapping, pos, len, flags, pagep, get_block);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_begin",
          "args": [
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "get_block"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2008-2028",
          "snippet": "int block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cont_expand_zero",
          "args": [
            "file",
            "mapping",
            "pos",
            "bytes"
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "cont_expand_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2274-2346",
          "snippet": "static int cont_expand_zero(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned blocksize = 1 << inode->i_blkbits;\n\tstruct page *page;\n\tvoid *fsdata;\n\tpgoff_t index, curidx;\n\tloff_t curpos;\n\tunsigned zerofrom, offset, len;\n\tint err = 0;\n\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\toffset = pos & ~PAGE_CACHE_MASK;\n\n\twhile (index > (curidx = (curpos = *bytes)>>PAGE_CACHE_SHIFT)) {\n\t\tzerofrom = curpos & ~PAGE_CACHE_MASK;\n\t\tif (zerofrom & (blocksize-1)) {\n\t\t\t*bytes |= (blocksize-1);\n\t\t\t(*bytes)++;\n\t\t}\n\t\tlen = PAGE_CACHE_SIZE - zerofrom;\n\n\t\terr = pagecache_write_begin(file, mapping, curpos, len,\n\t\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzero_user(page, zerofrom, len);\n\t\terr = pagecache_write_end(file, mapping, curpos, len, len,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tBUG_ON(err != len);\n\t\terr = 0;\n\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\n\t\tif (unlikely(fatal_signal_pending(current))) {\n\t\t\terr = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* page covers the boundary, find the boundary offset */\n\tif (index == curidx) {\n\t\tzerofrom = curpos & ~PAGE_CACHE_MASK;\n\t\t/* if we will expand the thing last block will be filled */\n\t\tif (offset <= zerofrom) {\n\t\t\tgoto out;\n\t\t}\n\t\tif (zerofrom & (blocksize-1)) {\n\t\t\t*bytes |= (blocksize-1);\n\t\t\t(*bytes)++;\n\t\t}\n\t\tlen = offset - zerofrom;\n\n\t\terr = pagecache_write_begin(file, mapping, curpos, len,\n\t\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzero_user(page, zerofrom, len);\n\t\terr = pagecache_write_end(file, mapping, curpos, len, len,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tBUG_ON(err != len);\n\t\terr = 0;\n\t}\nout:\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int cont_expand_zero(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned blocksize = 1 << inode->i_blkbits;\n\tstruct page *page;\n\tvoid *fsdata;\n\tpgoff_t index, curidx;\n\tloff_t curpos;\n\tunsigned zerofrom, offset, len;\n\tint err = 0;\n\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\toffset = pos & ~PAGE_CACHE_MASK;\n\n\twhile (index > (curidx = (curpos = *bytes)>>PAGE_CACHE_SHIFT)) {\n\t\tzerofrom = curpos & ~PAGE_CACHE_MASK;\n\t\tif (zerofrom & (blocksize-1)) {\n\t\t\t*bytes |= (blocksize-1);\n\t\t\t(*bytes)++;\n\t\t}\n\t\tlen = PAGE_CACHE_SIZE - zerofrom;\n\n\t\terr = pagecache_write_begin(file, mapping, curpos, len,\n\t\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzero_user(page, zerofrom, len);\n\t\terr = pagecache_write_end(file, mapping, curpos, len, len,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tBUG_ON(err != len);\n\t\terr = 0;\n\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\n\t\tif (unlikely(fatal_signal_pending(current))) {\n\t\t\terr = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* page covers the boundary, find the boundary offset */\n\tif (index == curidx) {\n\t\tzerofrom = curpos & ~PAGE_CACHE_MASK;\n\t\t/* if we will expand the thing last block will be filled */\n\t\tif (offset <= zerofrom) {\n\t\t\tgoto out;\n\t\t}\n\t\tif (zerofrom & (blocksize-1)) {\n\t\t\t*bytes |= (blocksize-1);\n\t\t\t(*bytes)++;\n\t\t}\n\t\tlen = offset - zerofrom;\n\n\t\terr = pagecache_write_begin(file, mapping, curpos, len,\n\t\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzero_user(page, zerofrom, len);\n\t\terr = pagecache_write_end(file, mapping, curpos, len, len,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tBUG_ON(err != len);\n\t\terr = 0;\n\t}\nout:\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint cont_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned blocksize = 1 << inode->i_blkbits;\n\tunsigned zerofrom;\n\tint err;\n\n\terr = cont_expand_zero(file, mapping, pos, bytes);\n\tif (err)\n\t\treturn err;\n\n\tzerofrom = *bytes & ~PAGE_CACHE_MASK;\n\tif (pos+len > *bytes && zerofrom & (blocksize-1)) {\n\t\t*bytes |= (blocksize-1);\n\t\t(*bytes)++;\n\t}\n\n\treturn block_write_begin(mapping, pos, len, flags, pagep, get_block);\n}"
  },
  {
    "function_name": "cont_expand_zero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2274-2346",
    "snippet": "static int cont_expand_zero(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned blocksize = 1 << inode->i_blkbits;\n\tstruct page *page;\n\tvoid *fsdata;\n\tpgoff_t index, curidx;\n\tloff_t curpos;\n\tunsigned zerofrom, offset, len;\n\tint err = 0;\n\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\toffset = pos & ~PAGE_CACHE_MASK;\n\n\twhile (index > (curidx = (curpos = *bytes)>>PAGE_CACHE_SHIFT)) {\n\t\tzerofrom = curpos & ~PAGE_CACHE_MASK;\n\t\tif (zerofrom & (blocksize-1)) {\n\t\t\t*bytes |= (blocksize-1);\n\t\t\t(*bytes)++;\n\t\t}\n\t\tlen = PAGE_CACHE_SIZE - zerofrom;\n\n\t\terr = pagecache_write_begin(file, mapping, curpos, len,\n\t\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzero_user(page, zerofrom, len);\n\t\terr = pagecache_write_end(file, mapping, curpos, len, len,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tBUG_ON(err != len);\n\t\terr = 0;\n\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\n\t\tif (unlikely(fatal_signal_pending(current))) {\n\t\t\terr = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* page covers the boundary, find the boundary offset */\n\tif (index == curidx) {\n\t\tzerofrom = curpos & ~PAGE_CACHE_MASK;\n\t\t/* if we will expand the thing last block will be filled */\n\t\tif (offset <= zerofrom) {\n\t\t\tgoto out;\n\t\t}\n\t\tif (zerofrom & (blocksize-1)) {\n\t\t\t*bytes |= (blocksize-1);\n\t\t\t(*bytes)++;\n\t\t}\n\t\tlen = offset - zerofrom;\n\n\t\terr = pagecache_write_begin(file, mapping, curpos, len,\n\t\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzero_user(page, zerofrom, len);\n\t\terr = pagecache_write_end(file, mapping, curpos, len, len,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tBUG_ON(err != len);\n\t\terr = 0;\n\t}\nout:\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err != len"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagecache_write_end",
          "args": [
            "file",
            "mapping",
            "curpos",
            "len",
            "len",
            "page",
            "fsdata"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "zerofrom",
            "len"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagecache_write_begin",
          "args": [
            "file",
            "mapping",
            "curpos",
            "len",
            "AOP_FLAG_UNINTERRUPTIBLE",
            "&page",
            "&fsdata"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fatal_signal_pending(current)"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_dirty_pages_ratelimited",
          "args": [
            "mapping"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err != len"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagecache_write_end",
          "args": [
            "file",
            "mapping",
            "curpos",
            "len",
            "len",
            "page",
            "fsdata"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "zerofrom",
            "len"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagecache_write_begin",
          "args": [
            "file",
            "mapping",
            "curpos",
            "len",
            "AOP_FLAG_UNINTERRUPTIBLE",
            "&page",
            "&fsdata"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int cont_expand_zero(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned blocksize = 1 << inode->i_blkbits;\n\tstruct page *page;\n\tvoid *fsdata;\n\tpgoff_t index, curidx;\n\tloff_t curpos;\n\tunsigned zerofrom, offset, len;\n\tint err = 0;\n\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\toffset = pos & ~PAGE_CACHE_MASK;\n\n\twhile (index > (curidx = (curpos = *bytes)>>PAGE_CACHE_SHIFT)) {\n\t\tzerofrom = curpos & ~PAGE_CACHE_MASK;\n\t\tif (zerofrom & (blocksize-1)) {\n\t\t\t*bytes |= (blocksize-1);\n\t\t\t(*bytes)++;\n\t\t}\n\t\tlen = PAGE_CACHE_SIZE - zerofrom;\n\n\t\terr = pagecache_write_begin(file, mapping, curpos, len,\n\t\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzero_user(page, zerofrom, len);\n\t\terr = pagecache_write_end(file, mapping, curpos, len, len,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tBUG_ON(err != len);\n\t\terr = 0;\n\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\n\t\tif (unlikely(fatal_signal_pending(current))) {\n\t\t\terr = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* page covers the boundary, find the boundary offset */\n\tif (index == curidx) {\n\t\tzerofrom = curpos & ~PAGE_CACHE_MASK;\n\t\t/* if we will expand the thing last block will be filled */\n\t\tif (offset <= zerofrom) {\n\t\t\tgoto out;\n\t\t}\n\t\tif (zerofrom & (blocksize-1)) {\n\t\t\t*bytes |= (blocksize-1);\n\t\t\t(*bytes)++;\n\t\t}\n\t\tlen = offset - zerofrom;\n\n\t\terr = pagecache_write_begin(file, mapping, curpos, len,\n\t\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzero_user(page, zerofrom, len);\n\t\terr = pagecache_write_end(file, mapping, curpos, len, len,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tBUG_ON(err != len);\n\t\terr = 0;\n\t}\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "generic_cont_expand_simple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2249-2271",
    "snippet": "int generic_cont_expand_simple(struct inode *inode, loff_t size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tvoid *fsdata;\n\tint err;\n\n\terr = inode_newsize_ok(inode, size);\n\tif (err)\n\t\tgoto out;\n\n\terr = pagecache_write_begin(NULL, mapping, size, 0,\n\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE|AOP_FLAG_CONT_EXPAND,\n\t\t\t\t&page, &fsdata);\n\tif (err)\n\t\tgoto out;\n\n\terr = pagecache_write_end(NULL, mapping, size, 0, 0, page, fsdata);\n\tBUG_ON(err > 0);\n\nout:\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err > 0"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagecache_write_end",
          "args": [
            "NULL",
            "mapping",
            "size",
            "0",
            "0",
            "page",
            "fsdata"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagecache_write_begin",
          "args": [
            "NULL",
            "mapping",
            "size",
            "0",
            "AOP_FLAG_UNINTERRUPTIBLE|AOP_FLAG_CONT_EXPAND",
            "&page",
            "&fsdata"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_newsize_ok",
          "args": [
            "inode",
            "size"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "99-124",
          "snippet": "int inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint generic_cont_expand_simple(struct inode *inode, loff_t size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tvoid *fsdata;\n\tint err;\n\n\terr = inode_newsize_ok(inode, size);\n\tif (err)\n\t\tgoto out;\n\n\terr = pagecache_write_begin(NULL, mapping, size, 0,\n\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE|AOP_FLAG_CONT_EXPAND,\n\t\t\t\t&page, &fsdata);\n\tif (err)\n\t\tgoto out;\n\n\terr = pagecache_write_end(NULL, mapping, size, 0, 0, page, fsdata);\n\tBUG_ON(err > 0);\n\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "block_read_full_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2159-2242",
    "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "READ",
            "bh"
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_buffer_async_read",
          "args": [
            "bh",
            "1"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "end_buffer_async_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "279-334",
          "snippet": "static void end_buffer_async_read(struct buffer_head *bh, int uptodate)\n{\n\tunsigned long flags;\n\tstruct buffer_head *first;\n\tstruct buffer_head *tmp;\n\tstruct page *page;\n\tint page_uptodate = 1;\n\n\tBUG_ON(!buffer_async_read(bh));\n\n\tpage = bh->b_page;\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\tclear_buffer_uptodate(bh);\n\t\tbuffer_io_error(bh, \", async page read\");\n\t\tSetPageError(page);\n\t}\n\n\t/*\n\t * Be _very_ careful from here on. Bad things can happen if\n\t * two buffer heads end IO at almost the same time and both\n\t * decide that the page is now completely done.\n\t */\n\tfirst = page_buffers(page);\n\tlocal_irq_save(flags);\n\tbit_spin_lock(BH_Uptodate_Lock, &first->b_state);\n\tclear_buffer_async_read(bh);\n\tunlock_buffer(bh);\n\ttmp = bh;\n\tdo {\n\t\tif (!buffer_uptodate(tmp))\n\t\t\tpage_uptodate = 0;\n\t\tif (buffer_async_read(tmp)) {\n\t\t\tBUG_ON(!buffer_locked(tmp));\n\t\t\tgoto still_busy;\n\t\t}\n\t\ttmp = tmp->b_this_page;\n\t} while (tmp != bh);\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * If none of the buffers had errors and they are all\n\t * uptodate then we can set the page uptodate.\n\t */\n\tif (page_uptodate && !PageError(page))\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn;\n\nstill_busy:\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void end_buffer_async_read(struct buffer_head *bh, int uptodate)\n{\n\tunsigned long flags;\n\tstruct buffer_head *first;\n\tstruct buffer_head *tmp;\n\tstruct page *page;\n\tint page_uptodate = 1;\n\n\tBUG_ON(!buffer_async_read(bh));\n\n\tpage = bh->b_page;\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\tclear_buffer_uptodate(bh);\n\t\tbuffer_io_error(bh, \", async page read\");\n\t\tSetPageError(page);\n\t}\n\n\t/*\n\t * Be _very_ careful from here on. Bad things can happen if\n\t * two buffer heads end IO at almost the same time and both\n\t * decide that the page is now completely done.\n\t */\n\tfirst = page_buffers(page);\n\tlocal_irq_save(flags);\n\tbit_spin_lock(BH_Uptodate_Lock, &first->b_state);\n\tclear_buffer_async_read(bh);\n\tunlock_buffer(bh);\n\ttmp = bh;\n\tdo {\n\t\tif (!buffer_uptodate(tmp))\n\t\t\tpage_uptodate = 0;\n\t\tif (buffer_async_read(tmp)) {\n\t\t\tBUG_ON(!buffer_locked(tmp));\n\t\t\tgoto still_busy;\n\t\t}\n\t\ttmp = tmp->b_this_page;\n\t} while (tmp != bh);\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * If none of the buffers had errors and they are all\n\t * uptodate then we can set the page uptodate.\n\t */\n\tif (page_uptodate && !PageError(page))\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn;\n\nstill_busy:\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_async_read",
          "args": [
            "bh"
          ],
          "line": 2226
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_async_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "407-411",
          "snippet": "static void mark_buffer_async_read(struct buffer_head *bh)\n{\n\tbh->b_end_io = end_buffer_async_read;\n\tset_buffer_async_read(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void mark_buffer_async_read(struct buffer_head *bh)\n{\n\tbh->b_end_io = end_buffer_async_read;\n\tset_buffer_async_read(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageMappedToDisk",
          "args": [
            "page"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "i * blocksize",
            "blocksize"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_block",
          "args": [
            "inode",
            "iblock",
            "bh",
            "0"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "139-147",
          "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "bh->b_size != blocksize"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_size_bits",
          "args": [
            "blocksize"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "block_size_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1634-1637",
          "snippet": "static inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_page_buffers",
          "args": [
            "page",
            "inode",
            "0"
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "create_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1639-1646",
          "snippet": "static struct buffer_head *create_page_buffers(struct page *page, struct inode *inode, unsigned int b_state)\n{\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << ACCESS_ONCE(inode->i_blkbits), b_state);\n\treturn page_buffers(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic struct buffer_head *create_page_buffers(struct page *page, struct inode *inode, unsigned int b_state)\n{\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << ACCESS_ONCE(inode->i_blkbits), b_state);\n\treturn page_buffers(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "block_is_partially_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2114-2149",
    "snippet": "int block_is_partially_uptodate(struct page *page, unsigned long from,\n\t\t\t\t\tunsigned long count)\n{\n\tunsigned block_start, block_end, blocksize;\n\tunsigned to;\n\tstruct buffer_head *bh, *head;\n\tint ret = 1;\n\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\n\thead = page_buffers(page);\n\tblocksize = head->b_size;\n\tto = min_t(unsigned, PAGE_CACHE_SIZE - from, count);\n\tto = from + to;\n\tif (from < blocksize && to > PAGE_CACHE_SIZE - blocksize)\n\t\treturn 0;\n\n\tbh = head;\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end > from && block_start < to) {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (block_end >= to)\n\t\t\t\tbreak;\n\t\t}\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsigned",
            "PAGE_CACHE_SIZE - from",
            "count"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_is_partially_uptodate(struct page *page, unsigned long from,\n\t\t\t\t\tunsigned long count)\n{\n\tunsigned block_start, block_end, blocksize;\n\tunsigned to;\n\tstruct buffer_head *bh, *head;\n\tint ret = 1;\n\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\n\thead = page_buffers(page);\n\tblocksize = head->b_size;\n\tto = min_t(unsigned, PAGE_CACHE_SIZE - from, count);\n\tto = from + to;\n\tif (from < blocksize && to > PAGE_CACHE_SIZE - blocksize)\n\t\treturn 0;\n\n\tbh = head;\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end > from && block_start < to) {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (block_end >= to)\n\t\t\t\tbreak;\n\t\t}\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "generic_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2067-2104",
    "snippet": "int generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint i_size_changed = 0;\n\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagecache_isize_extended",
          "args": [
            "inode",
            "old_size",
            "pos"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "pos+copied"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "copied",
            "page",
            "fsdata"
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2031-2064",
          "snippet": "int block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint i_size_changed = 0;\n\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}"
  },
  {
    "function_name": "block_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2031-2064",
    "snippet": "int block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__block_commit_write",
          "args": [
            "inode",
            "page",
            "start",
            "start+copied"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "__block_commit_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1964-2000",
          "snippet": "static int __block_commit_write(struct inode *inode, struct page *page,\n\t\tunsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tint partial = 0;\n\tunsigned blocksize;\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tblocksize = bh->b_size;\n\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t} else {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\tclear_buffer_new(bh);\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * If this is a partial write which happened to make all buffers\n\t * uptodate then we can optimize away a bogus readpage() for\n\t * the next read(). Here we 'discover' whether the page went\n\t * uptodate as a result of this (potentially partial) write.\n\t */\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int __block_commit_write(struct inode *inode, struct page *page,\n\t\tunsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tint partial = 0;\n\tunsigned blocksize;\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tblocksize = bh->b_size;\n\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t} else {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\tclear_buffer_new(bh);\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * If this is a partial write which happened to make all buffers\n\t * uptodate then we can optimize away a bogus readpage() for\n\t * the next read(). Here we 'discover' whether the page went\n\t * uptodate as a result of this (potentially partial) write.\n\t */\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zero_new_buffers",
          "args": [
            "page",
            "start+copied",
            "start+len"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "page_zero_new_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1845-1879",
          "snippet": "void page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copied < len"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}"
  },
  {
    "function_name": "block_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "2008-2028",
    "snippet": "int block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "pos",
            "len",
            "get_block"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1882-1961",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
  },
  {
    "function_name": "__block_commit_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1964-2000",
    "snippet": "static int __block_commit_write(struct inode *inode, struct page *page,\n\t\tunsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tint partial = 0;\n\tunsigned blocksize;\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tblocksize = bh->b_size;\n\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t} else {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\tclear_buffer_new(bh);\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * If this is a partial write which happened to make all buffers\n\t * uptodate then we can optimize away a bogus readpage() for\n\t * the next read(). Here we 'discover' whether the page went\n\t * uptodate as a result of this (potentially partial) write.\n\t */\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int __block_commit_write(struct inode *inode, struct page *page,\n\t\tunsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tint partial = 0;\n\tunsigned blocksize;\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tblocksize = bh->b_size;\n\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t} else {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\tclear_buffer_new(bh);\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * If this is a partial write which happened to make all buffers\n\t * uptodate then we can optimize away a bogus readpage() for\n\t * the next read(). Here we 'discover' whether the page went\n\t * uptodate as a result of this (potentially partial) write.\n\t */\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "__block_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1882-1961",
    "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_zero_new_buffers",
          "args": [
            "page",
            "from",
            "to"
          ],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "page_zero_new_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1845-1879",
          "snippet": "void page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "*wait_bh"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "*--wait_bh"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ",
            "1",
            "&bh"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segments",
          "args": [
            "page",
            "to",
            "block_end",
            "block_start",
            "from"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_underlying_metadata",
          "args": [
            "bh->b_bdev",
            "bh->b_blocknr"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_underlying_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1610-1623",
          "snippet": "void unmap_underlying_metadata(struct block_device *bdev, sector_t block)\n{\n\tstruct buffer_head *old_bh;\n\n\tmight_sleep();\n\n\told_bh = __find_get_block_slow(bdev, block);\n\tif (old_bh) {\n\t\tclear_buffer_dirty(old_bh);\n\t\twait_on_buffer(old_bh);\n\t\tclear_buffer_req(old_bh);\n\t\t__brelse(old_bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unmap_underlying_metadata(struct block_device *bdev, sector_t block)\n{\n\tstruct buffer_head *old_bh;\n\n\tmight_sleep();\n\n\told_bh = __find_get_block_slow(bdev, block);\n\tif (old_bh) {\n\t\tclear_buffer_dirty(old_bh);\n\t\twait_on_buffer(old_bh);\n\t\tclear_buffer_req(old_bh);\n\t\t__brelse(old_bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_block",
          "args": [
            "inode",
            "block",
            "bh",
            "1"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "139-147",
          "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "bh->b_size != blocksize"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_size_bits",
          "args": [
            "blocksize"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "block_size_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1634-1637",
          "snippet": "static inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_page_buffers",
          "args": [
            "page",
            "inode",
            "0"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "create_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1639-1646",
          "snippet": "static struct buffer_head *create_page_buffers(struct page *page, struct inode *inode, unsigned int b_state)\n{\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << ACCESS_ONCE(inode->i_blkbits), b_state);\n\treturn page_buffers(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic struct buffer_head *create_page_buffers(struct page *page, struct inode *inode, unsigned int b_state)\n{\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << ACCESS_ONCE(inode->i_blkbits), b_state);\n\treturn page_buffers(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "from > to"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "to > PAGE_CACHE_SIZE"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "from > PAGE_CACHE_SIZE"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
  },
  {
    "function_name": "page_zero_new_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1845-1879",
    "snippet": "void page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "start",
            "size"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "to",
            "block_end"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "from",
            "block_start"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_max_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "925-935",
          "snippet": "static sector_t blkdev_max_block(struct block_device *bdev, unsigned int size)\n{\n\tsector_t retval = ~((sector_t)0);\n\tloff_t sz = i_size_read(bdev->bd_inode);\n\n\tif (sz) {\n\t\tunsigned int sizebits = blksize_bits(size);\n\t\tretval = (sz >> sizebits);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic sector_t blkdev_max_block(struct block_device *bdev, unsigned int size)\n{\n\tsector_t retval = ~((sector_t)0);\n\tloff_t sz = i_size_read(bdev->bd_inode);\n\n\tif (sz) {\n\t\tunsigned int sizebits = blksize_bits(size);\n\t\tretval = (sz >> sizebits);\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}"
  },
  {
    "function_name": "__block_write_full_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1677-1838",
    "snippet": "static int __block_write_full_page(struct inode *inode, struct page *page,\n\t\t\tget_block_t *get_block, struct writeback_control *wbc,\n\t\t\tbh_end_io_t *handler)\n{\n\tint err;\n\tsector_t block;\n\tsector_t last_block;\n\tstruct buffer_head *bh, *head;\n\tunsigned int blocksize, bbits;\n\tint nr_underway = 0;\n\tint write_op = (wbc->sync_mode == WB_SYNC_ALL ?\n\t\t\tWRITE_SYNC : WRITE);\n\n\thead = create_page_buffers(page, inode,\n\t\t\t\t\t(1 << BH_Dirty)|(1 << BH_Uptodate));\n\n\t/*\n\t * Be very careful.  We have no exclusion from __set_page_dirty_buffers\n\t * here, and the (potentially unmapped) buffers may become dirty at\n\t * any time.  If a buffer becomes dirty here after we've inspected it\n\t * then we just miss that fact, and the page stays dirty.\n\t *\n\t * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;\n\t * handle that here by just cleaning them.\n\t */\n\n\tbh = head;\n\tblocksize = bh->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlast_block = (i_size_read(inode) - 1) >> bbits;\n\n\t/*\n\t * Get all the dirty buffers mapped to disk addresses and\n\t * handle any aliases from the underlying blockdev's mapping.\n\t */\n\tdo {\n\t\tif (block > last_block) {\n\t\t\t/*\n\t\t\t * mapped buffers outside i_size will occur, because\n\t\t\t * this page can be outside i_size when there is a\n\t\t\t * truncate in progress.\n\t\t\t */\n\t\t\t/*\n\t\t\t * The buffer was zeroed by block_write_full_page()\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t} else if ((!buffer_mapped(bh) || buffer_delay(bh)) &&\n\t\t\t   buffer_dirty(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tgoto recover;\n\t\t\tclear_buffer_delay(bh);\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\t/* blockdev mappings never come here */\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tblock++;\n\t} while (bh != head);\n\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tcontinue;\n\t\t/*\n\t\t * If it's a fully non-blocking write attempt and we cannot\n\t\t * lock the buffer then redirty the page.  Note that this can\n\t\t * potentially cause a busy-wait loop from writeback threads\n\t\t * and kswapd activity, but those code paths have their own\n\t\t * higher-level throttling.\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\tlock_buffer(bh);\n\t\t} else if (!trylock_buffer(bh)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tcontinue;\n\t\t}\n\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/*\n\t * The page and its buffers are protected by PageWriteback(), so we can\n\t * drop the bh refcounts early.\n\t */\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh(write_op, bh);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\n\terr = 0;\ndone:\n\tif (nr_underway == 0) {\n\t\t/*\n\t\t * The page was marked dirty, but the buffers were\n\t\t * clean.  Someone wrote them back by hand with\n\t\t * ll_rw_block/submit_bh.  A rare case.\n\t\t */\n\t\tend_page_writeback(page);\n\n\t\t/*\n\t\t * The page and buffer_heads can be released at any time from\n\t\t * here on.\n\t\t */\n\t}\n\treturn err;\n\nrecover:\n\t/*\n\t * ENOSPC, or some other error.  We may already have added some\n\t * blocks to the file, so we need to write these out to avoid\n\t * exposing stale data.\n\t * The page is currently locked and not marked for writeback\n\t */\n\tbh = head;\n\t/* Recovery: lock and submit the mapped buffers */\n\tdo {\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh) &&\n\t\t    !buffer_delay(bh)) {\n\t\t\tlock_buffer(bh);\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The buffer may have been set dirty during\n\t\t\t * attachment to a dirty page.\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\tSetPageError(page);\n\tBUG_ON(PageWriteback(page));\n\tmapping_set_error(page->mapping, err);\n\tset_page_writeback(page);\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tsubmit_bh(write_op, bh);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\tgoto done;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "write_op",
            "bh"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_async_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "420-423",
          "snippet": "void mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "page->mapping",
            "err"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_async_write_endio",
          "args": [
            "bh",
            "handler"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_async_write_endio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "413-418",
          "snippet": "static void mark_buffer_async_write_endio(struct buffer_head *bh,\n\t\t\t\t\t  bh_end_io_t *handler)\n{\n\tbh->b_end_io = handler;\n\tset_buffer_async_write(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void mark_buffer_async_write_endio(struct buffer_head *bh,\n\t\t\t\t\t  bh_end_io_t *handler)\n{\n\tbh->b_end_io = handler;\n\tset_buffer_async_write(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_buffer",
          "args": [
            "bh"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_underlying_metadata",
          "args": [
            "bh->b_bdev",
            "bh->b_blocknr"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_underlying_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1610-1623",
          "snippet": "void unmap_underlying_metadata(struct block_device *bdev, sector_t block)\n{\n\tstruct buffer_head *old_bh;\n\n\tmight_sleep();\n\n\told_bh = __find_get_block_slow(bdev, block);\n\tif (old_bh) {\n\t\tclear_buffer_dirty(old_bh);\n\t\twait_on_buffer(old_bh);\n\t\tclear_buffer_req(old_bh);\n\t\t__brelse(old_bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unmap_underlying_metadata(struct block_device *bdev, sector_t block)\n{\n\tstruct buffer_head *old_bh;\n\n\tmight_sleep();\n\n\told_bh = __find_get_block_slow(bdev, block);\n\tif (old_bh) {\n\t\tclear_buffer_dirty(old_bh);\n\t\twait_on_buffer(old_bh);\n\t\tclear_buffer_req(old_bh);\n\t\t__brelse(old_bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_block",
          "args": [
            "inode",
            "block",
            "bh",
            "1"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "139-147",
          "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "bh->b_size != blocksize"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_size_bits",
          "args": [
            "blocksize"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "block_size_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1634-1637",
          "snippet": "static inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_page_buffers",
          "args": [
            "page",
            "inode",
            "(1 << BH_Dirty)|(1 << BH_Uptodate)"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "create_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1639-1646",
          "snippet": "static struct buffer_head *create_page_buffers(struct page *page, struct inode *inode, unsigned int b_state)\n{\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << ACCESS_ONCE(inode->i_blkbits), b_state);\n\treturn page_buffers(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic struct buffer_head *create_page_buffers(struct page *page, struct inode *inode, unsigned int b_state)\n{\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << ACCESS_ONCE(inode->i_blkbits), b_state);\n\treturn page_buffers(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int __block_write_full_page(struct inode *inode, struct page *page,\n\t\t\tget_block_t *get_block, struct writeback_control *wbc,\n\t\t\tbh_end_io_t *handler)\n{\n\tint err;\n\tsector_t block;\n\tsector_t last_block;\n\tstruct buffer_head *bh, *head;\n\tunsigned int blocksize, bbits;\n\tint nr_underway = 0;\n\tint write_op = (wbc->sync_mode == WB_SYNC_ALL ?\n\t\t\tWRITE_SYNC : WRITE);\n\n\thead = create_page_buffers(page, inode,\n\t\t\t\t\t(1 << BH_Dirty)|(1 << BH_Uptodate));\n\n\t/*\n\t * Be very careful.  We have no exclusion from __set_page_dirty_buffers\n\t * here, and the (potentially unmapped) buffers may become dirty at\n\t * any time.  If a buffer becomes dirty here after we've inspected it\n\t * then we just miss that fact, and the page stays dirty.\n\t *\n\t * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;\n\t * handle that here by just cleaning them.\n\t */\n\n\tbh = head;\n\tblocksize = bh->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlast_block = (i_size_read(inode) - 1) >> bbits;\n\n\t/*\n\t * Get all the dirty buffers mapped to disk addresses and\n\t * handle any aliases from the underlying blockdev's mapping.\n\t */\n\tdo {\n\t\tif (block > last_block) {\n\t\t\t/*\n\t\t\t * mapped buffers outside i_size will occur, because\n\t\t\t * this page can be outside i_size when there is a\n\t\t\t * truncate in progress.\n\t\t\t */\n\t\t\t/*\n\t\t\t * The buffer was zeroed by block_write_full_page()\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t} else if ((!buffer_mapped(bh) || buffer_delay(bh)) &&\n\t\t\t   buffer_dirty(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tgoto recover;\n\t\t\tclear_buffer_delay(bh);\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\t/* blockdev mappings never come here */\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tblock++;\n\t} while (bh != head);\n\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tcontinue;\n\t\t/*\n\t\t * If it's a fully non-blocking write attempt and we cannot\n\t\t * lock the buffer then redirty the page.  Note that this can\n\t\t * potentially cause a busy-wait loop from writeback threads\n\t\t * and kswapd activity, but those code paths have their own\n\t\t * higher-level throttling.\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\tlock_buffer(bh);\n\t\t} else if (!trylock_buffer(bh)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tcontinue;\n\t\t}\n\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/*\n\t * The page and its buffers are protected by PageWriteback(), so we can\n\t * drop the bh refcounts early.\n\t */\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh(write_op, bh);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\n\terr = 0;\ndone:\n\tif (nr_underway == 0) {\n\t\t/*\n\t\t * The page was marked dirty, but the buffers were\n\t\t * clean.  Someone wrote them back by hand with\n\t\t * ll_rw_block/submit_bh.  A rare case.\n\t\t */\n\t\tend_page_writeback(page);\n\n\t\t/*\n\t\t * The page and buffer_heads can be released at any time from\n\t\t * here on.\n\t\t */\n\t}\n\treturn err;\n\nrecover:\n\t/*\n\t * ENOSPC, or some other error.  We may already have added some\n\t * blocks to the file, so we need to write these out to avoid\n\t * exposing stale data.\n\t * The page is currently locked and not marked for writeback\n\t */\n\tbh = head;\n\t/* Recovery: lock and submit the mapped buffers */\n\tdo {\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh) &&\n\t\t    !buffer_delay(bh)) {\n\t\t\tlock_buffer(bh);\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The buffer may have been set dirty during\n\t\t\t * attachment to a dirty page.\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\tSetPageError(page);\n\tBUG_ON(PageWriteback(page));\n\tmapping_set_error(page->mapping, err);\n\tset_page_writeback(page);\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tsubmit_bh(write_op, bh);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\tgoto done;\n}"
  },
  {
    "function_name": "create_page_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1639-1646",
    "snippet": "static struct buffer_head *create_page_buffers(struct page *page, struct inode *inode, unsigned int b_state)\n{\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << ACCESS_ONCE(inode->i_blkbits), b_state);\n\treturn page_buffers(page);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "1 << ACCESS_ONCE(inode->i_blkbits)",
            "b_state"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1564-1591",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "inode->i_blkbits"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic struct buffer_head *create_page_buffers(struct page *page, struct inode *inode, unsigned int b_state)\n{\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << ACCESS_ONCE(inode->i_blkbits), b_state);\n\treturn page_buffers(page);\n}"
  },
  {
    "function_name": "block_size_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1634-1637",
    "snippet": "static inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "blocksize"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}"
  },
  {
    "function_name": "unmap_underlying_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1610-1623",
    "snippet": "void unmap_underlying_metadata(struct block_device *bdev, sector_t block)\n{\n\tstruct buffer_head *old_bh;\n\n\tmight_sleep();\n\n\told_bh = __find_get_block_slow(bdev, block);\n\tif (old_bh) {\n\t\tclear_buffer_dirty(old_bh);\n\t\twait_on_buffer(old_bh);\n\t\tclear_buffer_req(old_bh);\n\t\t__brelse(old_bh);\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "old_bh"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_req",
          "args": [
            "old_bh"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "old_bh"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "old_bh"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__find_get_block_slow",
          "args": [
            "bdev",
            "block"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "__find_get_block_slow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "197-252",
          "snippet": "static struct buffer_head *\n__find_get_block_slow(struct block_device *bdev, sector_t block)\n{\n\tstruct inode *bd_inode = bdev->bd_inode;\n\tstruct address_space *bd_mapping = bd_inode->i_mapping;\n\tstruct buffer_head *ret = NULL;\n\tpgoff_t index;\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct page *page;\n\tint all_mapped = 1;\n\n\tindex = block >> (PAGE_CACHE_SHIFT - bd_inode->i_blkbits);\n\tpage = find_get_page_flags(bd_mapping, index, FGP_ACCESSED);\n\tif (!page)\n\t\tgoto out;\n\n\tspin_lock(&bd_mapping->private_lock);\n\tif (!page_has_buffers(page))\n\t\tgoto out_unlock;\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tall_mapped = 0;\n\t\telse if (bh->b_blocknr == block) {\n\t\t\tret = bh;\n\t\t\tget_bh(bh);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/* we might be here because some of the buffers on this page are\n\t * not mapped.  This is due to various races between\n\t * file io on the block device and getblk.  It gets dealt with\n\t * elsewhere, don't buffer_error if we had some unmapped buffers\n\t */\n\tif (all_mapped) {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\tprintk(\"__find_get_block_slow() failed. \"\n\t\t\t\"block=%llu, b_blocknr=%llu\\n\",\n\t\t\t(unsigned long long)block,\n\t\t\t(unsigned long long)bh->b_blocknr);\n\t\tprintk(\"b_state=0x%08lx, b_size=%zu\\n\",\n\t\t\tbh->b_state, bh->b_size);\n\t\tprintk(\"device %s blocksize: %d\\n\", bdevname(bdev, b),\n\t\t\t1 << bd_inode->i_blkbits);\n\t}\nout_unlock:\n\tspin_unlock(&bd_mapping->private_lock);\n\tpage_cache_release(page);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic struct buffer_head *\n__find_get_block_slow(struct block_device *bdev, sector_t block)\n{\n\tstruct inode *bd_inode = bdev->bd_inode;\n\tstruct address_space *bd_mapping = bd_inode->i_mapping;\n\tstruct buffer_head *ret = NULL;\n\tpgoff_t index;\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct page *page;\n\tint all_mapped = 1;\n\n\tindex = block >> (PAGE_CACHE_SHIFT - bd_inode->i_blkbits);\n\tpage = find_get_page_flags(bd_mapping, index, FGP_ACCESSED);\n\tif (!page)\n\t\tgoto out;\n\n\tspin_lock(&bd_mapping->private_lock);\n\tif (!page_has_buffers(page))\n\t\tgoto out_unlock;\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tall_mapped = 0;\n\t\telse if (bh->b_blocknr == block) {\n\t\t\tret = bh;\n\t\t\tget_bh(bh);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/* we might be here because some of the buffers on this page are\n\t * not mapped.  This is due to various races between\n\t * file io on the block device and getblk.  It gets dealt with\n\t * elsewhere, don't buffer_error if we had some unmapped buffers\n\t */\n\tif (all_mapped) {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\tprintk(\"__find_get_block_slow() failed. \"\n\t\t\t\"block=%llu, b_blocknr=%llu\\n\",\n\t\t\t(unsigned long long)block,\n\t\t\t(unsigned long long)bh->b_blocknr);\n\t\tprintk(\"b_state=0x%08lx, b_size=%zu\\n\",\n\t\t\tbh->b_state, bh->b_size);\n\t\tprintk(\"device %s blocksize: %d\\n\", bdevname(bdev, b),\n\t\t\t1 << bd_inode->i_blkbits);\n\t}\nout_unlock:\n\tspin_unlock(&bd_mapping->private_lock);\n\tpage_cache_release(page);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unmap_underlying_metadata(struct block_device *bdev, sector_t block)\n{\n\tstruct buffer_head *old_bh;\n\n\tmight_sleep();\n\n\told_bh = __find_get_block_slow(bdev, block);\n\tif (old_bh) {\n\t\tclear_buffer_dirty(old_bh);\n\t\twait_on_buffer(old_bh);\n\t\tclear_buffer_req(old_bh);\n\t\t__brelse(old_bh);\n\t}\n}"
  },
  {
    "function_name": "create_empty_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1564-1591",
    "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&page->mapping->private_lock"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "attach_page_buffers",
          "args": [
            "page",
            "head"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&page->mapping->private_lock"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page_buffers",
          "args": [
            "page",
            "blocksize",
            "1"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "855-908",
          "snippet": "struct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tint retry)\n{\n\tstruct buffer_head *bh, *head;\n\tlong offset;\n\ntry_again:\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(GFP_NOFS);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\t/*\n\t * Return failure for non-async IO requests.  Async IO requests\n\t * are not allowed to fail, so we have to wait until buffer heads\n\t * become available.  But we don't want tasks sleeping with \n\t * partially complete buffers, so all were released above.\n\t */\n\tif (!retry)\n\t\treturn NULL;\n\n\t/* We're _really_ low on memory. Now we just\n\t * wait for old buffer heads to become free due to\n\t * finishing IO.  Since this is an async request and\n\t * the reserve list is empty, we're sure there are \n\t * async buffer heads in use.\n\t */\n\tfree_more_memory();\n\tgoto try_again;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nstruct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tint retry)\n{\n\tstruct buffer_head *bh, *head;\n\tlong offset;\n\ntry_again:\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(GFP_NOFS);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\t/*\n\t * Return failure for non-async IO requests.  Async IO requests\n\t * are not allowed to fail, so we have to wait until buffer heads\n\t * become available.  But we don't want tasks sleeping with \n\t * partially complete buffers, so all were released above.\n\t */\n\tif (!retry)\n\t\treturn NULL;\n\n\t/* We're _really_ low on memory. Now we just\n\t * wait for old buffer heads to become free due to\n\t * finishing IO.  Since this is an async request and\n\t * the reserve list is empty, we're sure there are \n\t * async buffer heads in use.\n\t */\n\tfree_more_memory();\n\tgoto try_again;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
  },
  {
    "function_name": "block_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1509-1555",
    "snippet": "void block_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t  unsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int curr_off = 0;\n\tunsigned int stop = length + offset;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\t/*\n\t * Check for overflow\n\t */\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\t/*\n\t\t * Are we still fully in range ?\n\t\t */\n\t\tif (next_off > stop)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * is this block fully invalidated?\n\t\t */\n\t\tif (offset <= curr_off)\n\t\t\tdiscard_buffer(bh);\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\t} while (bh != head);\n\n\t/*\n\t * We release buffers only if the entire page is being invalidated.\n\t * The get_block cached value has been unconditionally invalidated,\n\t * so real IO is not possible anymore.\n\t */\n\tif (offset == 0)\n\t\ttry_to_release_page(page, 0);\nout:\n\treturn;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_release_page",
          "args": [
            "page",
            "0"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "discard_buffer",
          "args": [
            "bh"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "discard_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1475-1491",
          "snippet": "static void discard_buffer(struct buffer_head * bh)\n{\n\tunsigned long b_state, b_state_old;\n\n\tlock_buffer(bh);\n\tclear_buffer_dirty(bh);\n\tbh->b_bdev = NULL;\n\tb_state = bh->b_state;\n\tfor (;;) {\n\t\tb_state_old = cmpxchg(&bh->b_state, b_state,\n\t\t\t\t      (b_state & ~BUFFER_FLAGS_DISCARD));\n\t\tif (b_state_old == b_state)\n\t\t\tbreak;\n\t\tb_state = b_state_old;\n\t}\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BUFFER_FLAGS_DISCARD \\\n\t(1 << BH_Mapped | 1 << BH_New | 1 << BH_Req | \\\n\t 1 << BH_Delay | 1 << BH_Unwritten)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\n#define BUFFER_FLAGS_DISCARD \\\n\t(1 << BH_Mapped | 1 << BH_New | 1 << BH_Req | \\\n\t 1 << BH_Delay | 1 << BH_Unwritten)\n\nstatic void discard_buffer(struct buffer_head * bh)\n{\n\tunsigned long b_state, b_state_old;\n\n\tlock_buffer(bh);\n\tclear_buffer_dirty(bh);\n\tbh->b_bdev = NULL;\n\tb_state = bh->b_state;\n\tfor (;;) {\n\t\tb_state_old = cmpxchg(&bh->b_state, b_state,\n\t\t\t\t      (b_state & ~BUFFER_FLAGS_DISCARD));\n\t\tif (b_state_old == b_state)\n\t\t\tbreak;\n\t\tb_state = b_state_old;\n\t}\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "stop > PAGE_CACHE_SIZE || stop < length"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid block_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t  unsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int curr_off = 0;\n\tunsigned int stop = length + offset;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\t/*\n\t * Check for overflow\n\t */\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\t/*\n\t\t * Are we still fully in range ?\n\t\t */\n\t\tif (next_off > stop)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * is this block fully invalidated?\n\t\t */\n\t\tif (offset <= curr_off)\n\t\t\tdiscard_buffer(bh);\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\t} while (bh != head);\n\n\t/*\n\t * We release buffers only if the entire page is being invalidated.\n\t * The get_block cached value has been unconditionally invalidated,\n\t * so real IO is not possible anymore.\n\t */\n\tif (offset == 0)\n\t\ttry_to_release_page(page, 0);\nout:\n\treturn;\n}"
  },
  {
    "function_name": "discard_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1475-1491",
    "snippet": "static void discard_buffer(struct buffer_head * bh)\n{\n\tunsigned long b_state, b_state_old;\n\n\tlock_buffer(bh);\n\tclear_buffer_dirty(bh);\n\tbh->b_bdev = NULL;\n\tb_state = bh->b_state;\n\tfor (;;) {\n\t\tb_state_old = cmpxchg(&bh->b_state, b_state,\n\t\t\t\t      (b_state & ~BUFFER_FLAGS_DISCARD));\n\t\tif (b_state_old == b_state)\n\t\t\tbreak;\n\t\tb_state = b_state_old;\n\t}\n\tunlock_buffer(bh);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BUFFER_FLAGS_DISCARD \\\n\t(1 << BH_Mapped | 1 << BH_New | 1 << BH_Req | \\\n\t 1 << BH_Delay | 1 << BH_Unwritten)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&bh->b_state",
            "b_state",
            "(b_state & ~BUFFER_FLAGS_DISCARD)"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\n#define BUFFER_FLAGS_DISCARD \\\n\t(1 << BH_Mapped | 1 << BH_New | 1 << BH_Req | \\\n\t 1 << BH_Delay | 1 << BH_Unwritten)\n\nstatic void discard_buffer(struct buffer_head * bh)\n{\n\tunsigned long b_state, b_state_old;\n\n\tlock_buffer(bh);\n\tclear_buffer_dirty(bh);\n\tbh->b_bdev = NULL;\n\tb_state = bh->b_state;\n\tfor (;;) {\n\t\tb_state_old = cmpxchg(&bh->b_state, b_state,\n\t\t\t\t      (b_state & ~BUFFER_FLAGS_DISCARD));\n\t\tif (b_state_old == b_state)\n\t\t\tbreak;\n\t\tb_state = b_state_old;\n\t}\n\tunlock_buffer(bh);\n}"
  },
  {
    "function_name": "set_bh_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1451-1463",
    "snippet": "void set_bh_page(struct buffer_head *bh,\n\t\tstruct page *page, unsigned long offset)\n{\n\tbh->b_page = page;\n\tBUG_ON(offset >= PAGE_SIZE);\n\tif (PageHighMem(page))\n\t\t/*\n\t\t * This catches illegal uses and preserves the offset:\n\t\t */\n\t\tbh->b_data = (char *)(0 + offset);\n\telse\n\t\tbh->b_data = page_address(page) + offset;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "page"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset >= PAGE_SIZE"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid set_bh_page(struct buffer_head *bh,\n\t\tstruct page *page, unsigned long offset)\n{\n\tbh->b_page = page;\n\tBUG_ON(offset >= PAGE_SIZE);\n\tif (PageHighMem(page))\n\t\t/*\n\t\t * This catches illegal uses and preserves the offset:\n\t\t */\n\t\tbh->b_data = (char *)(0 + offset);\n\telse\n\t\tbh->b_data = page_address(page) + offset;\n}"
  },
  {
    "function_name": "invalidate_bh_lrus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1445-1448",
    "snippet": "void invalidate_bh_lrus(void)\n{\n\ton_each_cpu_cond(has_bh_in_lru, invalidate_bh_lru, NULL, 1, GFP_KERNEL);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "on_each_cpu_cond",
          "args": [
            "has_bh_in_lru",
            "invalidate_bh_lru",
            "NULL",
            "1",
            "GFP_KERNEL"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid invalidate_bh_lrus(void)\n{\n\ton_each_cpu_cond(has_bh_in_lru, invalidate_bh_lru, NULL, 1, GFP_KERNEL);\n}"
  },
  {
    "function_name": "has_bh_in_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1432-1443",
    "snippet": "static bool has_bh_in_lru(int cpu, void *dummy)\n{\n\tstruct bh_lru *b = per_cpu_ptr(&bh_lrus, cpu);\n\tint i;\n\t\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tif (b->bhs[i])\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BH_LRU_SIZE\t16"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&bh_lrus",
            "cpu"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\n#define BH_LRU_SIZE\t16\n\nstatic DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};\n\nstatic bool has_bh_in_lru(int cpu, void *dummy)\n{\n\tstruct bh_lru *b = per_cpu_ptr(&bh_lrus, cpu);\n\tint i;\n\t\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tif (b->bhs[i])\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "invalidate_bh_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1420-1430",
    "snippet": "static void invalidate_bh_lru(void *arg)\n{\n\tstruct bh_lru *b = &get_cpu_var(bh_lrus);\n\tint i;\n\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tbrelse(b->bhs[i]);\n\t\tb->bhs[i] = NULL;\n\t}\n\tput_cpu_var(bh_lrus);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BH_LRU_SIZE\t16"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu_var",
          "args": [
            "bh_lrus"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "b->bhs[i]"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu_var",
          "args": [
            "bh_lrus"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\n#define BH_LRU_SIZE\t16\n\nstatic DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};\n\nstatic void invalidate_bh_lru(void *arg)\n{\n\tstruct bh_lru *b = &get_cpu_var(bh_lrus);\n\tint i;\n\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tbrelse(b->bhs[i]);\n\t\tb->bhs[i] = NULL;\n\t}\n\tput_cpu_var(bh_lrus);\n}"
  },
  {
    "function_name": "__bread_gfp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1403-1412",
    "snippet": "struct buffer_head *\n__bread_gfp(struct block_device *bdev, sector_t block,\n\t\t   unsigned size, gfp_t gfp)\n{\n\tstruct buffer_head *bh = __getblk_gfp(bdev, block, size, gfp);\n\n\tif (likely(bh) && !buffer_uptodate(bh))\n\t\tbh = __bread_slow(bh);\n\treturn bh;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bread_slow",
          "args": [
            "bh"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "__bread_slow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1206-1222",
          "snippet": "static struct buffer_head *__bread_slow(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn bh;\n\t} else {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t\twait_on_buffer(bh);\n\t\tif (buffer_uptodate(bh))\n\t\t\treturn bh;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic struct buffer_head *__bread_slow(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn bh;\n\t} else {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t\twait_on_buffer(bh);\n\t\tif (buffer_uptodate(bh))\n\t\t\treturn bh;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "bh"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__getblk_gfp",
          "args": [
            "bdev",
            "block",
            "size",
            "gfp"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "__getblk_gfp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1365-1375",
          "snippet": "struct buffer_head *\n__getblk_gfp(struct block_device *bdev, sector_t block,\n\t     unsigned size, gfp_t gfp)\n{\n\tstruct buffer_head *bh = __find_get_block(bdev, block, size);\n\n\tmight_sleep();\n\tif (bh == NULL)\n\t\tbh = __getblk_slow(bdev, block, size, gfp);\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__getblk_gfp(struct block_device *bdev, sector_t block,\n\t     unsigned size, gfp_t gfp)\n{\n\tstruct buffer_head *bh = __find_get_block(bdev, block, size);\n\n\tmight_sleep();\n\tif (bh == NULL)\n\t\tbh = __getblk_slow(bdev, block, size, gfp);\n\treturn bh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__bread_gfp(struct block_device *bdev, sector_t block,\n\t\t   unsigned size, gfp_t gfp)\n{\n\tstruct buffer_head *bh = __getblk_gfp(bdev, block, size, gfp);\n\n\tif (likely(bh) && !buffer_uptodate(bh))\n\t\tbh = __bread_slow(bh);\n\treturn bh;\n}"
  },
  {
    "function_name": "__breadahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1381-1388",
    "snippet": "void __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READA",
            "1",
            "&bh"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "bh"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__getblk",
          "args": [
            "bdev",
            "block",
            "size"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}"
  },
  {
    "function_name": "__getblk_gfp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1365-1375",
    "snippet": "struct buffer_head *\n__getblk_gfp(struct block_device *bdev, sector_t block,\n\t     unsigned size, gfp_t gfp)\n{\n\tstruct buffer_head *bh = __find_get_block(bdev, block, size);\n\n\tmight_sleep();\n\tif (bh == NULL)\n\t\tbh = __getblk_slow(bdev, block, size, gfp);\n\treturn bh;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__getblk_slow",
          "args": [
            "bdev",
            "block",
            "size",
            "gfp"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "__getblk_slow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1073-1103",
          "snippet": "struct buffer_head *\n__getblk_slow(struct block_device *bdev, sector_t block,\n\t     unsigned size, gfp_t gfp)\n{\n\t/* Size must be multiple of hard sectorsize */\n\tif (unlikely(size & (bdev_logical_block_size(bdev)-1) ||\n\t\t\t(size < 512 || size > PAGE_SIZE))) {\n\t\tprintk(KERN_ERR \"getblk(): invalid block size %d requested\\n\",\n\t\t\t\t\tsize);\n\t\tprintk(KERN_ERR \"logical block size: %d\\n\",\n\t\t\t\t\tbdev_logical_block_size(bdev));\n\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tfor (;;) {\n\t\tstruct buffer_head *bh;\n\t\tint ret;\n\n\t\tbh = __find_get_block(bdev, block, size);\n\t\tif (bh)\n\t\t\treturn bh;\n\n\t\tret = grow_buffers(bdev, block, size, gfp);\n\t\tif (ret < 0)\n\t\t\treturn NULL;\n\t\tif (ret == 0)\n\t\t\tfree_more_memory();\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__getblk_slow(struct block_device *bdev, sector_t block,\n\t     unsigned size, gfp_t gfp)\n{\n\t/* Size must be multiple of hard sectorsize */\n\tif (unlikely(size & (bdev_logical_block_size(bdev)-1) ||\n\t\t\t(size < 512 || size > PAGE_SIZE))) {\n\t\tprintk(KERN_ERR \"getblk(): invalid block size %d requested\\n\",\n\t\t\t\t\tsize);\n\t\tprintk(KERN_ERR \"logical block size: %d\\n\",\n\t\t\t\t\tbdev_logical_block_size(bdev));\n\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tfor (;;) {\n\t\tstruct buffer_head *bh;\n\t\tint ret;\n\n\t\tbh = __find_get_block(bdev, block, size);\n\t\tif (bh)\n\t\t\treturn bh;\n\n\t\tret = grow_buffers(bdev, block, size, gfp);\n\t\tif (ret < 0)\n\t\t\treturn NULL;\n\t\tif (ret == 0)\n\t\t\tfree_more_memory();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__find_get_block",
          "args": [
            "bdev",
            "block",
            "size"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "__find_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1340-1354",
          "snippet": "struct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__getblk_gfp(struct block_device *bdev, sector_t block,\n\t     unsigned size, gfp_t gfp)\n{\n\tstruct buffer_head *bh = __find_get_block(bdev, block, size);\n\n\tmight_sleep();\n\tif (bh == NULL)\n\t\tbh = __getblk_slow(bdev, block, size, gfp);\n\treturn bh;\n}"
  },
  {
    "function_name": "__find_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1340-1354",
    "snippet": "struct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "touch_buffer",
          "args": [
            "bh"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "touch_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "57-61",
          "snippet": "inline void touch_buffer(struct buffer_head *bh)\n{\n\ttrace_block_touch_buffer(bh);\n\tmark_page_accessed(bh->b_page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\ninline void touch_buffer(struct buffer_head *bh)\n{\n\ttrace_block_touch_buffer(bh);\n\tmark_page_accessed(bh->b_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_lru_install",
          "args": [
            "bh"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "bh_lru_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1264-1300",
          "snippet": "static void bh_lru_install(struct buffer_head *bh)\n{\n\tstruct buffer_head *evictee = NULL;\n\n\tcheck_irqs_on();\n\tbh_lru_lock();\n\tif (__this_cpu_read(bh_lrus.bhs[0]) != bh) {\n\t\tstruct buffer_head *bhs[BH_LRU_SIZE];\n\t\tint in;\n\t\tint out = 0;\n\n\t\tget_bh(bh);\n\t\tbhs[out++] = bh;\n\t\tfor (in = 0; in < BH_LRU_SIZE; in++) {\n\t\t\tstruct buffer_head *bh2 =\n\t\t\t\t__this_cpu_read(bh_lrus.bhs[in]);\n\n\t\t\tif (bh2 == bh) {\n\t\t\t\t__brelse(bh2);\n\t\t\t} else {\n\t\t\t\tif (out >= BH_LRU_SIZE) {\n\t\t\t\t\tBUG_ON(evictee != NULL);\n\t\t\t\t\tevictee = bh2;\n\t\t\t\t} else {\n\t\t\t\t\tbhs[out++] = bh2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (out < BH_LRU_SIZE)\n\t\t\tbhs[out++] = NULL;\n\t\tmemcpy(this_cpu_ptr(&bh_lrus.bhs), bhs, sizeof(bhs));\n\t}\n\tbh_lru_unlock();\n\n\tif (evictee)\n\t\t__brelse(evictee);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BH_LRU_SIZE\t16"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\n#define BH_LRU_SIZE\t16\n\nstatic DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};\n\nstatic void bh_lru_install(struct buffer_head *bh)\n{\n\tstruct buffer_head *evictee = NULL;\n\n\tcheck_irqs_on();\n\tbh_lru_lock();\n\tif (__this_cpu_read(bh_lrus.bhs[0]) != bh) {\n\t\tstruct buffer_head *bhs[BH_LRU_SIZE];\n\t\tint in;\n\t\tint out = 0;\n\n\t\tget_bh(bh);\n\t\tbhs[out++] = bh;\n\t\tfor (in = 0; in < BH_LRU_SIZE; in++) {\n\t\t\tstruct buffer_head *bh2 =\n\t\t\t\t__this_cpu_read(bh_lrus.bhs[in]);\n\n\t\t\tif (bh2 == bh) {\n\t\t\t\t__brelse(bh2);\n\t\t\t} else {\n\t\t\t\tif (out >= BH_LRU_SIZE) {\n\t\t\t\t\tBUG_ON(evictee != NULL);\n\t\t\t\t\tevictee = bh2;\n\t\t\t\t} else {\n\t\t\t\t\tbhs[out++] = bh2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (out < BH_LRU_SIZE)\n\t\t\tbhs[out++] = NULL;\n\t\tmemcpy(this_cpu_ptr(&bh_lrus.bhs), bhs, sizeof(bhs));\n\t}\n\tbh_lru_unlock();\n\n\tif (evictee)\n\t\t__brelse(evictee);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__find_get_block_slow",
          "args": [
            "bdev",
            "block"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "__find_get_block_slow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "197-252",
          "snippet": "static struct buffer_head *\n__find_get_block_slow(struct block_device *bdev, sector_t block)\n{\n\tstruct inode *bd_inode = bdev->bd_inode;\n\tstruct address_space *bd_mapping = bd_inode->i_mapping;\n\tstruct buffer_head *ret = NULL;\n\tpgoff_t index;\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct page *page;\n\tint all_mapped = 1;\n\n\tindex = block >> (PAGE_CACHE_SHIFT - bd_inode->i_blkbits);\n\tpage = find_get_page_flags(bd_mapping, index, FGP_ACCESSED);\n\tif (!page)\n\t\tgoto out;\n\n\tspin_lock(&bd_mapping->private_lock);\n\tif (!page_has_buffers(page))\n\t\tgoto out_unlock;\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tall_mapped = 0;\n\t\telse if (bh->b_blocknr == block) {\n\t\t\tret = bh;\n\t\t\tget_bh(bh);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/* we might be here because some of the buffers on this page are\n\t * not mapped.  This is due to various races between\n\t * file io on the block device and getblk.  It gets dealt with\n\t * elsewhere, don't buffer_error if we had some unmapped buffers\n\t */\n\tif (all_mapped) {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\tprintk(\"__find_get_block_slow() failed. \"\n\t\t\t\"block=%llu, b_blocknr=%llu\\n\",\n\t\t\t(unsigned long long)block,\n\t\t\t(unsigned long long)bh->b_blocknr);\n\t\tprintk(\"b_state=0x%08lx, b_size=%zu\\n\",\n\t\t\tbh->b_state, bh->b_size);\n\t\tprintk(\"device %s blocksize: %d\\n\", bdevname(bdev, b),\n\t\t\t1 << bd_inode->i_blkbits);\n\t}\nout_unlock:\n\tspin_unlock(&bd_mapping->private_lock);\n\tpage_cache_release(page);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic struct buffer_head *\n__find_get_block_slow(struct block_device *bdev, sector_t block)\n{\n\tstruct inode *bd_inode = bdev->bd_inode;\n\tstruct address_space *bd_mapping = bd_inode->i_mapping;\n\tstruct buffer_head *ret = NULL;\n\tpgoff_t index;\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct page *page;\n\tint all_mapped = 1;\n\n\tindex = block >> (PAGE_CACHE_SHIFT - bd_inode->i_blkbits);\n\tpage = find_get_page_flags(bd_mapping, index, FGP_ACCESSED);\n\tif (!page)\n\t\tgoto out;\n\n\tspin_lock(&bd_mapping->private_lock);\n\tif (!page_has_buffers(page))\n\t\tgoto out_unlock;\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tall_mapped = 0;\n\t\telse if (bh->b_blocknr == block) {\n\t\t\tret = bh;\n\t\t\tget_bh(bh);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/* we might be here because some of the buffers on this page are\n\t * not mapped.  This is due to various races between\n\t * file io on the block device and getblk.  It gets dealt with\n\t * elsewhere, don't buffer_error if we had some unmapped buffers\n\t */\n\tif (all_mapped) {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\tprintk(\"__find_get_block_slow() failed. \"\n\t\t\t\"block=%llu, b_blocknr=%llu\\n\",\n\t\t\t(unsigned long long)block,\n\t\t\t(unsigned long long)bh->b_blocknr);\n\t\tprintk(\"b_state=0x%08lx, b_size=%zu\\n\",\n\t\t\tbh->b_state, bh->b_size);\n\t\tprintk(\"device %s blocksize: %d\\n\", bdevname(bdev, b),\n\t\t\t1 << bd_inode->i_blkbits);\n\t}\nout_unlock:\n\tspin_unlock(&bd_mapping->private_lock);\n\tpage_cache_release(page);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_bh_lru",
          "args": [
            "bdev",
            "block",
            "size"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_bh_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1305-1333",
          "snippet": "static struct buffer_head *\nlookup_bh_lru(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *ret = NULL;\n\tunsigned int i;\n\n\tcheck_irqs_on();\n\tbh_lru_lock();\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tstruct buffer_head *bh = __this_cpu_read(bh_lrus.bhs[i]);\n\n\t\tif (bh && bh->b_blocknr == block && bh->b_bdev == bdev &&\n\t\t    bh->b_size == size) {\n\t\t\tif (i) {\n\t\t\t\twhile (i) {\n\t\t\t\t\t__this_cpu_write(bh_lrus.bhs[i],\n\t\t\t\t\t\t__this_cpu_read(bh_lrus.bhs[i - 1]));\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\t__this_cpu_write(bh_lrus.bhs[0], bh);\n\t\t\t}\n\t\t\tget_bh(bh);\n\t\t\tret = bh;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbh_lru_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BH_LRU_SIZE\t16"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\n#define BH_LRU_SIZE\t16\n\nstatic DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};\n\nstatic struct buffer_head *\nlookup_bh_lru(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *ret = NULL;\n\tunsigned int i;\n\n\tcheck_irqs_on();\n\tbh_lru_lock();\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tstruct buffer_head *bh = __this_cpu_read(bh_lrus.bhs[i]);\n\n\t\tif (bh && bh->b_blocknr == block && bh->b_bdev == bdev &&\n\t\t    bh->b_size == size) {\n\t\t\tif (i) {\n\t\t\t\twhile (i) {\n\t\t\t\t\t__this_cpu_write(bh_lrus.bhs[i],\n\t\t\t\t\t\t__this_cpu_read(bh_lrus.bhs[i - 1]));\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\t__this_cpu_write(bh_lrus.bhs[0], bh);\n\t\t\t}\n\t\t\tget_bh(bh);\n\t\t\tret = bh;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbh_lru_unlock();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}"
  },
  {
    "function_name": "lookup_bh_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1305-1333",
    "snippet": "static struct buffer_head *\nlookup_bh_lru(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *ret = NULL;\n\tunsigned int i;\n\n\tcheck_irqs_on();\n\tbh_lru_lock();\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tstruct buffer_head *bh = __this_cpu_read(bh_lrus.bhs[i]);\n\n\t\tif (bh && bh->b_blocknr == block && bh->b_bdev == bdev &&\n\t\t    bh->b_size == size) {\n\t\t\tif (i) {\n\t\t\t\twhile (i) {\n\t\t\t\t\t__this_cpu_write(bh_lrus.bhs[i],\n\t\t\t\t\t\t__this_cpu_read(bh_lrus.bhs[i - 1]));\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\t__this_cpu_write(bh_lrus.bhs[0], bh);\n\t\t\t}\n\t\t\tget_bh(bh);\n\t\t\tret = bh;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbh_lru_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BH_LRU_SIZE\t16"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bh_lru_unlock",
          "args": [],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "bh_lrus.bhs[0]",
            "bh"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "bh_lrus.bhs[i]",
            "__this_cpu_read(bh_lrus.bhs[i - 1])"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "bh_lrus.bhs[i - 1]"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "bh_lrus.bhs[i]"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_lru_lock",
          "args": [],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irqs_on",
          "args": [],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "check_irqs_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1254-1259",
          "snippet": "static inline void check_irqs_on(void)\n{\n#ifdef irqs_disabled\n\tBUG_ON(irqs_disabled());\n#endif\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic inline void check_irqs_on(void)\n{\n#ifdef irqs_disabled\n\tBUG_ON(irqs_disabled());\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\n#define BH_LRU_SIZE\t16\n\nstatic DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};\n\nstatic struct buffer_head *\nlookup_bh_lru(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *ret = NULL;\n\tunsigned int i;\n\n\tcheck_irqs_on();\n\tbh_lru_lock();\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tstruct buffer_head *bh = __this_cpu_read(bh_lrus.bhs[i]);\n\n\t\tif (bh && bh->b_blocknr == block && bh->b_bdev == bdev &&\n\t\t    bh->b_size == size) {\n\t\t\tif (i) {\n\t\t\t\twhile (i) {\n\t\t\t\t\t__this_cpu_write(bh_lrus.bhs[i],\n\t\t\t\t\t\t__this_cpu_read(bh_lrus.bhs[i - 1]));\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\t__this_cpu_write(bh_lrus.bhs[0], bh);\n\t\t\t}\n\t\t\tget_bh(bh);\n\t\t\tret = bh;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbh_lru_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "bh_lru_install",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1264-1300",
    "snippet": "static void bh_lru_install(struct buffer_head *bh)\n{\n\tstruct buffer_head *evictee = NULL;\n\n\tcheck_irqs_on();\n\tbh_lru_lock();\n\tif (__this_cpu_read(bh_lrus.bhs[0]) != bh) {\n\t\tstruct buffer_head *bhs[BH_LRU_SIZE];\n\t\tint in;\n\t\tint out = 0;\n\n\t\tget_bh(bh);\n\t\tbhs[out++] = bh;\n\t\tfor (in = 0; in < BH_LRU_SIZE; in++) {\n\t\t\tstruct buffer_head *bh2 =\n\t\t\t\t__this_cpu_read(bh_lrus.bhs[in]);\n\n\t\t\tif (bh2 == bh) {\n\t\t\t\t__brelse(bh2);\n\t\t\t} else {\n\t\t\t\tif (out >= BH_LRU_SIZE) {\n\t\t\t\t\tBUG_ON(evictee != NULL);\n\t\t\t\t\tevictee = bh2;\n\t\t\t\t} else {\n\t\t\t\t\tbhs[out++] = bh2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (out < BH_LRU_SIZE)\n\t\t\tbhs[out++] = NULL;\n\t\tmemcpy(this_cpu_ptr(&bh_lrus.bhs), bhs, sizeof(bhs));\n\t}\n\tbh_lru_unlock();\n\n\tif (evictee)\n\t\t__brelse(evictee);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BH_LRU_SIZE\t16"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "evictee"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_lru_unlock",
          "args": [],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "this_cpu_ptr(&bh_lrus.bhs)",
            "bhs",
            "sizeof(bhs)"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&bh_lrus.bhs"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "evictee != NULL"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "bh_lrus.bhs[in]"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "bh_lrus.bhs[0]"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_lru_lock",
          "args": [],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irqs_on",
          "args": [],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "check_irqs_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1254-1259",
          "snippet": "static inline void check_irqs_on(void)\n{\n#ifdef irqs_disabled\n\tBUG_ON(irqs_disabled());\n#endif\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic inline void check_irqs_on(void)\n{\n#ifdef irqs_disabled\n\tBUG_ON(irqs_disabled());\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\n#define BH_LRU_SIZE\t16\n\nstatic DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};\n\nstatic void bh_lru_install(struct buffer_head *bh)\n{\n\tstruct buffer_head *evictee = NULL;\n\n\tcheck_irqs_on();\n\tbh_lru_lock();\n\tif (__this_cpu_read(bh_lrus.bhs[0]) != bh) {\n\t\tstruct buffer_head *bhs[BH_LRU_SIZE];\n\t\tint in;\n\t\tint out = 0;\n\n\t\tget_bh(bh);\n\t\tbhs[out++] = bh;\n\t\tfor (in = 0; in < BH_LRU_SIZE; in++) {\n\t\t\tstruct buffer_head *bh2 =\n\t\t\t\t__this_cpu_read(bh_lrus.bhs[in]);\n\n\t\t\tif (bh2 == bh) {\n\t\t\t\t__brelse(bh2);\n\t\t\t} else {\n\t\t\t\tif (out >= BH_LRU_SIZE) {\n\t\t\t\t\tBUG_ON(evictee != NULL);\n\t\t\t\t\tevictee = bh2;\n\t\t\t\t} else {\n\t\t\t\t\tbhs[out++] = bh2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (out < BH_LRU_SIZE)\n\t\t\tbhs[out++] = NULL;\n\t\tmemcpy(this_cpu_ptr(&bh_lrus.bhs), bhs, sizeof(bhs));\n\t}\n\tbh_lru_unlock();\n\n\tif (evictee)\n\t\t__brelse(evictee);\n}"
  },
  {
    "function_name": "check_irqs_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1254-1259",
    "snippet": "static inline void check_irqs_on(void)\n{\n#ifdef irqs_disabled\n\tBUG_ON(irqs_disabled());\n#endif\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "irqs_disabled()"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic inline void check_irqs_on(void)\n{\n#ifdef irqs_disabled\n\tBUG_ON(irqs_disabled());\n#endif\n}"
  },
  {
    "function_name": "__bread_slow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1206-1222",
    "snippet": "static struct buffer_head *__bread_slow(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn bh;\n\t} else {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t\twait_on_buffer(bh);\n\t\tif (buffer_uptodate(bh))\n\t\t\treturn bh;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "READ",
            "bh"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic struct buffer_head *__bread_slow(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn bh;\n\t} else {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t\twait_on_buffer(bh);\n\t\tif (buffer_uptodate(bh))\n\t\t\treturn bh;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}"
  },
  {
    "function_name": "__bforget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1191-1203",
    "snippet": "void __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&buffer_mapping->private_lock"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bh->b_assoc_buffers"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&buffer_mapping->private_lock"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}"
  },
  {
    "function_name": "__brelse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1177-1184",
    "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\""
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "buf"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&buf->b_count"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
  },
  {
    "function_name": "mark_buffer_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1141-1167",
    "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_page_dirty",
          "args": [
            "page",
            "mapping",
            "0"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "627-641",
          "snippet": "static void __set_page_dirty(struct page *page,\n\t\tstruct address_space *mapping, int warn)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mapping->tree_lock, flags);\n\tif (page->mapping) {\t/* Race with truncate? */\n\t\tWARN_ON_ONCE(warn && !PageUptodate(page));\n\t\taccount_page_dirtied(page, mapping);\n\t\tradix_tree_tag_set(&mapping->page_tree,\n\t\t\t\tpage_index(page), PAGECACHE_TAG_DIRTY);\n\t}\n\tspin_unlock_irqrestore(&mapping->tree_lock, flags);\n\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void __set_page_dirty(struct page *page,\n\t\tstruct address_space *mapping, int warn)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mapping->tree_lock, flags);\n\tif (page->mapping) {\t/* Race with truncate? */\n\t\tWARN_ON_ONCE(warn && !PageUptodate(page));\n\t\taccount_page_dirtied(page, mapping);\n\t\tradix_tree_tag_set(&mapping->page_tree,\n\t\t\t\tpage_index(page), PAGECACHE_TAG_DIRTY);\n\t}\n\tspin_unlock_irqrestore(&mapping->tree_lock, flags);\n\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestSetPageDirty",
          "args": [
            "page"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_set_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_block_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "__getblk_slow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1073-1103",
    "snippet": "struct buffer_head *\n__getblk_slow(struct block_device *bdev, sector_t block,\n\t     unsigned size, gfp_t gfp)\n{\n\t/* Size must be multiple of hard sectorsize */\n\tif (unlikely(size & (bdev_logical_block_size(bdev)-1) ||\n\t\t\t(size < 512 || size > PAGE_SIZE))) {\n\t\tprintk(KERN_ERR \"getblk(): invalid block size %d requested\\n\",\n\t\t\t\t\tsize);\n\t\tprintk(KERN_ERR \"logical block size: %d\\n\",\n\t\t\t\t\tbdev_logical_block_size(bdev));\n\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tfor (;;) {\n\t\tstruct buffer_head *bh;\n\t\tint ret;\n\n\t\tbh = __find_get_block(bdev, block, size);\n\t\tif (bh)\n\t\t\treturn bh;\n\n\t\tret = grow_buffers(bdev, block, size, gfp);\n\t\tif (ret < 0)\n\t\t\treturn NULL;\n\t\tif (ret == 0)\n\t\t\tfree_more_memory();\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_more_memory",
          "args": [],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "free_more_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "257-273",
          "snippet": "static void free_more_memory(void)\n{\n\tstruct zone *zone;\n\tint nid;\n\n\twakeup_flusher_threads(1024, WB_REASON_FREE_MORE_MEM);\n\tyield();\n\n\tfor_each_online_node(nid) {\n\t\t(void)first_zones_zonelist(node_zonelist(nid, GFP_NOFS),\n\t\t\t\t\t\tgfp_zone(GFP_NOFS), NULL,\n\t\t\t\t\t\t&zone);\n\t\tif (zone)\n\t\t\ttry_to_free_pages(node_zonelist(nid, GFP_NOFS), 0,\n\t\t\t\t\t\tGFP_NOFS, NULL);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void free_more_memory(void)\n{\n\tstruct zone *zone;\n\tint nid;\n\n\twakeup_flusher_threads(1024, WB_REASON_FREE_MORE_MEM);\n\tyield();\n\n\tfor_each_online_node(nid) {\n\t\t(void)first_zones_zonelist(node_zonelist(nid, GFP_NOFS),\n\t\t\t\t\t\tgfp_zone(GFP_NOFS), NULL,\n\t\t\t\t\t\t&zone);\n\t\tif (zone)\n\t\t\ttry_to_free_pages(node_zonelist(nid, GFP_NOFS), 0,\n\t\t\t\t\t\tGFP_NOFS, NULL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "grow_buffers",
          "args": [
            "bdev",
            "block",
            "size",
            "gfp"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "grow_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1042-1071",
          "snippet": "static int\ngrow_buffers(struct block_device *bdev, sector_t block, int size, gfp_t gfp)\n{\n\tpgoff_t index;\n\tint sizebits;\n\n\tsizebits = -1;\n\tdo {\n\t\tsizebits++;\n\t} while ((size << sizebits) < PAGE_SIZE);\n\n\tindex = block >> sizebits;\n\n\t/*\n\t * Check for a block which wants to lie outside our maximum possible\n\t * pagecache index.  (this comparison is done using sector_t types).\n\t */\n\tif (unlikely(index != block >> sizebits)) {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\tprintk(KERN_ERR \"%s: requested out-of-range block %llu for \"\n\t\t\t\"device %s\\n\",\n\t\t\t__func__, (unsigned long long)block,\n\t\t\tbdevname(bdev, b));\n\t\treturn -EIO;\n\t}\n\n\t/* Create a page with the proper size buffers.. */\n\treturn grow_dev_page(bdev, block, index, size, sizebits, gfp);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int\ngrow_buffers(struct block_device *bdev, sector_t block, int size, gfp_t gfp)\n{\n\tpgoff_t index;\n\tint sizebits;\n\n\tsizebits = -1;\n\tdo {\n\t\tsizebits++;\n\t} while ((size << sizebits) < PAGE_SIZE);\n\n\tindex = block >> sizebits;\n\n\t/*\n\t * Check for a block which wants to lie outside our maximum possible\n\t * pagecache index.  (this comparison is done using sector_t types).\n\t */\n\tif (unlikely(index != block >> sizebits)) {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\tprintk(KERN_ERR \"%s: requested out-of-range block %llu for \"\n\t\t\t\"device %s\\n\",\n\t\t\t__func__, (unsigned long long)block,\n\t\t\tbdevname(bdev, b));\n\t\treturn -EIO;\n\t}\n\n\t/* Create a page with the proper size buffers.. */\n\treturn grow_dev_page(bdev, block, index, size, sizebits, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__find_get_block",
          "args": [
            "bdev",
            "block",
            "size"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "__find_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1340-1354",
          "snippet": "struct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"logical block size: %d\\n\"",
            "bdev_logical_block_size(bdev)"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "bdev"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "size & (bdev_logical_block_size(bdev)-1) ||\n\t\t\t(size < 512 || size > PAGE_SIZE)"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "bdev"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__getblk_slow(struct block_device *bdev, sector_t block,\n\t     unsigned size, gfp_t gfp)\n{\n\t/* Size must be multiple of hard sectorsize */\n\tif (unlikely(size & (bdev_logical_block_size(bdev)-1) ||\n\t\t\t(size < 512 || size > PAGE_SIZE))) {\n\t\tprintk(KERN_ERR \"getblk(): invalid block size %d requested\\n\",\n\t\t\t\t\tsize);\n\t\tprintk(KERN_ERR \"logical block size: %d\\n\",\n\t\t\t\t\tbdev_logical_block_size(bdev));\n\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tfor (;;) {\n\t\tstruct buffer_head *bh;\n\t\tint ret;\n\n\t\tbh = __find_get_block(bdev, block, size);\n\t\tif (bh)\n\t\t\treturn bh;\n\n\t\tret = grow_buffers(bdev, block, size, gfp);\n\t\tif (ret < 0)\n\t\t\treturn NULL;\n\t\tif (ret == 0)\n\t\t\tfree_more_memory();\n\t}\n}"
  },
  {
    "function_name": "grow_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "1042-1071",
    "snippet": "static int\ngrow_buffers(struct block_device *bdev, sector_t block, int size, gfp_t gfp)\n{\n\tpgoff_t index;\n\tint sizebits;\n\n\tsizebits = -1;\n\tdo {\n\t\tsizebits++;\n\t} while ((size << sizebits) < PAGE_SIZE);\n\n\tindex = block >> sizebits;\n\n\t/*\n\t * Check for a block which wants to lie outside our maximum possible\n\t * pagecache index.  (this comparison is done using sector_t types).\n\t */\n\tif (unlikely(index != block >> sizebits)) {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\tprintk(KERN_ERR \"%s: requested out-of-range block %llu for \"\n\t\t\t\"device %s\\n\",\n\t\t\t__func__, (unsigned long long)block,\n\t\t\tbdevname(bdev, b));\n\t\treturn -EIO;\n\t}\n\n\t/* Create a page with the proper size buffers.. */\n\treturn grow_dev_page(bdev, block, index, size, sizebits, gfp);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "grow_dev_page",
          "args": [
            "bdev",
            "block",
            "index",
            "size",
            "sizebits",
            "gfp"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "grow_dev_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "974-1036",
          "snippet": "static int\ngrow_dev_page(struct block_device *bdev, sector_t block,\n\t      pgoff_t index, int size, int sizebits, gfp_t gfp)\n{\n\tstruct inode *inode = bdev->bd_inode;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tsector_t end_block;\n\tint ret = 0;\t\t/* Will call free_more_memory() */\n\tgfp_t gfp_mask;\n\n\tgfp_mask = (mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS) | gfp;\n\n\t/*\n\t * XXX: __getblk_slow() can not really deal with failure and\n\t * will endlessly loop on improvised global reclaim.  Prefer\n\t * looping in the allocator rather than here, at least that\n\t * code knows what it's doing.\n\t */\n\tgfp_mask |= __GFP_NOFAIL;\n\n\tpage = find_or_create_page(inode->i_mapping, index, gfp_mask);\n\tif (!page)\n\t\treturn ret;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (page_has_buffers(page)) {\n\t\tbh = page_buffers(page);\n\t\tif (bh->b_size == size) {\n\t\t\tend_block = init_page_buffers(page, bdev,\n\t\t\t\t\t\t(sector_t)index << sizebits,\n\t\t\t\t\t\tsize);\n\t\t\tgoto done;\n\t\t}\n\t\tif (!try_to_free_buffers(page))\n\t\t\tgoto failed;\n\t}\n\n\t/*\n\t * Allocate some buffers for this page\n\t */\n\tbh = alloc_page_buffers(page, size, 0);\n\tif (!bh)\n\t\tgoto failed;\n\n\t/*\n\t * Link the page to the buffers and initialise them.  Take the\n\t * lock to be atomic wrt __find_get_block(), which does not\n\t * run under the page lock.\n\t */\n\tspin_lock(&inode->i_mapping->private_lock);\n\tlink_dev_buffers(page, bh);\n\tend_block = init_page_buffers(page, bdev, (sector_t)index << sizebits,\n\t\t\tsize);\n\tspin_unlock(&inode->i_mapping->private_lock);\ndone:\n\tret = (block < end_block) ? 1 : -ENXIO;\nfailed:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int\ngrow_dev_page(struct block_device *bdev, sector_t block,\n\t      pgoff_t index, int size, int sizebits, gfp_t gfp)\n{\n\tstruct inode *inode = bdev->bd_inode;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tsector_t end_block;\n\tint ret = 0;\t\t/* Will call free_more_memory() */\n\tgfp_t gfp_mask;\n\n\tgfp_mask = (mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS) | gfp;\n\n\t/*\n\t * XXX: __getblk_slow() can not really deal with failure and\n\t * will endlessly loop on improvised global reclaim.  Prefer\n\t * looping in the allocator rather than here, at least that\n\t * code knows what it's doing.\n\t */\n\tgfp_mask |= __GFP_NOFAIL;\n\n\tpage = find_or_create_page(inode->i_mapping, index, gfp_mask);\n\tif (!page)\n\t\treturn ret;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (page_has_buffers(page)) {\n\t\tbh = page_buffers(page);\n\t\tif (bh->b_size == size) {\n\t\t\tend_block = init_page_buffers(page, bdev,\n\t\t\t\t\t\t(sector_t)index << sizebits,\n\t\t\t\t\t\tsize);\n\t\t\tgoto done;\n\t\t}\n\t\tif (!try_to_free_buffers(page))\n\t\t\tgoto failed;\n\t}\n\n\t/*\n\t * Allocate some buffers for this page\n\t */\n\tbh = alloc_page_buffers(page, size, 0);\n\tif (!bh)\n\t\tgoto failed;\n\n\t/*\n\t * Link the page to the buffers and initialise them.  Take the\n\t * lock to be atomic wrt __find_get_block(), which does not\n\t * run under the page lock.\n\t */\n\tspin_lock(&inode->i_mapping->private_lock);\n\tlink_dev_buffers(page, bh);\n\tend_block = init_page_buffers(page, bdev, (sector_t)index << sizebits,\n\t\t\tsize);\n\tspin_unlock(&inode->i_mapping->private_lock);\ndone:\n\tret = (block < end_block) ? 1 : -ENXIO;\nfailed:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: requested out-of-range block %llu for \"\n\t\t\t\"device %s\\n\"",
            "__func__",
            "(unsigned long long)block",
            "bdevname(bdev, b)"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "bdev",
            "b"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index != block >> sizebits"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int\ngrow_buffers(struct block_device *bdev, sector_t block, int size, gfp_t gfp)\n{\n\tpgoff_t index;\n\tint sizebits;\n\n\tsizebits = -1;\n\tdo {\n\t\tsizebits++;\n\t} while ((size << sizebits) < PAGE_SIZE);\n\n\tindex = block >> sizebits;\n\n\t/*\n\t * Check for a block which wants to lie outside our maximum possible\n\t * pagecache index.  (this comparison is done using sector_t types).\n\t */\n\tif (unlikely(index != block >> sizebits)) {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\tprintk(KERN_ERR \"%s: requested out-of-range block %llu for \"\n\t\t\t\"device %s\\n\",\n\t\t\t__func__, (unsigned long long)block,\n\t\t\tbdevname(bdev, b));\n\t\treturn -EIO;\n\t}\n\n\t/* Create a page with the proper size buffers.. */\n\treturn grow_dev_page(bdev, block, index, size, sizebits, gfp);\n}"
  },
  {
    "function_name": "grow_dev_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "974-1036",
    "snippet": "static int\ngrow_dev_page(struct block_device *bdev, sector_t block,\n\t      pgoff_t index, int size, int sizebits, gfp_t gfp)\n{\n\tstruct inode *inode = bdev->bd_inode;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tsector_t end_block;\n\tint ret = 0;\t\t/* Will call free_more_memory() */\n\tgfp_t gfp_mask;\n\n\tgfp_mask = (mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS) | gfp;\n\n\t/*\n\t * XXX: __getblk_slow() can not really deal with failure and\n\t * will endlessly loop on improvised global reclaim.  Prefer\n\t * looping in the allocator rather than here, at least that\n\t * code knows what it's doing.\n\t */\n\tgfp_mask |= __GFP_NOFAIL;\n\n\tpage = find_or_create_page(inode->i_mapping, index, gfp_mask);\n\tif (!page)\n\t\treturn ret;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (page_has_buffers(page)) {\n\t\tbh = page_buffers(page);\n\t\tif (bh->b_size == size) {\n\t\t\tend_block = init_page_buffers(page, bdev,\n\t\t\t\t\t\t(sector_t)index << sizebits,\n\t\t\t\t\t\tsize);\n\t\t\tgoto done;\n\t\t}\n\t\tif (!try_to_free_buffers(page))\n\t\t\tgoto failed;\n\t}\n\n\t/*\n\t * Allocate some buffers for this page\n\t */\n\tbh = alloc_page_buffers(page, size, 0);\n\tif (!bh)\n\t\tgoto failed;\n\n\t/*\n\t * Link the page to the buffers and initialise them.  Take the\n\t * lock to be atomic wrt __find_get_block(), which does not\n\t * run under the page lock.\n\t */\n\tspin_lock(&inode->i_mapping->private_lock);\n\tlink_dev_buffers(page, bh);\n\tend_block = init_page_buffers(page, bdev, (sector_t)index << sizebits,\n\t\t\tsize);\n\tspin_unlock(&inode->i_mapping->private_lock);\ndone:\n\tret = (block < end_block) ? 1 : -ENXIO;\nfailed:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_mapping->private_lock"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_page_buffers",
          "args": [
            "page",
            "bdev",
            "(sector_t)index << sizebits",
            "size"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "init_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "940-967",
          "snippet": "static sector_t\ninit_page_buffers(struct page *page, struct block_device *bdev,\n\t\t\tsector_t block, int size)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tstruct buffer_head *bh = head;\n\tint uptodate = PageUptodate(page);\n\tsector_t end_block = blkdev_max_block(I_BDEV(bdev->bd_inode), size);\n\n\tdo {\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tinit_buffer(bh, NULL, NULL);\n\t\t\tbh->b_bdev = bdev;\n\t\t\tbh->b_blocknr = block;\n\t\t\tif (uptodate)\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tif (block < end_block)\n\t\t\t\tset_buffer_mapped(bh);\n\t\t}\n\t\tblock++;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * Caller needs to validate requested block against end of device.\n\t */\n\treturn end_block;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic sector_t\ninit_page_buffers(struct page *page, struct block_device *bdev,\n\t\t\tsector_t block, int size)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tstruct buffer_head *bh = head;\n\tint uptodate = PageUptodate(page);\n\tsector_t end_block = blkdev_max_block(I_BDEV(bdev->bd_inode), size);\n\n\tdo {\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tinit_buffer(bh, NULL, NULL);\n\t\t\tbh->b_bdev = bdev;\n\t\t\tbh->b_blocknr = block;\n\t\t\tif (uptodate)\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tif (block < end_block)\n\t\t\t\tset_buffer_mapped(bh);\n\t\t}\n\t\tblock++;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * Caller needs to validate requested block against end of device.\n\t */\n\treturn end_block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_dev_buffers",
          "args": [
            "page",
            "bh"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "link_dev_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "911-923",
          "snippet": "static inline void\nlink_dev_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh, *tail;\n\n\tbh = head;\n\tdo {\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\tattach_page_buffers(page, head);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic inline void\nlink_dev_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh, *tail;\n\n\tbh = head;\n\tdo {\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\tattach_page_buffers(page, head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_mapping->private_lock"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page_buffers",
          "args": [
            "page",
            "size",
            "0"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "855-908",
          "snippet": "struct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tint retry)\n{\n\tstruct buffer_head *bh, *head;\n\tlong offset;\n\ntry_again:\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(GFP_NOFS);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\t/*\n\t * Return failure for non-async IO requests.  Async IO requests\n\t * are not allowed to fail, so we have to wait until buffer heads\n\t * become available.  But we don't want tasks sleeping with \n\t * partially complete buffers, so all were released above.\n\t */\n\tif (!retry)\n\t\treturn NULL;\n\n\t/* We're _really_ low on memory. Now we just\n\t * wait for old buffer heads to become free due to\n\t * finishing IO.  Since this is an async request and\n\t * the reserve list is empty, we're sure there are \n\t * async buffer heads in use.\n\t */\n\tfree_more_memory();\n\tgoto try_again;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nstruct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tint retry)\n{\n\tstruct buffer_head *bh, *head;\n\tlong offset;\n\ntry_again:\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(GFP_NOFS);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\t/*\n\t * Return failure for non-async IO requests.  Async IO requests\n\t * are not allowed to fail, so we have to wait until buffer heads\n\t * become available.  But we don't want tasks sleeping with \n\t * partially complete buffers, so all were released above.\n\t */\n\tif (!retry)\n\t\treturn NULL;\n\n\t/* We're _really_ low on memory. Now we just\n\t * wait for old buffer heads to become free due to\n\t * finishing IO.  Since this is an async request and\n\t * the reserve list is empty, we're sure there are \n\t * async buffer heads in use.\n\t */\n\tfree_more_memory();\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3214-3260",
          "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "inode->i_mapping",
            "index",
            "gfp_mask"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "inode->i_mapping"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int\ngrow_dev_page(struct block_device *bdev, sector_t block,\n\t      pgoff_t index, int size, int sizebits, gfp_t gfp)\n{\n\tstruct inode *inode = bdev->bd_inode;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tsector_t end_block;\n\tint ret = 0;\t\t/* Will call free_more_memory() */\n\tgfp_t gfp_mask;\n\n\tgfp_mask = (mapping_gfp_mask(inode->i_mapping) & ~__GFP_FS) | gfp;\n\n\t/*\n\t * XXX: __getblk_slow() can not really deal with failure and\n\t * will endlessly loop on improvised global reclaim.  Prefer\n\t * looping in the allocator rather than here, at least that\n\t * code knows what it's doing.\n\t */\n\tgfp_mask |= __GFP_NOFAIL;\n\n\tpage = find_or_create_page(inode->i_mapping, index, gfp_mask);\n\tif (!page)\n\t\treturn ret;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (page_has_buffers(page)) {\n\t\tbh = page_buffers(page);\n\t\tif (bh->b_size == size) {\n\t\t\tend_block = init_page_buffers(page, bdev,\n\t\t\t\t\t\t(sector_t)index << sizebits,\n\t\t\t\t\t\tsize);\n\t\t\tgoto done;\n\t\t}\n\t\tif (!try_to_free_buffers(page))\n\t\t\tgoto failed;\n\t}\n\n\t/*\n\t * Allocate some buffers for this page\n\t */\n\tbh = alloc_page_buffers(page, size, 0);\n\tif (!bh)\n\t\tgoto failed;\n\n\t/*\n\t * Link the page to the buffers and initialise them.  Take the\n\t * lock to be atomic wrt __find_get_block(), which does not\n\t * run under the page lock.\n\t */\n\tspin_lock(&inode->i_mapping->private_lock);\n\tlink_dev_buffers(page, bh);\n\tend_block = init_page_buffers(page, bdev, (sector_t)index << sizebits,\n\t\t\tsize);\n\tspin_unlock(&inode->i_mapping->private_lock);\ndone:\n\tret = (block < end_block) ? 1 : -ENXIO;\nfailed:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "init_page_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "940-967",
    "snippet": "static sector_t\ninit_page_buffers(struct page *page, struct block_device *bdev,\n\t\t\tsector_t block, int size)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tstruct buffer_head *bh = head;\n\tint uptodate = PageUptodate(page);\n\tsector_t end_block = blkdev_max_block(I_BDEV(bdev->bd_inode), size);\n\n\tdo {\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tinit_buffer(bh, NULL, NULL);\n\t\t\tbh->b_bdev = bdev;\n\t\t\tbh->b_blocknr = block;\n\t\t\tif (uptodate)\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tif (block < end_block)\n\t\t\t\tset_buffer_mapped(bh);\n\t\t}\n\t\tblock++;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * Caller needs to validate requested block against end of device.\n\t */\n\treturn end_block;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_buffer",
          "args": [
            "bh",
            "NULL",
            "NULL"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "init_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "50-54",
          "snippet": "void init_buffer(struct buffer_head *bh, bh_end_io_t *handler, void *private)\n{\n\tbh->b_end_io = handler;\n\tbh->b_private = private;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid init_buffer(struct buffer_head *bh, bh_end_io_t *handler, void *private)\n{\n\tbh->b_end_io = handler;\n\tbh->b_private = private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_max_block",
          "args": [
            "I_BDEV(bdev->bd_inode)",
            "size"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_max_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "925-935",
          "snippet": "static sector_t blkdev_max_block(struct block_device *bdev, unsigned int size)\n{\n\tsector_t retval = ~((sector_t)0);\n\tloff_t sz = i_size_read(bdev->bd_inode);\n\n\tif (sz) {\n\t\tunsigned int sizebits = blksize_bits(size);\n\t\tretval = (sz >> sizebits);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic sector_t blkdev_max_block(struct block_device *bdev, unsigned int size)\n{\n\tsector_t retval = ~((sector_t)0);\n\tloff_t sz = i_size_read(bdev->bd_inode);\n\n\tif (sz) {\n\t\tunsigned int sizebits = blksize_bits(size);\n\t\tretval = (sz >> sizebits);\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "I_BDEV",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "I_BDEV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "46-49",
          "snippet": "inline struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\ninline struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic sector_t\ninit_page_buffers(struct page *page, struct block_device *bdev,\n\t\t\tsector_t block, int size)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tstruct buffer_head *bh = head;\n\tint uptodate = PageUptodate(page);\n\tsector_t end_block = blkdev_max_block(I_BDEV(bdev->bd_inode), size);\n\n\tdo {\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tinit_buffer(bh, NULL, NULL);\n\t\t\tbh->b_bdev = bdev;\n\t\t\tbh->b_blocknr = block;\n\t\t\tif (uptodate)\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tif (block < end_block)\n\t\t\t\tset_buffer_mapped(bh);\n\t\t}\n\t\tblock++;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * Caller needs to validate requested block against end of device.\n\t */\n\treturn end_block;\n}"
  },
  {
    "function_name": "blkdev_max_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "925-935",
    "snippet": "static sector_t blkdev_max_block(struct block_device *bdev, unsigned int size)\n{\n\tsector_t retval = ~((sector_t)0);\n\tloff_t sz = i_size_read(bdev->bd_inode);\n\n\tif (sz) {\n\t\tunsigned int sizebits = blksize_bits(size);\n\t\tretval = (sz >> sizebits);\n\t}\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blksize_bits",
          "args": [
            "size"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic sector_t blkdev_max_block(struct block_device *bdev, unsigned int size)\n{\n\tsector_t retval = ~((sector_t)0);\n\tloff_t sz = i_size_read(bdev->bd_inode);\n\n\tif (sz) {\n\t\tunsigned int sizebits = blksize_bits(size);\n\t\tretval = (sz >> sizebits);\n\t}\n\treturn retval;\n}"
  },
  {
    "function_name": "link_dev_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "911-923",
    "snippet": "static inline void\nlink_dev_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh, *tail;\n\n\tbh = head;\n\tdo {\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\tattach_page_buffers(page, head);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "attach_page_buffers",
          "args": [
            "page",
            "head"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic inline void\nlink_dev_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh, *tail;\n\n\tbh = head;\n\tdo {\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\tattach_page_buffers(page, head);\n}"
  },
  {
    "function_name": "alloc_page_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "855-908",
    "snippet": "struct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tint retry)\n{\n\tstruct buffer_head *bh, *head;\n\tlong offset;\n\ntry_again:\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(GFP_NOFS);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\t/*\n\t * Return failure for non-async IO requests.  Async IO requests\n\t * are not allowed to fail, so we have to wait until buffer heads\n\t * become available.  But we don't want tasks sleeping with \n\t * partially complete buffers, so all were released above.\n\t */\n\tif (!retry)\n\t\treturn NULL;\n\n\t/* We're _really_ low on memory. Now we just\n\t * wait for old buffer heads to become free due to\n\t * finishing IO.  Since this is an async request and\n\t * the reserve list is empty, we're sure there are \n\t * async buffer heads in use.\n\t */\n\tfree_more_memory();\n\tgoto try_again;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_more_memory",
          "args": [],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "free_more_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "257-273",
          "snippet": "static void free_more_memory(void)\n{\n\tstruct zone *zone;\n\tint nid;\n\n\twakeup_flusher_threads(1024, WB_REASON_FREE_MORE_MEM);\n\tyield();\n\n\tfor_each_online_node(nid) {\n\t\t(void)first_zones_zonelist(node_zonelist(nid, GFP_NOFS),\n\t\t\t\t\t\tgfp_zone(GFP_NOFS), NULL,\n\t\t\t\t\t\t&zone);\n\t\tif (zone)\n\t\t\ttry_to_free_pages(node_zonelist(nid, GFP_NOFS), 0,\n\t\t\t\t\t\tGFP_NOFS, NULL);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void free_more_memory(void)\n{\n\tstruct zone *zone;\n\tint nid;\n\n\twakeup_flusher_threads(1024, WB_REASON_FREE_MORE_MEM);\n\tyield();\n\n\tfor_each_online_node(nid) {\n\t\t(void)first_zones_zonelist(node_zonelist(nid, GFP_NOFS),\n\t\t\t\t\t\tgfp_zone(GFP_NOFS), NULL,\n\t\t\t\t\t\t&zone);\n\t\tif (zone)\n\t\t\ttry_to_free_pages(node_zonelist(nid, GFP_NOFS), 0,\n\t\t\t\t\t\tGFP_NOFS, NULL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_buffer_head",
          "args": [
            "bh"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bh_page",
          "args": [
            "bh",
            "page",
            "offset"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "set_bh_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1451-1463",
          "snippet": "void set_bh_page(struct buffer_head *bh,\n\t\tstruct page *page, unsigned long offset)\n{\n\tbh->b_page = page;\n\tBUG_ON(offset >= PAGE_SIZE);\n\tif (PageHighMem(page))\n\t\t/*\n\t\t * This catches illegal uses and preserves the offset:\n\t\t */\n\t\tbh->b_data = (char *)(0 + offset);\n\telse\n\t\tbh->b_data = page_address(page) + offset;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid set_bh_page(struct buffer_head *bh,\n\t\tstruct page *page, unsigned long offset)\n{\n\tbh->b_page = page;\n\tBUG_ON(offset >= PAGE_SIZE);\n\tif (PageHighMem(page))\n\t\t/*\n\t\t * This catches illegal uses and preserves the offset:\n\t\t */\n\t\tbh->b_data = (char *)(0 + offset);\n\telse\n\t\tbh->b_data = page_address(page) + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_buffer_head",
          "args": [
            "GFP_NOFS"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nstruct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tint retry)\n{\n\tstruct buffer_head *bh, *head;\n\tlong offset;\n\ntry_again:\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(GFP_NOFS);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\t/*\n\t * Return failure for non-async IO requests.  Async IO requests\n\t * are not allowed to fail, so we have to wait until buffer heads\n\t * become available.  But we don't want tasks sleeping with \n\t * partially complete buffers, so all were released above.\n\t */\n\tif (!retry)\n\t\treturn NULL;\n\n\t/* We're _really_ low on memory. Now we just\n\t * wait for old buffer heads to become free due to\n\t * finishing IO.  Since this is an async request and\n\t * the reserve list is empty, we're sure there are \n\t * async buffer heads in use.\n\t */\n\tfree_more_memory();\n\tgoto try_again;\n}"
  },
  {
    "function_name": "remove_inode_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "823-844",
    "snippet": "int remove_inode_buffers(struct inode *inode)\n{\n\tint ret = 1;\n\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list)) {\n\t\t\tstruct buffer_head *bh = BH_ENTRY(list->next);\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t__remove_assoc_queue(bh);\n\t\t}\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&buffer_mapping->private_lock"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__remove_assoc_queue",
          "args": [
            "bh"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_assoc_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "479-486",
          "snippet": "static void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tif (buffer_write_io_error(bh))\n\t\tset_bit(AS_EIO, &bh->b_assoc_map->flags);\n\tbh->b_assoc_map = NULL;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tif (buffer_write_io_error(bh))\n\t\tset_bit(AS_EIO, &bh->b_assoc_map->flags);\n\tbh->b_assoc_map = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BH_ENTRY",
          "args": [
            "list->next"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&buffer_mapping->private_lock"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_has_buffers",
          "args": [
            "inode"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "inode_has_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "488-491",
          "snippet": "int inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nint remove_inode_buffers(struct inode *inode)\n{\n\tint ret = 1;\n\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list)) {\n\t\t\tstruct buffer_head *bh = BH_ENTRY(list->next);\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t__remove_assoc_queue(bh);\n\t\t}\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "invalidate_inode_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "802-814",
    "snippet": "void invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&buffer_mapping->private_lock"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__remove_assoc_queue",
          "args": [
            "BH_ENTRY(list->next)"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_assoc_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "479-486",
          "snippet": "static void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tif (buffer_write_io_error(bh))\n\t\tset_bit(AS_EIO, &bh->b_assoc_map->flags);\n\tbh->b_assoc_map = NULL;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tif (buffer_write_io_error(bh))\n\t\tset_bit(AS_EIO, &bh->b_assoc_map->flags);\n\tbh->b_assoc_map = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BH_ENTRY",
          "args": [
            "list->next"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&buffer_mapping->private_lock"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_has_buffers",
          "args": [
            "inode"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "inode_has_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "488-491",
          "snippet": "int inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nvoid invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
  },
  {
    "function_name": "fsync_buffers_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "714-791",
    "snippet": "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct list_head tmp;\n\tstruct address_space *mapping;\n\tint err = 0, err2;\n\tstruct blk_plug plug;\n\n\tINIT_LIST_HEAD(&tmp);\n\tblk_start_plug(&plug);\n\n\tspin_lock(lock);\n\twhile (!list_empty(list)) {\n\t\tbh = BH_ENTRY(list->next);\n\t\tmapping = bh->b_assoc_map;\n\t\t__remove_assoc_queue(bh);\n\t\t/* Avoid race with mark_buffer_dirty_inode() which does\n\t\t * a lockless check and we rely on seeing the dirty bit */\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh) || buffer_locked(bh)) {\n\t\t\tlist_add(&bh->b_assoc_buffers, &tmp);\n\t\t\tbh->b_assoc_map = mapping;\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\tget_bh(bh);\n\t\t\t\tspin_unlock(lock);\n\t\t\t\t/*\n\t\t\t\t * Ensure any pending I/O completes so that\n\t\t\t\t * write_dirty_buffer() actually writes the\n\t\t\t\t * current contents - it is a noop if I/O is\n\t\t\t\t * still in flight on potentially older\n\t\t\t\t * contents.\n\t\t\t\t */\n\t\t\t\twrite_dirty_buffer(bh, WRITE_SYNC);\n\n\t\t\t\t/*\n\t\t\t\t * Kick off IO for the previous mapping. Note\n\t\t\t\t * that we will not run the very last mapping,\n\t\t\t\t * wait_on_buffer() will do that for us\n\t\t\t\t * through sync_buffer().\n\t\t\t\t */\n\t\t\t\tbrelse(bh);\n\t\t\t\tspin_lock(lock);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(lock);\n\tblk_finish_plug(&plug);\n\tspin_lock(lock);\n\n\twhile (!list_empty(&tmp)) {\n\t\tbh = BH_ENTRY(tmp.prev);\n\t\tget_bh(bh);\n\t\tmapping = bh->b_assoc_map;\n\t\t__remove_assoc_queue(bh);\n\t\t/* Avoid race with mark_buffer_dirty_inode() which does\n\t\t * a lockless check and we rely on seeing the dirty bit */\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh)) {\n\t\t\tlist_add(&bh->b_assoc_buffers,\n\t\t\t\t &mapping->private_list);\n\t\t\tbh->b_assoc_map = mapping;\n\t\t}\n\t\tspin_unlock(lock);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\terr = -EIO;\n\t\tbrelse(bh);\n\t\tspin_lock(lock);\n\t}\n\t\n\tspin_unlock(lock);\n\terr2 = osync_buffers_list(lock, list);\n\tif (err)\n\t\treturn err;\n\telse\n\t\treturn err2;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "osync_buffers_list",
          "args": [
            "lock",
            "list"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "osync_buffers_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "503-526",
          "snippet": "static int osync_buffers_list(spinlock_t *lock, struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct list_head *p;\n\tint err = 0;\n\n\tspin_lock(lock);\nrepeat:\n\tlist_for_each_prev(p, list) {\n\t\tbh = BH_ENTRY(p);\n\t\tif (buffer_locked(bh)) {\n\t\t\tget_bh(bh);\n\t\t\tspin_unlock(lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\terr = -EIO;\n\t\t\tbrelse(bh);\n\t\t\tspin_lock(lock);\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\tspin_unlock(lock);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nstatic int osync_buffers_list(spinlock_t *lock, struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct list_head *p;\n\tint err = 0;\n\n\tspin_lock(lock);\nrepeat:\n\tlist_for_each_prev(p, list) {\n\t\tbh = BH_ENTRY(p);\n\t\tif (buffer_locked(bh)) {\n\t\t\tget_bh(bh);\n\t\t\tspin_unlock(lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\terr = -EIO;\n\t\t\tbrelse(bh);\n\t\t\tspin_lock(lock);\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\tspin_unlock(lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "lock"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "lock"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&bh->b_assoc_buffers",
            "&mapping->private_list"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_assoc_queue",
          "args": [
            "bh"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_assoc_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "479-486",
          "snippet": "static void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tif (buffer_write_io_error(bh))\n\t\tset_bit(AS_EIO, &bh->b_assoc_map->flags);\n\tbh->b_assoc_map = NULL;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tif (buffer_write_io_error(bh))\n\t\tset_bit(AS_EIO, &bh->b_assoc_map->flags);\n\tbh->b_assoc_map = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BH_ENTRY",
          "args": [
            "tmp.prev"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tmp"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_dirty_buffer",
          "args": [
            "bh",
            "WRITE_SYNC"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "write_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3115-3125",
          "snippet": "void write_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(rw, bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid write_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(rw, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BH_ENTRY",
          "args": [
            "list->next"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tmp"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct list_head tmp;\n\tstruct address_space *mapping;\n\tint err = 0, err2;\n\tstruct blk_plug plug;\n\n\tINIT_LIST_HEAD(&tmp);\n\tblk_start_plug(&plug);\n\n\tspin_lock(lock);\n\twhile (!list_empty(list)) {\n\t\tbh = BH_ENTRY(list->next);\n\t\tmapping = bh->b_assoc_map;\n\t\t__remove_assoc_queue(bh);\n\t\t/* Avoid race with mark_buffer_dirty_inode() which does\n\t\t * a lockless check and we rely on seeing the dirty bit */\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh) || buffer_locked(bh)) {\n\t\t\tlist_add(&bh->b_assoc_buffers, &tmp);\n\t\t\tbh->b_assoc_map = mapping;\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\tget_bh(bh);\n\t\t\t\tspin_unlock(lock);\n\t\t\t\t/*\n\t\t\t\t * Ensure any pending I/O completes so that\n\t\t\t\t * write_dirty_buffer() actually writes the\n\t\t\t\t * current contents - it is a noop if I/O is\n\t\t\t\t * still in flight on potentially older\n\t\t\t\t * contents.\n\t\t\t\t */\n\t\t\t\twrite_dirty_buffer(bh, WRITE_SYNC);\n\n\t\t\t\t/*\n\t\t\t\t * Kick off IO for the previous mapping. Note\n\t\t\t\t * that we will not run the very last mapping,\n\t\t\t\t * wait_on_buffer() will do that for us\n\t\t\t\t * through sync_buffer().\n\t\t\t\t */\n\t\t\t\tbrelse(bh);\n\t\t\t\tspin_lock(lock);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(lock);\n\tblk_finish_plug(&plug);\n\tspin_lock(lock);\n\n\twhile (!list_empty(&tmp)) {\n\t\tbh = BH_ENTRY(tmp.prev);\n\t\tget_bh(bh);\n\t\tmapping = bh->b_assoc_map;\n\t\t__remove_assoc_queue(bh);\n\t\t/* Avoid race with mark_buffer_dirty_inode() which does\n\t\t * a lockless check and we rely on seeing the dirty bit */\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh)) {\n\t\t\tlist_add(&bh->b_assoc_buffers,\n\t\t\t\t &mapping->private_list);\n\t\t\tbh->b_assoc_map = mapping;\n\t\t}\n\t\tspin_unlock(lock);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\terr = -EIO;\n\t\tbrelse(bh);\n\t\tspin_lock(lock);\n\t}\n\t\n\tspin_unlock(lock);\n\terr2 = osync_buffers_list(lock, list);\n\tif (err)\n\t\treturn err;\n\telse\n\t\treturn err2;\n}"
  },
  {
    "function_name": "__set_page_dirty_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "668-692",
    "snippet": "int __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\treturn newly_dirty;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_page_dirty",
          "args": [
            "page",
            "mapping",
            "1"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "627-641",
          "snippet": "static void __set_page_dirty(struct page *page,\n\t\tstruct address_space *mapping, int warn)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mapping->tree_lock, flags);\n\tif (page->mapping) {\t/* Race with truncate? */\n\t\tWARN_ON_ONCE(warn && !PageUptodate(page));\n\t\taccount_page_dirtied(page, mapping);\n\t\tradix_tree_tag_set(&mapping->page_tree,\n\t\t\t\tpage_index(page), PAGECACHE_TAG_DIRTY);\n\t}\n\tspin_unlock_irqrestore(&mapping->tree_lock, flags);\n\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void __set_page_dirty(struct page *page,\n\t\tstruct address_space *mapping, int warn)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mapping->tree_lock, flags);\n\tif (page->mapping) {\t/* Race with truncate? */\n\t\tWARN_ON_ONCE(warn && !PageUptodate(page));\n\t\taccount_page_dirtied(page, mapping);\n\t\tradix_tree_tag_set(&mapping->page_tree,\n\t\t\t\tpage_index(page), PAGECACHE_TAG_DIRTY);\n\t}\n\tspin_unlock_irqrestore(&mapping->tree_lock, flags);\n\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestSetPageDirty",
          "args": [
            "page"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestSetPageDirty",
          "args": [
            "page"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!mapping"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\treturn newly_dirty;\n}"
  },
  {
    "function_name": "__set_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "627-641",
    "snippet": "static void __set_page_dirty(struct page *page,\n\t\tstruct address_space *mapping, int warn)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mapping->tree_lock, flags);\n\tif (page->mapping) {\t/* Race with truncate? */\n\t\tWARN_ON_ONCE(warn && !PageUptodate(page));\n\t\taccount_page_dirtied(page, mapping);\n\t\tradix_tree_tag_set(&mapping->page_tree,\n\t\t\t\tpage_index(page), PAGECACHE_TAG_DIRTY);\n\t}\n\tspin_unlock_irqrestore(&mapping->tree_lock, flags);\n\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "mapping->host",
            "I_DIRTY_PAGES"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1181-1285",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&mapping->tree_lock",
            "flags"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_set",
          "args": [
            "&mapping->page_tree",
            "page_index(page)",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_index",
          "args": [
            "page"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_page_dirtied",
          "args": [
            "page",
            "mapping"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "warn && !PageUptodate(page)"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&mapping->tree_lock",
            "flags"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void __set_page_dirty(struct page *page,\n\t\tstruct address_space *mapping, int warn)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mapping->tree_lock, flags);\n\tif (page->mapping) {\t/* Race with truncate? */\n\t\tWARN_ON_ONCE(warn && !PageUptodate(page));\n\t\taccount_page_dirtied(page, mapping);\n\t\tradix_tree_tag_set(&mapping->page_tree,\n\t\t\t\tpage_index(page), PAGECACHE_TAG_DIRTY);\n\t}\n\tspin_unlock_irqrestore(&mapping->tree_lock, flags);\n\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n}"
  },
  {
    "function_name": "mark_buffer_dirty_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "599-617",
    "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&buffer_mapping->private_lock"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&bh->b_assoc_buffers",
            "&mapping->private_list"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&buffer_mapping->private_lock"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mapping->private_data != buffer_mapping"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
  },
  {
    "function_name": "write_boundary_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "588-597",
    "snippet": "void write_boundary_block(struct block_device *bdev,\n\t\t\tsector_t bblock, unsigned blocksize)\n{\n\tstruct buffer_head *bh = __find_get_block(bdev, bblock + 1, blocksize);\n\tif (bh) {\n\t\tif (buffer_dirty(bh))\n\t\t\tll_rw_block(WRITE, 1, &bh);\n\t\tput_bh(bh);\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "WRITE",
            "1",
            "&bh"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__find_get_block",
          "args": [
            "bdev",
            "bblock + 1",
            "blocksize"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "__find_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1340-1354",
          "snippet": "struct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid write_boundary_block(struct block_device *bdev,\n\t\t\tsector_t bblock, unsigned blocksize)\n{\n\tstruct buffer_head *bh = __find_get_block(bdev, bblock + 1, blocksize);\n\tif (bh) {\n\t\tif (buffer_dirty(bh))\n\t\t\tll_rw_block(WRITE, 1, &bh);\n\t\tput_bh(bh);\n\t}\n}"
  },
  {
    "function_name": "sync_mapping_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "570-579",
    "snippet": "int sync_mapping_buffers(struct address_space *mapping)\n{\n\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\tif (buffer_mapping == NULL || list_empty(&mapping->private_list))\n\t\treturn 0;\n\n\treturn fsync_buffers_list(&buffer_mapping->private_lock,\n\t\t\t\t\t&mapping->private_list);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsync_buffers_list",
          "args": [
            "&buffer_mapping->private_lock",
            "&mapping->private_list"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "fsync_buffers_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "714-791",
          "snippet": "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct list_head tmp;\n\tstruct address_space *mapping;\n\tint err = 0, err2;\n\tstruct blk_plug plug;\n\n\tINIT_LIST_HEAD(&tmp);\n\tblk_start_plug(&plug);\n\n\tspin_lock(lock);\n\twhile (!list_empty(list)) {\n\t\tbh = BH_ENTRY(list->next);\n\t\tmapping = bh->b_assoc_map;\n\t\t__remove_assoc_queue(bh);\n\t\t/* Avoid race with mark_buffer_dirty_inode() which does\n\t\t * a lockless check and we rely on seeing the dirty bit */\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh) || buffer_locked(bh)) {\n\t\t\tlist_add(&bh->b_assoc_buffers, &tmp);\n\t\t\tbh->b_assoc_map = mapping;\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\tget_bh(bh);\n\t\t\t\tspin_unlock(lock);\n\t\t\t\t/*\n\t\t\t\t * Ensure any pending I/O completes so that\n\t\t\t\t * write_dirty_buffer() actually writes the\n\t\t\t\t * current contents - it is a noop if I/O is\n\t\t\t\t * still in flight on potentially older\n\t\t\t\t * contents.\n\t\t\t\t */\n\t\t\t\twrite_dirty_buffer(bh, WRITE_SYNC);\n\n\t\t\t\t/*\n\t\t\t\t * Kick off IO for the previous mapping. Note\n\t\t\t\t * that we will not run the very last mapping,\n\t\t\t\t * wait_on_buffer() will do that for us\n\t\t\t\t * through sync_buffer().\n\t\t\t\t */\n\t\t\t\tbrelse(bh);\n\t\t\t\tspin_lock(lock);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(lock);\n\tblk_finish_plug(&plug);\n\tspin_lock(lock);\n\n\twhile (!list_empty(&tmp)) {\n\t\tbh = BH_ENTRY(tmp.prev);\n\t\tget_bh(bh);\n\t\tmapping = bh->b_assoc_map;\n\t\t__remove_assoc_queue(bh);\n\t\t/* Avoid race with mark_buffer_dirty_inode() which does\n\t\t * a lockless check and we rely on seeing the dirty bit */\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh)) {\n\t\t\tlist_add(&bh->b_assoc_buffers,\n\t\t\t\t &mapping->private_list);\n\t\t\tbh->b_assoc_map = mapping;\n\t\t}\n\t\tspin_unlock(lock);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\terr = -EIO;\n\t\tbrelse(bh);\n\t\tspin_lock(lock);\n\t}\n\t\n\tspin_unlock(lock);\n\terr2 = osync_buffers_list(lock, list);\n\tif (err)\n\t\treturn err;\n\telse\n\t\treturn err2;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct list_head tmp;\n\tstruct address_space *mapping;\n\tint err = 0, err2;\n\tstruct blk_plug plug;\n\n\tINIT_LIST_HEAD(&tmp);\n\tblk_start_plug(&plug);\n\n\tspin_lock(lock);\n\twhile (!list_empty(list)) {\n\t\tbh = BH_ENTRY(list->next);\n\t\tmapping = bh->b_assoc_map;\n\t\t__remove_assoc_queue(bh);\n\t\t/* Avoid race with mark_buffer_dirty_inode() which does\n\t\t * a lockless check and we rely on seeing the dirty bit */\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh) || buffer_locked(bh)) {\n\t\t\tlist_add(&bh->b_assoc_buffers, &tmp);\n\t\t\tbh->b_assoc_map = mapping;\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\tget_bh(bh);\n\t\t\t\tspin_unlock(lock);\n\t\t\t\t/*\n\t\t\t\t * Ensure any pending I/O completes so that\n\t\t\t\t * write_dirty_buffer() actually writes the\n\t\t\t\t * current contents - it is a noop if I/O is\n\t\t\t\t * still in flight on potentially older\n\t\t\t\t * contents.\n\t\t\t\t */\n\t\t\t\twrite_dirty_buffer(bh, WRITE_SYNC);\n\n\t\t\t\t/*\n\t\t\t\t * Kick off IO for the previous mapping. Note\n\t\t\t\t * that we will not run the very last mapping,\n\t\t\t\t * wait_on_buffer() will do that for us\n\t\t\t\t * through sync_buffer().\n\t\t\t\t */\n\t\t\t\tbrelse(bh);\n\t\t\t\tspin_lock(lock);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(lock);\n\tblk_finish_plug(&plug);\n\tspin_lock(lock);\n\n\twhile (!list_empty(&tmp)) {\n\t\tbh = BH_ENTRY(tmp.prev);\n\t\tget_bh(bh);\n\t\tmapping = bh->b_assoc_map;\n\t\t__remove_assoc_queue(bh);\n\t\t/* Avoid race with mark_buffer_dirty_inode() which does\n\t\t * a lockless check and we rely on seeing the dirty bit */\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh)) {\n\t\t\tlist_add(&bh->b_assoc_buffers,\n\t\t\t\t &mapping->private_list);\n\t\t\tbh->b_assoc_map = mapping;\n\t\t}\n\t\tspin_unlock(lock);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\terr = -EIO;\n\t\tbrelse(bh);\n\t\tspin_lock(lock);\n\t}\n\t\n\tspin_unlock(lock);\n\terr2 = osync_buffers_list(lock, list);\n\tif (err)\n\t\treturn err;\n\telse\n\t\treturn err2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&mapping->private_list"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_mapping_buffers(struct address_space *mapping)\n{\n\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\tif (buffer_mapping == NULL || list_empty(&mapping->private_list))\n\t\treturn 0;\n\n\treturn fsync_buffers_list(&buffer_mapping->private_lock,\n\t\t\t\t\t&mapping->private_list);\n}"
  },
  {
    "function_name": "emergency_thaw_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "548-557",
    "snippet": "void emergency_thaw_all(void)\n{\n\tstruct work_struct *work;\n\n\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\tif (work) {\n\t\tINIT_WORK(work, do_thaw_all);\n\t\tschedule_work(work);\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "work"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "755-771",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "work",
            "do_thaw_all"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*work)",
            "GFP_ATOMIC"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid emergency_thaw_all(void)\n{\n\tstruct work_struct *work;\n\n\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\tif (work) {\n\t\tINIT_WORK(work, do_thaw_all);\n\t\tschedule_work(work);\n\t}\n}"
  },
  {
    "function_name": "do_thaw_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "536-541",
    "snippet": "static void do_thaw_all(struct work_struct *work)\n{\n\titerate_supers(do_thaw_one, NULL);\n\tkfree(work);\n\tprintk(KERN_WARNING \"Emergency Thaw complete\\n\");\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Emergency Thaw complete\\n\""
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "work"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate_supers",
          "args": [
            "do_thaw_one",
            "NULL"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void do_thaw_all(struct work_struct *work)\n{\n\titerate_supers(do_thaw_one, NULL);\n\tkfree(work);\n\tprintk(KERN_WARNING \"Emergency Thaw complete\\n\");\n}"
  },
  {
    "function_name": "do_thaw_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "528-534",
    "snippet": "static void do_thaw_one(struct super_block *sb, void *unused)\n{\n\tchar b[BDEVNAME_SIZE];\n\twhile (sb->s_bdev && !thaw_bdev(sb->s_bdev, sb))\n\t\tprintk(KERN_WARNING \"Emergency Thaw on %s\\n\",\n\t\t       bdevname(sb->s_bdev, b));\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Emergency Thaw on %s\\n\"",
            "bdevname(sb->s_bdev, b)"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "sb->s_bdev",
            "b"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thaw_bdev",
          "args": [
            "sb->s_bdev",
            "sb"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "thaw_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "255-282",
          "snippet": "int thaw_bdev(struct block_device *bdev, struct super_block *sb)\n{\n\tint error = -EINVAL;\n\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (!bdev->bd_fsfreeze_count)\n\t\tgoto out;\n\n\terror = 0;\n\tif (--bdev->bd_fsfreeze_count > 0)\n\t\tgoto out;\n\n\tif (!sb)\n\t\tgoto out;\n\n\tif (sb->s_op->thaw_super)\n\t\terror = sb->s_op->thaw_super(sb);\n\telse\n\t\terror = thaw_super(sb);\n\tif (error) {\n\t\tbdev->bd_fsfreeze_count++;\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\treturn error;\n\t}\nout:\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint thaw_bdev(struct block_device *bdev, struct super_block *sb)\n{\n\tint error = -EINVAL;\n\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (!bdev->bd_fsfreeze_count)\n\t\tgoto out;\n\n\terror = 0;\n\tif (--bdev->bd_fsfreeze_count > 0)\n\t\tgoto out;\n\n\tif (!sb)\n\t\tgoto out;\n\n\tif (sb->s_op->thaw_super)\n\t\terror = sb->s_op->thaw_super(sb);\n\telse\n\t\terror = thaw_super(sb);\n\tif (error) {\n\t\tbdev->bd_fsfreeze_count++;\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\treturn error;\n\t}\nout:\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void do_thaw_one(struct super_block *sb, void *unused)\n{\n\tchar b[BDEVNAME_SIZE];\n\twhile (sb->s_bdev && !thaw_bdev(sb->s_bdev, sb))\n\t\tprintk(KERN_WARNING \"Emergency Thaw on %s\\n\",\n\t\t       bdevname(sb->s_bdev, b));\n}"
  },
  {
    "function_name": "osync_buffers_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "503-526",
    "snippet": "static int osync_buffers_list(spinlock_t *lock, struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct list_head *p;\n\tint err = 0;\n\n\tspin_lock(lock);\nrepeat:\n\tlist_for_each_prev(p, list) {\n\t\tbh = BH_ENTRY(p);\n\t\tif (buffer_locked(bh)) {\n\t\t\tget_bh(bh);\n\t\t\tspin_unlock(lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\terr = -EIO;\n\t\t\tbrelse(bh);\n\t\t\tspin_lock(lock);\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\tspin_unlock(lock);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "lock"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "lock"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BH_ENTRY",
          "args": [
            "p"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_prev",
          "args": [
            "p",
            "list"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nstatic int osync_buffers_list(spinlock_t *lock, struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct list_head *p;\n\tint err = 0;\n\n\tspin_lock(lock);\nrepeat:\n\tlist_for_each_prev(p, list) {\n\t\tbh = BH_ENTRY(p);\n\t\tif (buffer_locked(bh)) {\n\t\t\tget_bh(bh);\n\t\t\tspin_unlock(lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\terr = -EIO;\n\t\t\tbrelse(bh);\n\t\t\tspin_lock(lock);\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\tspin_unlock(lock);\n\treturn err;\n}"
  },
  {
    "function_name": "inode_has_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "488-491",
    "snippet": "int inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&inode->i_data.private_list"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}"
  },
  {
    "function_name": "__remove_assoc_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "479-486",
    "snippet": "static void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tif (buffer_write_io_error(bh))\n\t\tset_bit(AS_EIO, &bh->b_assoc_map->flags);\n\tbh->b_assoc_map = NULL;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AS_EIO",
            "&bh->b_assoc_map->flags"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!bh->b_assoc_map"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bh->b_assoc_buffers"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tif (buffer_write_io_error(bh))\n\t\tset_bit(AS_EIO, &bh->b_assoc_map->flags);\n\tbh->b_assoc_map = NULL;\n}"
  },
  {
    "function_name": "mark_buffer_async_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "420-423",
    "snippet": "void mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_async_write_endio",
          "args": [
            "bh",
            "end_buffer_async_write"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_async_write_endio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "413-418",
          "snippet": "static void mark_buffer_async_write_endio(struct buffer_head *bh,\n\t\t\t\t\t  bh_end_io_t *handler)\n{\n\tbh->b_end_io = handler;\n\tset_buffer_async_write(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void mark_buffer_async_write_endio(struct buffer_head *bh,\n\t\t\t\t\t  bh_end_io_t *handler)\n{\n\tbh->b_end_io = handler;\n\tset_buffer_async_write(bh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}"
  },
  {
    "function_name": "mark_buffer_async_write_endio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "413-418",
    "snippet": "static void mark_buffer_async_write_endio(struct buffer_head *bh,\n\t\t\t\t\t  bh_end_io_t *handler)\n{\n\tbh->b_end_io = handler;\n\tset_buffer_async_write(bh);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void mark_buffer_async_write_endio(struct buffer_head *bh,\n\t\t\t\t\t  bh_end_io_t *handler)\n{\n\tbh->b_end_io = handler;\n\tset_buffer_async_write(bh);\n}"
  },
  {
    "function_name": "mark_buffer_async_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "407-411",
    "snippet": "static void mark_buffer_async_read(struct buffer_head *bh)\n{\n\tbh->b_end_io = end_buffer_async_read;\n\tset_buffer_async_read(bh);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_async_read",
          "args": [
            "bh"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void mark_buffer_async_read(struct buffer_head *bh)\n{\n\tbh->b_end_io = end_buffer_async_read;\n\tset_buffer_async_read(bh);\n}"
  },
  {
    "function_name": "end_buffer_async_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "340-383",
    "snippet": "void end_buffer_async_write(struct buffer_head *bh, int uptodate)\n{\n\tunsigned long flags;\n\tstruct buffer_head *first;\n\tstruct buffer_head *tmp;\n\tstruct page *page;\n\n\tBUG_ON(!buffer_async_write(bh));\n\n\tpage = bh->b_page;\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\tbuffer_io_error(bh, \", lost async page write\");\n\t\tset_bit(AS_EIO, &page->mapping->flags);\n\t\tset_buffer_write_io_error(bh);\n\t\tclear_buffer_uptodate(bh);\n\t\tSetPageError(page);\n\t}\n\n\tfirst = page_buffers(page);\n\tlocal_irq_save(flags);\n\tbit_spin_lock(BH_Uptodate_Lock, &first->b_state);\n\n\tclear_buffer_async_write(bh);\n\tunlock_buffer(bh);\n\ttmp = bh->b_this_page;\n\twhile (tmp != bh) {\n\t\tif (buffer_async_write(tmp)) {\n\t\t\tBUG_ON(!buffer_locked(tmp));\n\t\t\tgoto still_busy;\n\t\t}\n\t\ttmp = tmp->b_this_page;\n\t}\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\tend_page_writeback(page);\n\treturn;\n\nstill_busy:\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\treturn;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_spin_unlock",
          "args": [
            "BH_Uptodate_Lock",
            "&first->b_state"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_spin_unlock",
          "args": [
            "BH_Uptodate_Lock",
            "&first->b_state"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_locked(tmp)"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "tmp"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_async_write",
          "args": [
            "tmp"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_async_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "420-423",
          "snippet": "void mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_spin_lock",
          "args": [
            "BH_Uptodate_Lock",
            "&first->b_state"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AS_EIO",
            "&page->mapping->flags"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_io_error",
          "args": [
            "bh",
            "\", lost async page write\""
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_io_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "131-140",
          "snippet": "static void buffer_io_error(struct buffer_head *bh, char *msg)\n{\n\tchar b[BDEVNAME_SIZE];\n\n\tif (!test_bit(BH_Quiet, &bh->b_state))\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"Buffer I/O error on dev %s, logical block %llu%s\\n\",\n\t\t\tbdevname(bh->b_bdev, b),\n\t\t\t(unsigned long long)bh->b_blocknr, msg);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void buffer_io_error(struct buffer_head *bh, char *msg)\n{\n\tchar b[BDEVNAME_SIZE];\n\n\tif (!test_bit(BH_Quiet, &bh->b_state))\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"Buffer I/O error on dev %s, logical block %llu%s\\n\",\n\t\t\tbdevname(bh->b_bdev, b),\n\t\t\t(unsigned long long)bh->b_blocknr, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_async_write(bh)"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid end_buffer_async_write(struct buffer_head *bh, int uptodate)\n{\n\tunsigned long flags;\n\tstruct buffer_head *first;\n\tstruct buffer_head *tmp;\n\tstruct page *page;\n\n\tBUG_ON(!buffer_async_write(bh));\n\n\tpage = bh->b_page;\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\tbuffer_io_error(bh, \", lost async page write\");\n\t\tset_bit(AS_EIO, &page->mapping->flags);\n\t\tset_buffer_write_io_error(bh);\n\t\tclear_buffer_uptodate(bh);\n\t\tSetPageError(page);\n\t}\n\n\tfirst = page_buffers(page);\n\tlocal_irq_save(flags);\n\tbit_spin_lock(BH_Uptodate_Lock, &first->b_state);\n\n\tclear_buffer_async_write(bh);\n\tunlock_buffer(bh);\n\ttmp = bh->b_this_page;\n\twhile (tmp != bh) {\n\t\tif (buffer_async_write(tmp)) {\n\t\t\tBUG_ON(!buffer_locked(tmp));\n\t\t\tgoto still_busy;\n\t\t}\n\t\ttmp = tmp->b_this_page;\n\t}\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\tend_page_writeback(page);\n\treturn;\n\nstill_busy:\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\treturn;\n}"
  },
  {
    "function_name": "end_buffer_async_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "279-334",
    "snippet": "static void end_buffer_async_read(struct buffer_head *bh, int uptodate)\n{\n\tunsigned long flags;\n\tstruct buffer_head *first;\n\tstruct buffer_head *tmp;\n\tstruct page *page;\n\tint page_uptodate = 1;\n\n\tBUG_ON(!buffer_async_read(bh));\n\n\tpage = bh->b_page;\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\tclear_buffer_uptodate(bh);\n\t\tbuffer_io_error(bh, \", async page read\");\n\t\tSetPageError(page);\n\t}\n\n\t/*\n\t * Be _very_ careful from here on. Bad things can happen if\n\t * two buffer heads end IO at almost the same time and both\n\t * decide that the page is now completely done.\n\t */\n\tfirst = page_buffers(page);\n\tlocal_irq_save(flags);\n\tbit_spin_lock(BH_Uptodate_Lock, &first->b_state);\n\tclear_buffer_async_read(bh);\n\tunlock_buffer(bh);\n\ttmp = bh;\n\tdo {\n\t\tif (!buffer_uptodate(tmp))\n\t\t\tpage_uptodate = 0;\n\t\tif (buffer_async_read(tmp)) {\n\t\t\tBUG_ON(!buffer_locked(tmp));\n\t\t\tgoto still_busy;\n\t\t}\n\t\ttmp = tmp->b_this_page;\n\t} while (tmp != bh);\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * If none of the buffers had errors and they are all\n\t * uptodate then we can set the page uptodate.\n\t */\n\tif (page_uptodate && !PageError(page))\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn;\n\nstill_busy:\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\treturn;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_spin_unlock",
          "args": [
            "BH_Uptodate_Lock",
            "&first->b_state"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_spin_unlock",
          "args": [
            "BH_Uptodate_Lock",
            "&first->b_state"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_locked(tmp)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "tmp"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_async_read",
          "args": [
            "tmp"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_async_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "407-411",
          "snippet": "static void mark_buffer_async_read(struct buffer_head *bh)\n{\n\tbh->b_end_io = end_buffer_async_read;\n\tset_buffer_async_read(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void mark_buffer_async_read(struct buffer_head *bh)\n{\n\tbh->b_end_io = end_buffer_async_read;\n\tset_buffer_async_read(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "tmp"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_async_read",
          "args": [
            "bh"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_spin_lock",
          "args": [
            "BH_Uptodate_Lock",
            "&first->b_state"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_io_error",
          "args": [
            "bh",
            "\", async page read\""
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_io_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "131-140",
          "snippet": "static void buffer_io_error(struct buffer_head *bh, char *msg)\n{\n\tchar b[BDEVNAME_SIZE];\n\n\tif (!test_bit(BH_Quiet, &bh->b_state))\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"Buffer I/O error on dev %s, logical block %llu%s\\n\",\n\t\t\tbdevname(bh->b_bdev, b),\n\t\t\t(unsigned long long)bh->b_blocknr, msg);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void buffer_io_error(struct buffer_head *bh, char *msg)\n{\n\tchar b[BDEVNAME_SIZE];\n\n\tif (!test_bit(BH_Quiet, &bh->b_state))\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"Buffer I/O error on dev %s, logical block %llu%s\\n\",\n\t\t\tbdevname(bh->b_bdev, b),\n\t\t\t(unsigned long long)bh->b_blocknr, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_async_read(bh)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void end_buffer_async_read(struct buffer_head *bh, int uptodate)\n{\n\tunsigned long flags;\n\tstruct buffer_head *first;\n\tstruct buffer_head *tmp;\n\tstruct page *page;\n\tint page_uptodate = 1;\n\n\tBUG_ON(!buffer_async_read(bh));\n\n\tpage = bh->b_page;\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\tclear_buffer_uptodate(bh);\n\t\tbuffer_io_error(bh, \", async page read\");\n\t\tSetPageError(page);\n\t}\n\n\t/*\n\t * Be _very_ careful from here on. Bad things can happen if\n\t * two buffer heads end IO at almost the same time and both\n\t * decide that the page is now completely done.\n\t */\n\tfirst = page_buffers(page);\n\tlocal_irq_save(flags);\n\tbit_spin_lock(BH_Uptodate_Lock, &first->b_state);\n\tclear_buffer_async_read(bh);\n\tunlock_buffer(bh);\n\ttmp = bh;\n\tdo {\n\t\tif (!buffer_uptodate(tmp))\n\t\t\tpage_uptodate = 0;\n\t\tif (buffer_async_read(tmp)) {\n\t\t\tBUG_ON(!buffer_locked(tmp));\n\t\t\tgoto still_busy;\n\t\t}\n\t\ttmp = tmp->b_this_page;\n\t} while (tmp != bh);\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * If none of the buffers had errors and they are all\n\t * uptodate then we can set the page uptodate.\n\t */\n\tif (page_uptodate && !PageError(page))\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn;\n\nstill_busy:\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\treturn;\n}"
  },
  {
    "function_name": "free_more_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "257-273",
    "snippet": "static void free_more_memory(void)\n{\n\tstruct zone *zone;\n\tint nid;\n\n\twakeup_flusher_threads(1024, WB_REASON_FREE_MORE_MEM);\n\tyield();\n\n\tfor_each_online_node(nid) {\n\t\t(void)first_zones_zonelist(node_zonelist(nid, GFP_NOFS),\n\t\t\t\t\t\tgfp_zone(GFP_NOFS), NULL,\n\t\t\t\t\t\t&zone);\n\t\tif (zone)\n\t\t\ttry_to_free_pages(node_zonelist(nid, GFP_NOFS), 0,\n\t\t\t\t\t\tGFP_NOFS, NULL);\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_free_pages",
          "args": [
            "node_zonelist(nid, GFP_NOFS)",
            "0",
            "GFP_NOFS",
            "NULL"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_zonelist",
          "args": [
            "nid",
            "GFP_NOFS"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "first_zones_zonelist",
          "args": [
            "node_zonelist(nid, GFP_NOFS)",
            "gfp_zone(GFP_NOFS)",
            "NULL",
            "&zone"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp_zone",
          "args": [
            "GFP_NOFS"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_zonelist",
          "args": [
            "nid",
            "GFP_NOFS"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yield",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_flusher_threads",
          "args": [
            "1024",
            "WB_REASON_FREE_MORE_MEM"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_flusher_threads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1118-1132",
          "snippet": "void wakeup_flusher_threads(long nr_pages, enum wb_reason reason)\n{\n\tstruct backing_dev_info *bdi;\n\n\tif (!nr_pages)\n\t\tnr_pages = get_nr_dirty_pages();\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(bdi, &bdi_list, bdi_list) {\n\t\tif (!bdi_has_dirty_io(bdi))\n\t\t\tcontinue;\n\t\t__bdi_start_writeback(bdi, nr_pages, false, reason);\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid wakeup_flusher_threads(long nr_pages, enum wb_reason reason)\n{\n\tstruct backing_dev_info *bdi;\n\n\tif (!nr_pages)\n\t\tnr_pages = get_nr_dirty_pages();\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(bdi, &bdi_list, bdi_list) {\n\t\tif (!bdi_has_dirty_io(bdi))\n\t\t\tcontinue;\n\t\t__bdi_start_writeback(bdi, nr_pages, false, reason);\n\t}\n\trcu_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void free_more_memory(void)\n{\n\tstruct zone *zone;\n\tint nid;\n\n\twakeup_flusher_threads(1024, WB_REASON_FREE_MORE_MEM);\n\tyield();\n\n\tfor_each_online_node(nid) {\n\t\t(void)first_zones_zonelist(node_zonelist(nid, GFP_NOFS),\n\t\t\t\t\t\tgfp_zone(GFP_NOFS), NULL,\n\t\t\t\t\t\t&zone);\n\t\tif (zone)\n\t\t\ttry_to_free_pages(node_zonelist(nid, GFP_NOFS), 0,\n\t\t\t\t\t\tGFP_NOFS, NULL);\n\t}\n}"
  },
  {
    "function_name": "__find_get_block_slow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "197-252",
    "snippet": "static struct buffer_head *\n__find_get_block_slow(struct block_device *bdev, sector_t block)\n{\n\tstruct inode *bd_inode = bdev->bd_inode;\n\tstruct address_space *bd_mapping = bd_inode->i_mapping;\n\tstruct buffer_head *ret = NULL;\n\tpgoff_t index;\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct page *page;\n\tint all_mapped = 1;\n\n\tindex = block >> (PAGE_CACHE_SHIFT - bd_inode->i_blkbits);\n\tpage = find_get_page_flags(bd_mapping, index, FGP_ACCESSED);\n\tif (!page)\n\t\tgoto out;\n\n\tspin_lock(&bd_mapping->private_lock);\n\tif (!page_has_buffers(page))\n\t\tgoto out_unlock;\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tall_mapped = 0;\n\t\telse if (bh->b_blocknr == block) {\n\t\t\tret = bh;\n\t\t\tget_bh(bh);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/* we might be here because some of the buffers on this page are\n\t * not mapped.  This is due to various races between\n\t * file io on the block device and getblk.  It gets dealt with\n\t * elsewhere, don't buffer_error if we had some unmapped buffers\n\t */\n\tif (all_mapped) {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\tprintk(\"__find_get_block_slow() failed. \"\n\t\t\t\"block=%llu, b_blocknr=%llu\\n\",\n\t\t\t(unsigned long long)block,\n\t\t\t(unsigned long long)bh->b_blocknr);\n\t\tprintk(\"b_state=0x%08lx, b_size=%zu\\n\",\n\t\t\tbh->b_state, bh->b_size);\n\t\tprintk(\"device %s blocksize: %d\\n\", bdevname(bdev, b),\n\t\t\t1 << bd_inode->i_blkbits);\n\t}\nout_unlock:\n\tspin_unlock(&bd_mapping->private_lock);\n\tpage_cache_release(page);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bd_mapping->private_lock"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"device %s blocksize: %d\\n\"",
            "bdevname(bdev, b)",
            "1 << bd_inode->i_blkbits"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "bdev",
            "b"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bd_mapping->private_lock"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_get_page_flags",
          "args": [
            "bd_mapping",
            "index",
            "FGP_ACCESSED"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic struct buffer_head *\n__find_get_block_slow(struct block_device *bdev, sector_t block)\n{\n\tstruct inode *bd_inode = bdev->bd_inode;\n\tstruct address_space *bd_mapping = bd_inode->i_mapping;\n\tstruct buffer_head *ret = NULL;\n\tpgoff_t index;\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct page *page;\n\tint all_mapped = 1;\n\n\tindex = block >> (PAGE_CACHE_SHIFT - bd_inode->i_blkbits);\n\tpage = find_get_page_flags(bd_mapping, index, FGP_ACCESSED);\n\tif (!page)\n\t\tgoto out;\n\n\tspin_lock(&bd_mapping->private_lock);\n\tif (!page_has_buffers(page))\n\t\tgoto out_unlock;\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tall_mapped = 0;\n\t\telse if (bh->b_blocknr == block) {\n\t\t\tret = bh;\n\t\t\tget_bh(bh);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/* we might be here because some of the buffers on this page are\n\t * not mapped.  This is due to various races between\n\t * file io on the block device and getblk.  It gets dealt with\n\t * elsewhere, don't buffer_error if we had some unmapped buffers\n\t */\n\tif (all_mapped) {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\tprintk(\"__find_get_block_slow() failed. \"\n\t\t\t\"block=%llu, b_blocknr=%llu\\n\",\n\t\t\t(unsigned long long)block,\n\t\t\t(unsigned long long)bh->b_blocknr);\n\t\tprintk(\"b_state=0x%08lx, b_size=%zu\\n\",\n\t\t\tbh->b_state, bh->b_size);\n\t\tprintk(\"device %s blocksize: %d\\n\", bdevname(bdev, b),\n\t\t\t1 << bd_inode->i_blkbits);\n\t}\nout_unlock:\n\tspin_unlock(&bd_mapping->private_lock);\n\tpage_cache_release(page);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "end_buffer_write_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "172-183",
    "snippet": "void end_buffer_write_sync(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\tbuffer_io_error(bh, \", lost sync page write\");\n\t\tset_buffer_write_io_error(bh);\n\t\tclear_buffer_uptodate(bh);\n\t}\n\tunlock_buffer(bh);\n\tput_bh(bh);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_io_error",
          "args": [
            "bh",
            "\", lost sync page write\""
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_io_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "131-140",
          "snippet": "static void buffer_io_error(struct buffer_head *bh, char *msg)\n{\n\tchar b[BDEVNAME_SIZE];\n\n\tif (!test_bit(BH_Quiet, &bh->b_state))\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"Buffer I/O error on dev %s, logical block %llu%s\\n\",\n\t\t\tbdevname(bh->b_bdev, b),\n\t\t\t(unsigned long long)bh->b_blocknr, msg);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void buffer_io_error(struct buffer_head *bh, char *msg)\n{\n\tchar b[BDEVNAME_SIZE];\n\n\tif (!test_bit(BH_Quiet, &bh->b_state))\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"Buffer I/O error on dev %s, logical block %llu%s\\n\",\n\t\t\tbdevname(bh->b_bdev, b),\n\t\t\t(unsigned long long)bh->b_blocknr, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid end_buffer_write_sync(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\tbuffer_io_error(bh, \", lost sync page write\");\n\t\tset_buffer_write_io_error(bh);\n\t\tclear_buffer_uptodate(bh);\n\t}\n\tunlock_buffer(bh);\n\tput_bh(bh);\n}"
  },
  {
    "function_name": "end_buffer_read_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "165-169",
    "snippet": "void end_buffer_read_sync(struct buffer_head *bh, int uptodate)\n{\n\t__end_buffer_read_notouch(bh, uptodate);\n\tput_bh(bh);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__end_buffer_read_notouch",
          "args": [
            "bh",
            "uptodate"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "__end_buffer_read_notouch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "150-159",
          "snippet": "static void __end_buffer_read_notouch(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\t/* This happens, due to failed READA attempts. */\n\t\tclear_buffer_uptodate(bh);\n\t}\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void __end_buffer_read_notouch(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\t/* This happens, due to failed READA attempts. */\n\t\tclear_buffer_uptodate(bh);\n\t}\n\tunlock_buffer(bh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid end_buffer_read_sync(struct buffer_head *bh, int uptodate)\n{\n\t__end_buffer_read_notouch(bh, uptodate);\n\tput_bh(bh);\n}"
  },
  {
    "function_name": "__end_buffer_read_notouch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "150-159",
    "snippet": "static void __end_buffer_read_notouch(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\t/* This happens, due to failed READA attempts. */\n\t\tclear_buffer_uptodate(bh);\n\t}\n\tunlock_buffer(bh);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void __end_buffer_read_notouch(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\t/* This happens, due to failed READA attempts. */\n\t\tclear_buffer_uptodate(bh);\n\t}\n\tunlock_buffer(bh);\n}"
  },
  {
    "function_name": "buffer_io_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "131-140",
    "snippet": "static void buffer_io_error(struct buffer_head *bh, char *msg)\n{\n\tchar b[BDEVNAME_SIZE];\n\n\tif (!test_bit(BH_Quiet, &bh->b_state))\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"Buffer I/O error on dev %s, logical block %llu%s\\n\",\n\t\t\tbdevname(bh->b_bdev, b),\n\t\t\t(unsigned long long)bh->b_blocknr, msg);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_ERR\n\t\t\t\"Buffer I/O error on dev %s, logical block %llu%s\\n\"",
            "bdevname(bh->b_bdev, b)",
            "(unsigned long long)bh->b_blocknr",
            "msg"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "bh->b_bdev",
            "b"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BH_Quiet",
            "&bh->b_state"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void buffer_io_error(struct buffer_head *bh, char *msg)\n{\n\tchar b[BDEVNAME_SIZE];\n\n\tif (!test_bit(BH_Quiet, &bh->b_state))\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"Buffer I/O error on dev %s, logical block %llu%s\\n\",\n\t\t\tbdevname(bh->b_bdev, b),\n\t\t\t(unsigned long long)bh->b_blocknr, msg);\n}"
  },
  {
    "function_name": "__clear_page_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "123-129",
    "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
  },
  {
    "function_name": "__wait_on_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "117-120",
    "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_bit_io",
          "args": [
            "&bh->b_state",
            "BH_Lock",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
  },
  {
    "function_name": "buffer_check_dirty_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "83-109",
    "snippet": "void buffer_check_dirty_writeback(struct page *page,\n\t\t\t\t     bool *dirty, bool *writeback)\n{\n\tstruct buffer_head *head, *bh;\n\t*dirty = false;\n\t*writeback = false;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tif (PageWriteback(page))\n\t\t*writeback = true;\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (buffer_locked(bh))\n\t\t\t*writeback = true;\n\n\t\tif (buffer_dirty(bh))\n\t\t\t*dirty = true;\n\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid buffer_check_dirty_writeback(struct page *page,\n\t\t\t\t     bool *dirty, bool *writeback)\n{\n\tstruct buffer_head *head, *bh;\n\t*dirty = false;\n\t*writeback = false;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tif (PageWriteback(page))\n\t\t*writeback = true;\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (buffer_locked(bh))\n\t\t\t*writeback = true;\n\n\t\tif (buffer_dirty(bh))\n\t\t\t*dirty = true;\n\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}"
  },
  {
    "function_name": "unlock_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "70-75",
    "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&bh->b_state",
            "BH_Lock"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "BH_Lock",
            "&bh->b_state"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
  },
  {
    "function_name": "__lock_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "64-67",
    "snippet": "void __lock_buffer(struct buffer_head *bh)\n{\n\twait_on_bit_lock_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_bit_lock_io",
          "args": [
            "&bh->b_state",
            "BH_Lock",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __lock_buffer(struct buffer_head *bh)\n{\n\twait_on_bit_lock_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
  },
  {
    "function_name": "touch_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "57-61",
    "snippet": "inline void touch_buffer(struct buffer_head *bh)\n{\n\ttrace_block_touch_buffer(bh);\n\tmark_page_accessed(bh->b_page);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_page_accessed",
          "args": [
            "bh->b_page"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_block_touch_buffer",
          "args": [
            "bh"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\ninline void touch_buffer(struct buffer_head *bh)\n{\n\ttrace_block_touch_buffer(bh);\n\tmark_page_accessed(bh->b_page);\n}"
  },
  {
    "function_name": "init_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
    "lines": "50-54",
    "snippet": "void init_buffer(struct buffer_head *bh, bh_end_io_t *handler, void *private)\n{\n\tbh->b_end_io = handler;\n\tbh->b_private = private;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid init_buffer(struct buffer_head *bh, bh_end_io_t *handler, void *private)\n{\n\tbh->b_end_io = handler;\n\tbh->b_private = private;\n}"
  }
]