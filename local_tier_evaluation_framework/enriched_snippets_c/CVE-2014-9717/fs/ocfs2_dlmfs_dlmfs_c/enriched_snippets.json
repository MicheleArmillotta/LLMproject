[
  {
    "function_name": "exit_dlmfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "669-683",
    "snippet": "static void __exit exit_dlmfs_fs(void)\n{\n\tunregister_filesystem(&dlmfs_fs_type);\n\n\tflush_workqueue(user_dlm_worker);\n\tdestroy_workqueue(user_dlm_worker);\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(dlmfs_inode_cache);\n\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dlmfs_inode_cache;",
      "struct workqueue_struct *user_dlm_worker;",
      "static struct file_system_type dlmfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ocfs2_dlmfs\",\n\t.mount\t\t= dlmfs_mount,\n\t.kill_sb\t= kill_litter_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "dlmfs_inode_cache"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "user_dlm_worker"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "user_dlm_worker"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&dlmfs_fs_type"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlmfs_inode_cache;\nstruct workqueue_struct *user_dlm_worker;\nstatic struct file_system_type dlmfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ocfs2_dlmfs\",\n\t.mount\t\t= dlmfs_mount,\n\t.kill_sb\t= kill_litter_super,\n};\n\nstatic void __exit exit_dlmfs_fs(void)\n{\n\tunregister_filesystem(&dlmfs_fs_type);\n\n\tflush_workqueue(user_dlm_worker);\n\tdestroy_workqueue(user_dlm_worker);\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(dlmfs_inode_cache);\n\n}"
  },
  {
    "function_name": "init_dlmfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "633-667",
    "snippet": "static int __init init_dlmfs_fs(void)\n{\n\tint status;\n\tint cleanup_inode = 0, cleanup_worker = 0;\n\n\tdlmfs_inode_cache = kmem_cache_create(\"dlmfs_inode_cache\",\n\t\t\t\tsizeof(struct dlmfs_inode_private),\n\t\t\t\t0, (SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\tdlmfs_init_once);\n\tif (!dlmfs_inode_cache) {\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tcleanup_inode = 1;\n\n\tuser_dlm_worker = create_singlethread_workqueue(\"user_dlm\");\n\tif (!user_dlm_worker) {\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tcleanup_worker = 1;\n\n\tuser_dlm_set_locking_protocol();\n\tstatus = register_filesystem(&dlmfs_fs_type);\nbail:\n\tif (status) {\n\t\tif (cleanup_inode)\n\t\t\tkmem_cache_destroy(dlmfs_inode_cache);\n\t\tif (cleanup_worker)\n\t\t\tdestroy_workqueue(user_dlm_worker);\n\t} else\n\t\tprintk(\"OCFS2 User DLM kernel interface loaded\\n\");\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dlmfs_inode_cache;",
      "struct workqueue_struct *user_dlm_worker;",
      "static struct file_system_type dlmfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ocfs2_dlmfs\",\n\t.mount\t\t= dlmfs_mount,\n\t.kill_sb\t= kill_litter_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"OCFS2 User DLM kernel interface loaded\\n\""
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "user_dlm_worker"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "dlmfs_inode_cache"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&dlmfs_fs_type"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_dlm_set_locking_protocol",
          "args": [],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "user_dlm_set_locking_protocol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "665-668",
          "snippet": "void user_dlm_set_locking_protocol(void)\n{\n\tocfs2_stack_glue_set_max_proto_version(&user_dlm_lproto.lp_max_version);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_locking_protocol user_dlm_lproto = {\n\t.lp_max_version = {\n\t\t.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,\n\t\t.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,\n\t},\n\t.lp_lock_ast\t\t= user_ast,\n\t.lp_blocking_ast\t= user_bast,\n\t.lp_unlock_ast\t\t= user_unlock_ast,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic struct ocfs2_locking_protocol user_dlm_lproto = {\n\t.lp_max_version = {\n\t\t.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,\n\t\t.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,\n\t},\n\t.lp_lock_ast\t\t= user_ast,\n\t.lp_blocking_ast\t= user_bast,\n\t.lp_unlock_ast\t\t= user_unlock_ast,\n};\n\nvoid user_dlm_set_locking_protocol(void)\n{\n\tocfs2_stack_glue_set_max_proto_version(&user_dlm_lproto.lp_max_version);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_singlethread_workqueue",
          "args": [
            "\"user_dlm\""
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"dlmfs_inode_cache\"",
            "sizeof(struct dlmfs_inode_private)",
            "0",
            "(SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\tSLAB_MEM_SPREAD)",
            "dlmfs_init_once"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlmfs_inode_cache;\nstruct workqueue_struct *user_dlm_worker;\nstatic struct file_system_type dlmfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ocfs2_dlmfs\",\n\t.mount\t\t= dlmfs_mount,\n\t.kill_sb\t= kill_litter_super,\n};\n\nstatic int __init init_dlmfs_fs(void)\n{\n\tint status;\n\tint cleanup_inode = 0, cleanup_worker = 0;\n\n\tdlmfs_inode_cache = kmem_cache_create(\"dlmfs_inode_cache\",\n\t\t\t\tsizeof(struct dlmfs_inode_private),\n\t\t\t\t0, (SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\tdlmfs_init_once);\n\tif (!dlmfs_inode_cache) {\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tcleanup_inode = 1;\n\n\tuser_dlm_worker = create_singlethread_workqueue(\"user_dlm\");\n\tif (!user_dlm_worker) {\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tcleanup_worker = 1;\n\n\tuser_dlm_set_locking_protocol();\n\tstatus = register_filesystem(&dlmfs_fs_type);\nbail:\n\tif (status) {\n\t\tif (cleanup_inode)\n\t\t\tkmem_cache_destroy(dlmfs_inode_cache);\n\t\tif (cleanup_worker)\n\t\t\tdestroy_workqueue(user_dlm_worker);\n\t} else\n\t\tprintk(\"OCFS2 User DLM kernel interface loaded\\n\");\n\treturn status;\n}"
  },
  {
    "function_name": "dlmfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "619-623",
    "snippet": "static struct dentry *dlmfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_nodev(fs_type, flags, data, dlmfs_fill_super);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_nodev",
          "args": [
            "fs_type",
            "flags",
            "data",
            "dlmfs_fill_super"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct dentry *dlmfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_nodev(fs_type, flags, data, dlmfs_fill_super);\n}"
  },
  {
    "function_name": "dlmfs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "569-582",
    "snippet": "static int dlmfs_fill_super(struct super_block * sb,\n\t\t\t    void * data,\n\t\t\t    int silent)\n{\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_blocksize = PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits = PAGE_CACHE_SHIFT;\n\tsb->s_magic = DLMFS_MAGIC;\n\tsb->s_op = &dlmfs_ops;\n\tsb->s_root = d_make_root(dlmfs_get_root_inode(sb));\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations dlmfs_ops;",
      "static const struct super_operations dlmfs_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.alloc_inode\t= dlmfs_alloc_inode,\n\t.destroy_inode\t= dlmfs_destroy_inode,\n\t.evict_inode\t= dlmfs_evict_inode,\n\t.drop_inode\t= generic_delete_inode,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "dlmfs_get_root_inode(sb)"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlmfs_get_root_inode",
          "args": [
            "sb"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "dlmfs_get_root_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
          "lines": "393-409",
          "snippet": "static struct inode *dlmfs_get_root_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tumode_t mode = S_IFDIR | 0755;\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, NULL, mode);\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinc_nlink(inode);\n\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinode->i_op = &dlmfs_root_inode_operations;\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/poll.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations dlmfs_root_inode_operations;",
            "static const struct inode_operations dlmfs_root_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n\t.mkdir\t\t= dlmfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct inode_operations dlmfs_root_inode_operations;\nstatic const struct inode_operations dlmfs_root_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n\t.mkdir\t\t= dlmfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n};\n\nstatic struct inode *dlmfs_get_root_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tumode_t mode = S_IFDIR | 0755;\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, NULL, mode);\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinc_nlink(inode);\n\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinode->i_op = &dlmfs_root_inode_operations;\n\t}\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct super_operations dlmfs_ops;\nstatic const struct super_operations dlmfs_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.alloc_inode\t= dlmfs_alloc_inode,\n\t.destroy_inode\t= dlmfs_destroy_inode,\n\t.evict_inode\t= dlmfs_evict_inode,\n\t.drop_inode\t= generic_delete_inode,\n};\n\nstatic int dlmfs_fill_super(struct super_block * sb,\n\t\t\t    void * data,\n\t\t\t    int silent)\n{\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_blocksize = PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits = PAGE_CACHE_SHIFT;\n\tsb->s_magic = DLMFS_MAGIC;\n\tsb->s_op = &dlmfs_ops;\n\tsb->s_root = d_make_root(dlmfs_get_root_inode(sb));\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "dlmfs_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "548-567",
    "snippet": "static int dlmfs_unlink(struct inode *dir,\n\t\t\tstruct dentry *dentry)\n{\n\tint status;\n\tstruct inode *inode = dentry->d_inode;\n\n\tmlog(0, \"unlink inode %lu\\n\", inode->i_ino);\n\n\t/* if there are no current holders, or none that are waiting\n\t * to acquire a lock, this basically destroys our lockres. */\n\tstatus = user_dlm_destroy_lock(&DLMFS_I(inode)->ip_lockres);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"unlink %pd, error %d from destroy\\n\",\n\t\t     dentry, status);\n\t\tgoto bail;\n\t}\n\tstatus = simple_unlink(dir, dentry);\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_unlink",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "simple_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "305-313",
          "snippet": "int simple_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tdrop_nlink(inode);\n\tdput(dentry);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tdrop_nlink(inode);\n\tdput(dentry);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"unlink %pd, error %d from destroy\\n\"",
            "dentry",
            "status"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_dlm_destroy_lock",
          "args": [
            "&DLMFS_I(inode)->ip_lockres"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "user_dlm_destroy_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "606-656",
          "snippet": "int user_dlm_destroy_lock(struct user_lock_res *lockres)\n{\n\tint status = -EBUSY;\n\tstruct ocfs2_cluster_connection *conn =\n\t\tcluster_connection_from_user_lockres(lockres);\n\n\tmlog(ML_BASTS, \"lockres %.*s\\n\", lockres->l_namelen, lockres->l_name);\n\n\tspin_lock(&lockres->l_lock);\n\tif (lockres->l_flags & USER_LOCK_IN_TEARDOWN) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\treturn 0;\n\t}\n\n\tlockres->l_flags |= USER_LOCK_IN_TEARDOWN;\n\n\twhile (lockres->l_flags & USER_LOCK_BUSY) {\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tuser_wait_on_busy_lock(lockres);\n\n\t\tspin_lock(&lockres->l_lock);\n\t}\n\n\tif (lockres->l_ro_holders || lockres->l_ex_holders) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\tif (!(lockres->l_flags & USER_LOCK_ATTACHED)) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto bail;\n\t}\n\n\tlockres->l_flags &= ~USER_LOCK_ATTACHED;\n\tlockres->l_flags |= USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n\n\tstatus = ocfs2_dlm_unlock(conn, &lockres->l_lksb, DLM_LKF_VALBLK);\n\tif (status) {\n\t\tuser_log_dlm_error(\"ocfs2_dlm_unlock\", status, lockres);\n\t\tgoto bail;\n\t}\n\n\tuser_wait_on_busy_lock(lockres);\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nint user_dlm_destroy_lock(struct user_lock_res *lockres)\n{\n\tint status = -EBUSY;\n\tstruct ocfs2_cluster_connection *conn =\n\t\tcluster_connection_from_user_lockres(lockres);\n\n\tmlog(ML_BASTS, \"lockres %.*s\\n\", lockres->l_namelen, lockres->l_name);\n\n\tspin_lock(&lockres->l_lock);\n\tif (lockres->l_flags & USER_LOCK_IN_TEARDOWN) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\treturn 0;\n\t}\n\n\tlockres->l_flags |= USER_LOCK_IN_TEARDOWN;\n\n\twhile (lockres->l_flags & USER_LOCK_BUSY) {\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tuser_wait_on_busy_lock(lockres);\n\n\t\tspin_lock(&lockres->l_lock);\n\t}\n\n\tif (lockres->l_ro_holders || lockres->l_ex_holders) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\tif (!(lockres->l_flags & USER_LOCK_ATTACHED)) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto bail;\n\t}\n\n\tlockres->l_flags &= ~USER_LOCK_ATTACHED;\n\tlockres->l_flags |= USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n\n\tstatus = ocfs2_dlm_unlock(conn, &lockres->l_lksb, DLM_LKF_VALBLK);\n\tif (status) {\n\t\tuser_log_dlm_error(\"ocfs2_dlm_unlock\", status, lockres);\n\t\tgoto bail;\n\t}\n\n\tuser_wait_on_busy_lock(lockres);\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DLMFS_I",
          "args": [
            "inode"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "DLMFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.h",
          "lines": "99-105",
          "snippet": "static inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"unlink inode %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlmfs_unlink(struct inode *dir,\n\t\t\tstruct dentry *dentry)\n{\n\tint status;\n\tstruct inode *inode = dentry->d_inode;\n\n\tmlog(0, \"unlink inode %lu\\n\", inode->i_ino);\n\n\t/* if there are no current holders, or none that are waiting\n\t * to acquire a lock, this basically destroys our lockres. */\n\tstatus = user_dlm_destroy_lock(&DLMFS_I(inode)->ip_lockres);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"unlink %pd, error %d from destroy\\n\",\n\t\t     dentry, status);\n\t\tgoto bail;\n\t}\n\tstatus = simple_unlink(dir, dentry);\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "dlmfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "514-546",
    "snippet": "static int dlmfs_create(struct inode *dir,\n\t\t\tstruct dentry *dentry,\n\t\t\tumode_t mode,\n\t\t\tbool excl)\n{\n\tint status = 0;\n\tstruct inode *inode;\n\tstruct qstr *name = &dentry->d_name;\n\n\tmlog(0, \"create %.*s\\n\", name->len, name->name);\n\n\t/* verify name is valid and doesn't contain any dlm reserved\n\t * characters */\n\tif (name->len >= USER_DLM_LOCK_ID_MAX_LEN ||\n\t    name->name[0] == '$') {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"invalid lock name, %.*s\\n\", name->len,\n\t\t     name->name);\n\t\tgoto bail;\n\t}\n\n\tinode = dlmfs_get_inode(dir, dentry, mode | S_IFREG);\n\tif (!inode) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\td_instantiate(dentry, inode);\n\tdget(dentry);\t/* Extra count - pin the dentry in core */\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlmfs_get_inode",
          "args": [
            "dir",
            "dentry",
            "mode | S_IFREG"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "dlmfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
          "lines": "411-460",
          "snippet": "static struct inode *dlmfs_get_inode(struct inode *parent,\n\t\t\t\t     struct dentry *dentry,\n\t\t\t\t     umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode * inode = new_inode(sb);\n\tstruct dlmfs_inode_private *ip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = get_next_ino();\n\tinode_init_owner(inode, parent, mode);\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\tip = DLMFS_I(inode);\n\tip->ip_conn = DLMFS_I(parent)->ip_conn;\n\n\tswitch (mode & S_IFMT) {\n\tdefault:\n\t\t/* for now we don't support anything other than\n\t\t * directories and regular files. */\n\t\tBUG();\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &dlmfs_file_inode_operations;\n\t\tinode->i_fop = &dlmfs_file_operations;\n\n\t\ti_size_write(inode,  DLM_LVB_LEN);\n\n\t\tuser_dlm_lock_res_init(&ip->ip_lockres, dentry);\n\n\t\t/* released at clear_inode time, this insures that we\n\t\t * get to drop the dlm reference on each lock *before*\n\t\t * we call the unregister code for releasing parent\n\t\t * directories. */\n\t\tip->ip_parent = igrab(parent);\n\t\tBUG_ON(!ip->ip_parent);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &dlmfs_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t/* directory inodes start off with i_nlink ==\n\t\t * 2 (for \".\" entry) */\n\t\tinc_nlink(inode);\n\t\tbreak;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/poll.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations dlmfs_file_operations;",
            "static const struct inode_operations dlmfs_dir_inode_operations;",
            "static const struct inode_operations dlmfs_file_inode_operations;",
            "static const struct file_operations dlmfs_file_operations = {\n\t.open\t\t= dlmfs_file_open,\n\t.release\t= dlmfs_file_release,\n\t.poll\t\t= dlmfs_file_poll,\n\t.read\t\t= dlmfs_file_read,\n\t.write\t\t= dlmfs_file_write,\n\t.llseek\t\t= default_llseek,\n};",
            "static const struct inode_operations dlmfs_dir_inode_operations = {\n\t.create\t\t= dlmfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.unlink\t\t= dlmfs_unlink,\n};",
            "static const struct inode_operations dlmfs_file_inode_operations = {\n\t.getattr\t= simple_getattr,\n\t.setattr\t= dlmfs_file_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct file_operations dlmfs_file_operations;\nstatic const struct inode_operations dlmfs_dir_inode_operations;\nstatic const struct inode_operations dlmfs_file_inode_operations;\nstatic const struct file_operations dlmfs_file_operations = {\n\t.open\t\t= dlmfs_file_open,\n\t.release\t= dlmfs_file_release,\n\t.poll\t\t= dlmfs_file_poll,\n\t.read\t\t= dlmfs_file_read,\n\t.write\t\t= dlmfs_file_write,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct inode_operations dlmfs_dir_inode_operations = {\n\t.create\t\t= dlmfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.unlink\t\t= dlmfs_unlink,\n};\nstatic const struct inode_operations dlmfs_file_inode_operations = {\n\t.getattr\t= simple_getattr,\n\t.setattr\t= dlmfs_file_setattr,\n};\n\nstatic struct inode *dlmfs_get_inode(struct inode *parent,\n\t\t\t\t     struct dentry *dentry,\n\t\t\t\t     umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode * inode = new_inode(sb);\n\tstruct dlmfs_inode_private *ip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = get_next_ino();\n\tinode_init_owner(inode, parent, mode);\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\tip = DLMFS_I(inode);\n\tip->ip_conn = DLMFS_I(parent)->ip_conn;\n\n\tswitch (mode & S_IFMT) {\n\tdefault:\n\t\t/* for now we don't support anything other than\n\t\t * directories and regular files. */\n\t\tBUG();\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &dlmfs_file_inode_operations;\n\t\tinode->i_fop = &dlmfs_file_operations;\n\n\t\ti_size_write(inode,  DLM_LVB_LEN);\n\n\t\tuser_dlm_lock_res_init(&ip->ip_lockres, dentry);\n\n\t\t/* released at clear_inode time, this insures that we\n\t\t * get to drop the dlm reference on each lock *before*\n\t\t * we call the unregister code for releasing parent\n\t\t * directories. */\n\t\tip->ip_parent = igrab(parent);\n\t\tBUG_ON(!ip->ip_parent);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &dlmfs_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t/* directory inodes start off with i_nlink ==\n\t\t * 2 (for \".\" entry) */\n\t\tinc_nlink(inode);\n\t\tbreak;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"invalid lock name, %.*s\\n\"",
            "name->len",
            "name->name"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlmfs_create(struct inode *dir,\n\t\t\tstruct dentry *dentry,\n\t\t\tumode_t mode,\n\t\t\tbool excl)\n{\n\tint status = 0;\n\tstruct inode *inode;\n\tstruct qstr *name = &dentry->d_name;\n\n\tmlog(0, \"create %.*s\\n\", name->len, name->name);\n\n\t/* verify name is valid and doesn't contain any dlm reserved\n\t * characters */\n\tif (name->len >= USER_DLM_LOCK_ID_MAX_LEN ||\n\t    name->name[0] == '$') {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"invalid lock name, %.*s\\n\", name->len,\n\t\t     name->name);\n\t\tgoto bail;\n\t}\n\n\tinode = dlmfs_get_inode(dir, dentry, mode | S_IFREG);\n\tif (!inode) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\td_instantiate(dentry, inode);\n\tdget(dentry);\t/* Extra count - pin the dentry in core */\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "dlmfs_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "466-512",
    "snippet": "static int dlmfs_mkdir(struct inode * dir,\n\t\t       struct dentry * dentry,\n\t\t       umode_t mode)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct qstr *domain = &dentry->d_name;\n\tstruct dlmfs_inode_private *ip;\n\tstruct ocfs2_cluster_connection *conn;\n\n\tmlog(0, \"mkdir %.*s\\n\", domain->len, domain->name);\n\n\t/* verify that we have a proper domain */\n\tif (domain->len >= GROUP_NAME_MAX) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"invalid domain name for directory.\\n\");\n\t\tgoto bail;\n\t}\n\n\tinode = dlmfs_get_inode(dir, dentry, mode | S_IFDIR);\n\tif (!inode) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tip = DLMFS_I(inode);\n\n\tconn = user_dlm_register(domain);\n\tif (IS_ERR(conn)) {\n\t\tstatus = PTR_ERR(conn);\n\t\tmlog(ML_ERROR, \"Error %d could not register domain \\\"%.*s\\\"\\n\",\n\t\t     status, domain->len, domain->name);\n\t\tgoto bail;\n\t}\n\tip->ip_conn = conn;\n\n\tinc_nlink(dir);\n\td_instantiate(dentry, inode);\n\tdget(dentry);\t/* Extra count - pin the dentry in core */\n\n\tstatus = 0;\nbail:\n\tif (status < 0)\n\t\tiput(inode);\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dir"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Error %d could not register domain \\\"%.*s\\\"\\n\"",
            "status",
            "domain->len",
            "domain->name"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "conn"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "conn"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_dlm_register",
          "args": [
            "domain"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "user_dlm_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "670-683",
          "snippet": "struct ocfs2_cluster_connection *user_dlm_register(struct qstr *name)\n{\n\tint rc;\n\tstruct ocfs2_cluster_connection *conn;\n\n\trc = ocfs2_cluster_connect_agnostic(name->name, name->len,\n\t\t\t\t\t    &user_dlm_lproto,\n\t\t\t\t\t    user_dlm_recovery_handler_noop,\n\t\t\t\t\t    NULL, &conn);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\treturn rc ? ERR_PTR(rc) : conn;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_locking_protocol user_dlm_lproto = {\n\t.lp_max_version = {\n\t\t.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,\n\t\t.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,\n\t},\n\t.lp_lock_ast\t\t= user_ast,\n\t.lp_blocking_ast\t= user_bast,\n\t.lp_unlock_ast\t\t= user_unlock_ast,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic struct ocfs2_locking_protocol user_dlm_lproto = {\n\t.lp_max_version = {\n\t\t.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,\n\t\t.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,\n\t},\n\t.lp_lock_ast\t\t= user_ast,\n\t.lp_blocking_ast\t= user_bast,\n\t.lp_unlock_ast\t\t= user_unlock_ast,\n};\n\nstruct ocfs2_cluster_connection *user_dlm_register(struct qstr *name)\n{\n\tint rc;\n\tstruct ocfs2_cluster_connection *conn;\n\n\trc = ocfs2_cluster_connect_agnostic(name->name, name->len,\n\t\t\t\t\t    &user_dlm_lproto,\n\t\t\t\t\t    user_dlm_recovery_handler_noop,\n\t\t\t\t\t    NULL, &conn);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\treturn rc ? ERR_PTR(rc) : conn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DLMFS_I",
          "args": [
            "inode"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "DLMFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.h",
          "lines": "99-105",
          "snippet": "static inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlmfs_get_inode",
          "args": [
            "dir",
            "dentry",
            "mode | S_IFDIR"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "dlmfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
          "lines": "411-460",
          "snippet": "static struct inode *dlmfs_get_inode(struct inode *parent,\n\t\t\t\t     struct dentry *dentry,\n\t\t\t\t     umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode * inode = new_inode(sb);\n\tstruct dlmfs_inode_private *ip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = get_next_ino();\n\tinode_init_owner(inode, parent, mode);\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\tip = DLMFS_I(inode);\n\tip->ip_conn = DLMFS_I(parent)->ip_conn;\n\n\tswitch (mode & S_IFMT) {\n\tdefault:\n\t\t/* for now we don't support anything other than\n\t\t * directories and regular files. */\n\t\tBUG();\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &dlmfs_file_inode_operations;\n\t\tinode->i_fop = &dlmfs_file_operations;\n\n\t\ti_size_write(inode,  DLM_LVB_LEN);\n\n\t\tuser_dlm_lock_res_init(&ip->ip_lockres, dentry);\n\n\t\t/* released at clear_inode time, this insures that we\n\t\t * get to drop the dlm reference on each lock *before*\n\t\t * we call the unregister code for releasing parent\n\t\t * directories. */\n\t\tip->ip_parent = igrab(parent);\n\t\tBUG_ON(!ip->ip_parent);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &dlmfs_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t/* directory inodes start off with i_nlink ==\n\t\t * 2 (for \".\" entry) */\n\t\tinc_nlink(inode);\n\t\tbreak;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/poll.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations dlmfs_file_operations;",
            "static const struct inode_operations dlmfs_dir_inode_operations;",
            "static const struct inode_operations dlmfs_file_inode_operations;",
            "static const struct file_operations dlmfs_file_operations = {\n\t.open\t\t= dlmfs_file_open,\n\t.release\t= dlmfs_file_release,\n\t.poll\t\t= dlmfs_file_poll,\n\t.read\t\t= dlmfs_file_read,\n\t.write\t\t= dlmfs_file_write,\n\t.llseek\t\t= default_llseek,\n};",
            "static const struct inode_operations dlmfs_dir_inode_operations = {\n\t.create\t\t= dlmfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.unlink\t\t= dlmfs_unlink,\n};",
            "static const struct inode_operations dlmfs_file_inode_operations = {\n\t.getattr\t= simple_getattr,\n\t.setattr\t= dlmfs_file_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct file_operations dlmfs_file_operations;\nstatic const struct inode_operations dlmfs_dir_inode_operations;\nstatic const struct inode_operations dlmfs_file_inode_operations;\nstatic const struct file_operations dlmfs_file_operations = {\n\t.open\t\t= dlmfs_file_open,\n\t.release\t= dlmfs_file_release,\n\t.poll\t\t= dlmfs_file_poll,\n\t.read\t\t= dlmfs_file_read,\n\t.write\t\t= dlmfs_file_write,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct inode_operations dlmfs_dir_inode_operations = {\n\t.create\t\t= dlmfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.unlink\t\t= dlmfs_unlink,\n};\nstatic const struct inode_operations dlmfs_file_inode_operations = {\n\t.getattr\t= simple_getattr,\n\t.setattr\t= dlmfs_file_setattr,\n};\n\nstatic struct inode *dlmfs_get_inode(struct inode *parent,\n\t\t\t\t     struct dentry *dentry,\n\t\t\t\t     umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode * inode = new_inode(sb);\n\tstruct dlmfs_inode_private *ip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = get_next_ino();\n\tinode_init_owner(inode, parent, mode);\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\tip = DLMFS_I(inode);\n\tip->ip_conn = DLMFS_I(parent)->ip_conn;\n\n\tswitch (mode & S_IFMT) {\n\tdefault:\n\t\t/* for now we don't support anything other than\n\t\t * directories and regular files. */\n\t\tBUG();\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &dlmfs_file_inode_operations;\n\t\tinode->i_fop = &dlmfs_file_operations;\n\n\t\ti_size_write(inode,  DLM_LVB_LEN);\n\n\t\tuser_dlm_lock_res_init(&ip->ip_lockres, dentry);\n\n\t\t/* released at clear_inode time, this insures that we\n\t\t * get to drop the dlm reference on each lock *before*\n\t\t * we call the unregister code for releasing parent\n\t\t * directories. */\n\t\tip->ip_parent = igrab(parent);\n\t\tBUG_ON(!ip->ip_parent);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &dlmfs_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t/* directory inodes start off with i_nlink ==\n\t\t * 2 (for \".\" entry) */\n\t\tinc_nlink(inode);\n\t\tbreak;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"invalid domain name for directory.\\n\""
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"mkdir %.*s\\n\"",
            "domain->len",
            "domain->name"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlmfs_mkdir(struct inode * dir,\n\t\t       struct dentry * dentry,\n\t\t       umode_t mode)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct qstr *domain = &dentry->d_name;\n\tstruct dlmfs_inode_private *ip;\n\tstruct ocfs2_cluster_connection *conn;\n\n\tmlog(0, \"mkdir %.*s\\n\", domain->len, domain->name);\n\n\t/* verify that we have a proper domain */\n\tif (domain->len >= GROUP_NAME_MAX) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"invalid domain name for directory.\\n\");\n\t\tgoto bail;\n\t}\n\n\tinode = dlmfs_get_inode(dir, dentry, mode | S_IFDIR);\n\tif (!inode) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tip = DLMFS_I(inode);\n\n\tconn = user_dlm_register(domain);\n\tif (IS_ERR(conn)) {\n\t\tstatus = PTR_ERR(conn);\n\t\tmlog(ML_ERROR, \"Error %d could not register domain \\\"%.*s\\\"\\n\",\n\t\t     status, domain->len, domain->name);\n\t\tgoto bail;\n\t}\n\tip->ip_conn = conn;\n\n\tinc_nlink(dir);\n\td_instantiate(dentry, inode);\n\tdget(dentry);\t/* Extra count - pin the dentry in core */\n\n\tstatus = 0;\nbail:\n\tif (status < 0)\n\t\tiput(inode);\n\treturn status;\n}"
  },
  {
    "function_name": "dlmfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "411-460",
    "snippet": "static struct inode *dlmfs_get_inode(struct inode *parent,\n\t\t\t\t     struct dentry *dentry,\n\t\t\t\t     umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode * inode = new_inode(sb);\n\tstruct dlmfs_inode_private *ip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = get_next_ino();\n\tinode_init_owner(inode, parent, mode);\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\tip = DLMFS_I(inode);\n\tip->ip_conn = DLMFS_I(parent)->ip_conn;\n\n\tswitch (mode & S_IFMT) {\n\tdefault:\n\t\t/* for now we don't support anything other than\n\t\t * directories and regular files. */\n\t\tBUG();\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &dlmfs_file_inode_operations;\n\t\tinode->i_fop = &dlmfs_file_operations;\n\n\t\ti_size_write(inode,  DLM_LVB_LEN);\n\n\t\tuser_dlm_lock_res_init(&ip->ip_lockres, dentry);\n\n\t\t/* released at clear_inode time, this insures that we\n\t\t * get to drop the dlm reference on each lock *before*\n\t\t * we call the unregister code for releasing parent\n\t\t * directories. */\n\t\tip->ip_parent = igrab(parent);\n\t\tBUG_ON(!ip->ip_parent);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &dlmfs_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t/* directory inodes start off with i_nlink ==\n\t\t * 2 (for \".\" entry) */\n\t\tinc_nlink(inode);\n\t\tbreak;\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations dlmfs_file_operations;",
      "static const struct inode_operations dlmfs_dir_inode_operations;",
      "static const struct inode_operations dlmfs_file_inode_operations;",
      "static const struct file_operations dlmfs_file_operations = {\n\t.open\t\t= dlmfs_file_open,\n\t.release\t= dlmfs_file_release,\n\t.poll\t\t= dlmfs_file_poll,\n\t.read\t\t= dlmfs_file_read,\n\t.write\t\t= dlmfs_file_write,\n\t.llseek\t\t= default_llseek,\n};",
      "static const struct inode_operations dlmfs_dir_inode_operations = {\n\t.create\t\t= dlmfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.unlink\t\t= dlmfs_unlink,\n};",
      "static const struct inode_operations dlmfs_file_inode_operations = {\n\t.getattr\t= simple_getattr,\n\t.setattr\t= dlmfs_file_setattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ip->ip_parent"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "parent"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_dlm_lock_res_init",
          "args": [
            "&ip->ip_lockres",
            "dentry"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "user_dlm_lock_res_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "586-604",
          "snippet": "void user_dlm_lock_res_init(struct user_lock_res *lockres,\n\t\t\t    struct dentry *dentry)\n{\n\tmemset(lockres, 0, sizeof(*lockres));\n\n\tspin_lock_init(&lockres->l_lock);\n\tinit_waitqueue_head(&lockres->l_event);\n\tlockres->l_level = DLM_LOCK_IV;\n\tlockres->l_requested = DLM_LOCK_IV;\n\tlockres->l_blocking = DLM_LOCK_IV;\n\n\t/* should have been checked before getting here. */\n\tBUG_ON(dentry->d_name.len >= USER_DLM_LOCK_ID_MAX_LEN);\n\n\tmemcpy(lockres->l_name,\n\t       dentry->d_name.name,\n\t       dentry->d_name.len);\n\tlockres->l_namelen = dentry->d_name.len;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nvoid user_dlm_lock_res_init(struct user_lock_res *lockres,\n\t\t\t    struct dentry *dentry)\n{\n\tmemset(lockres, 0, sizeof(*lockres));\n\n\tspin_lock_init(&lockres->l_lock);\n\tinit_waitqueue_head(&lockres->l_event);\n\tlockres->l_level = DLM_LOCK_IV;\n\tlockres->l_requested = DLM_LOCK_IV;\n\tlockres->l_blocking = DLM_LOCK_IV;\n\n\t/* should have been checked before getting here. */\n\tBUG_ON(dentry->d_name.len >= USER_DLM_LOCK_ID_MAX_LEN);\n\n\tmemcpy(lockres->l_name,\n\t       dentry->d_name.name,\n\t       dentry->d_name.len);\n\tlockres->l_namelen = dentry->d_name.len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "DLM_LVB_LEN"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DLMFS_I",
          "args": [
            "parent"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "DLMFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.h",
          "lines": "99-105",
          "snippet": "static inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_init_owner",
          "args": [
            "inode",
            "parent",
            "mode"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1880-1891",
          "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "828-845",
          "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define LAST_INO_BATCH 1024"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, last_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct file_operations dlmfs_file_operations;\nstatic const struct inode_operations dlmfs_dir_inode_operations;\nstatic const struct inode_operations dlmfs_file_inode_operations;\nstatic const struct file_operations dlmfs_file_operations = {\n\t.open\t\t= dlmfs_file_open,\n\t.release\t= dlmfs_file_release,\n\t.poll\t\t= dlmfs_file_poll,\n\t.read\t\t= dlmfs_file_read,\n\t.write\t\t= dlmfs_file_write,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct inode_operations dlmfs_dir_inode_operations = {\n\t.create\t\t= dlmfs_create,\n\t.lookup\t\t= simple_lookup,\n\t.unlink\t\t= dlmfs_unlink,\n};\nstatic const struct inode_operations dlmfs_file_inode_operations = {\n\t.getattr\t= simple_getattr,\n\t.setattr\t= dlmfs_file_setattr,\n};\n\nstatic struct inode *dlmfs_get_inode(struct inode *parent,\n\t\t\t\t     struct dentry *dentry,\n\t\t\t\t     umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode * inode = new_inode(sb);\n\tstruct dlmfs_inode_private *ip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = get_next_ino();\n\tinode_init_owner(inode, parent, mode);\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\tip = DLMFS_I(inode);\n\tip->ip_conn = DLMFS_I(parent)->ip_conn;\n\n\tswitch (mode & S_IFMT) {\n\tdefault:\n\t\t/* for now we don't support anything other than\n\t\t * directories and regular files. */\n\t\tBUG();\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &dlmfs_file_inode_operations;\n\t\tinode->i_fop = &dlmfs_file_operations;\n\n\t\ti_size_write(inode,  DLM_LVB_LEN);\n\n\t\tuser_dlm_lock_res_init(&ip->ip_lockres, dentry);\n\n\t\t/* released at clear_inode time, this insures that we\n\t\t * get to drop the dlm reference on each lock *before*\n\t\t * we call the unregister code for releasing parent\n\t\t * directories. */\n\t\tip->ip_parent = igrab(parent);\n\t\tBUG_ON(!ip->ip_parent);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &dlmfs_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\n\t\t/* directory inodes start off with i_nlink ==\n\t\t * 2 (for \".\" entry) */\n\t\tinc_nlink(inode);\n\t\tbreak;\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "dlmfs_get_root_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "393-409",
    "snippet": "static struct inode *dlmfs_get_root_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tumode_t mode = S_IFDIR | 0755;\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, NULL, mode);\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinc_nlink(inode);\n\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinode->i_op = &dlmfs_root_inode_operations;\n\t}\n\n\treturn inode;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations dlmfs_root_inode_operations;",
      "static const struct inode_operations dlmfs_root_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n\t.mkdir\t\t= dlmfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_init_owner",
          "args": [
            "inode",
            "NULL",
            "mode"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1880-1891",
          "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "828-845",
          "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define LAST_INO_BATCH 1024"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, last_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct inode_operations dlmfs_root_inode_operations;\nstatic const struct inode_operations dlmfs_root_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n\t.mkdir\t\t= dlmfs_mkdir,\n\t.rmdir\t\t= simple_rmdir,\n};\n\nstatic struct inode *dlmfs_get_root_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tumode_t mode = S_IFDIR | 0755;\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode_init_owner(inode, NULL, mode);\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinc_nlink(inode);\n\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinode->i_op = &dlmfs_root_inode_operations;\n\t}\n\n\treturn inode;\n}"
  },
  {
    "function_name": "dlmfs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "364-391",
    "snippet": "static void dlmfs_evict_inode(struct inode *inode)\n{\n\tint status;\n\tstruct dlmfs_inode_private *ip;\n\n\tclear_inode(inode);\n\n\tmlog(0, \"inode %lu\\n\", inode->i_ino);\n\n\tip = DLMFS_I(inode);\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tstatus = user_dlm_destroy_lock(&ip->ip_lockres);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t\tiput(ip->ip_parent);\n\t\tgoto clear_fields;\n\t}\n\n\tmlog(0, \"we're a directory, ip->ip_conn = 0x%p\\n\", ip->ip_conn);\n\t/* we must be a directory. If required, lets unregister the\n\t * dlm context now. */\n\tif (ip->ip_conn)\n\t\tuser_dlm_unregister(ip->ip_conn);\nclear_fields:\n\tip->ip_parent = NULL;\n\tip->ip_conn = NULL;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_dlm_unregister",
          "args": [
            "ip->ip_conn"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "user_dlm_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "685-688",
          "snippet": "void user_dlm_unregister(struct ocfs2_cluster_connection *conn)\n{\n\tocfs2_cluster_disconnect(conn, 0);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nvoid user_dlm_unregister(struct ocfs2_cluster_connection *conn)\n{\n\tocfs2_cluster_disconnect(conn, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"we're a directory, ip->ip_conn = 0x%p\\n\"",
            "ip->ip_conn"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "ip->ip_parent"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_dlm_destroy_lock",
          "args": [
            "&ip->ip_lockres"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "user_dlm_destroy_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "606-656",
          "snippet": "int user_dlm_destroy_lock(struct user_lock_res *lockres)\n{\n\tint status = -EBUSY;\n\tstruct ocfs2_cluster_connection *conn =\n\t\tcluster_connection_from_user_lockres(lockres);\n\n\tmlog(ML_BASTS, \"lockres %.*s\\n\", lockres->l_namelen, lockres->l_name);\n\n\tspin_lock(&lockres->l_lock);\n\tif (lockres->l_flags & USER_LOCK_IN_TEARDOWN) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\treturn 0;\n\t}\n\n\tlockres->l_flags |= USER_LOCK_IN_TEARDOWN;\n\n\twhile (lockres->l_flags & USER_LOCK_BUSY) {\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tuser_wait_on_busy_lock(lockres);\n\n\t\tspin_lock(&lockres->l_lock);\n\t}\n\n\tif (lockres->l_ro_holders || lockres->l_ex_holders) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\tif (!(lockres->l_flags & USER_LOCK_ATTACHED)) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto bail;\n\t}\n\n\tlockres->l_flags &= ~USER_LOCK_ATTACHED;\n\tlockres->l_flags |= USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n\n\tstatus = ocfs2_dlm_unlock(conn, &lockres->l_lksb, DLM_LKF_VALBLK);\n\tif (status) {\n\t\tuser_log_dlm_error(\"ocfs2_dlm_unlock\", status, lockres);\n\t\tgoto bail;\n\t}\n\n\tuser_wait_on_busy_lock(lockres);\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nint user_dlm_destroy_lock(struct user_lock_res *lockres)\n{\n\tint status = -EBUSY;\n\tstruct ocfs2_cluster_connection *conn =\n\t\tcluster_connection_from_user_lockres(lockres);\n\n\tmlog(ML_BASTS, \"lockres %.*s\\n\", lockres->l_namelen, lockres->l_name);\n\n\tspin_lock(&lockres->l_lock);\n\tif (lockres->l_flags & USER_LOCK_IN_TEARDOWN) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\treturn 0;\n\t}\n\n\tlockres->l_flags |= USER_LOCK_IN_TEARDOWN;\n\n\twhile (lockres->l_flags & USER_LOCK_BUSY) {\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tuser_wait_on_busy_lock(lockres);\n\n\t\tspin_lock(&lockres->l_lock);\n\t}\n\n\tif (lockres->l_ro_holders || lockres->l_ex_holders) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\tif (!(lockres->l_flags & USER_LOCK_ATTACHED)) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto bail;\n\t}\n\n\tlockres->l_flags &= ~USER_LOCK_ATTACHED;\n\tlockres->l_flags |= USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n\n\tstatus = ocfs2_dlm_unlock(conn, &lockres->l_lksb, DLM_LKF_VALBLK);\n\tif (status) {\n\t\tuser_log_dlm_error(\"ocfs2_dlm_unlock\", status, lockres);\n\t\tgoto bail;\n\t}\n\n\tuser_wait_on_busy_lock(lockres);\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DLMFS_I",
          "args": [
            "inode"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "DLMFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.h",
          "lines": "99-105",
          "snippet": "static inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlmfs_evict_inode(struct inode *inode)\n{\n\tint status;\n\tstruct dlmfs_inode_private *ip;\n\n\tclear_inode(inode);\n\n\tmlog(0, \"inode %lu\\n\", inode->i_ino);\n\n\tip = DLMFS_I(inode);\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tstatus = user_dlm_destroy_lock(&ip->ip_lockres);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t\tiput(ip->ip_parent);\n\t\tgoto clear_fields;\n\t}\n\n\tmlog(0, \"we're a directory, ip->ip_conn = 0x%p\\n\", ip->ip_conn);\n\t/* we must be a directory. If required, lets unregister the\n\t * dlm context now. */\n\tif (ip->ip_conn)\n\t\tuser_dlm_unregister(ip->ip_conn);\nclear_fields:\n\tip->ip_parent = NULL;\n\tip->ip_conn = NULL;\n}"
  },
  {
    "function_name": "dlmfs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "359-362",
    "snippet": "static void dlmfs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, dlmfs_i_callback);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "dlmfs_i_callback"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlmfs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, dlmfs_i_callback);\n}"
  },
  {
    "function_name": "dlmfs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "353-357",
    "snippet": "static void dlmfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(dlmfs_inode_cache, DLMFS_I(inode));\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dlmfs_inode_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "dlmfs_inode_cache",
            "DLMFS_I(inode)"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DLMFS_I",
          "args": [
            "inode"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "DLMFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.h",
          "lines": "99-105",
          "snippet": "static inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlmfs_inode_cache;\n\nstatic void dlmfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(dlmfs_inode_cache, DLMFS_I(inode));\n}"
  },
  {
    "function_name": "dlmfs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "342-351",
    "snippet": "static struct inode *dlmfs_alloc_inode(struct super_block *sb)\n{\n\tstruct dlmfs_inode_private *ip;\n\n\tip = kmem_cache_alloc(dlmfs_inode_cache, GFP_NOFS);\n\tif (!ip)\n\t\treturn NULL;\n\n\treturn &ip->ip_vfs_inode;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dlmfs_inode_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "dlmfs_inode_cache",
            "GFP_NOFS"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlmfs_inode_cache;\n\nstatic struct inode *dlmfs_alloc_inode(struct super_block *sb)\n{\n\tstruct dlmfs_inode_private *ip;\n\n\tip = kmem_cache_alloc(dlmfs_inode_cache, GFP_NOFS);\n\tif (!ip)\n\t\treturn NULL;\n\n\treturn &ip->ip_vfs_inode;\n}"
  },
  {
    "function_name": "dlmfs_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "331-340",
    "snippet": "static void dlmfs_init_once(void *foo)\n{\n\tstruct dlmfs_inode_private *ip =\n\t\t(struct dlmfs_inode_private *) foo;\n\n\tip->ip_conn = NULL;\n\tip->ip_parent = NULL;\n\n\tinode_init_once(&ip->ip_vfs_inode);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ip->ip_vfs_inode"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "355-367",
          "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlmfs_init_once(void *foo)\n{\n\tstruct dlmfs_inode_private *ip =\n\t\t(struct dlmfs_inode_private *) foo;\n\n\tip->ip_conn = NULL;\n\tip->ip_parent = NULL;\n\n\tinode_init_once(&ip->ip_vfs_inode);\n}"
  },
  {
    "function_name": "dlmfs_file_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "287-329",
    "snippet": "static ssize_t dlmfs_file_write(struct file *filp,\n\t\t\t\tconst char __user *buf,\n\t\t\t\tsize_t count,\n\t\t\t\tloff_t *ppos)\n{\n\tint bytes_left;\n\tssize_t writelen;\n\tchar *lvb_buf;\n\tstruct inode *inode = file_inode(filp);\n\n\tmlog(0, \"inode %lu, count = %zu, *ppos = %llu\\n\",\n\t\tinode->i_ino, count, *ppos);\n\n\tif (*ppos >= i_size_read(inode))\n\t\treturn -ENOSPC;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (!access_ok(VERIFY_READ, buf, count))\n\t\treturn -EFAULT;\n\n\t/* don't write past the lvb */\n\tif ((count + *ppos) > i_size_read(inode))\n\t\twritelen = i_size_read(inode) - *ppos;\n\telse\n\t\twritelen = count - *ppos;\n\n\tlvb_buf = kmalloc(writelen, GFP_NOFS);\n\tif (!lvb_buf)\n\t\treturn -ENOMEM;\n\n\tbytes_left = copy_from_user(lvb_buf, buf, writelen);\n\twritelen -= bytes_left;\n\tif (writelen)\n\t\tuser_dlm_write_lvb(inode, lvb_buf, writelen);\n\n\tkfree(lvb_buf);\n\n\t*ppos = *ppos + writelen;\n\tmlog(0, \"wrote %zd bytes\\n\", writelen);\n\treturn writelen;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"wrote %zd bytes\\n\"",
            "writelen"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lvb_buf"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_dlm_write_lvb",
          "args": [
            "inode",
            "lvb_buf",
            "writelen"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "user_dlm_write_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "545-561",
          "snippet": "void user_dlm_write_lvb(struct inode *inode,\n\t\t\tconst char *val,\n\t\t\tunsigned int len)\n{\n\tstruct user_lock_res *lockres = &DLMFS_I(inode)->ip_lockres;\n\tchar *lvb;\n\n\tBUG_ON(len > DLM_LVB_LEN);\n\n\tspin_lock(&lockres->l_lock);\n\n\tBUG_ON(lockres->l_level < DLM_LOCK_EX);\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tmemcpy(lvb, val, len);\n\n\tspin_unlock(&lockres->l_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nvoid user_dlm_write_lvb(struct inode *inode,\n\t\t\tconst char *val,\n\t\t\tunsigned int len)\n{\n\tstruct user_lock_res *lockres = &DLMFS_I(inode)->ip_lockres;\n\tchar *lvb;\n\n\tBUG_ON(len > DLM_LVB_LEN);\n\n\tspin_lock(&lockres->l_lock);\n\n\tBUG_ON(lockres->l_level < DLM_LOCK_EX);\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tmemcpy(lvb, val, len);\n\n\tspin_unlock(&lockres->l_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "lvb_buf",
            "buf",
            "writelen"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "writelen",
            "GFP_NOFS"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "buf",
            "count"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"inode %lu, count = %zu, *ppos = %llu\\n\"",
            "inode->i_ino",
            "count",
            "*ppos"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic ssize_t dlmfs_file_write(struct file *filp,\n\t\t\t\tconst char __user *buf,\n\t\t\t\tsize_t count,\n\t\t\t\tloff_t *ppos)\n{\n\tint bytes_left;\n\tssize_t writelen;\n\tchar *lvb_buf;\n\tstruct inode *inode = file_inode(filp);\n\n\tmlog(0, \"inode %lu, count = %zu, *ppos = %llu\\n\",\n\t\tinode->i_ino, count, *ppos);\n\n\tif (*ppos >= i_size_read(inode))\n\t\treturn -ENOSPC;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (!access_ok(VERIFY_READ, buf, count))\n\t\treturn -EFAULT;\n\n\t/* don't write past the lvb */\n\tif ((count + *ppos) > i_size_read(inode))\n\t\twritelen = i_size_read(inode) - *ppos;\n\telse\n\t\twritelen = count - *ppos;\n\n\tlvb_buf = kmalloc(writelen, GFP_NOFS);\n\tif (!lvb_buf)\n\t\treturn -ENOMEM;\n\n\tbytes_left = copy_from_user(lvb_buf, buf, writelen);\n\twritelen -= bytes_left;\n\tif (writelen)\n\t\tuser_dlm_write_lvb(inode, lvb_buf, writelen);\n\n\tkfree(lvb_buf);\n\n\t*ppos = *ppos + writelen;\n\tmlog(0, \"wrote %zd bytes\\n\", writelen);\n\treturn writelen;\n}"
  },
  {
    "function_name": "dlmfs_file_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "239-285",
    "snippet": "static ssize_t dlmfs_file_read(struct file *filp,\n\t\t\t       char __user *buf,\n\t\t\t       size_t count,\n\t\t\t       loff_t *ppos)\n{\n\tint bytes_left;\n\tssize_t readlen, got;\n\tchar *lvb_buf;\n\tstruct inode *inode = file_inode(filp);\n\n\tmlog(0, \"inode %lu, count = %zu, *ppos = %llu\\n\",\n\t\tinode->i_ino, count, *ppos);\n\n\tif (*ppos >= i_size_read(inode))\n\t\treturn 0;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\t/* don't read past the lvb */\n\tif ((count + *ppos) > i_size_read(inode))\n\t\treadlen = i_size_read(inode) - *ppos;\n\telse\n\t\treadlen = count;\n\n\tlvb_buf = kmalloc(readlen, GFP_NOFS);\n\tif (!lvb_buf)\n\t\treturn -ENOMEM;\n\n\tgot = user_dlm_read_lvb(inode, lvb_buf, readlen);\n\tif (got) {\n\t\tBUG_ON(got != readlen);\n\t\tbytes_left = __copy_to_user(buf, lvb_buf, readlen);\n\t\treadlen -= bytes_left;\n\t} else\n\t\treadlen = 0;\n\n\tkfree(lvb_buf);\n\n\t*ppos = *ppos + readlen;\n\n\tmlog(0, \"read %zd bytes\\n\", readlen);\n\treturn readlen;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"read %zd bytes\\n\"",
            "readlen"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lvb_buf"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "buf",
            "lvb_buf",
            "readlen"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "got != readlen"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_dlm_read_lvb",
          "args": [
            "inode",
            "lvb_buf",
            "readlen"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "user_dlm_read_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "563-584",
          "snippet": "ssize_t user_dlm_read_lvb(struct inode *inode,\n\t\t\t  char *val,\n\t\t\t  unsigned int len)\n{\n\tstruct user_lock_res *lockres = &DLMFS_I(inode)->ip_lockres;\n\tchar *lvb;\n\tssize_t ret = len;\n\n\tBUG_ON(len > DLM_LVB_LEN);\n\n\tspin_lock(&lockres->l_lock);\n\n\tBUG_ON(lockres->l_level < DLM_LOCK_PR);\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb)) {\n\t\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\t\tmemcpy(val, lvb, len);\n\t} else\n\t\tret = 0;\n\n\tspin_unlock(&lockres->l_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nssize_t user_dlm_read_lvb(struct inode *inode,\n\t\t\t  char *val,\n\t\t\t  unsigned int len)\n{\n\tstruct user_lock_res *lockres = &DLMFS_I(inode)->ip_lockres;\n\tchar *lvb;\n\tssize_t ret = len;\n\n\tBUG_ON(len > DLM_LVB_LEN);\n\n\tspin_lock(&lockres->l_lock);\n\n\tBUG_ON(lockres->l_level < DLM_LOCK_PR);\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb)) {\n\t\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\t\tmemcpy(val, lvb, len);\n\t} else\n\t\tret = 0;\n\n\tspin_unlock(&lockres->l_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "readlen",
            "GFP_NOFS"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "buf",
            "count"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"inode %lu, count = %zu, *ppos = %llu\\n\"",
            "inode->i_ino",
            "count",
            "*ppos"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic ssize_t dlmfs_file_read(struct file *filp,\n\t\t\t       char __user *buf,\n\t\t\t       size_t count,\n\t\t\t       loff_t *ppos)\n{\n\tint bytes_left;\n\tssize_t readlen, got;\n\tchar *lvb_buf;\n\tstruct inode *inode = file_inode(filp);\n\n\tmlog(0, \"inode %lu, count = %zu, *ppos = %llu\\n\",\n\t\tinode->i_ino, count, *ppos);\n\n\tif (*ppos >= i_size_read(inode))\n\t\treturn 0;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\t/* don't read past the lvb */\n\tif ((count + *ppos) > i_size_read(inode))\n\t\treadlen = i_size_read(inode) - *ppos;\n\telse\n\t\treadlen = count;\n\n\tlvb_buf = kmalloc(readlen, GFP_NOFS);\n\tif (!lvb_buf)\n\t\treturn -ENOMEM;\n\n\tgot = user_dlm_read_lvb(inode, lvb_buf, readlen);\n\tif (got) {\n\t\tBUG_ON(got != readlen);\n\t\tbytes_left = __copy_to_user(buf, lvb_buf, readlen);\n\t\treadlen -= bytes_left;\n\t} else\n\t\treadlen = 0;\n\n\tkfree(lvb_buf);\n\n\t*ppos = *ppos + readlen;\n\n\tmlog(0, \"read %zd bytes\\n\", readlen);\n\treturn readlen;\n}"
  },
  {
    "function_name": "dlmfs_file_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "223-237",
    "snippet": "static unsigned int dlmfs_file_poll(struct file *file, poll_table *wait)\n{\n\tint event = 0;\n\tstruct inode *inode = file_inode(file);\n\tstruct dlmfs_inode_private *ip = DLMFS_I(inode);\n\n\tpoll_wait(file, &ip->ip_lockres.l_event, wait);\n\n\tspin_lock(&ip->ip_lockres.l_lock);\n\tif (ip->ip_lockres.l_flags & USER_LOCK_BLOCKED)\n\t\tevent = POLLIN | POLLRDNORM;\n\tspin_unlock(&ip->ip_lockres.l_lock);\n\n\treturn event;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ip->ip_lockres.l_lock"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ip->ip_lockres.l_lock"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&ip->ip_lockres.l_event",
            "wait"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DLMFS_I",
          "args": [
            "inode"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "DLMFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.h",
          "lines": "99-105",
          "snippet": "static inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic unsigned int dlmfs_file_poll(struct file *file, poll_table *wait)\n{\n\tint event = 0;\n\tstruct inode *inode = file_inode(file);\n\tstruct dlmfs_inode_private *ip = DLMFS_I(inode);\n\n\tpoll_wait(file, &ip->ip_lockres.l_event, wait);\n\n\tspin_lock(&ip->ip_lockres.l_lock);\n\tif (ip->ip_lockres.l_flags & USER_LOCK_BLOCKED)\n\t\tevent = POLLIN | POLLRDNORM;\n\tspin_unlock(&ip->ip_lockres.l_lock);\n\n\treturn event;\n}"
  },
  {
    "function_name": "dlmfs_file_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "208-221",
    "snippet": "static int dlmfs_file_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint error;\n\tstruct inode *inode = dentry->d_inode;\n\n\tattr->ia_valid &= ~ATTR_SIZE;\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlmfs_file_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint error;\n\tstruct inode *inode = dentry->d_inode;\n\n\tattr->ia_valid &= ~ATTR_SIZE;\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "dlmfs_file_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "179-202",
    "snippet": "static int dlmfs_file_release(struct inode *inode,\n\t\t\t      struct file *file)\n{\n\tint level, status;\n\tstruct dlmfs_inode_private *ip = DLMFS_I(inode);\n\tstruct dlmfs_filp_private *fp = file->private_data;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tBUG();\n\n\tmlog(0, \"close called on inode %lu\\n\", inode->i_ino);\n\n\tstatus = 0;\n\tif (fp) {\n\t\tlevel = fp->fp_lock_level;\n\t\tif (level != DLM_LOCK_IV)\n\t\t\tuser_dlm_cluster_unlock(&ip->ip_lockres, level);\n\n\t\tkfree(fp);\n\t\tfile->private_data = NULL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fp"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_dlm_cluster_unlock",
          "args": [
            "&ip->ip_lockres",
            "level"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "user_dlm_cluster_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "529-543",
          "snippet": "void user_dlm_cluster_unlock(struct user_lock_res *lockres,\n\t\t\t     int level)\n{\n\tif (level != DLM_LOCK_EX &&\n\t    level != DLM_LOCK_PR) {\n\t\tmlog(ML_ERROR, \"lockres %.*s: invalid request!\\n\",\n\t\t     lockres->l_namelen, lockres->l_name);\n\t\treturn;\n\t}\n\n\tspin_lock(&lockres->l_lock);\n\tuser_dlm_dec_holders(lockres, level);\n\t__user_dlm_cond_queue_lockres(lockres);\n\tspin_unlock(&lockres->l_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nvoid user_dlm_cluster_unlock(struct user_lock_res *lockres,\n\t\t\t     int level)\n{\n\tif (level != DLM_LOCK_EX &&\n\t    level != DLM_LOCK_PR) {\n\t\tmlog(ML_ERROR, \"lockres %.*s: invalid request!\\n\",\n\t\t     lockres->l_namelen, lockres->l_name);\n\t\treturn;\n\t}\n\n\tspin_lock(&lockres->l_lock);\n\tuser_dlm_dec_holders(lockres, level);\n\t__user_dlm_cond_queue_lockres(lockres);\n\tspin_unlock(&lockres->l_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"close called on inode %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DLMFS_I",
          "args": [
            "inode"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "DLMFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.h",
          "lines": "99-105",
          "snippet": "static inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlmfs_file_release(struct inode *inode,\n\t\t\t      struct file *file)\n{\n\tint level, status;\n\tstruct dlmfs_inode_private *ip = DLMFS_I(inode);\n\tstruct dlmfs_filp_private *fp = file->private_data;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tBUG();\n\n\tmlog(0, \"close called on inode %lu\\n\", inode->i_ino);\n\n\tstatus = 0;\n\tif (fp) {\n\t\tlevel = fp->fp_lock_level;\n\t\tif (level != DLM_LOCK_IV)\n\t\t\tuser_dlm_cluster_unlock(&ip->ip_lockres, level);\n\n\t\tkfree(fp);\n\t\tfile->private_data = NULL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dlmfs_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "132-177",
    "snippet": "static int dlmfs_file_open(struct inode *inode,\n\t\t\t   struct file *file)\n{\n\tint status, level, flags;\n\tstruct dlmfs_filp_private *fp = NULL;\n\tstruct dlmfs_inode_private *ip;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tBUG();\n\n\tmlog(0, \"open called on inode %lu, flags 0x%x\\n\", inode->i_ino,\n\t\tfile->f_flags);\n\n\tstatus = dlmfs_decode_open_flags(file->f_flags, &level, &flags);\n\tif (status < 0)\n\t\tgoto bail;\n\n\t/* We don't want to honor O_APPEND at read/write time as it\n\t * doesn't make sense for LVB writes. */\n\tfile->f_flags &= ~O_APPEND;\n\n\tfp = kmalloc(sizeof(*fp), GFP_NOFS);\n\tif (!fp) {\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tfp->fp_lock_level = level;\n\n\tip = DLMFS_I(inode);\n\n\tstatus = user_dlm_cluster_lock(&ip->ip_lockres, level, flags);\n\tif (status < 0) {\n\t\t/* this is a strange error to return here but I want\n\t\t * to be able userspace to be able to distinguish a\n\t\t * valid lock request from one that simply couldn't be\n\t\t * granted. */\n\t\tif (flags & DLM_LKF_NOQUEUE && status == -EAGAIN)\n\t\t\tstatus = -ETXTBSY;\n\t\tkfree(fp);\n\t\tgoto bail;\n\t}\n\n\tfile->private_data = fp;\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fp"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_dlm_cluster_lock",
          "args": [
            "&ip->ip_lockres",
            "level",
            "flags"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "user_dlm_cluster_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "425-510",
          "snippet": "int user_dlm_cluster_lock(struct user_lock_res *lockres,\n\t\t\t  int level,\n\t\t\t  int lkm_flags)\n{\n\tint status, local_flags;\n\tstruct ocfs2_cluster_connection *conn =\n\t\tcluster_connection_from_user_lockres(lockres);\n\n\tif (level != DLM_LOCK_EX &&\n\t    level != DLM_LOCK_PR) {\n\t\tmlog(ML_ERROR, \"lockres %.*s: invalid request!\\n\",\n\t\t     lockres->l_namelen, lockres->l_name);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tmlog(ML_BASTS, \"lockres %.*s, level %d, flags = 0x%x\\n\",\n\t     lockres->l_namelen, lockres->l_name, level, lkm_flags);\n\nagain:\n\tif (signal_pending(current)) {\n\t\tstatus = -ERESTARTSYS;\n\t\tgoto bail;\n\t}\n\n\tspin_lock(&lockres->l_lock);\n\n\t/* We only compare against the currently granted level\n\t * here. If the lock is blocked waiting on a downconvert,\n\t * we'll get caught below. */\n\tif ((lockres->l_flags & USER_LOCK_BUSY) &&\n\t    (level > lockres->l_level)) {\n\t\t/* is someone sitting in dlm_lock? If so, wait on\n\t\t * them. */\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tuser_wait_on_busy_lock(lockres);\n\t\tgoto again;\n\t}\n\n\tif ((lockres->l_flags & USER_LOCK_BLOCKED) &&\n\t    (!user_may_continue_on_blocked_lock(lockres, level))) {\n\t\t/* is the lock is currently blocked on behalf of\n\t\t * another node */\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tuser_wait_on_blocked_lock(lockres);\n\t\tgoto again;\n\t}\n\n\tif (level > lockres->l_level) {\n\t\tlocal_flags = lkm_flags | DLM_LKF_VALBLK;\n\t\tif (lockres->l_level != DLM_LOCK_IV)\n\t\t\tlocal_flags |= DLM_LKF_CONVERT;\n\n\t\tlockres->l_requested = level;\n\t\tlockres->l_flags |= USER_LOCK_BUSY;\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tBUG_ON(level == DLM_LOCK_IV);\n\t\tBUG_ON(level == DLM_LOCK_NL);\n\n\t\t/* call dlm_lock to upgrade lock now */\n\t\tstatus = ocfs2_dlm_lock(conn, level, &lockres->l_lksb,\n\t\t\t\t\tlocal_flags, lockres->l_name,\n\t\t\t\t\tlockres->l_namelen);\n\t\tif (status) {\n\t\t\tif ((lkm_flags & DLM_LKF_NOQUEUE) &&\n\t\t\t    (status != -EAGAIN))\n\t\t\t\tuser_log_dlm_error(\"ocfs2_dlm_lock\",\n\t\t\t\t\t\t   status, lockres);\n\t\t\tuser_recover_from_dlm_error(lockres);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tuser_wait_on_busy_lock(lockres);\n\t\tgoto again;\n\t}\n\n\tuser_dlm_inc_holders(lockres, level);\n\tspin_unlock(&lockres->l_lock);\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nint user_dlm_cluster_lock(struct user_lock_res *lockres,\n\t\t\t  int level,\n\t\t\t  int lkm_flags)\n{\n\tint status, local_flags;\n\tstruct ocfs2_cluster_connection *conn =\n\t\tcluster_connection_from_user_lockres(lockres);\n\n\tif (level != DLM_LOCK_EX &&\n\t    level != DLM_LOCK_PR) {\n\t\tmlog(ML_ERROR, \"lockres %.*s: invalid request!\\n\",\n\t\t     lockres->l_namelen, lockres->l_name);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tmlog(ML_BASTS, \"lockres %.*s, level %d, flags = 0x%x\\n\",\n\t     lockres->l_namelen, lockres->l_name, level, lkm_flags);\n\nagain:\n\tif (signal_pending(current)) {\n\t\tstatus = -ERESTARTSYS;\n\t\tgoto bail;\n\t}\n\n\tspin_lock(&lockres->l_lock);\n\n\t/* We only compare against the currently granted level\n\t * here. If the lock is blocked waiting on a downconvert,\n\t * we'll get caught below. */\n\tif ((lockres->l_flags & USER_LOCK_BUSY) &&\n\t    (level > lockres->l_level)) {\n\t\t/* is someone sitting in dlm_lock? If so, wait on\n\t\t * them. */\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tuser_wait_on_busy_lock(lockres);\n\t\tgoto again;\n\t}\n\n\tif ((lockres->l_flags & USER_LOCK_BLOCKED) &&\n\t    (!user_may_continue_on_blocked_lock(lockres, level))) {\n\t\t/* is the lock is currently blocked on behalf of\n\t\t * another node */\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tuser_wait_on_blocked_lock(lockres);\n\t\tgoto again;\n\t}\n\n\tif (level > lockres->l_level) {\n\t\tlocal_flags = lkm_flags | DLM_LKF_VALBLK;\n\t\tif (lockres->l_level != DLM_LOCK_IV)\n\t\t\tlocal_flags |= DLM_LKF_CONVERT;\n\n\t\tlockres->l_requested = level;\n\t\tlockres->l_flags |= USER_LOCK_BUSY;\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tBUG_ON(level == DLM_LOCK_IV);\n\t\tBUG_ON(level == DLM_LOCK_NL);\n\n\t\t/* call dlm_lock to upgrade lock now */\n\t\tstatus = ocfs2_dlm_lock(conn, level, &lockres->l_lksb,\n\t\t\t\t\tlocal_flags, lockres->l_name,\n\t\t\t\t\tlockres->l_namelen);\n\t\tif (status) {\n\t\t\tif ((lkm_flags & DLM_LKF_NOQUEUE) &&\n\t\t\t    (status != -EAGAIN))\n\t\t\t\tuser_log_dlm_error(\"ocfs2_dlm_lock\",\n\t\t\t\t\t\t   status, lockres);\n\t\t\tuser_recover_from_dlm_error(lockres);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tuser_wait_on_busy_lock(lockres);\n\t\tgoto again;\n\t}\n\n\tuser_dlm_inc_holders(lockres, level);\n\tspin_unlock(&lockres->l_lock);\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DLMFS_I",
          "args": [
            "inode"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "DLMFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.h",
          "lines": "99-105",
          "snippet": "static inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*fp)",
            "GFP_NOFS"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlmfs_decode_open_flags",
          "args": [
            "file->f_flags",
            "&level",
            "&flags"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "dlmfs_decode_open_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
          "lines": "116-130",
          "snippet": "static int dlmfs_decode_open_flags(int open_flags,\n\t\t\t\t   int *level,\n\t\t\t\t   int *flags)\n{\n\tif (open_flags & (O_WRONLY|O_RDWR))\n\t\t*level = DLM_LOCK_EX;\n\telse\n\t\t*level = DLM_LOCK_PR;\n\n\t*flags = 0;\n\tif (open_flags & O_NONBLOCK)\n\t\t*flags |= DLM_LKF_NOQUEUE;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/poll.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlmfs_decode_open_flags(int open_flags,\n\t\t\t\t   int *level,\n\t\t\t\t   int *flags)\n{\n\tif (open_flags & (O_WRONLY|O_RDWR))\n\t\t*level = DLM_LOCK_EX;\n\telse\n\t\t*level = DLM_LOCK_PR;\n\n\t*flags = 0;\n\tif (open_flags & O_NONBLOCK)\n\t\t*flags |= DLM_LKF_NOQUEUE;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"open called on inode %lu, flags 0x%x\\n\"",
            "inode->i_ino",
            "file->f_flags"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlmfs_file_open(struct inode *inode,\n\t\t\t   struct file *file)\n{\n\tint status, level, flags;\n\tstruct dlmfs_filp_private *fp = NULL;\n\tstruct dlmfs_inode_private *ip;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tBUG();\n\n\tmlog(0, \"open called on inode %lu, flags 0x%x\\n\", inode->i_ino,\n\t\tfile->f_flags);\n\n\tstatus = dlmfs_decode_open_flags(file->f_flags, &level, &flags);\n\tif (status < 0)\n\t\tgoto bail;\n\n\t/* We don't want to honor O_APPEND at read/write time as it\n\t * doesn't make sense for LVB writes. */\n\tfile->f_flags &= ~O_APPEND;\n\n\tfp = kmalloc(sizeof(*fp), GFP_NOFS);\n\tif (!fp) {\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tfp->fp_lock_level = level;\n\n\tip = DLMFS_I(inode);\n\n\tstatus = user_dlm_cluster_lock(&ip->ip_lockres, level, flags);\n\tif (status < 0) {\n\t\t/* this is a strange error to return here but I want\n\t\t * to be able userspace to be able to distinguish a\n\t\t * valid lock request from one that simply couldn't be\n\t\t * granted. */\n\t\tif (flags & DLM_LKF_NOQUEUE && status == -EAGAIN)\n\t\t\tstatus = -ETXTBSY;\n\t\tkfree(fp);\n\t\tgoto bail;\n\t}\n\n\tfile->private_data = fp;\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "dlmfs_decode_open_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "116-130",
    "snippet": "static int dlmfs_decode_open_flags(int open_flags,\n\t\t\t\t   int *level,\n\t\t\t\t   int *flags)\n{\n\tif (open_flags & (O_WRONLY|O_RDWR))\n\t\t*level = DLM_LOCK_EX;\n\telse\n\t\t*level = DLM_LOCK_PR;\n\n\t*flags = 0;\n\tif (open_flags & O_NONBLOCK)\n\t\t*flags |= DLM_LKF_NOQUEUE;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlmfs_decode_open_flags(int open_flags,\n\t\t\t\t   int *level,\n\t\t\t\t   int *flags)\n{\n\tif (open_flags & (O_WRONLY|O_RDWR))\n\t\t*level = DLM_LOCK_EX;\n\telse\n\t\t*level = DLM_LOCK_PR;\n\n\t*flags = 0;\n\tif (open_flags & O_NONBLOCK)\n\t\t*flags |= DLM_LKF_NOQUEUE;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "param_get_dlmfs_capabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "96-101",
    "snippet": "static int param_get_dlmfs_capabilities(char *buffer,\n\t\t\t\t\tstruct kernel_param *kp)\n{\n\treturn strlcpy(buffer, DLMFS_CAPABILITIES,\n\t\t       strlen(DLMFS_CAPABILITIES) + 1);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DLMFS_CAPABILITIES \"bast stackglue\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "buffer",
            "DLMFS_CAPABILITIES",
            "strlen(DLMFS_CAPABILITIES) + 1"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "DLMFS_CAPABILITIES"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DLMFS_CAPABILITIES \"bast stackglue\"\n\nstatic int param_get_dlmfs_capabilities(char *buffer,\n\t\t\t\t\tstruct kernel_param *kp)\n{\n\treturn strlcpy(buffer, DLMFS_CAPABILITIES,\n\t\t       strlen(DLMFS_CAPABILITIES) + 1);\n}"
  },
  {
    "function_name": "param_set_dlmfs_capabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/dlmfs.c",
    "lines": "90-95",
    "snippet": "static int param_set_dlmfs_capabilities(const char *val,\n\t\t\t\t\tstruct kernel_param *kp)\n{\n\tprintk(KERN_ERR \"%s: readonly parameter\\n\", kp->name);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/poll.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: readonly parameter\\n\"",
            "kp->name"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/poll.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int param_set_dlmfs_capabilities(const char *val,\n\t\t\t\t\tstruct kernel_param *kp)\n{\n\tprintk(KERN_ERR \"%s: readonly parameter\\n\", kp->name);\n\treturn -EINVAL;\n}"
  }
]