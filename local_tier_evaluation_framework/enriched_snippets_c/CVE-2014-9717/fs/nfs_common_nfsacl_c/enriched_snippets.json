[
  {
    "function_name": "nfsacl_decode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/nfsacl.c",
    "lines": "264-295",
    "snippet": "int nfsacl_decode(struct xdr_buf *buf, unsigned int base, unsigned int *aclcnt,\n\t\t  struct posix_acl **pacl)\n{\n\tstruct nfsacl_decode_desc nfsacl_desc = {\n\t\t.desc = {\n\t\t\t.elem_size = 12,\n\t\t\t.xcode = pacl ? xdr_nfsace_decode : NULL,\n\t\t},\n\t};\n\tu32 entries;\n\tint err;\n\n\tif (xdr_decode_word(buf, base, &entries) ||\n\t    entries > NFS_ACL_MAX_ENTRIES)\n\t\treturn -EINVAL;\n\tnfsacl_desc.desc.array_maxlen = entries;\n\terr = xdr_decode_array2(buf, base + 4, &nfsacl_desc.desc);\n\tif (err)\n\t\treturn err;\n\tif (pacl) {\n\t\tif (entries != nfsacl_desc.desc.array_len ||\n\t\t    posix_acl_from_nfsacl(nfsacl_desc.acl) != 0) {\n\t\t\tposix_acl_release(nfsacl_desc.acl);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*pacl = nfsacl_desc.acl;\n\t}\n\tif (aclcnt)\n\t\t*aclcnt = entries;\n\treturn 8 + nfsacl_desc.desc.elem_size *\n\t\t   nfsacl_desc.desc.array_len;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/nfs3.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "nfsacl_desc.acl"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_from_nfsacl",
          "args": [
            "nfsacl_desc.acl"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_from_nfsacl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/nfsacl.c",
          "lines": "217-252",
          "snippet": "static int\nposix_acl_from_nfsacl(struct posix_acl *acl)\n{\n\tstruct posix_acl_entry *pa, *pe,\n\t       *group_obj = NULL, *mask = NULL;\n\n\tif (!acl)\n\t\treturn 0;\n\n\tsort(acl->a_entries, acl->a_count, sizeof(struct posix_acl_entry),\n\t     cmp_acl_entry, NULL);\n\n\t/* Find the ACL_GROUP_OBJ and ACL_MASK entries. */\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmask = pa;\n\t\t\t\t/* fall through */\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (acl->a_count == 4 && group_obj && mask &&\n\t    mask->e_perm == group_obj->e_perm) {\n\t\t/* remove bogus ACL_MASK entry */\n\t\tmemmove(mask, mask+1, (3 - (mask - acl->a_entries)) *\n\t\t\t\t      sizeof(struct posix_acl_entry));\n\t\tacl->a_count = 3;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/nfs3.h>\n#include <linux/nfsacl.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int\nposix_acl_from_nfsacl(struct posix_acl *acl)\n{\n\tstruct posix_acl_entry *pa, *pe,\n\t       *group_obj = NULL, *mask = NULL;\n\n\tif (!acl)\n\t\treturn 0;\n\n\tsort(acl->a_entries, acl->a_count, sizeof(struct posix_acl_entry),\n\t     cmp_acl_entry, NULL);\n\n\t/* Find the ACL_GROUP_OBJ and ACL_MASK entries. */\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmask = pa;\n\t\t\t\t/* fall through */\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (acl->a_count == 4 && group_obj && mask &&\n\t    mask->e_perm == group_obj->e_perm) {\n\t\t/* remove bogus ACL_MASK entry */\n\t\tmemmove(mask, mask+1, (3 - (mask - acl->a_entries)) *\n\t\t\t\t      sizeof(struct posix_acl_entry));\n\t\tacl->a_count = 3;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_array2",
          "args": [
            "buf",
            "base + 4",
            "&nfsacl_desc.desc"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_word",
          "args": [
            "buf",
            "base",
            "&entries"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/nfs3.h>\n#include <linux/nfsacl.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint nfsacl_decode(struct xdr_buf *buf, unsigned int base, unsigned int *aclcnt,\n\t\t  struct posix_acl **pacl)\n{\n\tstruct nfsacl_decode_desc nfsacl_desc = {\n\t\t.desc = {\n\t\t\t.elem_size = 12,\n\t\t\t.xcode = pacl ? xdr_nfsace_decode : NULL,\n\t\t},\n\t};\n\tu32 entries;\n\tint err;\n\n\tif (xdr_decode_word(buf, base, &entries) ||\n\t    entries > NFS_ACL_MAX_ENTRIES)\n\t\treturn -EINVAL;\n\tnfsacl_desc.desc.array_maxlen = entries;\n\terr = xdr_decode_array2(buf, base + 4, &nfsacl_desc.desc);\n\tif (err)\n\t\treturn err;\n\tif (pacl) {\n\t\tif (entries != nfsacl_desc.desc.array_len ||\n\t\t    posix_acl_from_nfsacl(nfsacl_desc.acl) != 0) {\n\t\t\tposix_acl_release(nfsacl_desc.acl);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*pacl = nfsacl_desc.acl;\n\t}\n\tif (aclcnt)\n\t\t*aclcnt = entries;\n\treturn 8 + nfsacl_desc.desc.elem_size *\n\t\t   nfsacl_desc.desc.array_len;\n}"
  },
  {
    "function_name": "posix_acl_from_nfsacl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/nfsacl.c",
    "lines": "217-252",
    "snippet": "static int\nposix_acl_from_nfsacl(struct posix_acl *acl)\n{\n\tstruct posix_acl_entry *pa, *pe,\n\t       *group_obj = NULL, *mask = NULL;\n\n\tif (!acl)\n\t\treturn 0;\n\n\tsort(acl->a_entries, acl->a_count, sizeof(struct posix_acl_entry),\n\t     cmp_acl_entry, NULL);\n\n\t/* Find the ACL_GROUP_OBJ and ACL_MASK entries. */\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmask = pa;\n\t\t\t\t/* fall through */\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (acl->a_count == 4 && group_obj && mask &&\n\t    mask->e_perm == group_obj->e_perm) {\n\t\t/* remove bogus ACL_MASK entry */\n\t\tmemmove(mask, mask+1, (3 - (mask - acl->a_entries)) *\n\t\t\t\t      sizeof(struct posix_acl_entry));\n\t\tacl->a_count = 3;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/nfs3.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "mask",
            "mask+1",
            "(3 - (mask - acl->a_entries)) *\n\t\t\t\t      sizeof(struct posix_acl_entry)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FOREACH_ACL_ENTRY",
          "args": [
            "pa",
            "acl",
            "pe"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "acl->a_entries",
            "acl->a_count",
            "sizeof(struct posix_acl_entry)",
            "cmp_acl_entry",
            "NULL"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/nfs3.h>\n#include <linux/nfsacl.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int\nposix_acl_from_nfsacl(struct posix_acl *acl)\n{\n\tstruct posix_acl_entry *pa, *pe,\n\t       *group_obj = NULL, *mask = NULL;\n\n\tif (!acl)\n\t\treturn 0;\n\n\tsort(acl->a_entries, acl->a_count, sizeof(struct posix_acl_entry),\n\t     cmp_acl_entry, NULL);\n\n\t/* Find the ACL_GROUP_OBJ and ACL_MASK entries. */\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmask = pa;\n\t\t\t\t/* fall through */\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (acl->a_count == 4 && group_obj && mask &&\n\t    mask->e_perm == group_obj->e_perm) {\n\t\t/* remove bogus ACL_MASK entry */\n\t\tmemmove(mask, mask+1, (3 - (mask - acl->a_entries)) *\n\t\t\t\t      sizeof(struct posix_acl_entry));\n\t\tacl->a_count = 3;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "cmp_acl_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/nfsacl.c",
    "lines": "195-212",
    "snippet": "static int\ncmp_acl_entry(const void *x, const void *y)\n{\n\tconst struct posix_acl_entry *a = x, *b = y;\n\n\tif (a->e_tag != b->e_tag)\n\t\treturn a->e_tag - b->e_tag;\n\telse if ((a->e_tag == ACL_USER) && uid_gt(a->e_uid, b->e_uid))\n\t\treturn 1;\n\telse if ((a->e_tag == ACL_USER) && uid_lt(a->e_uid, b->e_uid))\n\t\treturn -1;\n\telse if ((a->e_tag == ACL_GROUP) && gid_gt(a->e_gid, b->e_gid))\n\t\treturn 1;\n\telse if ((a->e_tag == ACL_GROUP) && gid_lt(a->e_gid, b->e_gid))\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/nfs3.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gid_lt",
          "args": [
            "a->e_gid",
            "b->e_gid"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_gt",
          "args": [
            "a->e_gid",
            "b->e_gid"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_lt",
          "args": [
            "a->e_uid",
            "b->e_uid"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_gt",
          "args": [
            "a->e_uid",
            "b->e_uid"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/nfs3.h>\n#include <linux/nfsacl.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int\ncmp_acl_entry(const void *x, const void *y)\n{\n\tconst struct posix_acl_entry *a = x, *b = y;\n\n\tif (a->e_tag != b->e_tag)\n\t\treturn a->e_tag - b->e_tag;\n\telse if ((a->e_tag == ACL_USER) && uid_gt(a->e_uid, b->e_uid))\n\t\treturn 1;\n\telse if ((a->e_tag == ACL_USER) && uid_lt(a->e_uid, b->e_uid))\n\t\treturn -1;\n\telse if ((a->e_tag == ACL_GROUP) && gid_gt(a->e_gid, b->e_gid))\n\t\treturn 1;\n\telse if ((a->e_tag == ACL_GROUP) && gid_lt(a->e_gid, b->e_gid))\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "xdr_nfsace_decode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/nfsacl.c",
    "lines": "144-193",
    "snippet": "static int\nxdr_nfsace_decode(struct xdr_array2_desc *desc, void *elem)\n{\n\tstruct nfsacl_decode_desc *nfsacl_desc =\n\t\t(struct nfsacl_decode_desc *) desc;\n\t__be32 *p = elem;\n\tstruct posix_acl_entry *entry;\n\tunsigned int id;\n\n\tif (!nfsacl_desc->acl) {\n\t\tif (desc->array_len > NFS_ACL_MAX_ENTRIES)\n\t\t\treturn -EINVAL;\n\t\tnfsacl_desc->acl = posix_acl_alloc(desc->array_len, GFP_KERNEL);\n\t\tif (!nfsacl_desc->acl)\n\t\t\treturn -ENOMEM;\n\t\tnfsacl_desc->count = 0;\n\t}\n\n\tentry = &nfsacl_desc->acl->a_entries[nfsacl_desc->count++];\n\tentry->e_tag = ntohl(*p++) & ~NFS_ACL_DEFAULT;\n\tid = ntohl(*p++);\n\tentry->e_perm = ntohl(*p++);\n\n\tswitch(entry->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_uid = make_kuid(&init_user_ns, id);\n\t\t\tif (!uid_valid(entry->e_uid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_gid = make_kgid(&init_user_ns, id);\n\t\t\tif (!gid_valid(entry->e_gid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_OTHER:\n\t\t\tif (entry->e_perm & ~S_IRWXO)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase ACL_MASK:\n\t\t\t/* Solaris sometimes sets additional bits in the mask */\n\t\t\tentry->e_perm &= S_IRWXO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/nfs3.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "entry->e_gid"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "id"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "entry->e_uid"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "id"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_alloc",
          "args": [
            "desc->array_len",
            "GFP_KERNEL"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "140-149",
          "snippet": "struct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/nfs3.h>\n#include <linux/nfsacl.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int\nxdr_nfsace_decode(struct xdr_array2_desc *desc, void *elem)\n{\n\tstruct nfsacl_decode_desc *nfsacl_desc =\n\t\t(struct nfsacl_decode_desc *) desc;\n\t__be32 *p = elem;\n\tstruct posix_acl_entry *entry;\n\tunsigned int id;\n\n\tif (!nfsacl_desc->acl) {\n\t\tif (desc->array_len > NFS_ACL_MAX_ENTRIES)\n\t\t\treturn -EINVAL;\n\t\tnfsacl_desc->acl = posix_acl_alloc(desc->array_len, GFP_KERNEL);\n\t\tif (!nfsacl_desc->acl)\n\t\t\treturn -ENOMEM;\n\t\tnfsacl_desc->count = 0;\n\t}\n\n\tentry = &nfsacl_desc->acl->a_entries[nfsacl_desc->count++];\n\tentry->e_tag = ntohl(*p++) & ~NFS_ACL_DEFAULT;\n\tid = ntohl(*p++);\n\tentry->e_perm = ntohl(*p++);\n\n\tswitch(entry->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_uid = make_kuid(&init_user_ns, id);\n\t\t\tif (!uid_valid(entry->e_uid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_gid = make_kgid(&init_user_ns, id);\n\t\t\tif (!gid_valid(entry->e_gid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_OTHER:\n\t\t\tif (entry->e_perm & ~S_IRWXO)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase ACL_MASK:\n\t\t\t/* Solaris sometimes sets additional bits in the mask */\n\t\t\tentry->e_perm &= S_IRWXO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsacl_encode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/nfsacl.c",
    "lines": "91-135",
    "snippet": "int nfsacl_encode(struct xdr_buf *buf, unsigned int base, struct inode *inode,\n\t\t  struct posix_acl *acl, int encode_entries, int typeflag)\n{\n\tint entries = (acl && acl->a_count) ? max_t(int, acl->a_count, 4) : 0;\n\tstruct nfsacl_encode_desc nfsacl_desc = {\n\t\t.desc = {\n\t\t\t.elem_size = 12,\n\t\t\t.array_len = encode_entries ? entries : 0,\n\t\t\t.xcode = xdr_nfsace_encode,\n\t\t},\n\t\t.acl = acl,\n\t\t.typeflag = typeflag,\n\t\t.uid = inode->i_uid,\n\t\t.gid = inode->i_gid,\n\t};\n\tstruct nfsacl_simple_acl aclbuf;\n\tint err;\n\n\tif (entries > NFS_ACL_MAX_ENTRIES ||\n\t    xdr_encode_word(buf, base, entries))\n\t\treturn -EINVAL;\n\tif (encode_entries && acl && acl->a_count == 3) {\n\t\tstruct posix_acl *acl2 = &aclbuf.acl;\n\n\t\t/* Avoid the use of posix_acl_alloc().  nfsacl_encode() is\n\t\t * invoked in contexts where a memory allocation failure is\n\t\t * fatal.  Fortunately this fake ACL is small enough to\n\t\t * construct on the stack. */\n\t\tposix_acl_init(acl2, 4);\n\n\t\t/* Insert entries in canonical order: other orders seem\n\t\t to confuse Solaris VxFS. */\n\t\tacl2->a_entries[0] = acl->a_entries[0];  /* ACL_USER_OBJ */\n\t\tacl2->a_entries[1] = acl->a_entries[1];  /* ACL_GROUP_OBJ */\n\t\tacl2->a_entries[2] = acl->a_entries[1];  /* ACL_MASK */\n\t\tacl2->a_entries[2].e_tag = ACL_MASK;\n\t\tacl2->a_entries[3] = acl->a_entries[2];  /* ACL_OTHER */\n\t\tnfsacl_desc.acl = acl2;\n\t}\n\terr = xdr_encode_array2(buf, base + 4, &nfsacl_desc.desc);\n\tif (!err)\n\t\terr = 8 + nfsacl_desc.desc.elem_size *\n\t\t\t  nfsacl_desc.desc.array_len;\n\treturn err;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/nfs3.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_array2",
          "args": [
            "buf",
            "base + 4",
            "&nfsacl_desc.desc"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_init",
          "args": [
            "acl2",
            "4"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "129-134",
          "snippet": "void\nposix_acl_init(struct posix_acl *acl, int count)\n{\n\tatomic_set(&acl->a_refcount, 1);\n\tacl->a_count = count;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid\nposix_acl_init(struct posix_acl *acl, int count)\n{\n\tatomic_set(&acl->a_refcount, 1);\n\tacl->a_count = count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_encode_word",
          "args": [
            "buf",
            "base",
            "entries"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "int",
            "acl->a_count",
            "4"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/nfs3.h>\n#include <linux/nfsacl.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint nfsacl_encode(struct xdr_buf *buf, unsigned int base, struct inode *inode,\n\t\t  struct posix_acl *acl, int encode_entries, int typeflag)\n{\n\tint entries = (acl && acl->a_count) ? max_t(int, acl->a_count, 4) : 0;\n\tstruct nfsacl_encode_desc nfsacl_desc = {\n\t\t.desc = {\n\t\t\t.elem_size = 12,\n\t\t\t.array_len = encode_entries ? entries : 0,\n\t\t\t.xcode = xdr_nfsace_encode,\n\t\t},\n\t\t.acl = acl,\n\t\t.typeflag = typeflag,\n\t\t.uid = inode->i_uid,\n\t\t.gid = inode->i_gid,\n\t};\n\tstruct nfsacl_simple_acl aclbuf;\n\tint err;\n\n\tif (entries > NFS_ACL_MAX_ENTRIES ||\n\t    xdr_encode_word(buf, base, entries))\n\t\treturn -EINVAL;\n\tif (encode_entries && acl && acl->a_count == 3) {\n\t\tstruct posix_acl *acl2 = &aclbuf.acl;\n\n\t\t/* Avoid the use of posix_acl_alloc().  nfsacl_encode() is\n\t\t * invoked in contexts where a memory allocation failure is\n\t\t * fatal.  Fortunately this fake ACL is small enough to\n\t\t * construct on the stack. */\n\t\tposix_acl_init(acl2, 4);\n\n\t\t/* Insert entries in canonical order: other orders seem\n\t\t to confuse Solaris VxFS. */\n\t\tacl2->a_entries[0] = acl->a_entries[0];  /* ACL_USER_OBJ */\n\t\tacl2->a_entries[1] = acl->a_entries[1];  /* ACL_GROUP_OBJ */\n\t\tacl2->a_entries[2] = acl->a_entries[1];  /* ACL_MASK */\n\t\tacl2->a_entries[2].e_tag = ACL_MASK;\n\t\tacl2->a_entries[3] = acl->a_entries[2];  /* ACL_OTHER */\n\t\tnfsacl_desc.acl = acl2;\n\t}\n\terr = xdr_encode_array2(buf, base + 4, &nfsacl_desc.desc);\n\tif (!err)\n\t\terr = 8 + nfsacl_desc.desc.elem_size *\n\t\t\t  nfsacl_desc.desc.array_len;\n\treturn err;\n}"
  },
  {
    "function_name": "xdr_nfsace_encode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs_common/nfsacl.c",
    "lines": "47-77",
    "snippet": "static int\nxdr_nfsace_encode(struct xdr_array2_desc *desc, void *elem)\n{\n\tstruct nfsacl_encode_desc *nfsacl_desc =\n\t\t(struct nfsacl_encode_desc *) desc;\n\t__be32 *p = elem;\n\n\tstruct posix_acl_entry *entry =\n\t\t&nfsacl_desc->acl->a_entries[nfsacl_desc->count++];\n\n\t*p++ = htonl(entry->e_tag | nfsacl_desc->typeflag);\n\tswitch(entry->e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\t\t*p++ = htonl(from_kuid(&init_user_ns, nfsacl_desc->uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP_OBJ:\n\t\t\t*p++ = htonl(from_kgid(&init_user_ns, nfsacl_desc->gid));\n\t\t\tbreak;\n\t\tcase ACL_USER:\n\t\t\t*p++ = htonl(from_kuid(&init_user_ns, entry->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\t*p++ = htonl(from_kgid(&init_user_ns, entry->e_gid));\n\t\t\tbreak;\n\t\tdefault:  /* Solaris depends on that! */\n\t\t\t*p++ = 0;\n\t\t\tbreak;\n\t}\n\t*p++ = htonl(entry->e_perm & S_IRWXO);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sort.h>",
      "#include <linux/nfs3.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "entry->e_perm & S_IRWXO"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "from_kgid(&init_user_ns, entry->e_gid)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "entry->e_gid"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "from_kuid(&init_user_ns, entry->e_uid)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "entry->e_uid"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "from_kgid(&init_user_ns, nfsacl_desc->gid)"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "nfsacl_desc->gid"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "from_kuid(&init_user_ns, nfsacl_desc->uid)"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "nfsacl_desc->uid"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "entry->e_tag | nfsacl_desc->typeflag"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sort.h>\n#include <linux/nfs3.h>\n#include <linux/nfsacl.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int\nxdr_nfsace_encode(struct xdr_array2_desc *desc, void *elem)\n{\n\tstruct nfsacl_encode_desc *nfsacl_desc =\n\t\t(struct nfsacl_encode_desc *) desc;\n\t__be32 *p = elem;\n\n\tstruct posix_acl_entry *entry =\n\t\t&nfsacl_desc->acl->a_entries[nfsacl_desc->count++];\n\n\t*p++ = htonl(entry->e_tag | nfsacl_desc->typeflag);\n\tswitch(entry->e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\t\t*p++ = htonl(from_kuid(&init_user_ns, nfsacl_desc->uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP_OBJ:\n\t\t\t*p++ = htonl(from_kgid(&init_user_ns, nfsacl_desc->gid));\n\t\t\tbreak;\n\t\tcase ACL_USER:\n\t\t\t*p++ = htonl(from_kuid(&init_user_ns, entry->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\t*p++ = htonl(from_kgid(&init_user_ns, entry->e_gid));\n\t\t\tbreak;\n\t\tdefault:  /* Solaris depends on that! */\n\t\t\t*p++ = 0;\n\t\t\tbreak;\n\t}\n\t*p++ = htonl(entry->e_perm & S_IRWXO);\n\treturn 0;\n}"
  }
]