[
  {
    "function_name": "xfs_vm_set_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "1757-1803",
    "snippet": "STATIC int\nxfs_vm_set_page_dirty(\n\tstruct page\t\t*page)\n{\n\tstruct address_space\t*mapping = page->mapping;\n\tstruct inode\t\t*inode = mapping->host;\n\tloff_t\t\t\tend_offset;\n\tloff_t\t\t\toffset;\n\tint\t\t\tnewly_dirty;\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tend_offset = i_size_read(inode);\n\toffset = page_offset(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tif (offset < end_offset)\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t\toffset += 1 << inode->i_blkbits;\n\t\t} while (bh != head);\n\t}\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty) {\n\t\t/* sigh - __set_page_dirty() is static, so copy it here, too */\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&mapping->tree_lock, flags);\n\t\tif (page->mapping) {\t/* Race with truncate? */\n\t\t\tWARN_ON_ONCE(!PageUptodate(page));\n\t\t\taccount_page_dirtied(page, mapping);\n\t\t\tradix_tree_tag_set(&mapping->page_tree,\n\t\t\t\t\tpage_index(page), PAGECACHE_TAG_DIRTY);\n\t\t}\n\t\tspin_unlock_irqrestore(&mapping->tree_lock, flags);\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n\treturn newly_dirty;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "mapping->host",
            "I_DIRTY_PAGES"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1181-1285",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&mapping->tree_lock",
            "flags"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_set",
          "args": [
            "&mapping->page_tree",
            "page_index(page)",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_index",
          "args": [
            "page"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_page_dirtied",
          "args": [
            "page",
            "mapping"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&mapping->tree_lock",
            "flags"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestSetPageDirty",
          "args": [
            "page"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestSetPageDirty",
          "args": [
            "page"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!mapping"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vm_set_page_dirty(\n\tstruct page\t\t*page)\n{\n\tstruct address_space\t*mapping = page->mapping;\n\tstruct inode\t\t*inode = mapping->host;\n\tloff_t\t\t\tend_offset;\n\tloff_t\t\t\toffset;\n\tint\t\t\tnewly_dirty;\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tend_offset = i_size_read(inode);\n\toffset = page_offset(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tif (offset < end_offset)\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t\toffset += 1 << inode->i_blkbits;\n\t\t} while (bh != head);\n\t}\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty) {\n\t\t/* sigh - __set_page_dirty() is static, so copy it here, too */\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&mapping->tree_lock, flags);\n\t\tif (page->mapping) {\t/* Race with truncate? */\n\t\t\tWARN_ON_ONCE(!PageUptodate(page));\n\t\t\taccount_page_dirtied(page, mapping);\n\t\t\tradix_tree_tag_set(&mapping->page_tree,\n\t\t\t\t\tpage_index(page), PAGECACHE_TAG_DIRTY);\n\t\t}\n\t\tspin_unlock_irqrestore(&mapping->tree_lock, flags);\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n\treturn newly_dirty;\n}"
  },
  {
    "function_name": "xfs_vm_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "1735-1743",
    "snippet": "STATIC int\nxfs_vm_readpages(\n\tstruct file\t\t*unused,\n\tstruct address_space\t*mapping,\n\tstruct list_head\t*pages,\n\tunsigned\t\tnr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, xfs_get_blocks);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpages",
          "args": [
            "mapping",
            "pages",
            "nr_pages",
            "xfs_get_blocks"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "355-386",
          "snippet": "int\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vm_readpages(\n\tstruct file\t\t*unused,\n\tstruct address_space\t*mapping,\n\tstruct list_head\t*pages,\n\tunsigned\t\tnr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, xfs_get_blocks);\n}"
  },
  {
    "function_name": "xfs_vm_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "1727-1733",
    "snippet": "STATIC int\nxfs_vm_readpage(\n\tstruct file\t\t*unused,\n\tstruct page\t\t*page)\n{\n\treturn mpage_readpage(page, xfs_get_blocks);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpage",
          "args": [
            "page",
            "xfs_get_blocks"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "392-406",
          "snippet": "int mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vm_readpage(\n\tstruct file\t\t*unused,\n\tstruct page\t\t*page)\n{\n\treturn mpage_readpage(page, xfs_get_blocks);\n}"
  },
  {
    "function_name": "xfs_vm_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "1712-1725",
    "snippet": "STATIC sector_t\nxfs_vm_bmap(\n\tstruct address_space\t*mapping,\n\tsector_t\t\tblock)\n{\n\tstruct inode\t\t*inode = (struct inode *)mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\n\ttrace_xfs_vm_bmap(XFS_I(inode));\n\txfs_ilock(ip, XFS_IOLOCK_SHARED);\n\tfilemap_write_and_wait(mapping);\n\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\treturn generic_block_bmap(mapping, block, xfs_get_blocks);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "xfs_get_blocks"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_IOLOCK_SHARED"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "mapping"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_IOLOCK_SHARED"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_vm_bmap",
          "args": [
            "XFS_I(inode)"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC sector_t\nxfs_vm_bmap(\n\tstruct address_space\t*mapping,\n\tsector_t\t\tblock)\n{\n\tstruct inode\t\t*inode = (struct inode *)mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\n\ttrace_xfs_vm_bmap(XFS_I(inode));\n\txfs_ilock(ip, XFS_IOLOCK_SHARED);\n\tfilemap_write_and_wait(mapping);\n\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\treturn generic_block_bmap(mapping, block, xfs_get_blocks);\n}"
  },
  {
    "function_name": "xfs_vm_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "1681-1710",
    "snippet": "STATIC int\nxfs_vm_write_end(\n\tstruct file\t\t*file,\n\tstruct address_space\t*mapping,\n\tloff_t\t\t\tpos,\n\tunsigned\t\tlen,\n\tunsigned\t\tcopied,\n\tstruct page\t\t*page,\n\tvoid\t\t\t*fsdata)\n{\n\tint\t\t\tret;\n\n\tASSERT(len <= PAGE_CACHE_SIZE);\n\n\tret = generic_write_end(file, mapping, pos, len, copied, page, fsdata);\n\tif (unlikely(ret < len)) {\n\t\tstruct inode\t*inode = mapping->host;\n\t\tsize_t\t\tisize = i_size_read(inode);\n\t\tloff_t\t\tto = pos + len;\n\n\t\tif (to > isize) {\n\t\t\t/* only kill blocks in this write beyond EOF */\n\t\t\tif (pos > isize)\n\t\t\t\tisize = pos;\n\t\t\txfs_vm_kill_delalloc_range(inode, isize, to);\n\t\t\ttruncate_pagecache_range(inode, isize, to);\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_pagecache_range",
          "args": [
            "inode",
            "isize",
            "to"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_vm_kill_delalloc_range",
          "args": [
            "inode",
            "isize",
            "to"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_vm_kill_delalloc_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "1524-1552",
          "snippet": "STATIC void\nxfs_vm_kill_delalloc_range(\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\tstart,\n\tloff_t\t\t\tend)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\txfs_fileoff_t\t\tstart_fsb;\n\txfs_fileoff_t\t\tend_fsb;\n\tint\t\t\terror;\n\n\tstart_fsb = XFS_B_TO_FSB(ip->i_mount, start);\n\tend_fsb = XFS_B_TO_FSB(ip->i_mount, end);\n\tif (end_fsb <= start_fsb)\n\t\treturn;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_bmap_punch_delalloc_range(ip, start_fsb,\n\t\t\t\t\t\tend_fsb - start_fsb);\n\tif (error) {\n\t\t/* something screwed, just bail */\n\t\tif (!XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\t\txfs_alert(ip->i_mount,\n\t\t\"xfs_vm_write_failed: unable to clean up ino %lld\",\n\t\t\t\t\tip->i_ino);\n\t\t}\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_vm_kill_delalloc_range(\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\tstart,\n\tloff_t\t\t\tend)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\txfs_fileoff_t\t\tstart_fsb;\n\txfs_fileoff_t\t\tend_fsb;\n\tint\t\t\terror;\n\n\tstart_fsb = XFS_B_TO_FSB(ip->i_mount, start);\n\tend_fsb = XFS_B_TO_FSB(ip->i_mount, end);\n\tif (end_fsb <= start_fsb)\n\t\treturn;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_bmap_punch_delalloc_range(ip, start_fsb,\n\t\t\t\t\t\tend_fsb - start_fsb);\n\tif (error) {\n\t\t/* something screwed, just bail */\n\t\tif (!XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\t\txfs_alert(ip->i_mount,\n\t\t\"xfs_vm_write_failed: unable to clean up ino %lld\",\n\t\t\t\t\tip->i_ino);\n\t\t}\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < len"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "copied",
            "page",
            "fsdata"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "generic_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2067-2104",
          "snippet": "int generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint i_size_changed = 0;\n\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint i_size_changed = 0;\n\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len <= PAGE_CACHE_SIZE"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vm_write_end(\n\tstruct file\t\t*file,\n\tstruct address_space\t*mapping,\n\tloff_t\t\t\tpos,\n\tunsigned\t\tlen,\n\tunsigned\t\tcopied,\n\tstruct page\t\t*page,\n\tvoid\t\t\t*fsdata)\n{\n\tint\t\t\tret;\n\n\tASSERT(len <= PAGE_CACHE_SIZE);\n\n\tret = generic_write_end(file, mapping, pos, len, copied, page, fsdata);\n\tif (unlikely(ret < len)) {\n\t\tstruct inode\t*inode = mapping->host;\n\t\tsize_t\t\tisize = i_size_read(inode);\n\t\tloff_t\t\tto = pos + len;\n\n\t\tif (to > isize) {\n\t\t\t/* only kill blocks in this write beyond EOF */\n\t\t\tif (pos > isize)\n\t\t\t\tisize = pos;\n\t\t\txfs_vm_kill_delalloc_range(inode, isize, to);\n\t\t\ttruncate_pagecache_range(inode, isize, to);\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "xfs_vm_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "1626-1671",
    "snippet": "STATIC int\nxfs_vm_write_begin(\n\tstruct file\t\t*file,\n\tstruct address_space\t*mapping,\n\tloff_t\t\t\tpos,\n\tunsigned\t\tlen,\n\tunsigned\t\tflags,\n\tstruct page\t\t**pagep,\n\tvoid\t\t\t**fsdata)\n{\n\tpgoff_t\t\t\tindex = pos >> PAGE_CACHE_SHIFT;\n\tstruct page\t\t*page;\n\tint\t\t\tstatus;\n\n\tASSERT(len <= PAGE_CACHE_SIZE);\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, xfs_get_blocks);\n\tif (unlikely(status)) {\n\t\tstruct inode\t*inode = mapping->host;\n\t\tsize_t\t\tisize = i_size_read(inode);\n\n\t\txfs_vm_write_failed(inode, page, pos, len);\n\t\tunlock_page(page);\n\n\t\t/*\n\t\t * If the write is beyond EOF, we only want to kill blocks\n\t\t * allocated in this write, not blocks that were previously\n\t\t * written successfully.\n\t\t */\n\t\tif (pos + len > isize) {\n\t\t\tssize_t start = max_t(ssize_t, pos, isize);\n\n\t\t\ttruncate_pagecache_range(inode, start, pos + len);\n\t\t}\n\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_pagecache_range",
          "args": [
            "inode",
            "start",
            "pos + len"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "ssize_t",
            "pos",
            "isize"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_vm_write_failed",
          "args": [
            "inode",
            "page",
            "pos",
            "len"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_vm_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "1554-1618",
          "snippet": "STATIC void\nxfs_vm_write_failed(\n\tstruct inode\t\t*inode,\n\tstruct page\t\t*page,\n\tloff_t\t\t\tpos,\n\tunsigned\t\tlen)\n{\n\tloff_t\t\t\tblock_offset;\n\tloff_t\t\t\tblock_start;\n\tloff_t\t\t\tblock_end;\n\tloff_t\t\t\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tloff_t\t\t\tto = from + len;\n\tstruct buffer_head\t*bh, *head;\n\n\t/*\n\t * The request pos offset might be 32 or 64 bit, this is all fine\n\t * on 64-bit platform.  However, for 64-bit pos request on 32-bit\n\t * platform, the high 32-bit will be masked off if we evaluate the\n\t * block_offset via (pos & PAGE_MASK) because the PAGE_MASK is\n\t * 0xfffff000 as an unsigned long, hence the result is incorrect\n\t * which could cause the following ASSERT failed in most cases.\n\t * In order to avoid this, we can evaluate the block_offset of the\n\t * start of the page by using shifts rather than masks the mismatch\n\t * problem.\n\t */\n\tblock_offset = (pos >> PAGE_CACHE_SHIFT) << PAGE_CACHE_SHIFT;\n\n\tASSERT(block_offset + from == pos);\n\n\thead = page_buffers(page);\n\tblock_start = 0;\n\tfor (bh = head; bh != head || !block_start;\n\t     bh = bh->b_this_page, block_start = block_end,\n\t\t\t\t   block_offset += bh->b_size) {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\t/* skip buffers before the write */\n\t\tif (block_end <= from)\n\t\t\tcontinue;\n\n\t\t/* if the buffer is after the write, we're done */\n\t\tif (block_start >= to)\n\t\t\tbreak;\n\n\t\tif (!buffer_delay(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_new(bh) && block_offset < i_size_read(inode))\n\t\t\tcontinue;\n\n\t\txfs_vm_kill_delalloc_range(inode, block_offset,\n\t\t\t\t\t   block_offset + bh->b_size);\n\n\t\t/*\n\t\t * This buffer does not contain data anymore. make sure anyone\n\t\t * who finds it knows that for certain.\n\t\t */\n\t\tclear_buffer_delay(bh);\n\t\tclear_buffer_uptodate(bh);\n\t\tclear_buffer_mapped(bh);\n\t\tclear_buffer_new(bh);\n\t\tclear_buffer_dirty(bh);\n\t}\n\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_vm_write_failed(\n\tstruct inode\t\t*inode,\n\tstruct page\t\t*page,\n\tloff_t\t\t\tpos,\n\tunsigned\t\tlen)\n{\n\tloff_t\t\t\tblock_offset;\n\tloff_t\t\t\tblock_start;\n\tloff_t\t\t\tblock_end;\n\tloff_t\t\t\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tloff_t\t\t\tto = from + len;\n\tstruct buffer_head\t*bh, *head;\n\n\t/*\n\t * The request pos offset might be 32 or 64 bit, this is all fine\n\t * on 64-bit platform.  However, for 64-bit pos request on 32-bit\n\t * platform, the high 32-bit will be masked off if we evaluate the\n\t * block_offset via (pos & PAGE_MASK) because the PAGE_MASK is\n\t * 0xfffff000 as an unsigned long, hence the result is incorrect\n\t * which could cause the following ASSERT failed in most cases.\n\t * In order to avoid this, we can evaluate the block_offset of the\n\t * start of the page by using shifts rather than masks the mismatch\n\t * problem.\n\t */\n\tblock_offset = (pos >> PAGE_CACHE_SHIFT) << PAGE_CACHE_SHIFT;\n\n\tASSERT(block_offset + from == pos);\n\n\thead = page_buffers(page);\n\tblock_start = 0;\n\tfor (bh = head; bh != head || !block_start;\n\t     bh = bh->b_this_page, block_start = block_end,\n\t\t\t\t   block_offset += bh->b_size) {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\t/* skip buffers before the write */\n\t\tif (block_end <= from)\n\t\t\tcontinue;\n\n\t\t/* if the buffer is after the write, we're done */\n\t\tif (block_start >= to)\n\t\t\tbreak;\n\n\t\tif (!buffer_delay(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_new(bh) && block_offset < i_size_read(inode))\n\t\t\tcontinue;\n\n\t\txfs_vm_kill_delalloc_range(inode, block_offset,\n\t\t\t\t\t   block_offset + bh->b_size);\n\n\t\t/*\n\t\t * This buffer does not contain data anymore. make sure anyone\n\t\t * who finds it knows that for certain.\n\t\t */\n\t\tclear_buffer_delay(bh);\n\t\tclear_buffer_uptodate(bh);\n\t\tclear_buffer_mapped(bh);\n\t\tclear_buffer_new(bh);\n\t\tclear_buffer_dirty(bh);\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "pos",
            "len",
            "xfs_get_blocks"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1882-1961",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len <= PAGE_CACHE_SIZE"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vm_write_begin(\n\tstruct file\t\t*file,\n\tstruct address_space\t*mapping,\n\tloff_t\t\t\tpos,\n\tunsigned\t\tlen,\n\tunsigned\t\tflags,\n\tstruct page\t\t**pagep,\n\tvoid\t\t\t**fsdata)\n{\n\tpgoff_t\t\t\tindex = pos >> PAGE_CACHE_SHIFT;\n\tstruct page\t\t*page;\n\tint\t\t\tstatus;\n\n\tASSERT(len <= PAGE_CACHE_SIZE);\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, xfs_get_blocks);\n\tif (unlikely(status)) {\n\t\tstruct inode\t*inode = mapping->host;\n\t\tsize_t\t\tisize = i_size_read(inode);\n\n\t\txfs_vm_write_failed(inode, page, pos, len);\n\t\tunlock_page(page);\n\n\t\t/*\n\t\t * If the write is beyond EOF, we only want to kill blocks\n\t\t * allocated in this write, not blocks that were previously\n\t\t * written successfully.\n\t\t */\n\t\tif (pos + len > isize) {\n\t\t\tssize_t start = max_t(ssize_t, pos, isize);\n\n\t\t\ttruncate_pagecache_range(inode, start, pos + len);\n\t\t}\n\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
  },
  {
    "function_name": "xfs_vm_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "1554-1618",
    "snippet": "STATIC void\nxfs_vm_write_failed(\n\tstruct inode\t\t*inode,\n\tstruct page\t\t*page,\n\tloff_t\t\t\tpos,\n\tunsigned\t\tlen)\n{\n\tloff_t\t\t\tblock_offset;\n\tloff_t\t\t\tblock_start;\n\tloff_t\t\t\tblock_end;\n\tloff_t\t\t\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tloff_t\t\t\tto = from + len;\n\tstruct buffer_head\t*bh, *head;\n\n\t/*\n\t * The request pos offset might be 32 or 64 bit, this is all fine\n\t * on 64-bit platform.  However, for 64-bit pos request on 32-bit\n\t * platform, the high 32-bit will be masked off if we evaluate the\n\t * block_offset via (pos & PAGE_MASK) because the PAGE_MASK is\n\t * 0xfffff000 as an unsigned long, hence the result is incorrect\n\t * which could cause the following ASSERT failed in most cases.\n\t * In order to avoid this, we can evaluate the block_offset of the\n\t * start of the page by using shifts rather than masks the mismatch\n\t * problem.\n\t */\n\tblock_offset = (pos >> PAGE_CACHE_SHIFT) << PAGE_CACHE_SHIFT;\n\n\tASSERT(block_offset + from == pos);\n\n\thead = page_buffers(page);\n\tblock_start = 0;\n\tfor (bh = head; bh != head || !block_start;\n\t     bh = bh->b_this_page, block_start = block_end,\n\t\t\t\t   block_offset += bh->b_size) {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\t/* skip buffers before the write */\n\t\tif (block_end <= from)\n\t\t\tcontinue;\n\n\t\t/* if the buffer is after the write, we're done */\n\t\tif (block_start >= to)\n\t\t\tbreak;\n\n\t\tif (!buffer_delay(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_new(bh) && block_offset < i_size_read(inode))\n\t\t\tcontinue;\n\n\t\txfs_vm_kill_delalloc_range(inode, block_offset,\n\t\t\t\t\t   block_offset + bh->b_size);\n\n\t\t/*\n\t\t * This buffer does not contain data anymore. make sure anyone\n\t\t * who finds it knows that for certain.\n\t\t */\n\t\tclear_buffer_delay(bh);\n\t\tclear_buffer_uptodate(bh);\n\t\tclear_buffer_mapped(bh);\n\t\tclear_buffer_new(bh);\n\t\tclear_buffer_dirty(bh);\n\t}\n\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_vm_kill_delalloc_range",
          "args": [
            "inode",
            "block_offset",
            "block_offset + bh->b_size"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_vm_kill_delalloc_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "1524-1552",
          "snippet": "STATIC void\nxfs_vm_kill_delalloc_range(\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\tstart,\n\tloff_t\t\t\tend)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\txfs_fileoff_t\t\tstart_fsb;\n\txfs_fileoff_t\t\tend_fsb;\n\tint\t\t\terror;\n\n\tstart_fsb = XFS_B_TO_FSB(ip->i_mount, start);\n\tend_fsb = XFS_B_TO_FSB(ip->i_mount, end);\n\tif (end_fsb <= start_fsb)\n\t\treturn;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_bmap_punch_delalloc_range(ip, start_fsb,\n\t\t\t\t\t\tend_fsb - start_fsb);\n\tif (error) {\n\t\t/* something screwed, just bail */\n\t\tif (!XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\t\txfs_alert(ip->i_mount,\n\t\t\"xfs_vm_write_failed: unable to clean up ino %lld\",\n\t\t\t\t\tip->i_ino);\n\t\t}\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_vm_kill_delalloc_range(\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\tstart,\n\tloff_t\t\t\tend)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\txfs_fileoff_t\t\tstart_fsb;\n\txfs_fileoff_t\t\tend_fsb;\n\tint\t\t\terror;\n\n\tstart_fsb = XFS_B_TO_FSB(ip->i_mount, start);\n\tend_fsb = XFS_B_TO_FSB(ip->i_mount, end);\n\tif (end_fsb <= start_fsb)\n\t\treturn;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_bmap_punch_delalloc_range(ip, start_fsb,\n\t\t\t\t\t\tend_fsb - start_fsb);\n\tif (error) {\n\t\t/* something screwed, just bail */\n\t\tif (!XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\t\txfs_alert(ip->i_mount,\n\t\t\"xfs_vm_write_failed: unable to clean up ino %lld\",\n\t\t\t\t\tip->i_ino);\n\t\t}\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "block_offset + from == pos"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_vm_write_failed(\n\tstruct inode\t\t*inode,\n\tstruct page\t\t*page,\n\tloff_t\t\t\tpos,\n\tunsigned\t\tlen)\n{\n\tloff_t\t\t\tblock_offset;\n\tloff_t\t\t\tblock_start;\n\tloff_t\t\t\tblock_end;\n\tloff_t\t\t\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tloff_t\t\t\tto = from + len;\n\tstruct buffer_head\t*bh, *head;\n\n\t/*\n\t * The request pos offset might be 32 or 64 bit, this is all fine\n\t * on 64-bit platform.  However, for 64-bit pos request on 32-bit\n\t * platform, the high 32-bit will be masked off if we evaluate the\n\t * block_offset via (pos & PAGE_MASK) because the PAGE_MASK is\n\t * 0xfffff000 as an unsigned long, hence the result is incorrect\n\t * which could cause the following ASSERT failed in most cases.\n\t * In order to avoid this, we can evaluate the block_offset of the\n\t * start of the page by using shifts rather than masks the mismatch\n\t * problem.\n\t */\n\tblock_offset = (pos >> PAGE_CACHE_SHIFT) << PAGE_CACHE_SHIFT;\n\n\tASSERT(block_offset + from == pos);\n\n\thead = page_buffers(page);\n\tblock_start = 0;\n\tfor (bh = head; bh != head || !block_start;\n\t     bh = bh->b_this_page, block_start = block_end,\n\t\t\t\t   block_offset += bh->b_size) {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\t/* skip buffers before the write */\n\t\tif (block_end <= from)\n\t\t\tcontinue;\n\n\t\t/* if the buffer is after the write, we're done */\n\t\tif (block_start >= to)\n\t\t\tbreak;\n\n\t\tif (!buffer_delay(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_new(bh) && block_offset < i_size_read(inode))\n\t\t\tcontinue;\n\n\t\txfs_vm_kill_delalloc_range(inode, block_offset,\n\t\t\t\t\t   block_offset + bh->b_size);\n\n\t\t/*\n\t\t * This buffer does not contain data anymore. make sure anyone\n\t\t * who finds it knows that for certain.\n\t\t */\n\t\tclear_buffer_delay(bh);\n\t\tclear_buffer_uptodate(bh);\n\t\tclear_buffer_mapped(bh);\n\t\tclear_buffer_new(bh);\n\t\tclear_buffer_dirty(bh);\n\t}\n\n}"
  },
  {
    "function_name": "xfs_vm_kill_delalloc_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "1524-1552",
    "snippet": "STATIC void\nxfs_vm_kill_delalloc_range(\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\tstart,\n\tloff_t\t\t\tend)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\txfs_fileoff_t\t\tstart_fsb;\n\txfs_fileoff_t\t\tend_fsb;\n\tint\t\t\terror;\n\n\tstart_fsb = XFS_B_TO_FSB(ip->i_mount, start);\n\tend_fsb = XFS_B_TO_FSB(ip->i_mount, end);\n\tif (end_fsb <= start_fsb)\n\t\treturn;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_bmap_punch_delalloc_range(ip, start_fsb,\n\t\t\t\t\t\tend_fsb - start_fsb);\n\tif (error) {\n\t\t/* something screwed, just bail */\n\t\tif (!XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\t\txfs_alert(ip->i_mount,\n\t\t\"xfs_vm_write_failed: unable to clean up ino %lld\",\n\t\t\t\t\tip->i_ino);\n\t\t}\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "ip->i_mount",
            "\"xfs_vm_write_failed: unable to clean up ino %lld\"",
            "ip->i_ino"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "ip->i_mount"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_punch_delalloc_range",
          "args": [
            "ip",
            "start_fsb",
            "end_fsb - start_fsb"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_punch_delalloc_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "725-790",
          "snippet": "int\nxfs_bmap_punch_delalloc_range(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tstart_fsb,\n\txfs_fileoff_t\t\tlength)\n{\n\txfs_fileoff_t\t\tremaining = length;\n\tint\t\t\terror = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tdo {\n\t\tint\t\tdone;\n\t\txfs_bmbt_irec_t\timap;\n\t\tint\t\tnimaps = 1;\n\t\txfs_fsblock_t\tfirstblock;\n\t\txfs_bmap_free_t flist;\n\n\t\t/*\n\t\t * Map the range first and check that it is a delalloc extent\n\t\t * before trying to unmap the range. Otherwise we will be\n\t\t * trying to remove a real extent (which requires a\n\t\t * transaction) or a hole, which is probably a bad idea...\n\t\t */\n\t\terror = xfs_bmapi_read(ip, start_fsb, 1, &imap, &nimaps,\n\t\t\t\t       XFS_BMAPI_ENTIRE);\n\n\t\tif (error) {\n\t\t\t/* something screwed, just bail */\n\t\t\tif (!XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\t\t\txfs_alert(ip->i_mount,\n\t\t\t\"Failed delalloc mapping lookup ino %lld fsb %lld.\",\n\t\t\t\t\t\tip->i_ino, start_fsb);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (!nimaps) {\n\t\t\t/* nothing there */\n\t\t\tgoto next_block;\n\t\t}\n\t\tif (imap.br_startblock != DELAYSTARTBLOCK) {\n\t\t\t/* been converted, ignore */\n\t\t\tgoto next_block;\n\t\t}\n\t\tWARN_ON(imap.br_blockcount == 0);\n\n\t\t/*\n\t\t * Note: while we initialise the firstblock/flist pair, they\n\t\t * should never be used because blocks should never be\n\t\t * allocated or freed for a delalloc extent and hence we need\n\t\t * don't cancel or finish them after the xfs_bunmapi() call.\n\t\t */\n\t\txfs_bmap_init(&flist, &firstblock);\n\t\terror = xfs_bunmapi(NULL, ip, start_fsb, 1, 0, 1, &firstblock,\n\t\t\t\t\t&flist, &done);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tASSERT(!flist.xbf_count && !flist.xbf_first);\nnext_block:\n\t\tstart_fsb++;\n\t\tremaining--;\n\t} while(remaining > 0);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_punch_delalloc_range(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tstart_fsb,\n\txfs_fileoff_t\t\tlength)\n{\n\txfs_fileoff_t\t\tremaining = length;\n\tint\t\t\terror = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tdo {\n\t\tint\t\tdone;\n\t\txfs_bmbt_irec_t\timap;\n\t\tint\t\tnimaps = 1;\n\t\txfs_fsblock_t\tfirstblock;\n\t\txfs_bmap_free_t flist;\n\n\t\t/*\n\t\t * Map the range first and check that it is a delalloc extent\n\t\t * before trying to unmap the range. Otherwise we will be\n\t\t * trying to remove a real extent (which requires a\n\t\t * transaction) or a hole, which is probably a bad idea...\n\t\t */\n\t\terror = xfs_bmapi_read(ip, start_fsb, 1, &imap, &nimaps,\n\t\t\t\t       XFS_BMAPI_ENTIRE);\n\n\t\tif (error) {\n\t\t\t/* something screwed, just bail */\n\t\t\tif (!XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\t\t\txfs_alert(ip->i_mount,\n\t\t\t\"Failed delalloc mapping lookup ino %lld fsb %lld.\",\n\t\t\t\t\t\tip->i_ino, start_fsb);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (!nimaps) {\n\t\t\t/* nothing there */\n\t\t\tgoto next_block;\n\t\t}\n\t\tif (imap.br_startblock != DELAYSTARTBLOCK) {\n\t\t\t/* been converted, ignore */\n\t\t\tgoto next_block;\n\t\t}\n\t\tWARN_ON(imap.br_blockcount == 0);\n\n\t\t/*\n\t\t * Note: while we initialise the firstblock/flist pair, they\n\t\t * should never be used because blocks should never be\n\t\t * allocated or freed for a delalloc extent and hence we need\n\t\t * don't cancel or finish them after the xfs_bunmapi() call.\n\t\t */\n\t\txfs_bmap_init(&flist, &firstblock);\n\t\terror = xfs_bunmapi(NULL, ip, start_fsb, 1, 0, 1, &firstblock,\n\t\t\t\t\t&flist, &done);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tASSERT(!flist.xbf_count && !flist.xbf_first);\nnext_block:\n\t\tstart_fsb++;\n\t\tremaining--;\n\t} while(remaining > 0);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "ip->i_mount",
            "end"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "ip->i_mount",
            "start"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_vm_kill_delalloc_range(\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\tstart,\n\tloff_t\t\t\tend)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\txfs_fileoff_t\t\tstart_fsb;\n\txfs_fileoff_t\t\tend_fsb;\n\tint\t\t\terror;\n\n\tstart_fsb = XFS_B_TO_FSB(ip->i_mount, start);\n\tend_fsb = XFS_B_TO_FSB(ip->i_mount, end);\n\tif (end_fsb <= start_fsb)\n\t\treturn;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_bmap_punch_delalloc_range(ip, start_fsb,\n\t\t\t\t\t\tend_fsb - start_fsb);\n\tif (error) {\n\t\t/* something screwed, just bail */\n\t\tif (!XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\t\txfs_alert(ip->i_mount,\n\t\t\"xfs_vm_write_failed: unable to clean up ino %lld\",\n\t\t\t\t\tip->i_ino);\n\t\t}\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n}"
  },
  {
    "function_name": "xfs_vm_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "1497-1516",
    "snippet": "STATIC ssize_t\nxfs_vm_direct_IO(\n\tint\t\t\trw,\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*iter,\n\tloff_t\t\t\toffset)\n{\n\tstruct inode\t\t*inode = iocb->ki_filp->f_mapping->host;\n\tstruct block_device\t*bdev = xfs_find_bdev_for_inode(inode);\n\n\tif (rw & WRITE) {\n\t\treturn __blockdev_direct_IO(rw, iocb, inode, bdev, iter,\n\t\t\t\t\t    offset, xfs_get_blocks_direct,\n\t\t\t\t\t    xfs_end_io_direct_write, NULL,\n\t\t\t\t\t    DIO_ASYNC_EXTEND);\n\t}\n\treturn __blockdev_direct_IO(rw, iocb, inode, bdev, iter,\n\t\t\t\t    offset, xfs_get_blocks_direct,\n\t\t\t\t    NULL, NULL, 0);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blockdev_direct_IO",
          "args": [
            "rw",
            "iocb",
            "inode",
            "bdev",
            "iter",
            "offset",
            "xfs_get_blocks_direct",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "__blockdev_direct_IO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/direct-io.c",
          "lines": "1304-1324",
          "snippet": "ssize_t\n__blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,\n\tstruct block_device *bdev, struct iov_iter *iter, loff_t offset,\n\tget_block_t get_block, dio_iodone_t end_io,\n\tdio_submit_t submit_io,\tint flags)\n{\n\t/*\n\t * The block device state is needed in the end to finally\n\t * submit everything.  Since it's likely to be cache cold\n\t * prefetch it here as first thing to hide some of the\n\t * latency.\n\t *\n\t * Attempt to prefetch the pieces we likely need later.\n\t */\n\tprefetch(&bdev->bd_disk->part_tbl);\n\tprefetch(bdev->bd_queue);\n\tprefetch((char *)bdev->bd_queue + SMP_CACHE_BYTES);\n\n\treturn do_blockdev_direct_IO(rw, iocb, inode, bdev, iter, offset,\n\t\t\t\t     get_block, end_io, submit_io, flags);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nssize_t\n__blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,\n\tstruct block_device *bdev, struct iov_iter *iter, loff_t offset,\n\tget_block_t get_block, dio_iodone_t end_io,\n\tdio_submit_t submit_io,\tint flags)\n{\n\t/*\n\t * The block device state is needed in the end to finally\n\t * submit everything.  Since it's likely to be cache cold\n\t * prefetch it here as first thing to hide some of the\n\t * latency.\n\t *\n\t * Attempt to prefetch the pieces we likely need later.\n\t */\n\tprefetch(&bdev->bd_disk->part_tbl);\n\tprefetch(bdev->bd_queue);\n\tprefetch((char *)bdev->bd_queue + SMP_CACHE_BYTES);\n\n\treturn do_blockdev_direct_IO(rw, iocb, inode, bdev, iter, offset,\n\t\t\t\t     get_block, end_io, submit_io, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_find_bdev_for_inode",
          "args": [
            "inode"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_find_bdev_for_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "59-70",
          "snippet": "block_device *\nxfs_find_bdev_for_inode(\n\tstruct inode\t\t*inode)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn mp->m_rtdev_targp->bt_bdev;\n\telse\n\t\treturn mp->m_ddev_targp->bt_bdev;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nblock_device *\nxfs_find_bdev_for_inode(\n\tstruct inode\t\t*inode)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn mp->m_rtdev_targp->bt_bdev;\n\telse\n\t\treturn mp->m_ddev_targp->bt_bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC ssize_t\nxfs_vm_direct_IO(\n\tint\t\t\trw,\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*iter,\n\tloff_t\t\t\toffset)\n{\n\tstruct inode\t\t*inode = iocb->ki_filp->f_mapping->host;\n\tstruct block_device\t*bdev = xfs_find_bdev_for_inode(inode);\n\n\tif (rw & WRITE) {\n\t\treturn __blockdev_direct_IO(rw, iocb, inode, bdev, iter,\n\t\t\t\t\t    offset, xfs_get_blocks_direct,\n\t\t\t\t\t    xfs_end_io_direct_write, NULL,\n\t\t\t\t\t    DIO_ASYNC_EXTEND);\n\t}\n\treturn __blockdev_direct_IO(rw, iocb, inode, bdev, iter,\n\t\t\t\t    offset, xfs_get_blocks_direct,\n\t\t\t\t    NULL, NULL, 0);\n}"
  },
  {
    "function_name": "xfs_end_io_direct_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "1448-1495",
    "snippet": "STATIC void\nxfs_end_io_direct_write(\n\tstruct kiocb\t\t*iocb,\n\tloff_t\t\t\toffset,\n\tssize_t\t\t\tsize,\n\tvoid\t\t\t*private)\n{\n\tstruct inode\t\t*inode = file_inode(iocb->ki_filp);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn;\n\n\t/*\n\t * While the generic direct I/O code updates the inode size, it does\n\t * so only after the end_io handler is called, which means our\n\t * end_io handler thinks the on-disk size is outside the in-core\n\t * size.  To prevent this just update it a little bit earlier here.\n\t */\n\tif (offset + size > i_size_read(inode))\n\t\ti_size_write(inode, offset + size);\n\n\t/*\n\t * For direct I/O we do not know if we need to allocate blocks or not,\n\t * so we can't preallocate an append transaction, as that results in\n\t * nested reservations and log space deadlocks. Hence allocate the\n\t * transaction here. While this is sub-optimal and can block IO\n\t * completion for some time, we're stuck with doing it this way until\n\t * we can pass the ioend to the direct IO allocation callbacks and\n\t * avoid nesting that way.\n\t */\n\tif (private && size > 0) {\n\t\txfs_iomap_write_unwritten(ip, offset, size);\n\t} else if (offset + size > ip->i_d.di_size) {\n\t\tstruct xfs_trans\t*tp;\n\t\tint\t\t\terror;\n\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_FSYNC_TS);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_fsyncts, 0, 0);\n\t\tif (error) {\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\treturn;\n\t\t}\n\n\t\txfs_setfilesize(ip, tp, offset, size);\n\t}\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_setfilesize",
          "args": [
            "ip",
            "tp",
            "offset",
            "size"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setfilesize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "136-160",
          "snippet": "STATIC int\nxfs_setfilesize(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t*tp,\n\txfs_off_t\t\toffset,\n\tsize_t\t\t\tsize)\n{\n\txfs_fsize_t\t\tisize;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tisize = xfs_new_eof(ip, offset + size);\n\tif (!isize) {\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn 0;\n\t}\n\n\ttrace_xfs_setfilesize(ip, offset, size);\n\n\tip->i_d.di_size = isize;\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\treturn xfs_trans_commit(tp, 0);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_setfilesize(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t*tp,\n\txfs_off_t\t\toffset,\n\tsize_t\t\t\tsize)\n{\n\txfs_fsize_t\t\tisize;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tisize = xfs_new_eof(ip, offset + size);\n\tif (!isize) {\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn 0;\n\t}\n\n\ttrace_xfs_setfilesize(ip, offset, size);\n\n\tip->i_d.di_size = isize;\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\treturn xfs_trans_commit(tp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "0"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_fsyncts",
            "0",
            "0"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_FSYNC_TS"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iomap_write_unwritten",
          "args": [
            "ip",
            "offset",
            "size"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iomap_write_unwritten",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iomap.c",
          "lines": "801-921",
          "snippet": "int\nxfs_iomap_write_unwritten(\n\txfs_inode_t\t*ip,\n\txfs_off_t\toffset,\n\txfs_off_t\tcount)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_fileoff_t\toffset_fsb;\n\txfs_filblks_t\tcount_fsb;\n\txfs_filblks_t\tnumblks_fsb;\n\txfs_fsblock_t\tfirstfsb;\n\tint\t\tnimaps;\n\txfs_trans_t\t*tp;\n\txfs_bmbt_irec_t imap;\n\txfs_bmap_free_t free_list;\n\txfs_fsize_t\ti_size;\n\tuint\t\tresblks;\n\tint\t\tcommitted;\n\tint\t\terror;\n\n\ttrace_xfs_unwritten_convert(ip, offset, count);\n\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\tcount_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + count);\n\tcount_fsb = (xfs_filblks_t)(count_fsb - offset_fsb);\n\n\t/*\n\t * Reserve enough blocks in this transaction for two complete extent\n\t * btree splits.  We may be converting the middle part of an unwritten\n\t * extent and in this case we will insert two new extents in the btree\n\t * each of which could cause a full split.\n\t *\n\t * This reservation amount will be used in the first call to\n\t * xfs_bmbt_split() to select an AG with enough space to satisfy the\n\t * rest of the operation.\n\t */\n\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0) << 1;\n\n\tdo {\n\t\t/*\n\t\t * set up a transaction to convert the range of extents\n\t\t * from unwritten to real. Do allocations in a loop until\n\t\t * we have covered the range passed in.\n\t\t *\n\t\t * Note that we open code the transaction allocation here\n\t\t * to pass KM_NOFS--we can't risk to recursing back into\n\t\t * the filesystem here as we might be asked to write out\n\t\t * the same inode that we complete here and might deadlock\n\t\t * on the iolock.\n\t\t */\n\t\tsb_start_intwrite(mp->m_super);\n\t\ttp = _xfs_trans_alloc(mp, XFS_TRANS_STRAT_WRITE, KM_NOFS);\n\t\ttp->t_flags |= XFS_TRANS_RESERVE | XFS_TRANS_FREEZE_PROT;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\t\t  resblks, 0);\n\t\tif (error) {\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\treturn error;\n\t\t}\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * Modify the unwritten extent state of the buffer.\n\t\t */\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\tnimaps = 1;\n\t\terror = xfs_bmapi_write(tp, ip, offset_fsb, count_fsb,\n\t\t\t\t  XFS_BMAPI_CONVERT, &firstfsb,\n\t\t\t\t  1, &imap, &nimaps, &free_list);\n\t\tif (error)\n\t\t\tgoto error_on_bmapi_transaction;\n\n\t\t/*\n\t\t * Log the updated inode size as we go.  We have to be careful\n\t\t * to only log it up to the actual write offset if it is\n\t\t * halfway into a block.\n\t\t */\n\t\ti_size = XFS_FSB_TO_B(mp, offset_fsb + count_fsb);\n\t\tif (i_size > offset + count)\n\t\t\ti_size = offset + count;\n\n\t\ti_size = xfs_new_eof(ip, i_size);\n\t\tif (i_size) {\n\t\t\tip->i_d.di_size = i_size;\n\t\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t\t}\n\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error)\n\t\t\tgoto error_on_bmapi_transaction;\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (!(imap.br_startblock || XFS_IS_REALTIME_INODE(ip)))\n\t\t\treturn xfs_alert_fsblock_zero(ip, &imap);\n\n\t\tif ((numblks_fsb = imap.br_blockcount) == 0) {\n\t\t\t/*\n\t\t\t * The numblks_fsb value should always get\n\t\t\t * smaller, otherwise the loop is stuck.\n\t\t\t */\n\t\t\tASSERT(imap.br_blockcount);\n\t\t\tbreak;\n\t\t}\n\t\toffset_fsb += numblks_fsb;\n\t\tcount_fsb -= numblks_fsb;\n\t} while (count_fsb > 0);\n\n\treturn 0;\n\nerror_on_bmapi_transaction:\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_cancel(tp, (XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT));\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_iomap_write_unwritten(\n\txfs_inode_t\t*ip,\n\txfs_off_t\toffset,\n\txfs_off_t\tcount)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_fileoff_t\toffset_fsb;\n\txfs_filblks_t\tcount_fsb;\n\txfs_filblks_t\tnumblks_fsb;\n\txfs_fsblock_t\tfirstfsb;\n\tint\t\tnimaps;\n\txfs_trans_t\t*tp;\n\txfs_bmbt_irec_t imap;\n\txfs_bmap_free_t free_list;\n\txfs_fsize_t\ti_size;\n\tuint\t\tresblks;\n\tint\t\tcommitted;\n\tint\t\terror;\n\n\ttrace_xfs_unwritten_convert(ip, offset, count);\n\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\tcount_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + count);\n\tcount_fsb = (xfs_filblks_t)(count_fsb - offset_fsb);\n\n\t/*\n\t * Reserve enough blocks in this transaction for two complete extent\n\t * btree splits.  We may be converting the middle part of an unwritten\n\t * extent and in this case we will insert two new extents in the btree\n\t * each of which could cause a full split.\n\t *\n\t * This reservation amount will be used in the first call to\n\t * xfs_bmbt_split() to select an AG with enough space to satisfy the\n\t * rest of the operation.\n\t */\n\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0) << 1;\n\n\tdo {\n\t\t/*\n\t\t * set up a transaction to convert the range of extents\n\t\t * from unwritten to real. Do allocations in a loop until\n\t\t * we have covered the range passed in.\n\t\t *\n\t\t * Note that we open code the transaction allocation here\n\t\t * to pass KM_NOFS--we can't risk to recursing back into\n\t\t * the filesystem here as we might be asked to write out\n\t\t * the same inode that we complete here and might deadlock\n\t\t * on the iolock.\n\t\t */\n\t\tsb_start_intwrite(mp->m_super);\n\t\ttp = _xfs_trans_alloc(mp, XFS_TRANS_STRAT_WRITE, KM_NOFS);\n\t\ttp->t_flags |= XFS_TRANS_RESERVE | XFS_TRANS_FREEZE_PROT;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\t\t  resblks, 0);\n\t\tif (error) {\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\treturn error;\n\t\t}\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * Modify the unwritten extent state of the buffer.\n\t\t */\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\tnimaps = 1;\n\t\terror = xfs_bmapi_write(tp, ip, offset_fsb, count_fsb,\n\t\t\t\t  XFS_BMAPI_CONVERT, &firstfsb,\n\t\t\t\t  1, &imap, &nimaps, &free_list);\n\t\tif (error)\n\t\t\tgoto error_on_bmapi_transaction;\n\n\t\t/*\n\t\t * Log the updated inode size as we go.  We have to be careful\n\t\t * to only log it up to the actual write offset if it is\n\t\t * halfway into a block.\n\t\t */\n\t\ti_size = XFS_FSB_TO_B(mp, offset_fsb + count_fsb);\n\t\tif (i_size > offset + count)\n\t\t\ti_size = offset + count;\n\n\t\ti_size = xfs_new_eof(ip, i_size);\n\t\tif (i_size) {\n\t\t\tip->i_d.di_size = i_size;\n\t\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t\t}\n\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error)\n\t\t\tgoto error_on_bmapi_transaction;\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (!(imap.br_startblock || XFS_IS_REALTIME_INODE(ip)))\n\t\t\treturn xfs_alert_fsblock_zero(ip, &imap);\n\n\t\tif ((numblks_fsb = imap.br_blockcount) == 0) {\n\t\t\t/*\n\t\t\t * The numblks_fsb value should always get\n\t\t\t * smaller, otherwise the loop is stuck.\n\t\t\t */\n\t\t\tASSERT(imap.br_blockcount);\n\t\t\tbreak;\n\t\t}\n\t\toffset_fsb += numblks_fsb;\n\t\tcount_fsb -= numblks_fsb;\n\t} while (count_fsb > 0);\n\n\treturn 0;\n\nerror_on_bmapi_transaction:\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_cancel(tp, (XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT));\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "offset + size"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "iocb->ki_filp"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_end_io_direct_write(\n\tstruct kiocb\t\t*iocb,\n\tloff_t\t\t\toffset,\n\tssize_t\t\t\tsize,\n\tvoid\t\t\t*private)\n{\n\tstruct inode\t\t*inode = file_inode(iocb->ki_filp);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn;\n\n\t/*\n\t * While the generic direct I/O code updates the inode size, it does\n\t * so only after the end_io handler is called, which means our\n\t * end_io handler thinks the on-disk size is outside the in-core\n\t * size.  To prevent this just update it a little bit earlier here.\n\t */\n\tif (offset + size > i_size_read(inode))\n\t\ti_size_write(inode, offset + size);\n\n\t/*\n\t * For direct I/O we do not know if we need to allocate blocks or not,\n\t * so we can't preallocate an append transaction, as that results in\n\t * nested reservations and log space deadlocks. Hence allocate the\n\t * transaction here. While this is sub-optimal and can block IO\n\t * completion for some time, we're stuck with doing it this way until\n\t * we can pass the ioend to the direct IO allocation callbacks and\n\t * avoid nesting that way.\n\t */\n\tif (private && size > 0) {\n\t\txfs_iomap_write_unwritten(ip, offset, size);\n\t} else if (offset + size > ip->i_d.di_size) {\n\t\tstruct xfs_trans\t*tp;\n\t\tint\t\t\terror;\n\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_FSYNC_TS);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_fsyncts, 0, 0);\n\t\tif (error) {\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\treturn;\n\t\t}\n\n\t\txfs_setfilesize(ip, tp, offset, size);\n\t}\n}"
  },
  {
    "function_name": "xfs_get_blocks_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "1431-1439",
    "snippet": "STATIC int\nxfs_get_blocks_direct(\n\tstruct inode\t\t*inode,\n\tsector_t\t\tiblock,\n\tstruct buffer_head\t*bh_result,\n\tint\t\t\tcreate)\n{\n\treturn __xfs_get_blocks(inode, iblock, bh_result, create, 1);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__xfs_get_blocks",
          "args": [
            "inode",
            "iblock",
            "bh_result",
            "create",
            "1"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_get_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "1236-1419",
          "snippet": "STATIC int\n__xfs_get_blocks(\n\tstruct inode\t\t*inode,\n\tsector_t\t\tiblock,\n\tstruct buffer_head\t*bh_result,\n\tint\t\t\tcreate,\n\tint\t\t\tdirect)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\toffset_fsb, end_fsb;\n\tint\t\t\terror = 0;\n\tint\t\t\tlockmode = 0;\n\tstruct xfs_bmbt_irec\timap;\n\tint\t\t\tnimaps = 1;\n\txfs_off_t\t\toffset;\n\tssize_t\t\t\tsize;\n\tint\t\t\tnew = 0;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\toffset = (xfs_off_t)iblock << inode->i_blkbits;\n\tASSERT(bh_result->b_size >= (1 << inode->i_blkbits));\n\tsize = bh_result->b_size;\n\n\tif (!create && direct && offset >= i_size_read(inode))\n\t\treturn 0;\n\n\t/*\n\t * Direct I/O is usually done on preallocated files, so try getting\n\t * a block mapping without an exclusive lock first.  For buffered\n\t * writes we already have the exclusive iolock anyway, so avoiding\n\t * a lock roundtrip here by taking the ilock exclusive from the\n\t * beginning is a useful micro optimization.\n\t */\n\tif (create && !direct) {\n\t\tlockmode = XFS_ILOCK_EXCL;\n\t\txfs_ilock(ip, lockmode);\n\t} else {\n\t\tlockmode = xfs_ilock_data_map_shared(ip);\n\t}\n\n\tASSERT(offset <= mp->m_super->s_maxbytes);\n\tif (offset + size > mp->m_super->s_maxbytes)\n\t\tsize = mp->m_super->s_maxbytes - offset;\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + size);\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\n\terror = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb,\n\t\t\t\t&imap, &nimaps, XFS_BMAPI_ENTIRE);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tif (create &&\n\t    (!nimaps ||\n\t     (imap.br_startblock == HOLESTARTBLOCK ||\n\t      imap.br_startblock == DELAYSTARTBLOCK))) {\n\t\tif (direct || xfs_get_extsz_hint(ip)) {\n\t\t\t/*\n\t\t\t * Drop the ilock in preparation for starting the block\n\t\t\t * allocation transaction.  It will be retaken\n\t\t\t * exclusively inside xfs_iomap_write_direct for the\n\t\t\t * actual allocation.\n\t\t\t */\n\t\t\txfs_iunlock(ip, lockmode);\n\t\t\terror = xfs_iomap_write_direct(ip, offset, size,\n\t\t\t\t\t\t       &imap, nimaps);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tnew = 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Delalloc reservations do not require a transaction,\n\t\t\t * we can go on without dropping the lock here. If we\n\t\t\t * are allocating a new delalloc block, make sure that\n\t\t\t * we set the new flag so that we mark the buffer new so\n\t\t\t * that we know that it is newly allocated if the write\n\t\t\t * fails.\n\t\t\t */\n\t\t\tif (nimaps && imap.br_startblock == HOLESTARTBLOCK)\n\t\t\t\tnew = 1;\n\t\t\terror = xfs_iomap_write_delay(ip, offset, size, &imap);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock;\n\n\t\t\txfs_iunlock(ip, lockmode);\n\t\t}\n\n\t\ttrace_xfs_get_blocks_alloc(ip, offset, size, 0, &imap);\n\t} else if (nimaps) {\n\t\ttrace_xfs_get_blocks_found(ip, offset, size, 0, &imap);\n\t\txfs_iunlock(ip, lockmode);\n\t} else {\n\t\ttrace_xfs_get_blocks_notfound(ip, offset, size);\n\t\tgoto out_unlock;\n\t}\n\n\tif (imap.br_startblock != HOLESTARTBLOCK &&\n\t    imap.br_startblock != DELAYSTARTBLOCK) {\n\t\t/*\n\t\t * For unwritten extents do not report a disk address on\n\t\t * the read case (treat as if we're reading into a hole).\n\t\t */\n\t\tif (create || !ISUNWRITTEN(&imap))\n\t\t\txfs_map_buffer(inode, bh_result, &imap, offset);\n\t\tif (create && ISUNWRITTEN(&imap)) {\n\t\t\tif (direct) {\n\t\t\t\tbh_result->b_private = inode;\n\t\t\t\tset_buffer_defer_completion(bh_result);\n\t\t\t}\n\t\t\tset_buffer_unwritten(bh_result);\n\t\t}\n\t}\n\n\t/*\n\t * If this is a realtime file, data may be on a different device.\n\t * to that pointed to from the buffer_head b_bdev currently.\n\t */\n\tbh_result->b_bdev = xfs_find_bdev_for_inode(inode);\n\n\t/*\n\t * If we previously allocated a block out beyond eof and we are now\n\t * coming back to use it then we will need to flag it as new even if it\n\t * has a disk address.\n\t *\n\t * With sub-block writes into unwritten extents we also need to mark\n\t * the buffer as new so that the unwritten parts of the buffer gets\n\t * correctly zeroed.\n\t */\n\tif (create &&\n\t    ((!buffer_mapped(bh_result) && !buffer_uptodate(bh_result)) ||\n\t     (offset >= i_size_read(inode)) ||\n\t     (new || ISUNWRITTEN(&imap))))\n\t\tset_buffer_new(bh_result);\n\n\tif (imap.br_startblock == DELAYSTARTBLOCK) {\n\t\tBUG_ON(direct);\n\t\tif (create) {\n\t\t\tset_buffer_uptodate(bh_result);\n\t\t\tset_buffer_mapped(bh_result);\n\t\t\tset_buffer_delay(bh_result);\n\t\t}\n\t}\n\n\t/*\n\t * If this is O_DIRECT or the mpage code calling tell them how large\n\t * the mapping is, so that we can avoid repeated get_blocks calls.\n\t *\n\t * If the mapping spans EOF, then we have to break the mapping up as the\n\t * mapping for blocks beyond EOF must be marked new so that sub block\n\t * regions can be correctly zeroed. We can't do this for mappings within\n\t * EOF unless the mapping was just allocated or is unwritten, otherwise\n\t * the callers would overwrite existing data with zeros. Hence we have\n\t * to split the mapping into a range up to and including EOF, and a\n\t * second mapping for beyond EOF.\n\t */\n\tif (direct || size > (1 << inode->i_blkbits)) {\n\t\txfs_off_t\t\tmapping_size;\n\n\t\tmapping_size = imap.br_startoff + imap.br_blockcount - iblock;\n\t\tmapping_size <<= inode->i_blkbits;\n\n\t\tASSERT(mapping_size > 0);\n\t\tif (mapping_size > size)\n\t\t\tmapping_size = size;\n\t\tif (offset < i_size_read(inode) &&\n\t\t    offset + mapping_size >= i_size_read(inode)) {\n\t\t\t/* limit mapping to block that spans EOF */\n\t\t\tmapping_size = roundup_64(i_size_read(inode) - offset,\n\t\t\t\t\t\t  1 << inode->i_blkbits);\n\t\t}\n\t\tif (mapping_size > LONG_MAX)\n\t\t\tmapping_size = LONG_MAX;\n\n\t\tbh_result->b_size = mapping_size;\n\t}\n\n\treturn 0;\n\nout_unlock:\n\txfs_iunlock(ip, lockmode);\n\treturn error;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\n__xfs_get_blocks(\n\tstruct inode\t\t*inode,\n\tsector_t\t\tiblock,\n\tstruct buffer_head\t*bh_result,\n\tint\t\t\tcreate,\n\tint\t\t\tdirect)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\toffset_fsb, end_fsb;\n\tint\t\t\terror = 0;\n\tint\t\t\tlockmode = 0;\n\tstruct xfs_bmbt_irec\timap;\n\tint\t\t\tnimaps = 1;\n\txfs_off_t\t\toffset;\n\tssize_t\t\t\tsize;\n\tint\t\t\tnew = 0;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\toffset = (xfs_off_t)iblock << inode->i_blkbits;\n\tASSERT(bh_result->b_size >= (1 << inode->i_blkbits));\n\tsize = bh_result->b_size;\n\n\tif (!create && direct && offset >= i_size_read(inode))\n\t\treturn 0;\n\n\t/*\n\t * Direct I/O is usually done on preallocated files, so try getting\n\t * a block mapping without an exclusive lock first.  For buffered\n\t * writes we already have the exclusive iolock anyway, so avoiding\n\t * a lock roundtrip here by taking the ilock exclusive from the\n\t * beginning is a useful micro optimization.\n\t */\n\tif (create && !direct) {\n\t\tlockmode = XFS_ILOCK_EXCL;\n\t\txfs_ilock(ip, lockmode);\n\t} else {\n\t\tlockmode = xfs_ilock_data_map_shared(ip);\n\t}\n\n\tASSERT(offset <= mp->m_super->s_maxbytes);\n\tif (offset + size > mp->m_super->s_maxbytes)\n\t\tsize = mp->m_super->s_maxbytes - offset;\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + size);\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\n\terror = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb,\n\t\t\t\t&imap, &nimaps, XFS_BMAPI_ENTIRE);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tif (create &&\n\t    (!nimaps ||\n\t     (imap.br_startblock == HOLESTARTBLOCK ||\n\t      imap.br_startblock == DELAYSTARTBLOCK))) {\n\t\tif (direct || xfs_get_extsz_hint(ip)) {\n\t\t\t/*\n\t\t\t * Drop the ilock in preparation for starting the block\n\t\t\t * allocation transaction.  It will be retaken\n\t\t\t * exclusively inside xfs_iomap_write_direct for the\n\t\t\t * actual allocation.\n\t\t\t */\n\t\t\txfs_iunlock(ip, lockmode);\n\t\t\terror = xfs_iomap_write_direct(ip, offset, size,\n\t\t\t\t\t\t       &imap, nimaps);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tnew = 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Delalloc reservations do not require a transaction,\n\t\t\t * we can go on without dropping the lock here. If we\n\t\t\t * are allocating a new delalloc block, make sure that\n\t\t\t * we set the new flag so that we mark the buffer new so\n\t\t\t * that we know that it is newly allocated if the write\n\t\t\t * fails.\n\t\t\t */\n\t\t\tif (nimaps && imap.br_startblock == HOLESTARTBLOCK)\n\t\t\t\tnew = 1;\n\t\t\terror = xfs_iomap_write_delay(ip, offset, size, &imap);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock;\n\n\t\t\txfs_iunlock(ip, lockmode);\n\t\t}\n\n\t\ttrace_xfs_get_blocks_alloc(ip, offset, size, 0, &imap);\n\t} else if (nimaps) {\n\t\ttrace_xfs_get_blocks_found(ip, offset, size, 0, &imap);\n\t\txfs_iunlock(ip, lockmode);\n\t} else {\n\t\ttrace_xfs_get_blocks_notfound(ip, offset, size);\n\t\tgoto out_unlock;\n\t}\n\n\tif (imap.br_startblock != HOLESTARTBLOCK &&\n\t    imap.br_startblock != DELAYSTARTBLOCK) {\n\t\t/*\n\t\t * For unwritten extents do not report a disk address on\n\t\t * the read case (treat as if we're reading into a hole).\n\t\t */\n\t\tif (create || !ISUNWRITTEN(&imap))\n\t\t\txfs_map_buffer(inode, bh_result, &imap, offset);\n\t\tif (create && ISUNWRITTEN(&imap)) {\n\t\t\tif (direct) {\n\t\t\t\tbh_result->b_private = inode;\n\t\t\t\tset_buffer_defer_completion(bh_result);\n\t\t\t}\n\t\t\tset_buffer_unwritten(bh_result);\n\t\t}\n\t}\n\n\t/*\n\t * If this is a realtime file, data may be on a different device.\n\t * to that pointed to from the buffer_head b_bdev currently.\n\t */\n\tbh_result->b_bdev = xfs_find_bdev_for_inode(inode);\n\n\t/*\n\t * If we previously allocated a block out beyond eof and we are now\n\t * coming back to use it then we will need to flag it as new even if it\n\t * has a disk address.\n\t *\n\t * With sub-block writes into unwritten extents we also need to mark\n\t * the buffer as new so that the unwritten parts of the buffer gets\n\t * correctly zeroed.\n\t */\n\tif (create &&\n\t    ((!buffer_mapped(bh_result) && !buffer_uptodate(bh_result)) ||\n\t     (offset >= i_size_read(inode)) ||\n\t     (new || ISUNWRITTEN(&imap))))\n\t\tset_buffer_new(bh_result);\n\n\tif (imap.br_startblock == DELAYSTARTBLOCK) {\n\t\tBUG_ON(direct);\n\t\tif (create) {\n\t\t\tset_buffer_uptodate(bh_result);\n\t\t\tset_buffer_mapped(bh_result);\n\t\t\tset_buffer_delay(bh_result);\n\t\t}\n\t}\n\n\t/*\n\t * If this is O_DIRECT or the mpage code calling tell them how large\n\t * the mapping is, so that we can avoid repeated get_blocks calls.\n\t *\n\t * If the mapping spans EOF, then we have to break the mapping up as the\n\t * mapping for blocks beyond EOF must be marked new so that sub block\n\t * regions can be correctly zeroed. We can't do this for mappings within\n\t * EOF unless the mapping was just allocated or is unwritten, otherwise\n\t * the callers would overwrite existing data with zeros. Hence we have\n\t * to split the mapping into a range up to and including EOF, and a\n\t * second mapping for beyond EOF.\n\t */\n\tif (direct || size > (1 << inode->i_blkbits)) {\n\t\txfs_off_t\t\tmapping_size;\n\n\t\tmapping_size = imap.br_startoff + imap.br_blockcount - iblock;\n\t\tmapping_size <<= inode->i_blkbits;\n\n\t\tASSERT(mapping_size > 0);\n\t\tif (mapping_size > size)\n\t\t\tmapping_size = size;\n\t\tif (offset < i_size_read(inode) &&\n\t\t    offset + mapping_size >= i_size_read(inode)) {\n\t\t\t/* limit mapping to block that spans EOF */\n\t\t\tmapping_size = roundup_64(i_size_read(inode) - offset,\n\t\t\t\t\t\t  1 << inode->i_blkbits);\n\t\t}\n\t\tif (mapping_size > LONG_MAX)\n\t\t\tmapping_size = LONG_MAX;\n\n\t\tbh_result->b_size = mapping_size;\n\t}\n\n\treturn 0;\n\nout_unlock:\n\txfs_iunlock(ip, lockmode);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_get_blocks_direct(\n\tstruct inode\t\t*inode,\n\tsector_t\t\tiblock,\n\tstruct buffer_head\t*bh_result,\n\tint\t\t\tcreate)\n{\n\treturn __xfs_get_blocks(inode, iblock, bh_result, create, 1);\n}"
  },
  {
    "function_name": "xfs_get_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "1421-1429",
    "snippet": "int\nxfs_get_blocks(\n\tstruct inode\t\t*inode,\n\tsector_t\t\tiblock,\n\tstruct buffer_head\t*bh_result,\n\tint\t\t\tcreate)\n{\n\treturn __xfs_get_blocks(inode, iblock, bh_result, create, 0);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__xfs_get_blocks",
          "args": [
            "inode",
            "iblock",
            "bh_result",
            "create",
            "0"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_get_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "1236-1419",
          "snippet": "STATIC int\n__xfs_get_blocks(\n\tstruct inode\t\t*inode,\n\tsector_t\t\tiblock,\n\tstruct buffer_head\t*bh_result,\n\tint\t\t\tcreate,\n\tint\t\t\tdirect)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\toffset_fsb, end_fsb;\n\tint\t\t\terror = 0;\n\tint\t\t\tlockmode = 0;\n\tstruct xfs_bmbt_irec\timap;\n\tint\t\t\tnimaps = 1;\n\txfs_off_t\t\toffset;\n\tssize_t\t\t\tsize;\n\tint\t\t\tnew = 0;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\toffset = (xfs_off_t)iblock << inode->i_blkbits;\n\tASSERT(bh_result->b_size >= (1 << inode->i_blkbits));\n\tsize = bh_result->b_size;\n\n\tif (!create && direct && offset >= i_size_read(inode))\n\t\treturn 0;\n\n\t/*\n\t * Direct I/O is usually done on preallocated files, so try getting\n\t * a block mapping without an exclusive lock first.  For buffered\n\t * writes we already have the exclusive iolock anyway, so avoiding\n\t * a lock roundtrip here by taking the ilock exclusive from the\n\t * beginning is a useful micro optimization.\n\t */\n\tif (create && !direct) {\n\t\tlockmode = XFS_ILOCK_EXCL;\n\t\txfs_ilock(ip, lockmode);\n\t} else {\n\t\tlockmode = xfs_ilock_data_map_shared(ip);\n\t}\n\n\tASSERT(offset <= mp->m_super->s_maxbytes);\n\tif (offset + size > mp->m_super->s_maxbytes)\n\t\tsize = mp->m_super->s_maxbytes - offset;\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + size);\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\n\terror = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb,\n\t\t\t\t&imap, &nimaps, XFS_BMAPI_ENTIRE);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tif (create &&\n\t    (!nimaps ||\n\t     (imap.br_startblock == HOLESTARTBLOCK ||\n\t      imap.br_startblock == DELAYSTARTBLOCK))) {\n\t\tif (direct || xfs_get_extsz_hint(ip)) {\n\t\t\t/*\n\t\t\t * Drop the ilock in preparation for starting the block\n\t\t\t * allocation transaction.  It will be retaken\n\t\t\t * exclusively inside xfs_iomap_write_direct for the\n\t\t\t * actual allocation.\n\t\t\t */\n\t\t\txfs_iunlock(ip, lockmode);\n\t\t\terror = xfs_iomap_write_direct(ip, offset, size,\n\t\t\t\t\t\t       &imap, nimaps);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tnew = 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Delalloc reservations do not require a transaction,\n\t\t\t * we can go on without dropping the lock here. If we\n\t\t\t * are allocating a new delalloc block, make sure that\n\t\t\t * we set the new flag so that we mark the buffer new so\n\t\t\t * that we know that it is newly allocated if the write\n\t\t\t * fails.\n\t\t\t */\n\t\t\tif (nimaps && imap.br_startblock == HOLESTARTBLOCK)\n\t\t\t\tnew = 1;\n\t\t\terror = xfs_iomap_write_delay(ip, offset, size, &imap);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock;\n\n\t\t\txfs_iunlock(ip, lockmode);\n\t\t}\n\n\t\ttrace_xfs_get_blocks_alloc(ip, offset, size, 0, &imap);\n\t} else if (nimaps) {\n\t\ttrace_xfs_get_blocks_found(ip, offset, size, 0, &imap);\n\t\txfs_iunlock(ip, lockmode);\n\t} else {\n\t\ttrace_xfs_get_blocks_notfound(ip, offset, size);\n\t\tgoto out_unlock;\n\t}\n\n\tif (imap.br_startblock != HOLESTARTBLOCK &&\n\t    imap.br_startblock != DELAYSTARTBLOCK) {\n\t\t/*\n\t\t * For unwritten extents do not report a disk address on\n\t\t * the read case (treat as if we're reading into a hole).\n\t\t */\n\t\tif (create || !ISUNWRITTEN(&imap))\n\t\t\txfs_map_buffer(inode, bh_result, &imap, offset);\n\t\tif (create && ISUNWRITTEN(&imap)) {\n\t\t\tif (direct) {\n\t\t\t\tbh_result->b_private = inode;\n\t\t\t\tset_buffer_defer_completion(bh_result);\n\t\t\t}\n\t\t\tset_buffer_unwritten(bh_result);\n\t\t}\n\t}\n\n\t/*\n\t * If this is a realtime file, data may be on a different device.\n\t * to that pointed to from the buffer_head b_bdev currently.\n\t */\n\tbh_result->b_bdev = xfs_find_bdev_for_inode(inode);\n\n\t/*\n\t * If we previously allocated a block out beyond eof and we are now\n\t * coming back to use it then we will need to flag it as new even if it\n\t * has a disk address.\n\t *\n\t * With sub-block writes into unwritten extents we also need to mark\n\t * the buffer as new so that the unwritten parts of the buffer gets\n\t * correctly zeroed.\n\t */\n\tif (create &&\n\t    ((!buffer_mapped(bh_result) && !buffer_uptodate(bh_result)) ||\n\t     (offset >= i_size_read(inode)) ||\n\t     (new || ISUNWRITTEN(&imap))))\n\t\tset_buffer_new(bh_result);\n\n\tif (imap.br_startblock == DELAYSTARTBLOCK) {\n\t\tBUG_ON(direct);\n\t\tif (create) {\n\t\t\tset_buffer_uptodate(bh_result);\n\t\t\tset_buffer_mapped(bh_result);\n\t\t\tset_buffer_delay(bh_result);\n\t\t}\n\t}\n\n\t/*\n\t * If this is O_DIRECT or the mpage code calling tell them how large\n\t * the mapping is, so that we can avoid repeated get_blocks calls.\n\t *\n\t * If the mapping spans EOF, then we have to break the mapping up as the\n\t * mapping for blocks beyond EOF must be marked new so that sub block\n\t * regions can be correctly zeroed. We can't do this for mappings within\n\t * EOF unless the mapping was just allocated or is unwritten, otherwise\n\t * the callers would overwrite existing data with zeros. Hence we have\n\t * to split the mapping into a range up to and including EOF, and a\n\t * second mapping for beyond EOF.\n\t */\n\tif (direct || size > (1 << inode->i_blkbits)) {\n\t\txfs_off_t\t\tmapping_size;\n\n\t\tmapping_size = imap.br_startoff + imap.br_blockcount - iblock;\n\t\tmapping_size <<= inode->i_blkbits;\n\n\t\tASSERT(mapping_size > 0);\n\t\tif (mapping_size > size)\n\t\t\tmapping_size = size;\n\t\tif (offset < i_size_read(inode) &&\n\t\t    offset + mapping_size >= i_size_read(inode)) {\n\t\t\t/* limit mapping to block that spans EOF */\n\t\t\tmapping_size = roundup_64(i_size_read(inode) - offset,\n\t\t\t\t\t\t  1 << inode->i_blkbits);\n\t\t}\n\t\tif (mapping_size > LONG_MAX)\n\t\t\tmapping_size = LONG_MAX;\n\n\t\tbh_result->b_size = mapping_size;\n\t}\n\n\treturn 0;\n\nout_unlock:\n\txfs_iunlock(ip, lockmode);\n\treturn error;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\n__xfs_get_blocks(\n\tstruct inode\t\t*inode,\n\tsector_t\t\tiblock,\n\tstruct buffer_head\t*bh_result,\n\tint\t\t\tcreate,\n\tint\t\t\tdirect)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\toffset_fsb, end_fsb;\n\tint\t\t\terror = 0;\n\tint\t\t\tlockmode = 0;\n\tstruct xfs_bmbt_irec\timap;\n\tint\t\t\tnimaps = 1;\n\txfs_off_t\t\toffset;\n\tssize_t\t\t\tsize;\n\tint\t\t\tnew = 0;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\toffset = (xfs_off_t)iblock << inode->i_blkbits;\n\tASSERT(bh_result->b_size >= (1 << inode->i_blkbits));\n\tsize = bh_result->b_size;\n\n\tif (!create && direct && offset >= i_size_read(inode))\n\t\treturn 0;\n\n\t/*\n\t * Direct I/O is usually done on preallocated files, so try getting\n\t * a block mapping without an exclusive lock first.  For buffered\n\t * writes we already have the exclusive iolock anyway, so avoiding\n\t * a lock roundtrip here by taking the ilock exclusive from the\n\t * beginning is a useful micro optimization.\n\t */\n\tif (create && !direct) {\n\t\tlockmode = XFS_ILOCK_EXCL;\n\t\txfs_ilock(ip, lockmode);\n\t} else {\n\t\tlockmode = xfs_ilock_data_map_shared(ip);\n\t}\n\n\tASSERT(offset <= mp->m_super->s_maxbytes);\n\tif (offset + size > mp->m_super->s_maxbytes)\n\t\tsize = mp->m_super->s_maxbytes - offset;\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + size);\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\n\terror = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb,\n\t\t\t\t&imap, &nimaps, XFS_BMAPI_ENTIRE);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tif (create &&\n\t    (!nimaps ||\n\t     (imap.br_startblock == HOLESTARTBLOCK ||\n\t      imap.br_startblock == DELAYSTARTBLOCK))) {\n\t\tif (direct || xfs_get_extsz_hint(ip)) {\n\t\t\t/*\n\t\t\t * Drop the ilock in preparation for starting the block\n\t\t\t * allocation transaction.  It will be retaken\n\t\t\t * exclusively inside xfs_iomap_write_direct for the\n\t\t\t * actual allocation.\n\t\t\t */\n\t\t\txfs_iunlock(ip, lockmode);\n\t\t\terror = xfs_iomap_write_direct(ip, offset, size,\n\t\t\t\t\t\t       &imap, nimaps);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tnew = 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Delalloc reservations do not require a transaction,\n\t\t\t * we can go on without dropping the lock here. If we\n\t\t\t * are allocating a new delalloc block, make sure that\n\t\t\t * we set the new flag so that we mark the buffer new so\n\t\t\t * that we know that it is newly allocated if the write\n\t\t\t * fails.\n\t\t\t */\n\t\t\tif (nimaps && imap.br_startblock == HOLESTARTBLOCK)\n\t\t\t\tnew = 1;\n\t\t\terror = xfs_iomap_write_delay(ip, offset, size, &imap);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock;\n\n\t\t\txfs_iunlock(ip, lockmode);\n\t\t}\n\n\t\ttrace_xfs_get_blocks_alloc(ip, offset, size, 0, &imap);\n\t} else if (nimaps) {\n\t\ttrace_xfs_get_blocks_found(ip, offset, size, 0, &imap);\n\t\txfs_iunlock(ip, lockmode);\n\t} else {\n\t\ttrace_xfs_get_blocks_notfound(ip, offset, size);\n\t\tgoto out_unlock;\n\t}\n\n\tif (imap.br_startblock != HOLESTARTBLOCK &&\n\t    imap.br_startblock != DELAYSTARTBLOCK) {\n\t\t/*\n\t\t * For unwritten extents do not report a disk address on\n\t\t * the read case (treat as if we're reading into a hole).\n\t\t */\n\t\tif (create || !ISUNWRITTEN(&imap))\n\t\t\txfs_map_buffer(inode, bh_result, &imap, offset);\n\t\tif (create && ISUNWRITTEN(&imap)) {\n\t\t\tif (direct) {\n\t\t\t\tbh_result->b_private = inode;\n\t\t\t\tset_buffer_defer_completion(bh_result);\n\t\t\t}\n\t\t\tset_buffer_unwritten(bh_result);\n\t\t}\n\t}\n\n\t/*\n\t * If this is a realtime file, data may be on a different device.\n\t * to that pointed to from the buffer_head b_bdev currently.\n\t */\n\tbh_result->b_bdev = xfs_find_bdev_for_inode(inode);\n\n\t/*\n\t * If we previously allocated a block out beyond eof and we are now\n\t * coming back to use it then we will need to flag it as new even if it\n\t * has a disk address.\n\t *\n\t * With sub-block writes into unwritten extents we also need to mark\n\t * the buffer as new so that the unwritten parts of the buffer gets\n\t * correctly zeroed.\n\t */\n\tif (create &&\n\t    ((!buffer_mapped(bh_result) && !buffer_uptodate(bh_result)) ||\n\t     (offset >= i_size_read(inode)) ||\n\t     (new || ISUNWRITTEN(&imap))))\n\t\tset_buffer_new(bh_result);\n\n\tif (imap.br_startblock == DELAYSTARTBLOCK) {\n\t\tBUG_ON(direct);\n\t\tif (create) {\n\t\t\tset_buffer_uptodate(bh_result);\n\t\t\tset_buffer_mapped(bh_result);\n\t\t\tset_buffer_delay(bh_result);\n\t\t}\n\t}\n\n\t/*\n\t * If this is O_DIRECT or the mpage code calling tell them how large\n\t * the mapping is, so that we can avoid repeated get_blocks calls.\n\t *\n\t * If the mapping spans EOF, then we have to break the mapping up as the\n\t * mapping for blocks beyond EOF must be marked new so that sub block\n\t * regions can be correctly zeroed. We can't do this for mappings within\n\t * EOF unless the mapping was just allocated or is unwritten, otherwise\n\t * the callers would overwrite existing data with zeros. Hence we have\n\t * to split the mapping into a range up to and including EOF, and a\n\t * second mapping for beyond EOF.\n\t */\n\tif (direct || size > (1 << inode->i_blkbits)) {\n\t\txfs_off_t\t\tmapping_size;\n\n\t\tmapping_size = imap.br_startoff + imap.br_blockcount - iblock;\n\t\tmapping_size <<= inode->i_blkbits;\n\n\t\tASSERT(mapping_size > 0);\n\t\tif (mapping_size > size)\n\t\t\tmapping_size = size;\n\t\tif (offset < i_size_read(inode) &&\n\t\t    offset + mapping_size >= i_size_read(inode)) {\n\t\t\t/* limit mapping to block that spans EOF */\n\t\t\tmapping_size = roundup_64(i_size_read(inode) - offset,\n\t\t\t\t\t\t  1 << inode->i_blkbits);\n\t\t}\n\t\tif (mapping_size > LONG_MAX)\n\t\t\tmapping_size = LONG_MAX;\n\n\t\tbh_result->b_size = mapping_size;\n\t}\n\n\treturn 0;\n\nout_unlock:\n\txfs_iunlock(ip, lockmode);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_get_blocks(\n\tstruct inode\t\t*inode,\n\tsector_t\t\tiblock,\n\tstruct buffer_head\t*bh_result,\n\tint\t\t\tcreate)\n{\n\treturn __xfs_get_blocks(inode, iblock, bh_result, create, 0);\n}"
  },
  {
    "function_name": "__xfs_get_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "1236-1419",
    "snippet": "STATIC int\n__xfs_get_blocks(\n\tstruct inode\t\t*inode,\n\tsector_t\t\tiblock,\n\tstruct buffer_head\t*bh_result,\n\tint\t\t\tcreate,\n\tint\t\t\tdirect)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\toffset_fsb, end_fsb;\n\tint\t\t\terror = 0;\n\tint\t\t\tlockmode = 0;\n\tstruct xfs_bmbt_irec\timap;\n\tint\t\t\tnimaps = 1;\n\txfs_off_t\t\toffset;\n\tssize_t\t\t\tsize;\n\tint\t\t\tnew = 0;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\toffset = (xfs_off_t)iblock << inode->i_blkbits;\n\tASSERT(bh_result->b_size >= (1 << inode->i_blkbits));\n\tsize = bh_result->b_size;\n\n\tif (!create && direct && offset >= i_size_read(inode))\n\t\treturn 0;\n\n\t/*\n\t * Direct I/O is usually done on preallocated files, so try getting\n\t * a block mapping without an exclusive lock first.  For buffered\n\t * writes we already have the exclusive iolock anyway, so avoiding\n\t * a lock roundtrip here by taking the ilock exclusive from the\n\t * beginning is a useful micro optimization.\n\t */\n\tif (create && !direct) {\n\t\tlockmode = XFS_ILOCK_EXCL;\n\t\txfs_ilock(ip, lockmode);\n\t} else {\n\t\tlockmode = xfs_ilock_data_map_shared(ip);\n\t}\n\n\tASSERT(offset <= mp->m_super->s_maxbytes);\n\tif (offset + size > mp->m_super->s_maxbytes)\n\t\tsize = mp->m_super->s_maxbytes - offset;\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + size);\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\n\terror = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb,\n\t\t\t\t&imap, &nimaps, XFS_BMAPI_ENTIRE);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tif (create &&\n\t    (!nimaps ||\n\t     (imap.br_startblock == HOLESTARTBLOCK ||\n\t      imap.br_startblock == DELAYSTARTBLOCK))) {\n\t\tif (direct || xfs_get_extsz_hint(ip)) {\n\t\t\t/*\n\t\t\t * Drop the ilock in preparation for starting the block\n\t\t\t * allocation transaction.  It will be retaken\n\t\t\t * exclusively inside xfs_iomap_write_direct for the\n\t\t\t * actual allocation.\n\t\t\t */\n\t\t\txfs_iunlock(ip, lockmode);\n\t\t\terror = xfs_iomap_write_direct(ip, offset, size,\n\t\t\t\t\t\t       &imap, nimaps);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tnew = 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Delalloc reservations do not require a transaction,\n\t\t\t * we can go on without dropping the lock here. If we\n\t\t\t * are allocating a new delalloc block, make sure that\n\t\t\t * we set the new flag so that we mark the buffer new so\n\t\t\t * that we know that it is newly allocated if the write\n\t\t\t * fails.\n\t\t\t */\n\t\t\tif (nimaps && imap.br_startblock == HOLESTARTBLOCK)\n\t\t\t\tnew = 1;\n\t\t\terror = xfs_iomap_write_delay(ip, offset, size, &imap);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock;\n\n\t\t\txfs_iunlock(ip, lockmode);\n\t\t}\n\n\t\ttrace_xfs_get_blocks_alloc(ip, offset, size, 0, &imap);\n\t} else if (nimaps) {\n\t\ttrace_xfs_get_blocks_found(ip, offset, size, 0, &imap);\n\t\txfs_iunlock(ip, lockmode);\n\t} else {\n\t\ttrace_xfs_get_blocks_notfound(ip, offset, size);\n\t\tgoto out_unlock;\n\t}\n\n\tif (imap.br_startblock != HOLESTARTBLOCK &&\n\t    imap.br_startblock != DELAYSTARTBLOCK) {\n\t\t/*\n\t\t * For unwritten extents do not report a disk address on\n\t\t * the read case (treat as if we're reading into a hole).\n\t\t */\n\t\tif (create || !ISUNWRITTEN(&imap))\n\t\t\txfs_map_buffer(inode, bh_result, &imap, offset);\n\t\tif (create && ISUNWRITTEN(&imap)) {\n\t\t\tif (direct) {\n\t\t\t\tbh_result->b_private = inode;\n\t\t\t\tset_buffer_defer_completion(bh_result);\n\t\t\t}\n\t\t\tset_buffer_unwritten(bh_result);\n\t\t}\n\t}\n\n\t/*\n\t * If this is a realtime file, data may be on a different device.\n\t * to that pointed to from the buffer_head b_bdev currently.\n\t */\n\tbh_result->b_bdev = xfs_find_bdev_for_inode(inode);\n\n\t/*\n\t * If we previously allocated a block out beyond eof and we are now\n\t * coming back to use it then we will need to flag it as new even if it\n\t * has a disk address.\n\t *\n\t * With sub-block writes into unwritten extents we also need to mark\n\t * the buffer as new so that the unwritten parts of the buffer gets\n\t * correctly zeroed.\n\t */\n\tif (create &&\n\t    ((!buffer_mapped(bh_result) && !buffer_uptodate(bh_result)) ||\n\t     (offset >= i_size_read(inode)) ||\n\t     (new || ISUNWRITTEN(&imap))))\n\t\tset_buffer_new(bh_result);\n\n\tif (imap.br_startblock == DELAYSTARTBLOCK) {\n\t\tBUG_ON(direct);\n\t\tif (create) {\n\t\t\tset_buffer_uptodate(bh_result);\n\t\t\tset_buffer_mapped(bh_result);\n\t\t\tset_buffer_delay(bh_result);\n\t\t}\n\t}\n\n\t/*\n\t * If this is O_DIRECT or the mpage code calling tell them how large\n\t * the mapping is, so that we can avoid repeated get_blocks calls.\n\t *\n\t * If the mapping spans EOF, then we have to break the mapping up as the\n\t * mapping for blocks beyond EOF must be marked new so that sub block\n\t * regions can be correctly zeroed. We can't do this for mappings within\n\t * EOF unless the mapping was just allocated or is unwritten, otherwise\n\t * the callers would overwrite existing data with zeros. Hence we have\n\t * to split the mapping into a range up to and including EOF, and a\n\t * second mapping for beyond EOF.\n\t */\n\tif (direct || size > (1 << inode->i_blkbits)) {\n\t\txfs_off_t\t\tmapping_size;\n\n\t\tmapping_size = imap.br_startoff + imap.br_blockcount - iblock;\n\t\tmapping_size <<= inode->i_blkbits;\n\n\t\tASSERT(mapping_size > 0);\n\t\tif (mapping_size > size)\n\t\t\tmapping_size = size;\n\t\tif (offset < i_size_read(inode) &&\n\t\t    offset + mapping_size >= i_size_read(inode)) {\n\t\t\t/* limit mapping to block that spans EOF */\n\t\t\tmapping_size = roundup_64(i_size_read(inode) - offset,\n\t\t\t\t\t\t  1 << inode->i_blkbits);\n\t\t}\n\t\tif (mapping_size > LONG_MAX)\n\t\t\tmapping_size = LONG_MAX;\n\n\t\tbh_result->b_size = mapping_size;\n\t}\n\n\treturn 0;\n\nout_unlock:\n\txfs_iunlock(ip, lockmode);\n\treturn error;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "lockmode"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup_64",
          "args": [
            "i_size_read(inode) - offset",
            "1 << inode->i_blkbits"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mapping_size > 0"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_delay",
          "args": [
            "bh_result"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh_result"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh_result"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "direct"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISUNWRITTEN",
          "args": [
            "&imap"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh_result"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_find_bdev_for_inode",
          "args": [
            "inode"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_find_bdev_for_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "59-70",
          "snippet": "block_device *\nxfs_find_bdev_for_inode(\n\tstruct inode\t\t*inode)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn mp->m_rtdev_targp->bt_bdev;\n\telse\n\t\treturn mp->m_ddev_targp->bt_bdev;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nblock_device *\nxfs_find_bdev_for_inode(\n\tstruct inode\t\t*inode)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn mp->m_rtdev_targp->bt_bdev;\n\telse\n\t\treturn mp->m_ddev_targp->bt_bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_unwritten",
          "args": [
            "bh_result"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_defer_completion",
          "args": [
            "bh_result"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISUNWRITTEN",
          "args": [
            "&imap"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_map_buffer",
          "args": [
            "inode",
            "bh_result",
            "&imap",
            "offset"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_map_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "594-616",
          "snippet": "STATIC void\nxfs_map_buffer(\n\tstruct inode\t\t*inode,\n\tstruct buffer_head\t*bh,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_off_t\t\toffset)\n{\n\tsector_t\t\tbn;\n\tstruct xfs_mount\t*m = XFS_I(inode)->i_mount;\n\txfs_off_t\t\tiomap_offset = XFS_FSB_TO_B(m, imap->br_startoff);\n\txfs_daddr_t\t\tiomap_bn = xfs_fsb_to_db(XFS_I(inode), imap->br_startblock);\n\n\tASSERT(imap->br_startblock != HOLESTARTBLOCK);\n\tASSERT(imap->br_startblock != DELAYSTARTBLOCK);\n\n\tbn = (iomap_bn >> (inode->i_blkbits - BBSHIFT)) +\n\t      ((offset - iomap_offset) >> inode->i_blkbits);\n\n\tASSERT(bn || XFS_IS_REALTIME_INODE(XFS_I(inode)));\n\n\tbh->b_blocknr = bn;\n\tset_buffer_mapped(bh);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_map_buffer(\n\tstruct inode\t\t*inode,\n\tstruct buffer_head\t*bh,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_off_t\t\toffset)\n{\n\tsector_t\t\tbn;\n\tstruct xfs_mount\t*m = XFS_I(inode)->i_mount;\n\txfs_off_t\t\tiomap_offset = XFS_FSB_TO_B(m, imap->br_startoff);\n\txfs_daddr_t\t\tiomap_bn = xfs_fsb_to_db(XFS_I(inode), imap->br_startblock);\n\n\tASSERT(imap->br_startblock != HOLESTARTBLOCK);\n\tASSERT(imap->br_startblock != DELAYSTARTBLOCK);\n\n\tbn = (iomap_bn >> (inode->i_blkbits - BBSHIFT)) +\n\t      ((offset - iomap_offset) >> inode->i_blkbits);\n\n\tASSERT(bn || XFS_IS_REALTIME_INODE(XFS_I(inode)));\n\n\tbh->b_blocknr = bn;\n\tset_buffer_mapped(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISUNWRITTEN",
          "args": [
            "&imap"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_get_blocks_notfound",
          "args": [
            "ip",
            "offset",
            "size"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_get_blocks_found",
          "args": [
            "ip",
            "offset",
            "size",
            "0",
            "&imap"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_get_blocks_alloc",
          "args": [
            "ip",
            "offset",
            "size",
            "0",
            "&imap"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iomap_write_delay",
          "args": [
            "ip",
            "offset",
            "size",
            "&imap"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iomap_write_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iomap.c",
          "lines": "531-634",
          "snippet": "int\nxfs_iomap_write_delay(\n\txfs_inode_t\t*ip,\n\txfs_off_t\toffset,\n\tsize_t\t\tcount,\n\txfs_bmbt_irec_t *ret_imap)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_fileoff_t\toffset_fsb;\n\txfs_fileoff_t\tlast_fsb;\n\txfs_off_t\taligned_offset;\n\txfs_fileoff_t\tioalign;\n\txfs_extlen_t\textsz;\n\tint\t\tnimaps;\n\txfs_bmbt_irec_t imap[XFS_WRITE_IMAPS];\n\tint\t\tprealloc;\n\tint\t\terror;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * Make sure that the dquots are there. This doesn't hold\n\t * the ilock across a disk read.\n\t */\n\terror = xfs_qm_dqattach_locked(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\textsz = xfs_get_extsz_hint(ip);\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\n\terror = xfs_iomap_eof_want_preallocate(mp, ip, offset, count,\n\t\t\t\timap, XFS_WRITE_IMAPS, &prealloc);\n\tif (error)\n\t\treturn error;\n\nretry:\n\tif (prealloc) {\n\t\txfs_fsblock_t\talloc_blocks;\n\n\t\talloc_blocks = xfs_iomap_prealloc_size(mp, ip, offset, imap,\n\t\t\t\t\t\t       XFS_WRITE_IMAPS);\n\n\t\taligned_offset = XFS_WRITEIO_ALIGN(mp, (offset + count - 1));\n\t\tioalign = XFS_B_TO_FSBT(mp, aligned_offset);\n\t\tlast_fsb = ioalign + alloc_blocks;\n\t} else {\n\t\tlast_fsb = XFS_B_TO_FSB(mp, ((xfs_ufsize_t)(offset + count)));\n\t}\n\n\tif (prealloc || extsz) {\n\t\terror = xfs_iomap_eof_align_last_fsb(mp, ip, extsz, &last_fsb);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Make sure preallocation does not create extents beyond the range we\n\t * actually support in this filesystem.\n\t */\n\tif (last_fsb > XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes))\n\t\tlast_fsb = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\n\tASSERT(last_fsb > offset_fsb);\n\n\tnimaps = XFS_WRITE_IMAPS;\n\terror = xfs_bmapi_delay(ip, offset_fsb, last_fsb - offset_fsb,\n\t\t\t\timap, &nimaps, XFS_BMAPI_ENTIRE);\n\tswitch (error) {\n\tcase 0:\n\tcase -ENOSPC:\n\tcase -EDQUOT:\n\t\tbreak;\n\tdefault:\n\t\treturn error;\n\t}\n\n\t/*\n\t * If bmapi returned us nothing, we got either ENOSPC or EDQUOT. Retry\n\t * without EOF preallocation.\n\t */\n\tif (nimaps == 0) {\n\t\ttrace_xfs_delalloc_enospc(ip, offset, count);\n\t\tif (prealloc) {\n\t\t\tprealloc = 0;\n\t\t\terror = 0;\n\t\t\tgoto retry;\n\t\t}\n\t\treturn error ? error : -ENOSPC;\n\t}\n\n\tif (!(imap[0].br_startblock || XFS_IS_REALTIME_INODE(ip)))\n\t\treturn xfs_alert_fsblock_zero(ip, &imap[0]);\n\n\t/*\n\t * Tag the inode as speculatively preallocated so we can reclaim this\n\t * space on demand, if necessary.\n\t */\n\tif (prealloc)\n\t\txfs_inode_set_eofblocks_tag(ip);\n\n\t*ret_imap = imap[0];\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define XFS_WRITE_IMAPS\t\tXFS_BMAP_MAX_NMAP"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define XFS_WRITE_IMAPS\t\tXFS_BMAP_MAX_NMAP\n\nint\nxfs_iomap_write_delay(\n\txfs_inode_t\t*ip,\n\txfs_off_t\toffset,\n\tsize_t\t\tcount,\n\txfs_bmbt_irec_t *ret_imap)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_fileoff_t\toffset_fsb;\n\txfs_fileoff_t\tlast_fsb;\n\txfs_off_t\taligned_offset;\n\txfs_fileoff_t\tioalign;\n\txfs_extlen_t\textsz;\n\tint\t\tnimaps;\n\txfs_bmbt_irec_t imap[XFS_WRITE_IMAPS];\n\tint\t\tprealloc;\n\tint\t\terror;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * Make sure that the dquots are there. This doesn't hold\n\t * the ilock across a disk read.\n\t */\n\terror = xfs_qm_dqattach_locked(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\textsz = xfs_get_extsz_hint(ip);\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\n\terror = xfs_iomap_eof_want_preallocate(mp, ip, offset, count,\n\t\t\t\timap, XFS_WRITE_IMAPS, &prealloc);\n\tif (error)\n\t\treturn error;\n\nretry:\n\tif (prealloc) {\n\t\txfs_fsblock_t\talloc_blocks;\n\n\t\talloc_blocks = xfs_iomap_prealloc_size(mp, ip, offset, imap,\n\t\t\t\t\t\t       XFS_WRITE_IMAPS);\n\n\t\taligned_offset = XFS_WRITEIO_ALIGN(mp, (offset + count - 1));\n\t\tioalign = XFS_B_TO_FSBT(mp, aligned_offset);\n\t\tlast_fsb = ioalign + alloc_blocks;\n\t} else {\n\t\tlast_fsb = XFS_B_TO_FSB(mp, ((xfs_ufsize_t)(offset + count)));\n\t}\n\n\tif (prealloc || extsz) {\n\t\terror = xfs_iomap_eof_align_last_fsb(mp, ip, extsz, &last_fsb);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Make sure preallocation does not create extents beyond the range we\n\t * actually support in this filesystem.\n\t */\n\tif (last_fsb > XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes))\n\t\tlast_fsb = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\n\tASSERT(last_fsb > offset_fsb);\n\n\tnimaps = XFS_WRITE_IMAPS;\n\terror = xfs_bmapi_delay(ip, offset_fsb, last_fsb - offset_fsb,\n\t\t\t\timap, &nimaps, XFS_BMAPI_ENTIRE);\n\tswitch (error) {\n\tcase 0:\n\tcase -ENOSPC:\n\tcase -EDQUOT:\n\t\tbreak;\n\tdefault:\n\t\treturn error;\n\t}\n\n\t/*\n\t * If bmapi returned us nothing, we got either ENOSPC or EDQUOT. Retry\n\t * without EOF preallocation.\n\t */\n\tif (nimaps == 0) {\n\t\ttrace_xfs_delalloc_enospc(ip, offset, count);\n\t\tif (prealloc) {\n\t\t\tprealloc = 0;\n\t\t\terror = 0;\n\t\t\tgoto retry;\n\t\t}\n\t\treturn error ? error : -ENOSPC;\n\t}\n\n\tif (!(imap[0].br_startblock || XFS_IS_REALTIME_INODE(ip)))\n\t\treturn xfs_alert_fsblock_zero(ip, &imap[0]);\n\n\t/*\n\t * Tag the inode as speculatively preallocated so we can reclaim this\n\t * space on demand, if necessary.\n\t */\n\tif (prealloc)\n\t\txfs_inode_set_eofblocks_tag(ip);\n\n\t*ret_imap = imap[0];\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iomap_write_direct",
          "args": [
            "ip",
            "offset",
            "size",
            "&imap",
            "nimaps"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iomap_write_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iomap.c",
          "lines": "112-241",
          "snippet": "int\nxfs_iomap_write_direct(\n\txfs_inode_t\t*ip,\n\txfs_off_t\toffset,\n\tsize_t\t\tcount,\n\txfs_bmbt_irec_t *imap,\n\tint\t\tnmaps)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_fileoff_t\toffset_fsb;\n\txfs_fileoff_t\tlast_fsb;\n\txfs_filblks_t\tcount_fsb, resaligned;\n\txfs_fsblock_t\tfirstfsb;\n\txfs_extlen_t\textsz, temp;\n\tint\t\tnimaps;\n\tint\t\tquota_flag;\n\tint\t\trt;\n\txfs_trans_t\t*tp;\n\txfs_bmap_free_t free_list;\n\tuint\t\tqblocks, resblks, resrtextents;\n\tint\t\tcommitted;\n\tint\t\terror;\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\trt = XFS_IS_REALTIME_INODE(ip);\n\textsz = xfs_get_extsz_hint(ip);\n\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\tlast_fsb = XFS_B_TO_FSB(mp, ((xfs_ufsize_t)(offset + count)));\n\tif ((offset + count) > XFS_ISIZE(ip)) {\n\t\terror = xfs_iomap_eof_align_last_fsb(mp, ip, extsz, &last_fsb);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tif (nmaps && (imap->br_startblock == HOLESTARTBLOCK))\n\t\t\tlast_fsb = MIN(last_fsb, (xfs_fileoff_t)\n\t\t\t\t\timap->br_blockcount +\n\t\t\t\t\timap->br_startoff);\n\t}\n\tcount_fsb = last_fsb - offset_fsb;\n\tASSERT(count_fsb > 0);\n\n\tresaligned = count_fsb;\n\tif (unlikely(extsz)) {\n\t\tif ((temp = do_mod(offset_fsb, extsz)))\n\t\t\tresaligned += temp;\n\t\tif ((temp = do_mod(resaligned, extsz)))\n\t\t\tresaligned += extsz - temp;\n\t}\n\n\tif (unlikely(rt)) {\n\t\tresrtextents = qblocks = resaligned;\n\t\tresrtextents /= mp->m_sb.sb_rextsize;\n\t\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\t\tquota_flag = XFS_QMOPT_RES_RTBLKS;\n\t} else {\n\t\tresrtextents = 0;\n\t\tresblks = qblocks = XFS_DIOSTRAT_SPACE_RES(mp, resaligned);\n\t\tquota_flag = XFS_QMOPT_RES_REGBLKS;\n\t}\n\n\t/*\n\t * Allocate and setup the transaction\n\t */\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\t  resblks, resrtextents);\n\t/*\n\t * Check for running out of space, note: need lock to return\n\t */\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\terror = xfs_trans_reserve_quota_nblks(tp, ip, qblocks, 0, quota_flag);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * From this point onwards we overwrite the imap pointer that the\n\t * caller gave to us.\n\t */\n\txfs_bmap_init(&free_list, &firstfsb);\n\tnimaps = 1;\n\terror = xfs_bmapi_write(tp, ip, offset_fsb, count_fsb,\n\t\t\t\tXFS_BMAPI_PREALLOC, &firstfsb, 0,\n\t\t\t\timap, &nimaps, &free_list);\n\tif (error)\n\t\tgoto out_bmap_cancel;\n\n\t/*\n\t * Complete the transaction\n\t */\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error)\n\t\tgoto out_bmap_cancel;\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Copy any maps to caller's array and return any error.\n\t */\n\tif (nimaps == 0) {\n\t\terror = -ENOSPC;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!(imap->br_startblock || XFS_IS_REALTIME_INODE(ip)))\n\t\terror = xfs_alert_fsblock_zero(ip, imap);\n\nout_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n\nout_bmap_cancel:\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_unreserve_quota_nblks(tp, ip, (long)qblocks, 0, quota_flag);\nout_trans_cancel:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_iomap_write_direct(\n\txfs_inode_t\t*ip,\n\txfs_off_t\toffset,\n\tsize_t\t\tcount,\n\txfs_bmbt_irec_t *imap,\n\tint\t\tnmaps)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_fileoff_t\toffset_fsb;\n\txfs_fileoff_t\tlast_fsb;\n\txfs_filblks_t\tcount_fsb, resaligned;\n\txfs_fsblock_t\tfirstfsb;\n\txfs_extlen_t\textsz, temp;\n\tint\t\tnimaps;\n\tint\t\tquota_flag;\n\tint\t\trt;\n\txfs_trans_t\t*tp;\n\txfs_bmap_free_t free_list;\n\tuint\t\tqblocks, resblks, resrtextents;\n\tint\t\tcommitted;\n\tint\t\terror;\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\trt = XFS_IS_REALTIME_INODE(ip);\n\textsz = xfs_get_extsz_hint(ip);\n\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\tlast_fsb = XFS_B_TO_FSB(mp, ((xfs_ufsize_t)(offset + count)));\n\tif ((offset + count) > XFS_ISIZE(ip)) {\n\t\terror = xfs_iomap_eof_align_last_fsb(mp, ip, extsz, &last_fsb);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tif (nmaps && (imap->br_startblock == HOLESTARTBLOCK))\n\t\t\tlast_fsb = MIN(last_fsb, (xfs_fileoff_t)\n\t\t\t\t\timap->br_blockcount +\n\t\t\t\t\timap->br_startoff);\n\t}\n\tcount_fsb = last_fsb - offset_fsb;\n\tASSERT(count_fsb > 0);\n\n\tresaligned = count_fsb;\n\tif (unlikely(extsz)) {\n\t\tif ((temp = do_mod(offset_fsb, extsz)))\n\t\t\tresaligned += temp;\n\t\tif ((temp = do_mod(resaligned, extsz)))\n\t\t\tresaligned += extsz - temp;\n\t}\n\n\tif (unlikely(rt)) {\n\t\tresrtextents = qblocks = resaligned;\n\t\tresrtextents /= mp->m_sb.sb_rextsize;\n\t\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\t\tquota_flag = XFS_QMOPT_RES_RTBLKS;\n\t} else {\n\t\tresrtextents = 0;\n\t\tresblks = qblocks = XFS_DIOSTRAT_SPACE_RES(mp, resaligned);\n\t\tquota_flag = XFS_QMOPT_RES_REGBLKS;\n\t}\n\n\t/*\n\t * Allocate and setup the transaction\n\t */\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\t  resblks, resrtextents);\n\t/*\n\t * Check for running out of space, note: need lock to return\n\t */\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\terror = xfs_trans_reserve_quota_nblks(tp, ip, qblocks, 0, quota_flag);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * From this point onwards we overwrite the imap pointer that the\n\t * caller gave to us.\n\t */\n\txfs_bmap_init(&free_list, &firstfsb);\n\tnimaps = 1;\n\terror = xfs_bmapi_write(tp, ip, offset_fsb, count_fsb,\n\t\t\t\tXFS_BMAPI_PREALLOC, &firstfsb, 0,\n\t\t\t\timap, &nimaps, &free_list);\n\tif (error)\n\t\tgoto out_bmap_cancel;\n\n\t/*\n\t * Complete the transaction\n\t */\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error)\n\t\tgoto out_bmap_cancel;\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Copy any maps to caller's array and return any error.\n\t */\n\tif (nimaps == 0) {\n\t\terror = -ENOSPC;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!(imap->br_startblock || XFS_IS_REALTIME_INODE(ip)))\n\t\terror = xfs_alert_fsblock_zero(ip, imap);\n\nout_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n\nout_bmap_cancel:\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_unreserve_quota_nblks(tp, ip, (long)qblocks, 0, quota_flag);\nout_trans_cancel:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_get_extsz_hint",
          "args": [
            "ip"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_extsz_hint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "67-76",
          "snippet": "xfs_extlen_t\nxfs_get_extsz_hint(\n\tstruct xfs_inode\t*ip)\n{\n\tif ((ip->i_d.di_flags & XFS_DIFLAG_EXTSIZE) && ip->i_d.di_extsize)\n\t\treturn ip->i_d.di_extsize;\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn ip->i_mount->m_sb.sb_rextsize;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_extlen_t\nxfs_get_extsz_hint(\n\tstruct xfs_inode\t*ip)\n{\n\tif ((ip->i_d.di_flags & XFS_DIFLAG_EXTSIZE) && ip->i_d.di_extsize)\n\t\treturn ip->i_d.di_extsize;\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn ip->i_mount->m_sb.sb_rextsize;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "ip",
            "offset_fsb",
            "end_fsb - offset_fsb",
            "&imap",
            "&nimaps",
            "XFS_BMAPI_ENTIRE"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSBT",
          "args": [
            "mp",
            "offset"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "(xfs_ufsize_t)offset + size"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "offset <= mp->m_super->s_maxbytes"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ilock_data_map_shared",
          "args": [
            "ip"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_data_map_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "93-104",
          "snippet": "uint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nuint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "lockmode"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bh_result->b_size >= (1 << inode->i_blkbits)"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\n__xfs_get_blocks(\n\tstruct inode\t\t*inode,\n\tsector_t\t\tiblock,\n\tstruct buffer_head\t*bh_result,\n\tint\t\t\tcreate,\n\tint\t\t\tdirect)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\toffset_fsb, end_fsb;\n\tint\t\t\terror = 0;\n\tint\t\t\tlockmode = 0;\n\tstruct xfs_bmbt_irec\timap;\n\tint\t\t\tnimaps = 1;\n\txfs_off_t\t\toffset;\n\tssize_t\t\t\tsize;\n\tint\t\t\tnew = 0;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\toffset = (xfs_off_t)iblock << inode->i_blkbits;\n\tASSERT(bh_result->b_size >= (1 << inode->i_blkbits));\n\tsize = bh_result->b_size;\n\n\tif (!create && direct && offset >= i_size_read(inode))\n\t\treturn 0;\n\n\t/*\n\t * Direct I/O is usually done on preallocated files, so try getting\n\t * a block mapping without an exclusive lock first.  For buffered\n\t * writes we already have the exclusive iolock anyway, so avoiding\n\t * a lock roundtrip here by taking the ilock exclusive from the\n\t * beginning is a useful micro optimization.\n\t */\n\tif (create && !direct) {\n\t\tlockmode = XFS_ILOCK_EXCL;\n\t\txfs_ilock(ip, lockmode);\n\t} else {\n\t\tlockmode = xfs_ilock_data_map_shared(ip);\n\t}\n\n\tASSERT(offset <= mp->m_super->s_maxbytes);\n\tif (offset + size > mp->m_super->s_maxbytes)\n\t\tsize = mp->m_super->s_maxbytes - offset;\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + size);\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\n\terror = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb,\n\t\t\t\t&imap, &nimaps, XFS_BMAPI_ENTIRE);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tif (create &&\n\t    (!nimaps ||\n\t     (imap.br_startblock == HOLESTARTBLOCK ||\n\t      imap.br_startblock == DELAYSTARTBLOCK))) {\n\t\tif (direct || xfs_get_extsz_hint(ip)) {\n\t\t\t/*\n\t\t\t * Drop the ilock in preparation for starting the block\n\t\t\t * allocation transaction.  It will be retaken\n\t\t\t * exclusively inside xfs_iomap_write_direct for the\n\t\t\t * actual allocation.\n\t\t\t */\n\t\t\txfs_iunlock(ip, lockmode);\n\t\t\terror = xfs_iomap_write_direct(ip, offset, size,\n\t\t\t\t\t\t       &imap, nimaps);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tnew = 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Delalloc reservations do not require a transaction,\n\t\t\t * we can go on without dropping the lock here. If we\n\t\t\t * are allocating a new delalloc block, make sure that\n\t\t\t * we set the new flag so that we mark the buffer new so\n\t\t\t * that we know that it is newly allocated if the write\n\t\t\t * fails.\n\t\t\t */\n\t\t\tif (nimaps && imap.br_startblock == HOLESTARTBLOCK)\n\t\t\t\tnew = 1;\n\t\t\terror = xfs_iomap_write_delay(ip, offset, size, &imap);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock;\n\n\t\t\txfs_iunlock(ip, lockmode);\n\t\t}\n\n\t\ttrace_xfs_get_blocks_alloc(ip, offset, size, 0, &imap);\n\t} else if (nimaps) {\n\t\ttrace_xfs_get_blocks_found(ip, offset, size, 0, &imap);\n\t\txfs_iunlock(ip, lockmode);\n\t} else {\n\t\ttrace_xfs_get_blocks_notfound(ip, offset, size);\n\t\tgoto out_unlock;\n\t}\n\n\tif (imap.br_startblock != HOLESTARTBLOCK &&\n\t    imap.br_startblock != DELAYSTARTBLOCK) {\n\t\t/*\n\t\t * For unwritten extents do not report a disk address on\n\t\t * the read case (treat as if we're reading into a hole).\n\t\t */\n\t\tif (create || !ISUNWRITTEN(&imap))\n\t\t\txfs_map_buffer(inode, bh_result, &imap, offset);\n\t\tif (create && ISUNWRITTEN(&imap)) {\n\t\t\tif (direct) {\n\t\t\t\tbh_result->b_private = inode;\n\t\t\t\tset_buffer_defer_completion(bh_result);\n\t\t\t}\n\t\t\tset_buffer_unwritten(bh_result);\n\t\t}\n\t}\n\n\t/*\n\t * If this is a realtime file, data may be on a different device.\n\t * to that pointed to from the buffer_head b_bdev currently.\n\t */\n\tbh_result->b_bdev = xfs_find_bdev_for_inode(inode);\n\n\t/*\n\t * If we previously allocated a block out beyond eof and we are now\n\t * coming back to use it then we will need to flag it as new even if it\n\t * has a disk address.\n\t *\n\t * With sub-block writes into unwritten extents we also need to mark\n\t * the buffer as new so that the unwritten parts of the buffer gets\n\t * correctly zeroed.\n\t */\n\tif (create &&\n\t    ((!buffer_mapped(bh_result) && !buffer_uptodate(bh_result)) ||\n\t     (offset >= i_size_read(inode)) ||\n\t     (new || ISUNWRITTEN(&imap))))\n\t\tset_buffer_new(bh_result);\n\n\tif (imap.br_startblock == DELAYSTARTBLOCK) {\n\t\tBUG_ON(direct);\n\t\tif (create) {\n\t\t\tset_buffer_uptodate(bh_result);\n\t\t\tset_buffer_mapped(bh_result);\n\t\t\tset_buffer_delay(bh_result);\n\t\t}\n\t}\n\n\t/*\n\t * If this is O_DIRECT or the mpage code calling tell them how large\n\t * the mapping is, so that we can avoid repeated get_blocks calls.\n\t *\n\t * If the mapping spans EOF, then we have to break the mapping up as the\n\t * mapping for blocks beyond EOF must be marked new so that sub block\n\t * regions can be correctly zeroed. We can't do this for mappings within\n\t * EOF unless the mapping was just allocated or is unwritten, otherwise\n\t * the callers would overwrite existing data with zeros. Hence we have\n\t * to split the mapping into a range up to and including EOF, and a\n\t * second mapping for beyond EOF.\n\t */\n\tif (direct || size > (1 << inode->i_blkbits)) {\n\t\txfs_off_t\t\tmapping_size;\n\n\t\tmapping_size = imap.br_startoff + imap.br_blockcount - iblock;\n\t\tmapping_size <<= inode->i_blkbits;\n\n\t\tASSERT(mapping_size > 0);\n\t\tif (mapping_size > size)\n\t\t\tmapping_size = size;\n\t\tif (offset < i_size_read(inode) &&\n\t\t    offset + mapping_size >= i_size_read(inode)) {\n\t\t\t/* limit mapping to block that spans EOF */\n\t\t\tmapping_size = roundup_64(i_size_read(inode) - offset,\n\t\t\t\t\t\t  1 << inode->i_blkbits);\n\t\t}\n\t\tif (mapping_size > LONG_MAX)\n\t\t\tmapping_size = LONG_MAX;\n\n\t\tbh_result->b_size = mapping_size;\n\t}\n\n\treturn 0;\n\nout_unlock:\n\txfs_iunlock(ip, lockmode);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_vm_releasepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "1217-1234",
    "snippet": "STATIC int\nxfs_vm_releasepage(\n\tstruct page\t\t*page,\n\tgfp_t\t\t\tgfp_mask)\n{\n\tint\t\t\tdelalloc, unwritten;\n\n\ttrace_xfs_releasepage(page->mapping->host, page, 0, 0);\n\n\txfs_count_page_state(page, &delalloc, &unwritten);\n\n\tif (WARN_ON_ONCE(delalloc))\n\t\treturn 0;\n\tif (WARN_ON_ONCE(unwritten))\n\t\treturn 0;\n\n\treturn try_to_free_buffers(page);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3214-3260",
          "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "unwritten"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "delalloc"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_count_page_state",
          "args": [
            "page",
            "&delalloc",
            "&unwritten"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_count_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "40-57",
          "snippet": "void\nxfs_count_page_state(\n\tstruct page\t\t*page,\n\tint\t\t\t*delalloc,\n\tint\t\t\t*unwritten)\n{\n\tstruct buffer_head\t*bh, *head;\n\n\t*delalloc = *unwritten = 0;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_unwritten(bh))\n\t\t\t(*unwritten) = 1;\n\t\telse if (buffer_delay(bh))\n\t\t\t(*delalloc) = 1;\n\t} while ((bh = bh->b_this_page) != head);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_count_page_state(\n\tstruct page\t\t*page,\n\tint\t\t\t*delalloc,\n\tint\t\t\t*unwritten)\n{\n\tstruct buffer_head\t*bh, *head;\n\n\t*delalloc = *unwritten = 0;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_unwritten(bh))\n\t\t\t(*unwritten) = 1;\n\t\telse if (buffer_delay(bh))\n\t\t\t(*delalloc) = 1;\n\t} while ((bh = bh->b_this_page) != head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_releasepage",
          "args": [
            "page->mapping->host",
            "page",
            "0",
            "0"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vm_releasepage(\n\tstruct page\t\t*page,\n\tgfp_t\t\t\tgfp_mask)\n{\n\tint\t\t\tdelalloc, unwritten;\n\n\ttrace_xfs_releasepage(page->mapping->host, page, 0, 0);\n\n\txfs_count_page_state(page, &delalloc, &unwritten);\n\n\tif (WARN_ON_ONCE(delalloc))\n\t\treturn 0;\n\tif (WARN_ON_ONCE(unwritten))\n\t\treturn 0;\n\n\treturn try_to_free_buffers(page);\n}"
  },
  {
    "function_name": "xfs_vm_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "1201-1208",
    "snippet": "STATIC int\nxfs_vm_writepages(\n\tstruct address_space\t*mapping,\n\tstruct writeback_control *wbc)\n{\n\txfs_iflags_clear(XFS_I(mapping->host), XFS_ITRUNCATED);\n\treturn generic_writepages(mapping, wbc);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_writepages",
          "args": [
            "mapping",
            "wbc"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iflags_clear",
          "args": [
            "XFS_I(mapping->host)",
            "XFS_ITRUNCATED"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflags_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "126-132",
          "snippet": "static inline void\nxfs_iflags_clear(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\tip->i_flags &= ~flags;\n\tspin_unlock(&ip->i_flags_lock);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline void\nxfs_iflags_clear(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\tip->i_flags &= ~flags;\n\tspin_unlock(&ip->i_flags_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "mapping->host"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vm_writepages(\n\tstruct address_space\t*mapping,\n\tstruct writeback_control *wbc)\n{\n\txfs_iflags_clear(XFS_I(mapping->host), XFS_ITRUNCATED);\n\treturn generic_writepages(mapping, wbc);\n}"
  },
  {
    "function_name": "xfs_vm_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "938-1199",
    "snippet": "STATIC int\nxfs_vm_writepage(\n\tstruct page\t\t*page,\n\tstruct writeback_control *wbc)\n{\n\tstruct inode\t\t*inode = page->mapping->host;\n\tstruct buffer_head\t*bh, *head;\n\tstruct xfs_bmbt_irec\timap;\n\txfs_ioend_t\t\t*ioend = NULL, *iohead = NULL;\n\tloff_t\t\t\toffset;\n\tunsigned int\t\ttype;\n\t__uint64_t              end_offset;\n\tpgoff_t                 end_index, last_index;\n\tssize_t\t\t\tlen;\n\tint\t\t\terr, imap_valid = 0, uptodate = 1;\n\tint\t\t\tcount = 0;\n\tint\t\t\tnonblocking = 0;\n\n\ttrace_xfs_writepage(inode, page, 0, 0);\n\n\tASSERT(page_has_buffers(page));\n\n\t/*\n\t * Refuse to write the page out if we are called from reclaim context.\n\t *\n\t * This avoids stack overflows when called from deeply used stacks in\n\t * random callers for direct reclaim or memcg reclaim.  We explicitly\n\t * allow reclaim from kswapd as the stack usage there is relatively low.\n\t *\n\t * This should never happen except in the case of a VM regression so\n\t * warn about it.\n\t */\n\tif (WARN_ON_ONCE((current->flags & (PF_MEMALLOC|PF_KSWAPD)) ==\n\t\t\tPF_MEMALLOC))\n\t\tgoto redirty;\n\n\t/*\n\t * Given that we do not allow direct reclaim to call us, we should\n\t * never be called while in a filesystem transaction.\n\t */\n\tif (WARN_ON_ONCE(current->flags & PF_FSTRANS))\n\t\tgoto redirty;\n\n\t/* Is this page beyond the end of the file? */\n\toffset = i_size_read(inode);\n\tend_index = offset >> PAGE_CACHE_SHIFT;\n\tlast_index = (offset - 1) >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * The page index is less than the end_index, adjust the end_offset\n\t * to the highest offset that this page should represent.\n\t * -----------------------------------------------------\n\t * |\t\t\tfile mapping\t       | <EOF> |\n\t * -----------------------------------------------------\n\t * | Page ... | Page N-2 | Page N-1 |  Page N  |       |\n\t * ^--------------------------------^----------|--------\n\t * |     desired writeback range    |      see else    |\n\t * ---------------------------------^------------------|\n\t */\n\tif (page->index < end_index)\n\t\tend_offset = (xfs_off_t)(page->index + 1) << PAGE_CACHE_SHIFT;\n\telse {\n\t\t/*\n\t\t * Check whether the page to write out is beyond or straddles\n\t\t * i_size or not.\n\t\t * -------------------------------------------------------\n\t\t * |\t\tfile mapping\t\t        | <EOF>  |\n\t\t * -------------------------------------------------------\n\t\t * | Page ... | Page N-2 | Page N-1 |  Page N   | Beyond |\n\t\t * ^--------------------------------^-----------|---------\n\t\t * |\t\t\t\t    |      Straddles     |\n\t\t * ---------------------------------^-----------|--------|\n\t\t */\n\t\tunsigned offset_into_page = offset & (PAGE_CACHE_SIZE - 1);\n\n\t\t/*\n\t\t * Skip the page if it is fully outside i_size, e.g. due to a\n\t\t * truncate operation that is in progress. We must redirty the\n\t\t * page so that reclaim stops reclaiming it. Otherwise\n\t\t * xfs_vm_releasepage() is called on it and gets confused.\n\t\t *\n\t\t * Note that the end_index is unsigned long, it would overflow\n\t\t * if the given offset is greater than 16TB on 32-bit system\n\t\t * and if we do check the page is fully outside i_size or not\n\t\t * via \"if (page->index >= end_index + 1)\" as \"end_index + 1\"\n\t\t * will be evaluated to 0.  Hence this page will be redirtied\n\t\t * and be written out repeatedly which would result in an\n\t\t * infinite loop, the user program that perform this operation\n\t\t * will hang.  Instead, we can verify this situation by checking\n\t\t * if the page to write is totally beyond the i_size or if it's\n\t\t * offset is just equal to the EOF.\n\t\t */\n\t\tif (page->index > end_index ||\n\t\t    (page->index == end_index && offset_into_page == 0))\n\t\t\tgoto redirty;\n\n\t\t/*\n\t\t * The page straddles i_size.  It must be zeroed out on each\n\t\t * and every writepage invocation because it may be mmapped.\n\t\t * \"A file is mapped in multiples of the page size.  For a file\n\t\t * that is not a multiple of the page size, the remaining\n\t\t * memory is zeroed when mapped, and writes to that region are\n\t\t * not written out to the file.\"\n\t\t */\n\t\tzero_user_segment(page, offset_into_page, PAGE_CACHE_SIZE);\n\n\t\t/* Adjust the end_offset to the end of file */\n\t\tend_offset = offset;\n\t}\n\n\tlen = 1 << inode->i_blkbits;\n\n\tbh = head = page_buffers(page);\n\toffset = page_offset(page);\n\ttype = XFS_IO_OVERWRITE;\n\n\tif (wbc->sync_mode == WB_SYNC_NONE)\n\t\tnonblocking = 1;\n\n\tdo {\n\t\tint new_ioend = 0;\n\n\t\tif (offset >= end_offset)\n\t\t\tbreak;\n\t\tif (!buffer_uptodate(bh))\n\t\t\tuptodate = 0;\n\n\t\t/*\n\t\t * set_page_dirty dirties all buffers in a page, independent\n\t\t * of their state.  The dirty state however is entirely\n\t\t * meaningless for holes (!mapped && uptodate), so skip\n\t\t * buffers covering holes here.\n\t\t */\n\t\tif (!buffer_mapped(bh) && buffer_uptodate(bh)) {\n\t\t\timap_valid = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_unwritten(bh)) {\n\t\t\tif (type != XFS_IO_UNWRITTEN) {\n\t\t\t\ttype = XFS_IO_UNWRITTEN;\n\t\t\t\timap_valid = 0;\n\t\t\t}\n\t\t} else if (buffer_delay(bh)) {\n\t\t\tif (type != XFS_IO_DELALLOC) {\n\t\t\t\ttype = XFS_IO_DELALLOC;\n\t\t\t\timap_valid = 0;\n\t\t\t}\n\t\t} else if (buffer_uptodate(bh)) {\n\t\t\tif (type != XFS_IO_OVERWRITE) {\n\t\t\t\ttype = XFS_IO_OVERWRITE;\n\t\t\t\timap_valid = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (PageUptodate(page))\n\t\t\t\tASSERT(buffer_mapped(bh));\n\t\t\t/*\n\t\t\t * This buffer is not uptodate and will not be\n\t\t\t * written to disk.  Ensure that we will put any\n\t\t\t * subsequent writeable buffers into a new\n\t\t\t * ioend.\n\t\t\t */\n\t\t\timap_valid = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (imap_valid)\n\t\t\timap_valid = xfs_imap_valid(inode, &imap, offset);\n\t\tif (!imap_valid) {\n\t\t\t/*\n\t\t\t * If we didn't have a valid mapping then we need to\n\t\t\t * put the new mapping into a separate ioend structure.\n\t\t\t * This ensures non-contiguous extents always have\n\t\t\t * separate ioends, which is particularly important\n\t\t\t * for unwritten extent conversion at I/O completion\n\t\t\t * time.\n\t\t\t */\n\t\t\tnew_ioend = 1;\n\t\t\terr = xfs_map_blocks(inode, offset, &imap, type,\n\t\t\t\t\t     nonblocking);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\timap_valid = xfs_imap_valid(inode, &imap, offset);\n\t\t}\n\t\tif (imap_valid) {\n\t\t\tlock_buffer(bh);\n\t\t\tif (type != XFS_IO_OVERWRITE)\n\t\t\t\txfs_map_at_offset(inode, bh, &imap, offset);\n\t\t\txfs_add_to_ioend(inode, bh, offset, type, &ioend,\n\t\t\t\t\t new_ioend);\n\t\t\tcount++;\n\t\t}\n\n\t\tif (!iohead)\n\t\t\tiohead = ioend;\n\n\t} while (offset += len, ((bh = bh->b_this_page) != head));\n\n\tif (uptodate && bh == head)\n\t\tSetPageUptodate(page);\n\n\txfs_start_page_writeback(page, 1, count);\n\n\t/* if there is no IO to be submitted for this page, we are done */\n\tif (!ioend)\n\t\treturn 0;\n\n\tASSERT(iohead);\n\n\t/*\n\t * Any errors from this point onwards need tobe reported through the IO\n\t * completion path as we have marked the initial page as under writeback\n\t * and unlocked it.\n\t */\n\tif (imap_valid) {\n\t\txfs_off_t\t\tend_index;\n\n\t\tend_index = imap.br_startoff + imap.br_blockcount;\n\n\t\t/* to bytes */\n\t\tend_index <<= inode->i_blkbits;\n\n\t\t/* to pages */\n\t\tend_index = (end_index - 1) >> PAGE_CACHE_SHIFT;\n\n\t\t/* check against file size */\n\t\tif (end_index > last_index)\n\t\t\tend_index = last_index;\n\n\t\txfs_cluster_write(inode, page->index + 1, &imap, &ioend,\n\t\t\t\t  wbc, end_index);\n\t}\n\n\n\t/*\n\t * Reserve log space if we might write beyond the on-disk inode size.\n\t */\n\terr = 0;\n\tif (ioend->io_type != XFS_IO_UNWRITTEN && xfs_ioend_is_append(ioend))\n\t\terr = xfs_setfilesize_trans_alloc(ioend);\n\n\txfs_submit_ioend(wbc, iohead, err);\n\n\treturn 0;\n\nerror:\n\tif (iohead)\n\t\txfs_cancel_ioend(iohead);\n\n\tif (err == -EAGAIN)\n\t\tgoto redirty;\n\n\txfs_aops_discard_page(page);\n\tClearPageUptodate(page);\n\tunlock_page(page);\n\treturn err;\n\nredirty:\n\tredirty_page_for_writepage(wbc, page);\n\tunlock_page(page);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_aops_discard_page",
          "args": [
            "page"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_aops_discard_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "881-928",
          "snippet": "STATIC void\nxfs_aops_discard_page(\n\tstruct page\t\t*page)\n{\n\tstruct inode\t\t*inode = page->mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct buffer_head\t*bh, *head;\n\tloff_t\t\t\toffset = page_offset(page);\n\n\tif (!xfs_check_page_type(page, XFS_IO_DELALLOC, true))\n\t\tgoto out_invalidate;\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\tgoto out_invalidate;\n\n\txfs_alert(ip->i_mount,\n\t\t\"page discard on page %p, inode 0x%llx, offset %llu.\",\n\t\t\tpage, ip->i_ino, offset);\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tint\t\terror;\n\t\txfs_fileoff_t\tstart_fsb;\n\n\t\tif (!buffer_delay(bh))\n\t\t\tgoto next_buffer;\n\n\t\tstart_fsb = XFS_B_TO_FSBT(ip->i_mount, offset);\n\t\terror = xfs_bmap_punch_delalloc_range(ip, start_fsb, 1);\n\t\tif (error) {\n\t\t\t/* something screwed, just bail */\n\t\t\tif (!XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\t\t\txfs_alert(ip->i_mount,\n\t\t\t\"page discard unable to remove delalloc mapping.\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nnext_buffer:\n\t\toffset += 1 << inode->i_blkbits;\n\n\t} while ((bh = bh->b_this_page) != head);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\nout_invalidate:\n\txfs_vm_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\treturn;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_aops_discard_page(\n\tstruct page\t\t*page)\n{\n\tstruct inode\t\t*inode = page->mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct buffer_head\t*bh, *head;\n\tloff_t\t\t\toffset = page_offset(page);\n\n\tif (!xfs_check_page_type(page, XFS_IO_DELALLOC, true))\n\t\tgoto out_invalidate;\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\tgoto out_invalidate;\n\n\txfs_alert(ip->i_mount,\n\t\t\"page discard on page %p, inode 0x%llx, offset %llu.\",\n\t\t\tpage, ip->i_ino, offset);\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tint\t\terror;\n\t\txfs_fileoff_t\tstart_fsb;\n\n\t\tif (!buffer_delay(bh))\n\t\t\tgoto next_buffer;\n\n\t\tstart_fsb = XFS_B_TO_FSBT(ip->i_mount, offset);\n\t\terror = xfs_bmap_punch_delalloc_range(ip, start_fsb, 1);\n\t\tif (error) {\n\t\t\t/* something screwed, just bail */\n\t\t\tif (!XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\t\t\txfs_alert(ip->i_mount,\n\t\t\t\"page discard unable to remove delalloc mapping.\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nnext_buffer:\n\t\toffset += 1 << inode->i_blkbits;\n\n\t} while ((bh = bh->b_this_page) != head);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\nout_invalidate:\n\txfs_vm_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_cancel_ioend",
          "args": [
            "iohead"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_cancel_ioend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "531-556",
          "snippet": "STATIC void\nxfs_cancel_ioend(\n\txfs_ioend_t\t\t*ioend)\n{\n\txfs_ioend_t\t\t*next;\n\tstruct buffer_head\t*bh, *next_bh;\n\n\tdo {\n\t\tnext = ioend->io_list;\n\t\tbh = ioend->io_buffer_head;\n\t\tdo {\n\t\t\tnext_bh = bh->b_private;\n\t\t\tclear_buffer_async_write(bh);\n\t\t\t/*\n\t\t\t * The unwritten flag is cleared when added to the\n\t\t\t * ioend. We're not submitting for I/O so mark the\n\t\t\t * buffer unwritten again for next time around.\n\t\t\t */\n\t\t\tif (ioend->io_type == XFS_IO_UNWRITTEN)\n\t\t\t\tset_buffer_unwritten(bh);\n\t\t\tunlock_buffer(bh);\n\t\t} while ((bh = next_bh) != NULL);\n\n\t\tmempool_free(ioend, xfs_ioend_pool);\n\t} while ((ioend = next) != NULL);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_cancel_ioend(\n\txfs_ioend_t\t\t*ioend)\n{\n\txfs_ioend_t\t\t*next;\n\tstruct buffer_head\t*bh, *next_bh;\n\n\tdo {\n\t\tnext = ioend->io_list;\n\t\tbh = ioend->io_buffer_head;\n\t\tdo {\n\t\t\tnext_bh = bh->b_private;\n\t\t\tclear_buffer_async_write(bh);\n\t\t\t/*\n\t\t\t * The unwritten flag is cleared when added to the\n\t\t\t * ioend. We're not submitting for I/O so mark the\n\t\t\t * buffer unwritten again for next time around.\n\t\t\t */\n\t\t\tif (ioend->io_type == XFS_IO_UNWRITTEN)\n\t\t\t\tset_buffer_unwritten(bh);\n\t\t\tunlock_buffer(bh);\n\t\t} while ((bh = next_bh) != NULL);\n\n\t\tmempool_free(ioend, xfs_ioend_pool);\n\t} while ((ioend = next) != NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_submit_ioend",
          "args": [
            "wbc",
            "iohead",
            "err"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_submit_ioend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "466-524",
          "snippet": "STATIC void\nxfs_submit_ioend(\n\tstruct writeback_control *wbc,\n\txfs_ioend_t\t\t*ioend,\n\tint\t\t\tfail)\n{\n\txfs_ioend_t\t\t*head = ioend;\n\txfs_ioend_t\t\t*next;\n\tstruct buffer_head\t*bh;\n\tstruct bio\t\t*bio;\n\tsector_t\t\tlastblock = 0;\n\n\t/* Pass 1 - start writeback */\n\tdo {\n\t\tnext = ioend->io_list;\n\t\tfor (bh = ioend->io_buffer_head; bh; bh = bh->b_private)\n\t\t\txfs_start_buffer_writeback(bh);\n\t} while ((ioend = next) != NULL);\n\n\t/* Pass 2 - submit I/O */\n\tioend = head;\n\tdo {\n\t\tnext = ioend->io_list;\n\t\tbio = NULL;\n\n\t\t/*\n\t\t * If we are failing the IO now, just mark the ioend with an\n\t\t * error and finish it. This will run IO completion immediately\n\t\t * as there is only one reference to the ioend at this point in\n\t\t * time.\n\t\t */\n\t\tif (fail) {\n\t\t\tioend->io_error = fail;\n\t\t\txfs_finish_ioend(ioend);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (bh = ioend->io_buffer_head; bh; bh = bh->b_private) {\n\n\t\t\tif (!bio) {\n retry:\n\t\t\t\tbio = xfs_alloc_ioend_bio(bh);\n\t\t\t} else if (bh->b_blocknr != lastblock + 1) {\n\t\t\t\txfs_submit_ioend_bio(wbc, ioend, bio);\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\tif (xfs_bio_add_buffer(bio, bh) != bh->b_size) {\n\t\t\t\txfs_submit_ioend_bio(wbc, ioend, bio);\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\tlastblock = bh->b_blocknr;\n\t\t}\n\t\tif (bio)\n\t\t\txfs_submit_ioend_bio(wbc, ioend, bio);\n\t\txfs_finish_ioend(ioend);\n\t} while ((ioend = next) != NULL);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_submit_ioend(\n\tstruct writeback_control *wbc,\n\txfs_ioend_t\t\t*ioend,\n\tint\t\t\tfail)\n{\n\txfs_ioend_t\t\t*head = ioend;\n\txfs_ioend_t\t\t*next;\n\tstruct buffer_head\t*bh;\n\tstruct bio\t\t*bio;\n\tsector_t\t\tlastblock = 0;\n\n\t/* Pass 1 - start writeback */\n\tdo {\n\t\tnext = ioend->io_list;\n\t\tfor (bh = ioend->io_buffer_head; bh; bh = bh->b_private)\n\t\t\txfs_start_buffer_writeback(bh);\n\t} while ((ioend = next) != NULL);\n\n\t/* Pass 2 - submit I/O */\n\tioend = head;\n\tdo {\n\t\tnext = ioend->io_list;\n\t\tbio = NULL;\n\n\t\t/*\n\t\t * If we are failing the IO now, just mark the ioend with an\n\t\t * error and finish it. This will run IO completion immediately\n\t\t * as there is only one reference to the ioend at this point in\n\t\t * time.\n\t\t */\n\t\tif (fail) {\n\t\t\tioend->io_error = fail;\n\t\t\txfs_finish_ioend(ioend);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (bh = ioend->io_buffer_head; bh; bh = bh->b_private) {\n\n\t\t\tif (!bio) {\n retry:\n\t\t\t\tbio = xfs_alloc_ioend_bio(bh);\n\t\t\t} else if (bh->b_blocknr != lastblock + 1) {\n\t\t\t\txfs_submit_ioend_bio(wbc, ioend, bio);\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\tif (xfs_bio_add_buffer(bio, bh) != bh->b_size) {\n\t\t\t\txfs_submit_ioend_bio(wbc, ioend, bio);\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\tlastblock = bh->b_blocknr;\n\t\t}\n\t\tif (bio)\n\t\t\txfs_submit_ioend_bio(wbc, ioend, bio);\n\t\txfs_finish_ioend(ioend);\n\t} while ((ioend = next) != NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_setfilesize_trans_alloc",
          "args": [
            "ioend"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setfilesize_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "101-131",
          "snippet": "STATIC int\nxfs_setfilesize_trans_alloc(\n\tstruct xfs_ioend\t*ioend)\n{\n\tstruct xfs_mount\t*mp = XFS_I(ioend->io_inode)->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_FSYNC_TS);\n\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_fsyncts, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\tioend->io_append_trans = tp;\n\n\t/*\n\t * We may pass freeze protection with a transaction.  So tell lockdep\n\t * we released it.\n\t */\n\trwsem_release(&ioend->io_inode->i_sb->s_writers.lock_map[SB_FREEZE_FS-1],\n\t\t      1, _THIS_IP_);\n\t/*\n\t * We hand off the transaction to the completion thread now, so\n\t * clear the flag here.\n\t */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_setfilesize_trans_alloc(\n\tstruct xfs_ioend\t*ioend)\n{\n\tstruct xfs_mount\t*mp = XFS_I(ioend->io_inode)->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_FSYNC_TS);\n\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_fsyncts, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\tioend->io_append_trans = tp;\n\n\t/*\n\t * We may pass freeze protection with a transaction.  So tell lockdep\n\t * we released it.\n\t */\n\trwsem_release(&ioend->io_inode->i_sb->s_writers.lock_map[SB_FREEZE_FS-1],\n\t\t      1, _THIS_IP_);\n\t/*\n\t * We hand off the transaction to the completion thread now, so\n\t * clear the flag here.\n\t */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ioend_is_append",
          "args": [
            "ioend"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioend_is_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "95-99",
          "snippet": "static inline bool xfs_ioend_is_append(struct xfs_ioend *ioend)\n{\n\treturn ioend->io_offset + ioend->io_size >\n\t\tXFS_I(ioend->io_inode)->i_d.di_size;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic inline bool xfs_ioend_is_append(struct xfs_ioend *ioend)\n{\n\treturn ioend->io_offset + ioend->io_size >\n\t\tXFS_I(ioend->io_inode)->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_cluster_write",
          "args": [
            "inode",
            "page->index + 1",
            "&imap",
            "&ioend",
            "wbc",
            "end_index"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_cluster_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "823-852",
          "snippet": "STATIC void\nxfs_cluster_write(\n\tstruct inode\t\t*inode,\n\tpgoff_t\t\t\ttindex,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_ioend_t\t\t**ioendp,\n\tstruct writeback_control *wbc,\n\tpgoff_t\t\t\ttlast)\n{\n\tstruct pagevec\t\tpvec;\n\tint\t\t\tdone = 0, i;\n\n\tpagevec_init(&pvec, 0);\n\twhile (!done && tindex <= tlast) {\n\t\tunsigned len = min_t(pgoff_t, PAGEVEC_SIZE, tlast - tindex + 1);\n\n\t\tif (!pagevec_lookup(&pvec, inode->i_mapping, tindex, len))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tdone = xfs_convert_page(inode, pvec.pages[i], tindex++,\n\t\t\t\t\timap, ioendp, wbc);\n\t\t\tif (done)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_cluster_write(\n\tstruct inode\t\t*inode,\n\tpgoff_t\t\t\ttindex,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_ioend_t\t\t**ioendp,\n\tstruct writeback_control *wbc,\n\tpgoff_t\t\t\ttlast)\n{\n\tstruct pagevec\t\tpvec;\n\tint\t\t\tdone = 0, i;\n\n\tpagevec_init(&pvec, 0);\n\twhile (!done && tindex <= tlast) {\n\t\tunsigned len = min_t(pgoff_t, PAGEVEC_SIZE, tlast - tindex + 1);\n\n\t\tif (!pagevec_lookup(&pvec, inode->i_mapping, tindex, len))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tdone = xfs_convert_page(inode, pvec.pages[i], tindex++,\n\t\t\t\t\timap, ioendp, wbc);\n\t\t\tif (done)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "iohead"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_start_page_writeback",
          "args": [
            "page",
            "1",
            "count"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_start_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "410-437",
          "snippet": "STATIC void\nxfs_start_page_writeback(\n\tstruct page\t\t*page,\n\tint\t\t\tclear_dirty,\n\tint\t\t\tbuffers)\n{\n\tASSERT(PageLocked(page));\n\tASSERT(!PageWriteback(page));\n\n\t/*\n\t * if the page was not fully cleaned, we need to ensure that the higher\n\t * layers come back to it correctly. That means we need to keep the page\n\t * dirty, and for WB_SYNC_ALL writeback we need to ensure the\n\t * PAGECACHE_TAG_TOWRITE index mark is not removed so another attempt to\n\t * write this page in this writeback sweep will be made.\n\t */\n\tif (clear_dirty) {\n\t\tclear_page_dirty_for_io(page);\n\t\tset_page_writeback(page);\n\t} else\n\t\tset_page_writeback_keepwrite(page);\n\n\tunlock_page(page);\n\n\t/* If no buffers on the page are to be written, finish it here */\n\tif (!buffers)\n\t\tend_page_writeback(page);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_start_page_writeback(\n\tstruct page\t\t*page,\n\tint\t\t\tclear_dirty,\n\tint\t\t\tbuffers)\n{\n\tASSERT(PageLocked(page));\n\tASSERT(!PageWriteback(page));\n\n\t/*\n\t * if the page was not fully cleaned, we need to ensure that the higher\n\t * layers come back to it correctly. That means we need to keep the page\n\t * dirty, and for WB_SYNC_ALL writeback we need to ensure the\n\t * PAGECACHE_TAG_TOWRITE index mark is not removed so another attempt to\n\t * write this page in this writeback sweep will be made.\n\t */\n\tif (clear_dirty) {\n\t\tclear_page_dirty_for_io(page);\n\t\tset_page_writeback(page);\n\t} else\n\t\tset_page_writeback_keepwrite(page);\n\n\tunlock_page(page);\n\n\t/* If no buffers on the page are to be written, finish it here */\n\tif (!buffers)\n\t\tend_page_writeback(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_add_to_ioend",
          "args": [
            "inode",
            "bh",
            "offset",
            "type",
            "&ioend",
            "new_ioend"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_add_to_ioend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "564-592",
          "snippet": "STATIC void\nxfs_add_to_ioend(\n\tstruct inode\t\t*inode,\n\tstruct buffer_head\t*bh,\n\txfs_off_t\t\toffset,\n\tunsigned int\t\ttype,\n\txfs_ioend_t\t\t**result,\n\tint\t\t\tneed_ioend)\n{\n\txfs_ioend_t\t\t*ioend = *result;\n\n\tif (!ioend || need_ioend || type != ioend->io_type) {\n\t\txfs_ioend_t\t*previous = *result;\n\n\t\tioend = xfs_alloc_ioend(inode, type);\n\t\tioend->io_offset = offset;\n\t\tioend->io_buffer_head = bh;\n\t\tioend->io_buffer_tail = bh;\n\t\tif (previous)\n\t\t\tprevious->io_list = ioend;\n\t\t*result = ioend;\n\t} else {\n\t\tioend->io_buffer_tail->b_private = bh;\n\t\tioend->io_buffer_tail = bh;\n\t}\n\n\tbh->b_private = NULL;\n\tioend->io_size += bh->b_size;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_add_to_ioend(\n\tstruct inode\t\t*inode,\n\tstruct buffer_head\t*bh,\n\txfs_off_t\t\toffset,\n\tunsigned int\t\ttype,\n\txfs_ioend_t\t\t**result,\n\tint\t\t\tneed_ioend)\n{\n\txfs_ioend_t\t\t*ioend = *result;\n\n\tif (!ioend || need_ioend || type != ioend->io_type) {\n\t\txfs_ioend_t\t*previous = *result;\n\n\t\tioend = xfs_alloc_ioend(inode, type);\n\t\tioend->io_offset = offset;\n\t\tioend->io_buffer_head = bh;\n\t\tioend->io_buffer_tail = bh;\n\t\tif (previous)\n\t\t\tprevious->io_list = ioend;\n\t\t*result = ioend;\n\t} else {\n\t\tioend->io_buffer_tail->b_private = bh;\n\t\tioend->io_buffer_tail = bh;\n\t}\n\n\tbh->b_private = NULL;\n\tioend->io_size += bh->b_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_map_at_offset",
          "args": [
            "inode",
            "bh",
            "&imap",
            "offset"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_map_at_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "618-632",
          "snippet": "STATIC void\nxfs_map_at_offset(\n\tstruct inode\t\t*inode,\n\tstruct buffer_head\t*bh,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_off_t\t\toffset)\n{\n\tASSERT(imap->br_startblock != HOLESTARTBLOCK);\n\tASSERT(imap->br_startblock != DELAYSTARTBLOCK);\n\n\txfs_map_buffer(inode, bh, imap, offset);\n\tset_buffer_mapped(bh);\n\tclear_buffer_delay(bh);\n\tclear_buffer_unwritten(bh);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_map_at_offset(\n\tstruct inode\t\t*inode,\n\tstruct buffer_head\t*bh,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_off_t\t\toffset)\n{\n\tASSERT(imap->br_startblock != HOLESTARTBLOCK);\n\tASSERT(imap->br_startblock != DELAYSTARTBLOCK);\n\n\txfs_map_buffer(inode, bh, imap, offset);\n\tset_buffer_mapped(bh);\n\tclear_buffer_delay(bh);\n\tclear_buffer_unwritten(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_imap_valid",
          "args": [
            "inode",
            "&imap",
            "offset"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_imap_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "338-348",
          "snippet": "STATIC int\nxfs_imap_valid(\n\tstruct inode\t\t*inode,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_off_t\t\toffset)\n{\n\toffset >>= inode->i_blkbits;\n\n\treturn offset >= imap->br_startoff &&\n\t\toffset < imap->br_startoff + imap->br_blockcount;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_imap_valid(\n\tstruct inode\t\t*inode,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_off_t\t\toffset)\n{\n\toffset >>= inode->i_blkbits;\n\n\treturn offset >= imap->br_startoff &&\n\t\toffset < imap->br_startoff + imap->br_blockcount;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_map_blocks",
          "args": [
            "inode",
            "offset",
            "&imap",
            "type",
            "nonblocking"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_map_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "275-336",
          "snippet": "STATIC int\nxfs_map_blocks(\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\toffset,\n\tstruct xfs_bmbt_irec\t*imap,\n\tint\t\t\ttype,\n\tint\t\t\tnonblocking)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tssize_t\t\t\tcount = 1 << inode->i_blkbits;\n\txfs_fileoff_t\t\toffset_fsb, end_fsb;\n\tint\t\t\terror = 0;\n\tint\t\t\tbmapi_flags = XFS_BMAPI_ENTIRE;\n\tint\t\t\tnimaps = 1;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tif (type == XFS_IO_UNWRITTEN)\n\t\tbmapi_flags |= XFS_BMAPI_IGSTATE;\n\n\tif (!xfs_ilock_nowait(ip, XFS_ILOCK_SHARED)) {\n\t\tif (nonblocking)\n\t\t\treturn -EAGAIN;\n\t\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\t}\n\n\tASSERT(ip->i_d.di_format != XFS_DINODE_FMT_BTREE ||\n\t       (ip->i_df.if_flags & XFS_IFEXTENTS));\n\tASSERT(offset <= mp->m_super->s_maxbytes);\n\n\tif (offset + count > mp->m_super->s_maxbytes)\n\t\tcount = mp->m_super->s_maxbytes - offset;\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + count);\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\terror = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb,\n\t\t\t\timap, &nimaps, bmapi_flags);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (error)\n\t\treturn error;\n\n\tif (type == XFS_IO_DELALLOC &&\n\t    (!nimaps || isnullstartblock(imap->br_startblock))) {\n\t\terror = xfs_iomap_write_allocate(ip, offset, imap);\n\t\tif (!error)\n\t\t\ttrace_xfs_map_blocks_alloc(ip, offset, count, type, imap);\n\t\treturn error;\n\t}\n\n#ifdef DEBUG\n\tif (type == XFS_IO_UNWRITTEN) {\n\t\tASSERT(nimaps);\n\t\tASSERT(imap->br_startblock != HOLESTARTBLOCK);\n\t\tASSERT(imap->br_startblock != DELAYSTARTBLOCK);\n\t}\n#endif\n\tif (nimaps)\n\t\ttrace_xfs_map_blocks_found(ip, offset, count, type, imap);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_map_blocks(\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\toffset,\n\tstruct xfs_bmbt_irec\t*imap,\n\tint\t\t\ttype,\n\tint\t\t\tnonblocking)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tssize_t\t\t\tcount = 1 << inode->i_blkbits;\n\txfs_fileoff_t\t\toffset_fsb, end_fsb;\n\tint\t\t\terror = 0;\n\tint\t\t\tbmapi_flags = XFS_BMAPI_ENTIRE;\n\tint\t\t\tnimaps = 1;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tif (type == XFS_IO_UNWRITTEN)\n\t\tbmapi_flags |= XFS_BMAPI_IGSTATE;\n\n\tif (!xfs_ilock_nowait(ip, XFS_ILOCK_SHARED)) {\n\t\tif (nonblocking)\n\t\t\treturn -EAGAIN;\n\t\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\t}\n\n\tASSERT(ip->i_d.di_format != XFS_DINODE_FMT_BTREE ||\n\t       (ip->i_df.if_flags & XFS_IFEXTENTS));\n\tASSERT(offset <= mp->m_super->s_maxbytes);\n\n\tif (offset + count > mp->m_super->s_maxbytes)\n\t\tcount = mp->m_super->s_maxbytes - offset;\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + count);\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\terror = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb,\n\t\t\t\timap, &nimaps, bmapi_flags);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (error)\n\t\treturn error;\n\n\tif (type == XFS_IO_DELALLOC &&\n\t    (!nimaps || isnullstartblock(imap->br_startblock))) {\n\t\terror = xfs_iomap_write_allocate(ip, offset, imap);\n\t\tif (!error)\n\t\t\ttrace_xfs_map_blocks_alloc(ip, offset, count, type, imap);\n\t\treturn error;\n\t}\n\n#ifdef DEBUG\n\tif (type == XFS_IO_UNWRITTEN) {\n\t\tASSERT(nimaps);\n\t\tASSERT(imap->br_startblock != HOLESTARTBLOCK);\n\t\tASSERT(imap->br_startblock != DELAYSTARTBLOCK);\n\t}\n#endif\n\tif (nimaps)\n\t\ttrace_xfs_map_blocks_found(ip, offset, count, type, imap);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "buffer_mapped(bh)"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "offset_into_page",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "page->index + 1"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "current->flags & PF_FSTRANS"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(current->flags & (PF_MEMALLOC|PF_KSWAPD)) ==\n\t\t\tPF_MEMALLOC"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "page_has_buffers(page)"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_writepage",
          "args": [
            "inode",
            "page",
            "0",
            "0"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vm_writepage(\n\tstruct page\t\t*page,\n\tstruct writeback_control *wbc)\n{\n\tstruct inode\t\t*inode = page->mapping->host;\n\tstruct buffer_head\t*bh, *head;\n\tstruct xfs_bmbt_irec\timap;\n\txfs_ioend_t\t\t*ioend = NULL, *iohead = NULL;\n\tloff_t\t\t\toffset;\n\tunsigned int\t\ttype;\n\t__uint64_t              end_offset;\n\tpgoff_t                 end_index, last_index;\n\tssize_t\t\t\tlen;\n\tint\t\t\terr, imap_valid = 0, uptodate = 1;\n\tint\t\t\tcount = 0;\n\tint\t\t\tnonblocking = 0;\n\n\ttrace_xfs_writepage(inode, page, 0, 0);\n\n\tASSERT(page_has_buffers(page));\n\n\t/*\n\t * Refuse to write the page out if we are called from reclaim context.\n\t *\n\t * This avoids stack overflows when called from deeply used stacks in\n\t * random callers for direct reclaim or memcg reclaim.  We explicitly\n\t * allow reclaim from kswapd as the stack usage there is relatively low.\n\t *\n\t * This should never happen except in the case of a VM regression so\n\t * warn about it.\n\t */\n\tif (WARN_ON_ONCE((current->flags & (PF_MEMALLOC|PF_KSWAPD)) ==\n\t\t\tPF_MEMALLOC))\n\t\tgoto redirty;\n\n\t/*\n\t * Given that we do not allow direct reclaim to call us, we should\n\t * never be called while in a filesystem transaction.\n\t */\n\tif (WARN_ON_ONCE(current->flags & PF_FSTRANS))\n\t\tgoto redirty;\n\n\t/* Is this page beyond the end of the file? */\n\toffset = i_size_read(inode);\n\tend_index = offset >> PAGE_CACHE_SHIFT;\n\tlast_index = (offset - 1) >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * The page index is less than the end_index, adjust the end_offset\n\t * to the highest offset that this page should represent.\n\t * -----------------------------------------------------\n\t * |\t\t\tfile mapping\t       | <EOF> |\n\t * -----------------------------------------------------\n\t * | Page ... | Page N-2 | Page N-1 |  Page N  |       |\n\t * ^--------------------------------^----------|--------\n\t * |     desired writeback range    |      see else    |\n\t * ---------------------------------^------------------|\n\t */\n\tif (page->index < end_index)\n\t\tend_offset = (xfs_off_t)(page->index + 1) << PAGE_CACHE_SHIFT;\n\telse {\n\t\t/*\n\t\t * Check whether the page to write out is beyond or straddles\n\t\t * i_size or not.\n\t\t * -------------------------------------------------------\n\t\t * |\t\tfile mapping\t\t        | <EOF>  |\n\t\t * -------------------------------------------------------\n\t\t * | Page ... | Page N-2 | Page N-1 |  Page N   | Beyond |\n\t\t * ^--------------------------------^-----------|---------\n\t\t * |\t\t\t\t    |      Straddles     |\n\t\t * ---------------------------------^-----------|--------|\n\t\t */\n\t\tunsigned offset_into_page = offset & (PAGE_CACHE_SIZE - 1);\n\n\t\t/*\n\t\t * Skip the page if it is fully outside i_size, e.g. due to a\n\t\t * truncate operation that is in progress. We must redirty the\n\t\t * page so that reclaim stops reclaiming it. Otherwise\n\t\t * xfs_vm_releasepage() is called on it and gets confused.\n\t\t *\n\t\t * Note that the end_index is unsigned long, it would overflow\n\t\t * if the given offset is greater than 16TB on 32-bit system\n\t\t * and if we do check the page is fully outside i_size or not\n\t\t * via \"if (page->index >= end_index + 1)\" as \"end_index + 1\"\n\t\t * will be evaluated to 0.  Hence this page will be redirtied\n\t\t * and be written out repeatedly which would result in an\n\t\t * infinite loop, the user program that perform this operation\n\t\t * will hang.  Instead, we can verify this situation by checking\n\t\t * if the page to write is totally beyond the i_size or if it's\n\t\t * offset is just equal to the EOF.\n\t\t */\n\t\tif (page->index > end_index ||\n\t\t    (page->index == end_index && offset_into_page == 0))\n\t\t\tgoto redirty;\n\n\t\t/*\n\t\t * The page straddles i_size.  It must be zeroed out on each\n\t\t * and every writepage invocation because it may be mmapped.\n\t\t * \"A file is mapped in multiples of the page size.  For a file\n\t\t * that is not a multiple of the page size, the remaining\n\t\t * memory is zeroed when mapped, and writes to that region are\n\t\t * not written out to the file.\"\n\t\t */\n\t\tzero_user_segment(page, offset_into_page, PAGE_CACHE_SIZE);\n\n\t\t/* Adjust the end_offset to the end of file */\n\t\tend_offset = offset;\n\t}\n\n\tlen = 1 << inode->i_blkbits;\n\n\tbh = head = page_buffers(page);\n\toffset = page_offset(page);\n\ttype = XFS_IO_OVERWRITE;\n\n\tif (wbc->sync_mode == WB_SYNC_NONE)\n\t\tnonblocking = 1;\n\n\tdo {\n\t\tint new_ioend = 0;\n\n\t\tif (offset >= end_offset)\n\t\t\tbreak;\n\t\tif (!buffer_uptodate(bh))\n\t\t\tuptodate = 0;\n\n\t\t/*\n\t\t * set_page_dirty dirties all buffers in a page, independent\n\t\t * of their state.  The dirty state however is entirely\n\t\t * meaningless for holes (!mapped && uptodate), so skip\n\t\t * buffers covering holes here.\n\t\t */\n\t\tif (!buffer_mapped(bh) && buffer_uptodate(bh)) {\n\t\t\timap_valid = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_unwritten(bh)) {\n\t\t\tif (type != XFS_IO_UNWRITTEN) {\n\t\t\t\ttype = XFS_IO_UNWRITTEN;\n\t\t\t\timap_valid = 0;\n\t\t\t}\n\t\t} else if (buffer_delay(bh)) {\n\t\t\tif (type != XFS_IO_DELALLOC) {\n\t\t\t\ttype = XFS_IO_DELALLOC;\n\t\t\t\timap_valid = 0;\n\t\t\t}\n\t\t} else if (buffer_uptodate(bh)) {\n\t\t\tif (type != XFS_IO_OVERWRITE) {\n\t\t\t\ttype = XFS_IO_OVERWRITE;\n\t\t\t\timap_valid = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (PageUptodate(page))\n\t\t\t\tASSERT(buffer_mapped(bh));\n\t\t\t/*\n\t\t\t * This buffer is not uptodate and will not be\n\t\t\t * written to disk.  Ensure that we will put any\n\t\t\t * subsequent writeable buffers into a new\n\t\t\t * ioend.\n\t\t\t */\n\t\t\timap_valid = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (imap_valid)\n\t\t\timap_valid = xfs_imap_valid(inode, &imap, offset);\n\t\tif (!imap_valid) {\n\t\t\t/*\n\t\t\t * If we didn't have a valid mapping then we need to\n\t\t\t * put the new mapping into a separate ioend structure.\n\t\t\t * This ensures non-contiguous extents always have\n\t\t\t * separate ioends, which is particularly important\n\t\t\t * for unwritten extent conversion at I/O completion\n\t\t\t * time.\n\t\t\t */\n\t\t\tnew_ioend = 1;\n\t\t\terr = xfs_map_blocks(inode, offset, &imap, type,\n\t\t\t\t\t     nonblocking);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\timap_valid = xfs_imap_valid(inode, &imap, offset);\n\t\t}\n\t\tif (imap_valid) {\n\t\t\tlock_buffer(bh);\n\t\t\tif (type != XFS_IO_OVERWRITE)\n\t\t\t\txfs_map_at_offset(inode, bh, &imap, offset);\n\t\t\txfs_add_to_ioend(inode, bh, offset, type, &ioend,\n\t\t\t\t\t new_ioend);\n\t\t\tcount++;\n\t\t}\n\n\t\tif (!iohead)\n\t\t\tiohead = ioend;\n\n\t} while (offset += len, ((bh = bh->b_this_page) != head));\n\n\tif (uptodate && bh == head)\n\t\tSetPageUptodate(page);\n\n\txfs_start_page_writeback(page, 1, count);\n\n\t/* if there is no IO to be submitted for this page, we are done */\n\tif (!ioend)\n\t\treturn 0;\n\n\tASSERT(iohead);\n\n\t/*\n\t * Any errors from this point onwards need tobe reported through the IO\n\t * completion path as we have marked the initial page as under writeback\n\t * and unlocked it.\n\t */\n\tif (imap_valid) {\n\t\txfs_off_t\t\tend_index;\n\n\t\tend_index = imap.br_startoff + imap.br_blockcount;\n\n\t\t/* to bytes */\n\t\tend_index <<= inode->i_blkbits;\n\n\t\t/* to pages */\n\t\tend_index = (end_index - 1) >> PAGE_CACHE_SHIFT;\n\n\t\t/* check against file size */\n\t\tif (end_index > last_index)\n\t\t\tend_index = last_index;\n\n\t\txfs_cluster_write(inode, page->index + 1, &imap, &ioend,\n\t\t\t\t  wbc, end_index);\n\t}\n\n\n\t/*\n\t * Reserve log space if we might write beyond the on-disk inode size.\n\t */\n\terr = 0;\n\tif (ioend->io_type != XFS_IO_UNWRITTEN && xfs_ioend_is_append(ioend))\n\t\terr = xfs_setfilesize_trans_alloc(ioend);\n\n\txfs_submit_ioend(wbc, iohead, err);\n\n\treturn 0;\n\nerror:\n\tif (iohead)\n\t\txfs_cancel_ioend(iohead);\n\n\tif (err == -EAGAIN)\n\t\tgoto redirty;\n\n\txfs_aops_discard_page(page);\n\tClearPageUptodate(page);\n\tunlock_page(page);\n\treturn err;\n\nredirty:\n\tredirty_page_for_writepage(wbc, page);\n\tunlock_page(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_aops_discard_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "881-928",
    "snippet": "STATIC void\nxfs_aops_discard_page(\n\tstruct page\t\t*page)\n{\n\tstruct inode\t\t*inode = page->mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct buffer_head\t*bh, *head;\n\tloff_t\t\t\toffset = page_offset(page);\n\n\tif (!xfs_check_page_type(page, XFS_IO_DELALLOC, true))\n\t\tgoto out_invalidate;\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\tgoto out_invalidate;\n\n\txfs_alert(ip->i_mount,\n\t\t\"page discard on page %p, inode 0x%llx, offset %llu.\",\n\t\t\tpage, ip->i_ino, offset);\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tint\t\terror;\n\t\txfs_fileoff_t\tstart_fsb;\n\n\t\tif (!buffer_delay(bh))\n\t\t\tgoto next_buffer;\n\n\t\tstart_fsb = XFS_B_TO_FSBT(ip->i_mount, offset);\n\t\terror = xfs_bmap_punch_delalloc_range(ip, start_fsb, 1);\n\t\tif (error) {\n\t\t\t/* something screwed, just bail */\n\t\t\tif (!XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\t\t\txfs_alert(ip->i_mount,\n\t\t\t\"page discard unable to remove delalloc mapping.\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nnext_buffer:\n\t\toffset += 1 << inode->i_blkbits;\n\n\t} while ((bh = bh->b_this_page) != head);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\nout_invalidate:\n\txfs_vm_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\treturn;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_vm_invalidatepage",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_vm_invalidatepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "854-863",
          "snippet": "STATIC void\nxfs_vm_invalidatepage(\n\tstruct page\t\t*page,\n\tunsigned int\t\toffset,\n\tunsigned int\t\tlength)\n{\n\ttrace_xfs_invalidatepage(page->mapping->host, page, offset,\n\t\t\t\t length);\n\tblock_invalidatepage(page, offset, length);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_vm_invalidatepage(\n\tstruct page\t\t*page,\n\tunsigned int\t\toffset,\n\tunsigned int\t\tlength)\n{\n\ttrace_xfs_invalidatepage(page->mapping->host, page, offset,\n\t\t\t\t length);\n\tblock_invalidatepage(page, offset, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "ip->i_mount",
            "\"page discard unable to remove delalloc mapping.\""
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_fsblock_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iomap.c",
          "lines": "95-110",
          "snippet": "STATIC int\nxfs_alert_fsblock_zero(\n\txfs_inode_t\t*ip,\n\txfs_bmbt_irec_t\t*imap)\n{\n\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\"blkcnt: %llx extent-state: %x\",\n\t\t(unsigned long long)ip->i_ino,\n\t\t(unsigned long long)imap->br_startblock,\n\t\t(unsigned long long)imap->br_startoff,\n\t\t(unsigned long long)imap->br_blockcount,\n\t\timap->br_state);\n\treturn -EFSCORRUPTED;\n}",
          "includes": [
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_alert_fsblock_zero(\n\txfs_inode_t\t*ip,\n\txfs_bmbt_irec_t\t*imap)\n{\n\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\"blkcnt: %llx extent-state: %x\",\n\t\t(unsigned long long)ip->i_ino,\n\t\t(unsigned long long)imap->br_startblock,\n\t\t(unsigned long long)imap->br_startoff,\n\t\t(unsigned long long)imap->br_blockcount,\n\t\timap->br_state);\n\treturn -EFSCORRUPTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "ip->i_mount"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_punch_delalloc_range",
          "args": [
            "ip",
            "start_fsb",
            "1"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_punch_delalloc_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "725-790",
          "snippet": "int\nxfs_bmap_punch_delalloc_range(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tstart_fsb,\n\txfs_fileoff_t\t\tlength)\n{\n\txfs_fileoff_t\t\tremaining = length;\n\tint\t\t\terror = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tdo {\n\t\tint\t\tdone;\n\t\txfs_bmbt_irec_t\timap;\n\t\tint\t\tnimaps = 1;\n\t\txfs_fsblock_t\tfirstblock;\n\t\txfs_bmap_free_t flist;\n\n\t\t/*\n\t\t * Map the range first and check that it is a delalloc extent\n\t\t * before trying to unmap the range. Otherwise we will be\n\t\t * trying to remove a real extent (which requires a\n\t\t * transaction) or a hole, which is probably a bad idea...\n\t\t */\n\t\terror = xfs_bmapi_read(ip, start_fsb, 1, &imap, &nimaps,\n\t\t\t\t       XFS_BMAPI_ENTIRE);\n\n\t\tif (error) {\n\t\t\t/* something screwed, just bail */\n\t\t\tif (!XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\t\t\txfs_alert(ip->i_mount,\n\t\t\t\"Failed delalloc mapping lookup ino %lld fsb %lld.\",\n\t\t\t\t\t\tip->i_ino, start_fsb);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (!nimaps) {\n\t\t\t/* nothing there */\n\t\t\tgoto next_block;\n\t\t}\n\t\tif (imap.br_startblock != DELAYSTARTBLOCK) {\n\t\t\t/* been converted, ignore */\n\t\t\tgoto next_block;\n\t\t}\n\t\tWARN_ON(imap.br_blockcount == 0);\n\n\t\t/*\n\t\t * Note: while we initialise the firstblock/flist pair, they\n\t\t * should never be used because blocks should never be\n\t\t * allocated or freed for a delalloc extent and hence we need\n\t\t * don't cancel or finish them after the xfs_bunmapi() call.\n\t\t */\n\t\txfs_bmap_init(&flist, &firstblock);\n\t\terror = xfs_bunmapi(NULL, ip, start_fsb, 1, 0, 1, &firstblock,\n\t\t\t\t\t&flist, &done);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tASSERT(!flist.xbf_count && !flist.xbf_first);\nnext_block:\n\t\tstart_fsb++;\n\t\tremaining--;\n\t} while(remaining > 0);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_punch_delalloc_range(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tstart_fsb,\n\txfs_fileoff_t\t\tlength)\n{\n\txfs_fileoff_t\t\tremaining = length;\n\tint\t\t\terror = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tdo {\n\t\tint\t\tdone;\n\t\txfs_bmbt_irec_t\timap;\n\t\tint\t\tnimaps = 1;\n\t\txfs_fsblock_t\tfirstblock;\n\t\txfs_bmap_free_t flist;\n\n\t\t/*\n\t\t * Map the range first and check that it is a delalloc extent\n\t\t * before trying to unmap the range. Otherwise we will be\n\t\t * trying to remove a real extent (which requires a\n\t\t * transaction) or a hole, which is probably a bad idea...\n\t\t */\n\t\terror = xfs_bmapi_read(ip, start_fsb, 1, &imap, &nimaps,\n\t\t\t\t       XFS_BMAPI_ENTIRE);\n\n\t\tif (error) {\n\t\t\t/* something screwed, just bail */\n\t\t\tif (!XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\t\t\txfs_alert(ip->i_mount,\n\t\t\t\"Failed delalloc mapping lookup ino %lld fsb %lld.\",\n\t\t\t\t\t\tip->i_ino, start_fsb);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (!nimaps) {\n\t\t\t/* nothing there */\n\t\t\tgoto next_block;\n\t\t}\n\t\tif (imap.br_startblock != DELAYSTARTBLOCK) {\n\t\t\t/* been converted, ignore */\n\t\t\tgoto next_block;\n\t\t}\n\t\tWARN_ON(imap.br_blockcount == 0);\n\n\t\t/*\n\t\t * Note: while we initialise the firstblock/flist pair, they\n\t\t * should never be used because blocks should never be\n\t\t * allocated or freed for a delalloc extent and hence we need\n\t\t * don't cancel or finish them after the xfs_bunmapi() call.\n\t\t */\n\t\txfs_bmap_init(&flist, &firstblock);\n\t\terror = xfs_bunmapi(NULL, ip, start_fsb, 1, 0, 1, &firstblock,\n\t\t\t\t\t&flist, &done);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tASSERT(!flist.xbf_count && !flist.xbf_first);\nnext_block:\n\t\tstart_fsb++;\n\t\tremaining--;\n\t} while(remaining > 0);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSBT",
          "args": [
            "ip->i_mount",
            "offset"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "ip->i_mount",
            "\"page discard on page %p, inode 0x%llx, offset %llu.\"",
            "page",
            "ip->i_ino",
            "offset"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "ip->i_mount"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_check_page_type",
          "args": [
            "page",
            "XFS_IO_DELALLOC",
            "true"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_check_page_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "640-675",
          "snippet": "STATIC bool\nxfs_check_page_type(\n\tstruct page\t\t*page,\n\tunsigned int\t\ttype,\n\tbool\t\t\tcheck_all_buffers)\n{\n\tstruct buffer_head\t*bh;\n\tstruct buffer_head\t*head;\n\n\tif (PageWriteback(page))\n\t\treturn false;\n\tif (!page->mapping)\n\t\treturn false;\n\tif (!page_has_buffers(page))\n\t\treturn false;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_unwritten(bh)) {\n\t\t\tif (type == XFS_IO_UNWRITTEN)\n\t\t\t\treturn true;\n\t\t} else if (buffer_delay(bh)) {\n\t\t\tif (type == XFS_IO_DELALLOC)\n\t\t\t\treturn true;\n\t\t} else if (buffer_dirty(bh) && buffer_mapped(bh)) {\n\t\t\tif (type == XFS_IO_OVERWRITE)\n\t\t\t\treturn true;\n\t\t}\n\n\t\t/* If we are only checking the first buffer, we are done now. */\n\t\tif (!check_all_buffers)\n\t\t\tbreak;\n\t} while ((bh = bh->b_this_page) != head);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC bool\nxfs_check_page_type(\n\tstruct page\t\t*page,\n\tunsigned int\t\ttype,\n\tbool\t\t\tcheck_all_buffers)\n{\n\tstruct buffer_head\t*bh;\n\tstruct buffer_head\t*head;\n\n\tif (PageWriteback(page))\n\t\treturn false;\n\tif (!page->mapping)\n\t\treturn false;\n\tif (!page_has_buffers(page))\n\t\treturn false;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_unwritten(bh)) {\n\t\t\tif (type == XFS_IO_UNWRITTEN)\n\t\t\t\treturn true;\n\t\t} else if (buffer_delay(bh)) {\n\t\t\tif (type == XFS_IO_DELALLOC)\n\t\t\t\treturn true;\n\t\t} else if (buffer_dirty(bh) && buffer_mapped(bh)) {\n\t\t\tif (type == XFS_IO_OVERWRITE)\n\t\t\t\treturn true;\n\t\t}\n\n\t\t/* If we are only checking the first buffer, we are done now. */\n\t\tif (!check_all_buffers)\n\t\t\tbreak;\n\t} while ((bh = bh->b_this_page) != head);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_aops_discard_page(\n\tstruct page\t\t*page)\n{\n\tstruct inode\t\t*inode = page->mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct buffer_head\t*bh, *head;\n\tloff_t\t\t\toffset = page_offset(page);\n\n\tif (!xfs_check_page_type(page, XFS_IO_DELALLOC, true))\n\t\tgoto out_invalidate;\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\tgoto out_invalidate;\n\n\txfs_alert(ip->i_mount,\n\t\t\"page discard on page %p, inode 0x%llx, offset %llu.\",\n\t\t\tpage, ip->i_ino, offset);\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tint\t\terror;\n\t\txfs_fileoff_t\tstart_fsb;\n\n\t\tif (!buffer_delay(bh))\n\t\t\tgoto next_buffer;\n\n\t\tstart_fsb = XFS_B_TO_FSBT(ip->i_mount, offset);\n\t\terror = xfs_bmap_punch_delalloc_range(ip, start_fsb, 1);\n\t\tif (error) {\n\t\t\t/* something screwed, just bail */\n\t\t\tif (!XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\t\t\txfs_alert(ip->i_mount,\n\t\t\t\"page discard unable to remove delalloc mapping.\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nnext_buffer:\n\t\toffset += 1 << inode->i_blkbits;\n\n\t} while ((bh = bh->b_this_page) != head);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\nout_invalidate:\n\txfs_vm_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\treturn;\n}"
  },
  {
    "function_name": "xfs_vm_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "854-863",
    "snippet": "STATIC void\nxfs_vm_invalidatepage(\n\tstruct page\t\t*page,\n\tunsigned int\t\toffset,\n\tunsigned int\t\tlength)\n{\n\ttrace_xfs_invalidatepage(page->mapping->host, page, offset,\n\t\t\t\t length);\n\tblock_invalidatepage(page, offset, length);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_invalidatepage",
          "args": [
            "page",
            "offset",
            "length"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "block_invalidatepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1509-1555",
          "snippet": "void block_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t  unsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int curr_off = 0;\n\tunsigned int stop = length + offset;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\t/*\n\t * Check for overflow\n\t */\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\t/*\n\t\t * Are we still fully in range ?\n\t\t */\n\t\tif (next_off > stop)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * is this block fully invalidated?\n\t\t */\n\t\tif (offset <= curr_off)\n\t\t\tdiscard_buffer(bh);\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\t} while (bh != head);\n\n\t/*\n\t * We release buffers only if the entire page is being invalidated.\n\t * The get_block cached value has been unconditionally invalidated,\n\t * so real IO is not possible anymore.\n\t */\n\tif (offset == 0)\n\t\ttry_to_release_page(page, 0);\nout:\n\treturn;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid block_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t  unsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int curr_off = 0;\n\tunsigned int stop = length + offset;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\t/*\n\t * Check for overflow\n\t */\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\t/*\n\t\t * Are we still fully in range ?\n\t\t */\n\t\tif (next_off > stop)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * is this block fully invalidated?\n\t\t */\n\t\tif (offset <= curr_off)\n\t\t\tdiscard_buffer(bh);\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\t} while (bh != head);\n\n\t/*\n\t * We release buffers only if the entire page is being invalidated.\n\t * The get_block cached value has been unconditionally invalidated,\n\t * so real IO is not possible anymore.\n\t */\n\tif (offset == 0)\n\t\ttry_to_release_page(page, 0);\nout:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_invalidatepage",
          "args": [
            "page->mapping->host",
            "page",
            "offset",
            "length"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_vm_invalidatepage(\n\tstruct page\t\t*page,\n\tunsigned int\t\toffset,\n\tunsigned int\t\tlength)\n{\n\ttrace_xfs_invalidatepage(page->mapping->host, page, offset,\n\t\t\t\t length);\n\tblock_invalidatepage(page, offset, length);\n}"
  },
  {
    "function_name": "xfs_cluster_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "823-852",
    "snippet": "STATIC void\nxfs_cluster_write(\n\tstruct inode\t\t*inode,\n\tpgoff_t\t\t\ttindex,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_ioend_t\t\t**ioendp,\n\tstruct writeback_control *wbc,\n\tpgoff_t\t\t\ttlast)\n{\n\tstruct pagevec\t\tpvec;\n\tint\t\t\tdone = 0, i;\n\n\tpagevec_init(&pvec, 0);\n\twhile (!done && tindex <= tlast) {\n\t\tunsigned len = min_t(pgoff_t, PAGEVEC_SIZE, tlast - tindex + 1);\n\n\t\tif (!pagevec_lookup(&pvec, inode->i_mapping, tindex, len))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tdone = xfs_convert_page(inode, pvec.pages[i], tindex++,\n\t\t\t\t\timap, ioendp, wbc);\n\t\t\tif (done)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_convert_page",
          "args": [
            "inode",
            "pvec.pages[i]",
            "tindex++",
            "imap",
            "ioendp",
            "wbc"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_convert_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "683-817",
          "snippet": "STATIC int\nxfs_convert_page(\n\tstruct inode\t\t*inode,\n\tstruct page\t\t*page,\n\tloff_t\t\t\ttindex,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_ioend_t\t\t**ioendp,\n\tstruct writeback_control *wbc)\n{\n\tstruct buffer_head\t*bh, *head;\n\txfs_off_t\t\tend_offset;\n\tunsigned long\t\tp_offset;\n\tunsigned int\t\ttype;\n\tint\t\t\tlen, page_dirty;\n\tint\t\t\tcount = 0, done = 0, uptodate = 1;\n \txfs_off_t\t\toffset = page_offset(page);\n\n\tif (page->index != tindex)\n\t\tgoto fail;\n\tif (!trylock_page(page))\n\t\tgoto fail;\n\tif (PageWriteback(page))\n\t\tgoto fail_unlock_page;\n\tif (page->mapping != inode->i_mapping)\n\t\tgoto fail_unlock_page;\n\tif (!xfs_check_page_type(page, (*ioendp)->io_type, false))\n\t\tgoto fail_unlock_page;\n\n\t/*\n\t * page_dirty is initially a count of buffers on the page before\n\t * EOF and is decremented as we move each into a cleanable state.\n\t *\n\t * Derivation:\n\t *\n\t * End offset is the highest offset that this page should represent.\n\t * If we are on the last page, (end_offset & (PAGE_CACHE_SIZE - 1))\n\t * will evaluate non-zero and be less than PAGE_CACHE_SIZE and\n\t * hence give us the correct page_dirty count. On any other page,\n\t * it will be zero and in that case we need page_dirty to be the\n\t * count of buffers on the page.\n\t */\n\tend_offset = min_t(unsigned long long,\n\t\t\t(xfs_off_t)(page->index + 1) << PAGE_CACHE_SHIFT,\n\t\t\ti_size_read(inode));\n\n\t/*\n\t * If the current map does not span the entire page we are about to try\n\t * to write, then give up. The only way we can write a page that spans\n\t * multiple mappings in a single writeback iteration is via the\n\t * xfs_vm_writepage() function. Data integrity writeback requires the\n\t * entire page to be written in a single attempt, otherwise the part of\n\t * the page we don't write here doesn't get written as part of the data\n\t * integrity sync.\n\t *\n\t * For normal writeback, we also don't attempt to write partial pages\n\t * here as it simply means that write_cache_pages() will see it under\n\t * writeback and ignore the page until some point in the future, at\n\t * which time this will be the only page in the file that needs\n\t * writeback.  Hence for more optimal IO patterns, we should always\n\t * avoid partial page writeback due to multiple mappings on a page here.\n\t */\n\tif (!xfs_imap_valid(inode, imap, end_offset))\n\t\tgoto fail_unlock_page;\n\n\tlen = 1 << inode->i_blkbits;\n\tp_offset = min_t(unsigned long, end_offset & (PAGE_CACHE_SIZE - 1),\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\tp_offset = p_offset ? roundup(p_offset, len) : PAGE_CACHE_SIZE;\n\tpage_dirty = p_offset / len;\n\n\t/*\n\t * The moment we find a buffer that doesn't match our current type\n\t * specification or can't be written, abort the loop and start\n\t * writeback. As per the above xfs_imap_valid() check, only\n\t * xfs_vm_writepage() can handle partial page writeback fully - we are\n\t * limited here to the buffers that are contiguous with the current\n\t * ioend, and hence a buffer we can't write breaks that contiguity and\n\t * we have to defer the rest of the IO to xfs_vm_writepage().\n\t */\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (offset >= end_offset)\n\t\t\tbreak;\n\t\tif (!buffer_uptodate(bh))\n\t\t\tuptodate = 0;\n\t\tif (!(PageUptodate(page) || buffer_uptodate(bh))) {\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (buffer_unwritten(bh) || buffer_delay(bh) ||\n\t\t    buffer_mapped(bh)) {\n\t\t\tif (buffer_unwritten(bh))\n\t\t\t\ttype = XFS_IO_UNWRITTEN;\n\t\t\telse if (buffer_delay(bh))\n\t\t\t\ttype = XFS_IO_DELALLOC;\n\t\t\telse\n\t\t\t\ttype = XFS_IO_OVERWRITE;\n\n\t\t\t/*\n\t\t\t * imap should always be valid because of the above\n\t\t\t * partial page end_offset check on the imap.\n\t\t\t */\n\t\t\tASSERT(xfs_imap_valid(inode, imap, offset));\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (type != XFS_IO_OVERWRITE)\n\t\t\t\txfs_map_at_offset(inode, bh, imap, offset);\n\t\t\txfs_add_to_ioend(inode, bh, offset, type,\n\t\t\t\t\t ioendp, done);\n\n\t\t\tpage_dirty--;\n\t\t\tcount++;\n\t\t} else {\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\t}\n\t} while (offset += len, (bh = bh->b_this_page) != head);\n\n\tif (uptodate && bh == head)\n\t\tSetPageUptodate(page);\n\n\tif (count) {\n\t\tif (--wbc->nr_to_write <= 0 &&\n\t\t    wbc->sync_mode == WB_SYNC_NONE)\n\t\t\tdone = 1;\n\t}\n\txfs_start_page_writeback(page, !page_dirty, count);\n\n\treturn done;\n fail_unlock_page:\n\tunlock_page(page);\n fail:\n\treturn 1;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_convert_page(\n\tstruct inode\t\t*inode,\n\tstruct page\t\t*page,\n\tloff_t\t\t\ttindex,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_ioend_t\t\t**ioendp,\n\tstruct writeback_control *wbc)\n{\n\tstruct buffer_head\t*bh, *head;\n\txfs_off_t\t\tend_offset;\n\tunsigned long\t\tp_offset;\n\tunsigned int\t\ttype;\n\tint\t\t\tlen, page_dirty;\n\tint\t\t\tcount = 0, done = 0, uptodate = 1;\n \txfs_off_t\t\toffset = page_offset(page);\n\n\tif (page->index != tindex)\n\t\tgoto fail;\n\tif (!trylock_page(page))\n\t\tgoto fail;\n\tif (PageWriteback(page))\n\t\tgoto fail_unlock_page;\n\tif (page->mapping != inode->i_mapping)\n\t\tgoto fail_unlock_page;\n\tif (!xfs_check_page_type(page, (*ioendp)->io_type, false))\n\t\tgoto fail_unlock_page;\n\n\t/*\n\t * page_dirty is initially a count of buffers on the page before\n\t * EOF and is decremented as we move each into a cleanable state.\n\t *\n\t * Derivation:\n\t *\n\t * End offset is the highest offset that this page should represent.\n\t * If we are on the last page, (end_offset & (PAGE_CACHE_SIZE - 1))\n\t * will evaluate non-zero and be less than PAGE_CACHE_SIZE and\n\t * hence give us the correct page_dirty count. On any other page,\n\t * it will be zero and in that case we need page_dirty to be the\n\t * count of buffers on the page.\n\t */\n\tend_offset = min_t(unsigned long long,\n\t\t\t(xfs_off_t)(page->index + 1) << PAGE_CACHE_SHIFT,\n\t\t\ti_size_read(inode));\n\n\t/*\n\t * If the current map does not span the entire page we are about to try\n\t * to write, then give up. The only way we can write a page that spans\n\t * multiple mappings in a single writeback iteration is via the\n\t * xfs_vm_writepage() function. Data integrity writeback requires the\n\t * entire page to be written in a single attempt, otherwise the part of\n\t * the page we don't write here doesn't get written as part of the data\n\t * integrity sync.\n\t *\n\t * For normal writeback, we also don't attempt to write partial pages\n\t * here as it simply means that write_cache_pages() will see it under\n\t * writeback and ignore the page until some point in the future, at\n\t * which time this will be the only page in the file that needs\n\t * writeback.  Hence for more optimal IO patterns, we should always\n\t * avoid partial page writeback due to multiple mappings on a page here.\n\t */\n\tif (!xfs_imap_valid(inode, imap, end_offset))\n\t\tgoto fail_unlock_page;\n\n\tlen = 1 << inode->i_blkbits;\n\tp_offset = min_t(unsigned long, end_offset & (PAGE_CACHE_SIZE - 1),\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\tp_offset = p_offset ? roundup(p_offset, len) : PAGE_CACHE_SIZE;\n\tpage_dirty = p_offset / len;\n\n\t/*\n\t * The moment we find a buffer that doesn't match our current type\n\t * specification or can't be written, abort the loop and start\n\t * writeback. As per the above xfs_imap_valid() check, only\n\t * xfs_vm_writepage() can handle partial page writeback fully - we are\n\t * limited here to the buffers that are contiguous with the current\n\t * ioend, and hence a buffer we can't write breaks that contiguity and\n\t * we have to defer the rest of the IO to xfs_vm_writepage().\n\t */\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (offset >= end_offset)\n\t\t\tbreak;\n\t\tif (!buffer_uptodate(bh))\n\t\t\tuptodate = 0;\n\t\tif (!(PageUptodate(page) || buffer_uptodate(bh))) {\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (buffer_unwritten(bh) || buffer_delay(bh) ||\n\t\t    buffer_mapped(bh)) {\n\t\t\tif (buffer_unwritten(bh))\n\t\t\t\ttype = XFS_IO_UNWRITTEN;\n\t\t\telse if (buffer_delay(bh))\n\t\t\t\ttype = XFS_IO_DELALLOC;\n\t\t\telse\n\t\t\t\ttype = XFS_IO_OVERWRITE;\n\n\t\t\t/*\n\t\t\t * imap should always be valid because of the above\n\t\t\t * partial page end_offset check on the imap.\n\t\t\t */\n\t\t\tASSERT(xfs_imap_valid(inode, imap, offset));\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (type != XFS_IO_OVERWRITE)\n\t\t\t\txfs_map_at_offset(inode, bh, imap, offset);\n\t\t\txfs_add_to_ioend(inode, bh, offset, type,\n\t\t\t\t\t ioendp, done);\n\n\t\t\tpage_dirty--;\n\t\t\tcount++;\n\t\t} else {\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\t}\n\t} while (offset += len, (bh = bh->b_this_page) != head);\n\n\tif (uptodate && bh == head)\n\t\tSetPageUptodate(page);\n\n\tif (count) {\n\t\tif (--wbc->nr_to_write <= 0 &&\n\t\t    wbc->sync_mode == WB_SYNC_NONE)\n\t\t\tdone = 1;\n\t}\n\txfs_start_page_writeback(page, !page_dirty, count);\n\n\treturn done;\n fail_unlock_page:\n\tunlock_page(page);\n fail:\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pvec"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup",
          "args": [
            "&pvec",
            "inode->i_mapping",
            "tindex",
            "len"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "pgoff_t",
            "PAGEVEC_SIZE",
            "tlast - tindex + 1"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_cluster_write(\n\tstruct inode\t\t*inode,\n\tpgoff_t\t\t\ttindex,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_ioend_t\t\t**ioendp,\n\tstruct writeback_control *wbc,\n\tpgoff_t\t\t\ttlast)\n{\n\tstruct pagevec\t\tpvec;\n\tint\t\t\tdone = 0, i;\n\n\tpagevec_init(&pvec, 0);\n\twhile (!done && tindex <= tlast) {\n\t\tunsigned len = min_t(pgoff_t, PAGEVEC_SIZE, tlast - tindex + 1);\n\n\t\tif (!pagevec_lookup(&pvec, inode->i_mapping, tindex, len))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tdone = xfs_convert_page(inode, pvec.pages[i], tindex++,\n\t\t\t\t\timap, ioendp, wbc);\n\t\t\tif (done)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}"
  },
  {
    "function_name": "xfs_convert_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "683-817",
    "snippet": "STATIC int\nxfs_convert_page(\n\tstruct inode\t\t*inode,\n\tstruct page\t\t*page,\n\tloff_t\t\t\ttindex,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_ioend_t\t\t**ioendp,\n\tstruct writeback_control *wbc)\n{\n\tstruct buffer_head\t*bh, *head;\n\txfs_off_t\t\tend_offset;\n\tunsigned long\t\tp_offset;\n\tunsigned int\t\ttype;\n\tint\t\t\tlen, page_dirty;\n\tint\t\t\tcount = 0, done = 0, uptodate = 1;\n \txfs_off_t\t\toffset = page_offset(page);\n\n\tif (page->index != tindex)\n\t\tgoto fail;\n\tif (!trylock_page(page))\n\t\tgoto fail;\n\tif (PageWriteback(page))\n\t\tgoto fail_unlock_page;\n\tif (page->mapping != inode->i_mapping)\n\t\tgoto fail_unlock_page;\n\tif (!xfs_check_page_type(page, (*ioendp)->io_type, false))\n\t\tgoto fail_unlock_page;\n\n\t/*\n\t * page_dirty is initially a count of buffers on the page before\n\t * EOF and is decremented as we move each into a cleanable state.\n\t *\n\t * Derivation:\n\t *\n\t * End offset is the highest offset that this page should represent.\n\t * If we are on the last page, (end_offset & (PAGE_CACHE_SIZE - 1))\n\t * will evaluate non-zero and be less than PAGE_CACHE_SIZE and\n\t * hence give us the correct page_dirty count. On any other page,\n\t * it will be zero and in that case we need page_dirty to be the\n\t * count of buffers on the page.\n\t */\n\tend_offset = min_t(unsigned long long,\n\t\t\t(xfs_off_t)(page->index + 1) << PAGE_CACHE_SHIFT,\n\t\t\ti_size_read(inode));\n\n\t/*\n\t * If the current map does not span the entire page we are about to try\n\t * to write, then give up. The only way we can write a page that spans\n\t * multiple mappings in a single writeback iteration is via the\n\t * xfs_vm_writepage() function. Data integrity writeback requires the\n\t * entire page to be written in a single attempt, otherwise the part of\n\t * the page we don't write here doesn't get written as part of the data\n\t * integrity sync.\n\t *\n\t * For normal writeback, we also don't attempt to write partial pages\n\t * here as it simply means that write_cache_pages() will see it under\n\t * writeback and ignore the page until some point in the future, at\n\t * which time this will be the only page in the file that needs\n\t * writeback.  Hence for more optimal IO patterns, we should always\n\t * avoid partial page writeback due to multiple mappings on a page here.\n\t */\n\tif (!xfs_imap_valid(inode, imap, end_offset))\n\t\tgoto fail_unlock_page;\n\n\tlen = 1 << inode->i_blkbits;\n\tp_offset = min_t(unsigned long, end_offset & (PAGE_CACHE_SIZE - 1),\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\tp_offset = p_offset ? roundup(p_offset, len) : PAGE_CACHE_SIZE;\n\tpage_dirty = p_offset / len;\n\n\t/*\n\t * The moment we find a buffer that doesn't match our current type\n\t * specification or can't be written, abort the loop and start\n\t * writeback. As per the above xfs_imap_valid() check, only\n\t * xfs_vm_writepage() can handle partial page writeback fully - we are\n\t * limited here to the buffers that are contiguous with the current\n\t * ioend, and hence a buffer we can't write breaks that contiguity and\n\t * we have to defer the rest of the IO to xfs_vm_writepage().\n\t */\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (offset >= end_offset)\n\t\t\tbreak;\n\t\tif (!buffer_uptodate(bh))\n\t\t\tuptodate = 0;\n\t\tif (!(PageUptodate(page) || buffer_uptodate(bh))) {\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (buffer_unwritten(bh) || buffer_delay(bh) ||\n\t\t    buffer_mapped(bh)) {\n\t\t\tif (buffer_unwritten(bh))\n\t\t\t\ttype = XFS_IO_UNWRITTEN;\n\t\t\telse if (buffer_delay(bh))\n\t\t\t\ttype = XFS_IO_DELALLOC;\n\t\t\telse\n\t\t\t\ttype = XFS_IO_OVERWRITE;\n\n\t\t\t/*\n\t\t\t * imap should always be valid because of the above\n\t\t\t * partial page end_offset check on the imap.\n\t\t\t */\n\t\t\tASSERT(xfs_imap_valid(inode, imap, offset));\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (type != XFS_IO_OVERWRITE)\n\t\t\t\txfs_map_at_offset(inode, bh, imap, offset);\n\t\t\txfs_add_to_ioend(inode, bh, offset, type,\n\t\t\t\t\t ioendp, done);\n\n\t\t\tpage_dirty--;\n\t\t\tcount++;\n\t\t} else {\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\t}\n\t} while (offset += len, (bh = bh->b_this_page) != head);\n\n\tif (uptodate && bh == head)\n\t\tSetPageUptodate(page);\n\n\tif (count) {\n\t\tif (--wbc->nr_to_write <= 0 &&\n\t\t    wbc->sync_mode == WB_SYNC_NONE)\n\t\t\tdone = 1;\n\t}\n\txfs_start_page_writeback(page, !page_dirty, count);\n\n\treturn done;\n fail_unlock_page:\n\tunlock_page(page);\n fail:\n\treturn 1;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_start_page_writeback",
          "args": [
            "page",
            "!page_dirty",
            "count"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_start_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "410-437",
          "snippet": "STATIC void\nxfs_start_page_writeback(\n\tstruct page\t\t*page,\n\tint\t\t\tclear_dirty,\n\tint\t\t\tbuffers)\n{\n\tASSERT(PageLocked(page));\n\tASSERT(!PageWriteback(page));\n\n\t/*\n\t * if the page was not fully cleaned, we need to ensure that the higher\n\t * layers come back to it correctly. That means we need to keep the page\n\t * dirty, and for WB_SYNC_ALL writeback we need to ensure the\n\t * PAGECACHE_TAG_TOWRITE index mark is not removed so another attempt to\n\t * write this page in this writeback sweep will be made.\n\t */\n\tif (clear_dirty) {\n\t\tclear_page_dirty_for_io(page);\n\t\tset_page_writeback(page);\n\t} else\n\t\tset_page_writeback_keepwrite(page);\n\n\tunlock_page(page);\n\n\t/* If no buffers on the page are to be written, finish it here */\n\tif (!buffers)\n\t\tend_page_writeback(page);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_start_page_writeback(\n\tstruct page\t\t*page,\n\tint\t\t\tclear_dirty,\n\tint\t\t\tbuffers)\n{\n\tASSERT(PageLocked(page));\n\tASSERT(!PageWriteback(page));\n\n\t/*\n\t * if the page was not fully cleaned, we need to ensure that the higher\n\t * layers come back to it correctly. That means we need to keep the page\n\t * dirty, and for WB_SYNC_ALL writeback we need to ensure the\n\t * PAGECACHE_TAG_TOWRITE index mark is not removed so another attempt to\n\t * write this page in this writeback sweep will be made.\n\t */\n\tif (clear_dirty) {\n\t\tclear_page_dirty_for_io(page);\n\t\tset_page_writeback(page);\n\t} else\n\t\tset_page_writeback_keepwrite(page);\n\n\tunlock_page(page);\n\n\t/* If no buffers on the page are to be written, finish it here */\n\tif (!buffers)\n\t\tend_page_writeback(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_add_to_ioend",
          "args": [
            "inode",
            "bh",
            "offset",
            "type",
            "ioendp",
            "done"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_add_to_ioend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "564-592",
          "snippet": "STATIC void\nxfs_add_to_ioend(\n\tstruct inode\t\t*inode,\n\tstruct buffer_head\t*bh,\n\txfs_off_t\t\toffset,\n\tunsigned int\t\ttype,\n\txfs_ioend_t\t\t**result,\n\tint\t\t\tneed_ioend)\n{\n\txfs_ioend_t\t\t*ioend = *result;\n\n\tif (!ioend || need_ioend || type != ioend->io_type) {\n\t\txfs_ioend_t\t*previous = *result;\n\n\t\tioend = xfs_alloc_ioend(inode, type);\n\t\tioend->io_offset = offset;\n\t\tioend->io_buffer_head = bh;\n\t\tioend->io_buffer_tail = bh;\n\t\tif (previous)\n\t\t\tprevious->io_list = ioend;\n\t\t*result = ioend;\n\t} else {\n\t\tioend->io_buffer_tail->b_private = bh;\n\t\tioend->io_buffer_tail = bh;\n\t}\n\n\tbh->b_private = NULL;\n\tioend->io_size += bh->b_size;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_add_to_ioend(\n\tstruct inode\t\t*inode,\n\tstruct buffer_head\t*bh,\n\txfs_off_t\t\toffset,\n\tunsigned int\t\ttype,\n\txfs_ioend_t\t\t**result,\n\tint\t\t\tneed_ioend)\n{\n\txfs_ioend_t\t\t*ioend = *result;\n\n\tif (!ioend || need_ioend || type != ioend->io_type) {\n\t\txfs_ioend_t\t*previous = *result;\n\n\t\tioend = xfs_alloc_ioend(inode, type);\n\t\tioend->io_offset = offset;\n\t\tioend->io_buffer_head = bh;\n\t\tioend->io_buffer_tail = bh;\n\t\tif (previous)\n\t\t\tprevious->io_list = ioend;\n\t\t*result = ioend;\n\t} else {\n\t\tioend->io_buffer_tail->b_private = bh;\n\t\tioend->io_buffer_tail = bh;\n\t}\n\n\tbh->b_private = NULL;\n\tioend->io_size += bh->b_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_map_at_offset",
          "args": [
            "inode",
            "bh",
            "imap",
            "offset"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_map_at_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "618-632",
          "snippet": "STATIC void\nxfs_map_at_offset(\n\tstruct inode\t\t*inode,\n\tstruct buffer_head\t*bh,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_off_t\t\toffset)\n{\n\tASSERT(imap->br_startblock != HOLESTARTBLOCK);\n\tASSERT(imap->br_startblock != DELAYSTARTBLOCK);\n\n\txfs_map_buffer(inode, bh, imap, offset);\n\tset_buffer_mapped(bh);\n\tclear_buffer_delay(bh);\n\tclear_buffer_unwritten(bh);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_map_at_offset(\n\tstruct inode\t\t*inode,\n\tstruct buffer_head\t*bh,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_off_t\t\toffset)\n{\n\tASSERT(imap->br_startblock != HOLESTARTBLOCK);\n\tASSERT(imap->br_startblock != DELAYSTARTBLOCK);\n\n\txfs_map_buffer(inode, bh, imap, offset);\n\tset_buffer_mapped(bh);\n\tclear_buffer_delay(bh);\n\tclear_buffer_unwritten(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_imap_valid(inode, imap, offset)"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_imap_valid",
          "args": [
            "inode",
            "imap",
            "offset"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_imap_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "338-348",
          "snippet": "STATIC int\nxfs_imap_valid(\n\tstruct inode\t\t*inode,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_off_t\t\toffset)\n{\n\toffset >>= inode->i_blkbits;\n\n\treturn offset >= imap->br_startoff &&\n\t\toffset < imap->br_startoff + imap->br_blockcount;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_imap_valid(\n\tstruct inode\t\t*inode,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_off_t\t\toffset)\n{\n\toffset >>= inode->i_blkbits;\n\n\treturn offset >= imap->br_startoff &&\n\t\toffset < imap->br_startoff + imap->br_blockcount;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "p_offset",
            "len"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "end_offset & (PAGE_CACHE_SIZE - 1)",
            "PAGE_CACHE_SIZE"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong long",
            "(xfs_off_t)(page->index + 1) << PAGE_CACHE_SHIFT",
            "i_size_read(inode)"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "page->index + 1"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_check_page_type",
          "args": [
            "page",
            "(*ioendp)->io_type",
            "false"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_check_page_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "640-675",
          "snippet": "STATIC bool\nxfs_check_page_type(\n\tstruct page\t\t*page,\n\tunsigned int\t\ttype,\n\tbool\t\t\tcheck_all_buffers)\n{\n\tstruct buffer_head\t*bh;\n\tstruct buffer_head\t*head;\n\n\tif (PageWriteback(page))\n\t\treturn false;\n\tif (!page->mapping)\n\t\treturn false;\n\tif (!page_has_buffers(page))\n\t\treturn false;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_unwritten(bh)) {\n\t\t\tif (type == XFS_IO_UNWRITTEN)\n\t\t\t\treturn true;\n\t\t} else if (buffer_delay(bh)) {\n\t\t\tif (type == XFS_IO_DELALLOC)\n\t\t\t\treturn true;\n\t\t} else if (buffer_dirty(bh) && buffer_mapped(bh)) {\n\t\t\tif (type == XFS_IO_OVERWRITE)\n\t\t\t\treturn true;\n\t\t}\n\n\t\t/* If we are only checking the first buffer, we are done now. */\n\t\tif (!check_all_buffers)\n\t\t\tbreak;\n\t} while ((bh = bh->b_this_page) != head);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC bool\nxfs_check_page_type(\n\tstruct page\t\t*page,\n\tunsigned int\t\ttype,\n\tbool\t\t\tcheck_all_buffers)\n{\n\tstruct buffer_head\t*bh;\n\tstruct buffer_head\t*head;\n\n\tif (PageWriteback(page))\n\t\treturn false;\n\tif (!page->mapping)\n\t\treturn false;\n\tif (!page_has_buffers(page))\n\t\treturn false;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_unwritten(bh)) {\n\t\t\tif (type == XFS_IO_UNWRITTEN)\n\t\t\t\treturn true;\n\t\t} else if (buffer_delay(bh)) {\n\t\t\tif (type == XFS_IO_DELALLOC)\n\t\t\t\treturn true;\n\t\t} else if (buffer_dirty(bh) && buffer_mapped(bh)) {\n\t\t\tif (type == XFS_IO_OVERWRITE)\n\t\t\t\treturn true;\n\t\t}\n\n\t\t/* If we are only checking the first buffer, we are done now. */\n\t\tif (!check_all_buffers)\n\t\t\tbreak;\n\t} while ((bh = bh->b_this_page) != head);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_convert_page(\n\tstruct inode\t\t*inode,\n\tstruct page\t\t*page,\n\tloff_t\t\t\ttindex,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_ioend_t\t\t**ioendp,\n\tstruct writeback_control *wbc)\n{\n\tstruct buffer_head\t*bh, *head;\n\txfs_off_t\t\tend_offset;\n\tunsigned long\t\tp_offset;\n\tunsigned int\t\ttype;\n\tint\t\t\tlen, page_dirty;\n\tint\t\t\tcount = 0, done = 0, uptodate = 1;\n \txfs_off_t\t\toffset = page_offset(page);\n\n\tif (page->index != tindex)\n\t\tgoto fail;\n\tif (!trylock_page(page))\n\t\tgoto fail;\n\tif (PageWriteback(page))\n\t\tgoto fail_unlock_page;\n\tif (page->mapping != inode->i_mapping)\n\t\tgoto fail_unlock_page;\n\tif (!xfs_check_page_type(page, (*ioendp)->io_type, false))\n\t\tgoto fail_unlock_page;\n\n\t/*\n\t * page_dirty is initially a count of buffers on the page before\n\t * EOF and is decremented as we move each into a cleanable state.\n\t *\n\t * Derivation:\n\t *\n\t * End offset is the highest offset that this page should represent.\n\t * If we are on the last page, (end_offset & (PAGE_CACHE_SIZE - 1))\n\t * will evaluate non-zero and be less than PAGE_CACHE_SIZE and\n\t * hence give us the correct page_dirty count. On any other page,\n\t * it will be zero and in that case we need page_dirty to be the\n\t * count of buffers on the page.\n\t */\n\tend_offset = min_t(unsigned long long,\n\t\t\t(xfs_off_t)(page->index + 1) << PAGE_CACHE_SHIFT,\n\t\t\ti_size_read(inode));\n\n\t/*\n\t * If the current map does not span the entire page we are about to try\n\t * to write, then give up. The only way we can write a page that spans\n\t * multiple mappings in a single writeback iteration is via the\n\t * xfs_vm_writepage() function. Data integrity writeback requires the\n\t * entire page to be written in a single attempt, otherwise the part of\n\t * the page we don't write here doesn't get written as part of the data\n\t * integrity sync.\n\t *\n\t * For normal writeback, we also don't attempt to write partial pages\n\t * here as it simply means that write_cache_pages() will see it under\n\t * writeback and ignore the page until some point in the future, at\n\t * which time this will be the only page in the file that needs\n\t * writeback.  Hence for more optimal IO patterns, we should always\n\t * avoid partial page writeback due to multiple mappings on a page here.\n\t */\n\tif (!xfs_imap_valid(inode, imap, end_offset))\n\t\tgoto fail_unlock_page;\n\n\tlen = 1 << inode->i_blkbits;\n\tp_offset = min_t(unsigned long, end_offset & (PAGE_CACHE_SIZE - 1),\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\tp_offset = p_offset ? roundup(p_offset, len) : PAGE_CACHE_SIZE;\n\tpage_dirty = p_offset / len;\n\n\t/*\n\t * The moment we find a buffer that doesn't match our current type\n\t * specification or can't be written, abort the loop and start\n\t * writeback. As per the above xfs_imap_valid() check, only\n\t * xfs_vm_writepage() can handle partial page writeback fully - we are\n\t * limited here to the buffers that are contiguous with the current\n\t * ioend, and hence a buffer we can't write breaks that contiguity and\n\t * we have to defer the rest of the IO to xfs_vm_writepage().\n\t */\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (offset >= end_offset)\n\t\t\tbreak;\n\t\tif (!buffer_uptodate(bh))\n\t\t\tuptodate = 0;\n\t\tif (!(PageUptodate(page) || buffer_uptodate(bh))) {\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (buffer_unwritten(bh) || buffer_delay(bh) ||\n\t\t    buffer_mapped(bh)) {\n\t\t\tif (buffer_unwritten(bh))\n\t\t\t\ttype = XFS_IO_UNWRITTEN;\n\t\t\telse if (buffer_delay(bh))\n\t\t\t\ttype = XFS_IO_DELALLOC;\n\t\t\telse\n\t\t\t\ttype = XFS_IO_OVERWRITE;\n\n\t\t\t/*\n\t\t\t * imap should always be valid because of the above\n\t\t\t * partial page end_offset check on the imap.\n\t\t\t */\n\t\t\tASSERT(xfs_imap_valid(inode, imap, offset));\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (type != XFS_IO_OVERWRITE)\n\t\t\t\txfs_map_at_offset(inode, bh, imap, offset);\n\t\t\txfs_add_to_ioend(inode, bh, offset, type,\n\t\t\t\t\t ioendp, done);\n\n\t\t\tpage_dirty--;\n\t\t\tcount++;\n\t\t} else {\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\t}\n\t} while (offset += len, (bh = bh->b_this_page) != head);\n\n\tif (uptodate && bh == head)\n\t\tSetPageUptodate(page);\n\n\tif (count) {\n\t\tif (--wbc->nr_to_write <= 0 &&\n\t\t    wbc->sync_mode == WB_SYNC_NONE)\n\t\t\tdone = 1;\n\t}\n\txfs_start_page_writeback(page, !page_dirty, count);\n\n\treturn done;\n fail_unlock_page:\n\tunlock_page(page);\n fail:\n\treturn 1;\n}"
  },
  {
    "function_name": "xfs_check_page_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "640-675",
    "snippet": "STATIC bool\nxfs_check_page_type(\n\tstruct page\t\t*page,\n\tunsigned int\t\ttype,\n\tbool\t\t\tcheck_all_buffers)\n{\n\tstruct buffer_head\t*bh;\n\tstruct buffer_head\t*head;\n\n\tif (PageWriteback(page))\n\t\treturn false;\n\tif (!page->mapping)\n\t\treturn false;\n\tif (!page_has_buffers(page))\n\t\treturn false;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_unwritten(bh)) {\n\t\t\tif (type == XFS_IO_UNWRITTEN)\n\t\t\t\treturn true;\n\t\t} else if (buffer_delay(bh)) {\n\t\t\tif (type == XFS_IO_DELALLOC)\n\t\t\t\treturn true;\n\t\t} else if (buffer_dirty(bh) && buffer_mapped(bh)) {\n\t\t\tif (type == XFS_IO_OVERWRITE)\n\t\t\t\treturn true;\n\t\t}\n\n\t\t/* If we are only checking the first buffer, we are done now. */\n\t\tif (!check_all_buffers)\n\t\t\tbreak;\n\t} while ((bh = bh->b_this_page) != head);\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC bool\nxfs_check_page_type(\n\tstruct page\t\t*page,\n\tunsigned int\t\ttype,\n\tbool\t\t\tcheck_all_buffers)\n{\n\tstruct buffer_head\t*bh;\n\tstruct buffer_head\t*head;\n\n\tif (PageWriteback(page))\n\t\treturn false;\n\tif (!page->mapping)\n\t\treturn false;\n\tif (!page_has_buffers(page))\n\t\treturn false;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_unwritten(bh)) {\n\t\t\tif (type == XFS_IO_UNWRITTEN)\n\t\t\t\treturn true;\n\t\t} else if (buffer_delay(bh)) {\n\t\t\tif (type == XFS_IO_DELALLOC)\n\t\t\t\treturn true;\n\t\t} else if (buffer_dirty(bh) && buffer_mapped(bh)) {\n\t\t\tif (type == XFS_IO_OVERWRITE)\n\t\t\t\treturn true;\n\t\t}\n\n\t\t/* If we are only checking the first buffer, we are done now. */\n\t\tif (!check_all_buffers)\n\t\t\tbreak;\n\t} while ((bh = bh->b_this_page) != head);\n\n\treturn false;\n}"
  },
  {
    "function_name": "xfs_map_at_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "618-632",
    "snippet": "STATIC void\nxfs_map_at_offset(\n\tstruct inode\t\t*inode,\n\tstruct buffer_head\t*bh,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_off_t\t\toffset)\n{\n\tASSERT(imap->br_startblock != HOLESTARTBLOCK);\n\tASSERT(imap->br_startblock != DELAYSTARTBLOCK);\n\n\txfs_map_buffer(inode, bh, imap, offset);\n\tset_buffer_mapped(bh);\n\tclear_buffer_delay(bh);\n\tclear_buffer_unwritten(bh);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_delay",
          "args": [
            "bh"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_map_buffer",
          "args": [
            "inode",
            "bh",
            "imap",
            "offset"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_map_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "594-616",
          "snippet": "STATIC void\nxfs_map_buffer(\n\tstruct inode\t\t*inode,\n\tstruct buffer_head\t*bh,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_off_t\t\toffset)\n{\n\tsector_t\t\tbn;\n\tstruct xfs_mount\t*m = XFS_I(inode)->i_mount;\n\txfs_off_t\t\tiomap_offset = XFS_FSB_TO_B(m, imap->br_startoff);\n\txfs_daddr_t\t\tiomap_bn = xfs_fsb_to_db(XFS_I(inode), imap->br_startblock);\n\n\tASSERT(imap->br_startblock != HOLESTARTBLOCK);\n\tASSERT(imap->br_startblock != DELAYSTARTBLOCK);\n\n\tbn = (iomap_bn >> (inode->i_blkbits - BBSHIFT)) +\n\t      ((offset - iomap_offset) >> inode->i_blkbits);\n\n\tASSERT(bn || XFS_IS_REALTIME_INODE(XFS_I(inode)));\n\n\tbh->b_blocknr = bn;\n\tset_buffer_mapped(bh);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_map_buffer(\n\tstruct inode\t\t*inode,\n\tstruct buffer_head\t*bh,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_off_t\t\toffset)\n{\n\tsector_t\t\tbn;\n\tstruct xfs_mount\t*m = XFS_I(inode)->i_mount;\n\txfs_off_t\t\tiomap_offset = XFS_FSB_TO_B(m, imap->br_startoff);\n\txfs_daddr_t\t\tiomap_bn = xfs_fsb_to_db(XFS_I(inode), imap->br_startblock);\n\n\tASSERT(imap->br_startblock != HOLESTARTBLOCK);\n\tASSERT(imap->br_startblock != DELAYSTARTBLOCK);\n\n\tbn = (iomap_bn >> (inode->i_blkbits - BBSHIFT)) +\n\t      ((offset - iomap_offset) >> inode->i_blkbits);\n\n\tASSERT(bn || XFS_IS_REALTIME_INODE(XFS_I(inode)));\n\n\tbh->b_blocknr = bn;\n\tset_buffer_mapped(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "imap->br_startblock != DELAYSTARTBLOCK"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "imap->br_startblock != HOLESTARTBLOCK"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_map_at_offset(\n\tstruct inode\t\t*inode,\n\tstruct buffer_head\t*bh,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_off_t\t\toffset)\n{\n\tASSERT(imap->br_startblock != HOLESTARTBLOCK);\n\tASSERT(imap->br_startblock != DELAYSTARTBLOCK);\n\n\txfs_map_buffer(inode, bh, imap, offset);\n\tset_buffer_mapped(bh);\n\tclear_buffer_delay(bh);\n\tclear_buffer_unwritten(bh);\n}"
  },
  {
    "function_name": "xfs_map_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "594-616",
    "snippet": "STATIC void\nxfs_map_buffer(\n\tstruct inode\t\t*inode,\n\tstruct buffer_head\t*bh,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_off_t\t\toffset)\n{\n\tsector_t\t\tbn;\n\tstruct xfs_mount\t*m = XFS_I(inode)->i_mount;\n\txfs_off_t\t\tiomap_offset = XFS_FSB_TO_B(m, imap->br_startoff);\n\txfs_daddr_t\t\tiomap_bn = xfs_fsb_to_db(XFS_I(inode), imap->br_startblock);\n\n\tASSERT(imap->br_startblock != HOLESTARTBLOCK);\n\tASSERT(imap->br_startblock != DELAYSTARTBLOCK);\n\n\tbn = (iomap_bn >> (inode->i_blkbits - BBSHIFT)) +\n\t      ((offset - iomap_offset) >> inode->i_blkbits);\n\n\tASSERT(bn || XFS_IS_REALTIME_INODE(XFS_I(inode)));\n\n\tbh->b_blocknr = bn;\n\tset_buffer_mapped(bh);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bn || XFS_IS_REALTIME_INODE(XFS_I(inode))"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "XFS_I(inode)"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "imap->br_startblock != DELAYSTARTBLOCK"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "imap->br_startblock != HOLESTARTBLOCK"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_fsb_to_db",
          "args": [
            "XFS_I(inode)",
            "imap->br_startblock"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_fsb_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "51-57",
          "snippet": "xfs_daddr_t\nxfs_fsb_to_db(struct xfs_inode *ip, xfs_fsblock_t fsb)\n{\n\treturn (XFS_IS_REALTIME_INODE(ip) ? \\\n\t\t (xfs_daddr_t)XFS_FSB_TO_BB((ip)->i_mount, (fsb)) : \\\n\t\t XFS_FSB_TO_DADDR((ip)->i_mount, (fsb)));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_daddr_t\nxfs_fsb_to_db(struct xfs_inode *ip, xfs_fsblock_t fsb)\n{\n\treturn (XFS_IS_REALTIME_INODE(ip) ? \\\n\t\t (xfs_daddr_t)XFS_FSB_TO_BB((ip)->i_mount, (fsb)) : \\\n\t\t XFS_FSB_TO_DADDR((ip)->i_mount, (fsb)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "m",
            "imap->br_startoff"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_map_buffer(\n\tstruct inode\t\t*inode,\n\tstruct buffer_head\t*bh,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_off_t\t\toffset)\n{\n\tsector_t\t\tbn;\n\tstruct xfs_mount\t*m = XFS_I(inode)->i_mount;\n\txfs_off_t\t\tiomap_offset = XFS_FSB_TO_B(m, imap->br_startoff);\n\txfs_daddr_t\t\tiomap_bn = xfs_fsb_to_db(XFS_I(inode), imap->br_startblock);\n\n\tASSERT(imap->br_startblock != HOLESTARTBLOCK);\n\tASSERT(imap->br_startblock != DELAYSTARTBLOCK);\n\n\tbn = (iomap_bn >> (inode->i_blkbits - BBSHIFT)) +\n\t      ((offset - iomap_offset) >> inode->i_blkbits);\n\n\tASSERT(bn || XFS_IS_REALTIME_INODE(XFS_I(inode)));\n\n\tbh->b_blocknr = bn;\n\tset_buffer_mapped(bh);\n}"
  },
  {
    "function_name": "xfs_add_to_ioend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "564-592",
    "snippet": "STATIC void\nxfs_add_to_ioend(\n\tstruct inode\t\t*inode,\n\tstruct buffer_head\t*bh,\n\txfs_off_t\t\toffset,\n\tunsigned int\t\ttype,\n\txfs_ioend_t\t\t**result,\n\tint\t\t\tneed_ioend)\n{\n\txfs_ioend_t\t\t*ioend = *result;\n\n\tif (!ioend || need_ioend || type != ioend->io_type) {\n\t\txfs_ioend_t\t*previous = *result;\n\n\t\tioend = xfs_alloc_ioend(inode, type);\n\t\tioend->io_offset = offset;\n\t\tioend->io_buffer_head = bh;\n\t\tioend->io_buffer_tail = bh;\n\t\tif (previous)\n\t\t\tprevious->io_list = ioend;\n\t\t*result = ioend;\n\t} else {\n\t\tioend->io_buffer_tail->b_private = bh;\n\t\tioend->io_buffer_tail = bh;\n\t}\n\n\tbh->b_private = NULL;\n\tioend->io_size += bh->b_size;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_alloc_ioend",
          "args": [
            "inode",
            "type"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_ioend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "246-273",
          "snippet": "STATIC xfs_ioend_t *\nxfs_alloc_ioend(\n\tstruct inode\t\t*inode,\n\tunsigned int\t\ttype)\n{\n\txfs_ioend_t\t\t*ioend;\n\n\tioend = mempool_alloc(xfs_ioend_pool, GFP_NOFS);\n\n\t/*\n\t * Set the count to 1 initially, which will prevent an I/O\n\t * completion callback from happening before we have started\n\t * all the I/O from calling the completion routine too early.\n\t */\n\tatomic_set(&ioend->io_remaining, 1);\n\tioend->io_error = 0;\n\tioend->io_list = NULL;\n\tioend->io_type = type;\n\tioend->io_inode = inode;\n\tioend->io_buffer_head = NULL;\n\tioend->io_buffer_tail = NULL;\n\tioend->io_offset = 0;\n\tioend->io_size = 0;\n\tioend->io_append_trans = NULL;\n\n\tINIT_WORK(&ioend->io_work, xfs_end_io);\n\treturn ioend;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC xfs_ioend_t *\nxfs_alloc_ioend(\n\tstruct inode\t\t*inode,\n\tunsigned int\t\ttype)\n{\n\txfs_ioend_t\t\t*ioend;\n\n\tioend = mempool_alloc(xfs_ioend_pool, GFP_NOFS);\n\n\t/*\n\t * Set the count to 1 initially, which will prevent an I/O\n\t * completion callback from happening before we have started\n\t * all the I/O from calling the completion routine too early.\n\t */\n\tatomic_set(&ioend->io_remaining, 1);\n\tioend->io_error = 0;\n\tioend->io_list = NULL;\n\tioend->io_type = type;\n\tioend->io_inode = inode;\n\tioend->io_buffer_head = NULL;\n\tioend->io_buffer_tail = NULL;\n\tioend->io_offset = 0;\n\tioend->io_size = 0;\n\tioend->io_append_trans = NULL;\n\n\tINIT_WORK(&ioend->io_work, xfs_end_io);\n\treturn ioend;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_add_to_ioend(\n\tstruct inode\t\t*inode,\n\tstruct buffer_head\t*bh,\n\txfs_off_t\t\toffset,\n\tunsigned int\t\ttype,\n\txfs_ioend_t\t\t**result,\n\tint\t\t\tneed_ioend)\n{\n\txfs_ioend_t\t\t*ioend = *result;\n\n\tif (!ioend || need_ioend || type != ioend->io_type) {\n\t\txfs_ioend_t\t*previous = *result;\n\n\t\tioend = xfs_alloc_ioend(inode, type);\n\t\tioend->io_offset = offset;\n\t\tioend->io_buffer_head = bh;\n\t\tioend->io_buffer_tail = bh;\n\t\tif (previous)\n\t\t\tprevious->io_list = ioend;\n\t\t*result = ioend;\n\t} else {\n\t\tioend->io_buffer_tail->b_private = bh;\n\t\tioend->io_buffer_tail = bh;\n\t}\n\n\tbh->b_private = NULL;\n\tioend->io_size += bh->b_size;\n}"
  },
  {
    "function_name": "xfs_cancel_ioend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "531-556",
    "snippet": "STATIC void\nxfs_cancel_ioend(\n\txfs_ioend_t\t\t*ioend)\n{\n\txfs_ioend_t\t\t*next;\n\tstruct buffer_head\t*bh, *next_bh;\n\n\tdo {\n\t\tnext = ioend->io_list;\n\t\tbh = ioend->io_buffer_head;\n\t\tdo {\n\t\t\tnext_bh = bh->b_private;\n\t\t\tclear_buffer_async_write(bh);\n\t\t\t/*\n\t\t\t * The unwritten flag is cleared when added to the\n\t\t\t * ioend. We're not submitting for I/O so mark the\n\t\t\t * buffer unwritten again for next time around.\n\t\t\t */\n\t\t\tif (ioend->io_type == XFS_IO_UNWRITTEN)\n\t\t\t\tset_buffer_unwritten(bh);\n\t\t\tunlock_buffer(bh);\n\t\t} while ((bh = next_bh) != NULL);\n\n\t\tmempool_free(ioend, xfs_ioend_pool);\n\t} while ((ioend = next) != NULL);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mempool_free",
          "args": [
            "ioend",
            "xfs_ioend_pool"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_cancel_ioend(\n\txfs_ioend_t\t\t*ioend)\n{\n\txfs_ioend_t\t\t*next;\n\tstruct buffer_head\t*bh, *next_bh;\n\n\tdo {\n\t\tnext = ioend->io_list;\n\t\tbh = ioend->io_buffer_head;\n\t\tdo {\n\t\t\tnext_bh = bh->b_private;\n\t\t\tclear_buffer_async_write(bh);\n\t\t\t/*\n\t\t\t * The unwritten flag is cleared when added to the\n\t\t\t * ioend. We're not submitting for I/O so mark the\n\t\t\t * buffer unwritten again for next time around.\n\t\t\t */\n\t\t\tif (ioend->io_type == XFS_IO_UNWRITTEN)\n\t\t\t\tset_buffer_unwritten(bh);\n\t\t\tunlock_buffer(bh);\n\t\t} while ((bh = next_bh) != NULL);\n\n\t\tmempool_free(ioend, xfs_ioend_pool);\n\t} while ((ioend = next) != NULL);\n}"
  },
  {
    "function_name": "xfs_submit_ioend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "466-524",
    "snippet": "STATIC void\nxfs_submit_ioend(\n\tstruct writeback_control *wbc,\n\txfs_ioend_t\t\t*ioend,\n\tint\t\t\tfail)\n{\n\txfs_ioend_t\t\t*head = ioend;\n\txfs_ioend_t\t\t*next;\n\tstruct buffer_head\t*bh;\n\tstruct bio\t\t*bio;\n\tsector_t\t\tlastblock = 0;\n\n\t/* Pass 1 - start writeback */\n\tdo {\n\t\tnext = ioend->io_list;\n\t\tfor (bh = ioend->io_buffer_head; bh; bh = bh->b_private)\n\t\t\txfs_start_buffer_writeback(bh);\n\t} while ((ioend = next) != NULL);\n\n\t/* Pass 2 - submit I/O */\n\tioend = head;\n\tdo {\n\t\tnext = ioend->io_list;\n\t\tbio = NULL;\n\n\t\t/*\n\t\t * If we are failing the IO now, just mark the ioend with an\n\t\t * error and finish it. This will run IO completion immediately\n\t\t * as there is only one reference to the ioend at this point in\n\t\t * time.\n\t\t */\n\t\tif (fail) {\n\t\t\tioend->io_error = fail;\n\t\t\txfs_finish_ioend(ioend);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (bh = ioend->io_buffer_head; bh; bh = bh->b_private) {\n\n\t\t\tif (!bio) {\n retry:\n\t\t\t\tbio = xfs_alloc_ioend_bio(bh);\n\t\t\t} else if (bh->b_blocknr != lastblock + 1) {\n\t\t\t\txfs_submit_ioend_bio(wbc, ioend, bio);\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\tif (xfs_bio_add_buffer(bio, bh) != bh->b_size) {\n\t\t\t\txfs_submit_ioend_bio(wbc, ioend, bio);\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\tlastblock = bh->b_blocknr;\n\t\t}\n\t\tif (bio)\n\t\t\txfs_submit_ioend_bio(wbc, ioend, bio);\n\t\txfs_finish_ioend(ioend);\n\t} while ((ioend = next) != NULL);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_finish_ioend",
          "args": [
            "ioend"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_finish_ioend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "187-201",
          "snippet": "STATIC void\nxfs_finish_ioend(\n\tstruct xfs_ioend\t*ioend)\n{\n\tif (atomic_dec_and_test(&ioend->io_remaining)) {\n\t\tstruct xfs_mount\t*mp = XFS_I(ioend->io_inode)->i_mount;\n\n\t\tif (ioend->io_type == XFS_IO_UNWRITTEN)\n\t\t\tqueue_work(mp->m_unwritten_workqueue, &ioend->io_work);\n\t\telse if (ioend->io_append_trans)\n\t\t\tqueue_work(mp->m_data_workqueue, &ioend->io_work);\n\t\telse\n\t\t\txfs_destroy_ioend(ioend);\n\t}\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_finish_ioend(\n\tstruct xfs_ioend\t*ioend)\n{\n\tif (atomic_dec_and_test(&ioend->io_remaining)) {\n\t\tstruct xfs_mount\t*mp = XFS_I(ioend->io_inode)->i_mount;\n\n\t\tif (ioend->io_type == XFS_IO_UNWRITTEN)\n\t\t\tqueue_work(mp->m_unwritten_workqueue, &ioend->io_work);\n\t\telse if (ioend->io_append_trans)\n\t\t\tqueue_work(mp->m_data_workqueue, &ioend->io_work);\n\t\telse\n\t\t\txfs_destroy_ioend(ioend);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_submit_ioend_bio",
          "args": [
            "wbc",
            "ioend",
            "bio"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_submit_ioend_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "371-381",
          "snippet": "STATIC void\nxfs_submit_ioend_bio(\n\tstruct writeback_control *wbc,\n\txfs_ioend_t\t\t*ioend,\n\tstruct bio\t\t*bio)\n{\n\tatomic_inc(&ioend->io_remaining);\n\tbio->bi_private = ioend;\n\tbio->bi_end_io = xfs_end_bio;\n\tsubmit_bio(wbc->sync_mode == WB_SYNC_ALL ? WRITE_SYNC : WRITE, bio);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_submit_ioend_bio(\n\tstruct writeback_control *wbc,\n\txfs_ioend_t\t\t*ioend,\n\tstruct bio\t\t*bio)\n{\n\tatomic_inc(&ioend->io_remaining);\n\tbio->bi_private = ioend;\n\tbio->bi_end_io = xfs_end_bio;\n\tsubmit_bio(wbc->sync_mode == WB_SYNC_ALL ? WRITE_SYNC : WRITE, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bio_add_buffer",
          "args": [
            "bio",
            "bh"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bio_add_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "439-442",
          "snippet": "static inline int xfs_bio_add_buffer(struct bio *bio, struct buffer_head *bh)\n{\n\treturn bio_add_page(bio, bh->b_page, bh->b_size, bh_offset(bh));\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic inline int xfs_bio_add_buffer(struct bio *bio, struct buffer_head *bh)\n{\n\treturn bio_add_page(bio, bh->b_page, bh->b_size, bh_offset(bh));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_ioend_bio",
          "args": [
            "bh"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_ioend_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "383-394",
          "snippet": "bio *\nxfs_alloc_ioend_bio(\n\tstruct buffer_head\t*bh)\n{\n\tint\t\t\tnvecs = bio_get_nr_vecs(bh->b_bdev);\n\tstruct bio\t\t*bio = bio_alloc(GFP_NOIO, nvecs);\n\n\tASSERT(bio->bi_private == NULL);\n\tbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\n\tbio->bi_bdev = bh->b_bdev;\n\treturn bio;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nbio *\nxfs_alloc_ioend_bio(\n\tstruct buffer_head\t*bh)\n{\n\tint\t\t\tnvecs = bio_get_nr_vecs(bh->b_bdev);\n\tstruct bio\t\t*bio = bio_alloc(GFP_NOIO, nvecs);\n\n\tASSERT(bio->bi_private == NULL);\n\tbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\n\tbio->bi_bdev = bh->b_bdev;\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_start_buffer_writeback",
          "args": [
            "bh"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_start_buffer_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "396-408",
          "snippet": "STATIC void\nxfs_start_buffer_writeback(\n\tstruct buffer_head\t*bh)\n{\n\tASSERT(buffer_mapped(bh));\n\tASSERT(buffer_locked(bh));\n\tASSERT(!buffer_delay(bh));\n\tASSERT(!buffer_unwritten(bh));\n\n\tmark_buffer_async_write(bh);\n\tset_buffer_uptodate(bh);\n\tclear_buffer_dirty(bh);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_start_buffer_writeback(\n\tstruct buffer_head\t*bh)\n{\n\tASSERT(buffer_mapped(bh));\n\tASSERT(buffer_locked(bh));\n\tASSERT(!buffer_delay(bh));\n\tASSERT(!buffer_unwritten(bh));\n\n\tmark_buffer_async_write(bh);\n\tset_buffer_uptodate(bh);\n\tclear_buffer_dirty(bh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_submit_ioend(\n\tstruct writeback_control *wbc,\n\txfs_ioend_t\t\t*ioend,\n\tint\t\t\tfail)\n{\n\txfs_ioend_t\t\t*head = ioend;\n\txfs_ioend_t\t\t*next;\n\tstruct buffer_head\t*bh;\n\tstruct bio\t\t*bio;\n\tsector_t\t\tlastblock = 0;\n\n\t/* Pass 1 - start writeback */\n\tdo {\n\t\tnext = ioend->io_list;\n\t\tfor (bh = ioend->io_buffer_head; bh; bh = bh->b_private)\n\t\t\txfs_start_buffer_writeback(bh);\n\t} while ((ioend = next) != NULL);\n\n\t/* Pass 2 - submit I/O */\n\tioend = head;\n\tdo {\n\t\tnext = ioend->io_list;\n\t\tbio = NULL;\n\n\t\t/*\n\t\t * If we are failing the IO now, just mark the ioend with an\n\t\t * error and finish it. This will run IO completion immediately\n\t\t * as there is only one reference to the ioend at this point in\n\t\t * time.\n\t\t */\n\t\tif (fail) {\n\t\t\tioend->io_error = fail;\n\t\t\txfs_finish_ioend(ioend);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (bh = ioend->io_buffer_head; bh; bh = bh->b_private) {\n\n\t\t\tif (!bio) {\n retry:\n\t\t\t\tbio = xfs_alloc_ioend_bio(bh);\n\t\t\t} else if (bh->b_blocknr != lastblock + 1) {\n\t\t\t\txfs_submit_ioend_bio(wbc, ioend, bio);\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\tif (xfs_bio_add_buffer(bio, bh) != bh->b_size) {\n\t\t\t\txfs_submit_ioend_bio(wbc, ioend, bio);\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\tlastblock = bh->b_blocknr;\n\t\t}\n\t\tif (bio)\n\t\t\txfs_submit_ioend_bio(wbc, ioend, bio);\n\t\txfs_finish_ioend(ioend);\n\t} while ((ioend = next) != NULL);\n}"
  },
  {
    "function_name": "xfs_bio_add_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "439-442",
    "snippet": "static inline int xfs_bio_add_buffer(struct bio *bio, struct buffer_head *bh)\n{\n\treturn bio_add_page(bio, bh->b_page, bh->b_size, bh_offset(bh));\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "bh->b_page",
            "bh->b_size",
            "bh_offset(bh)"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic inline int xfs_bio_add_buffer(struct bio *bio, struct buffer_head *bh)\n{\n\treturn bio_add_page(bio, bh->b_page, bh->b_size, bh_offset(bh));\n}"
  },
  {
    "function_name": "xfs_start_page_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "410-437",
    "snippet": "STATIC void\nxfs_start_page_writeback(\n\tstruct page\t\t*page,\n\tint\t\t\tclear_dirty,\n\tint\t\t\tbuffers)\n{\n\tASSERT(PageLocked(page));\n\tASSERT(!PageWriteback(page));\n\n\t/*\n\t * if the page was not fully cleaned, we need to ensure that the higher\n\t * layers come back to it correctly. That means we need to keep the page\n\t * dirty, and for WB_SYNC_ALL writeback we need to ensure the\n\t * PAGECACHE_TAG_TOWRITE index mark is not removed so another attempt to\n\t * write this page in this writeback sweep will be made.\n\t */\n\tif (clear_dirty) {\n\t\tclear_page_dirty_for_io(page);\n\t\tset_page_writeback(page);\n\t} else\n\t\tset_page_writeback_keepwrite(page);\n\n\tunlock_page(page);\n\n\t/* If no buffers on the page are to be written, finish it here */\n\tif (!buffers)\n\t\tend_page_writeback(page);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback_keepwrite",
          "args": [
            "page"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!PageWriteback(page)"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "PageLocked(page)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_start_page_writeback(\n\tstruct page\t\t*page,\n\tint\t\t\tclear_dirty,\n\tint\t\t\tbuffers)\n{\n\tASSERT(PageLocked(page));\n\tASSERT(!PageWriteback(page));\n\n\t/*\n\t * if the page was not fully cleaned, we need to ensure that the higher\n\t * layers come back to it correctly. That means we need to keep the page\n\t * dirty, and for WB_SYNC_ALL writeback we need to ensure the\n\t * PAGECACHE_TAG_TOWRITE index mark is not removed so another attempt to\n\t * write this page in this writeback sweep will be made.\n\t */\n\tif (clear_dirty) {\n\t\tclear_page_dirty_for_io(page);\n\t\tset_page_writeback(page);\n\t} else\n\t\tset_page_writeback_keepwrite(page);\n\n\tunlock_page(page);\n\n\t/* If no buffers on the page are to be written, finish it here */\n\tif (!buffers)\n\t\tend_page_writeback(page);\n}"
  },
  {
    "function_name": "xfs_start_buffer_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "396-408",
    "snippet": "STATIC void\nxfs_start_buffer_writeback(\n\tstruct buffer_head\t*bh)\n{\n\tASSERT(buffer_mapped(bh));\n\tASSERT(buffer_locked(bh));\n\tASSERT(!buffer_delay(bh));\n\tASSERT(!buffer_unwritten(bh));\n\n\tmark_buffer_async_write(bh);\n\tset_buffer_uptodate(bh);\n\tclear_buffer_dirty(bh);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_async_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "420-423",
          "snippet": "void mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!buffer_unwritten(bh)"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!buffer_delay(bh)"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "buffer_locked(bh)"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "buffer_mapped(bh)"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_start_buffer_writeback(\n\tstruct buffer_head\t*bh)\n{\n\tASSERT(buffer_mapped(bh));\n\tASSERT(buffer_locked(bh));\n\tASSERT(!buffer_delay(bh));\n\tASSERT(!buffer_unwritten(bh));\n\n\tmark_buffer_async_write(bh);\n\tset_buffer_uptodate(bh);\n\tclear_buffer_dirty(bh);\n}"
  },
  {
    "function_name": "xfs_alloc_ioend_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "383-394",
    "snippet": "bio *\nxfs_alloc_ioend_bio(\n\tstruct buffer_head\t*bh)\n{\n\tint\t\t\tnvecs = bio_get_nr_vecs(bh->b_bdev);\n\tstruct bio\t\t*bio = bio_alloc(GFP_NOIO, nvecs);\n\n\tASSERT(bio->bi_private == NULL);\n\tbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\n\tbio->bi_bdev = bh->b_bdev;\n\treturn bio;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bio->bi_private == NULL"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_NOIO",
            "nvecs"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_get_nr_vecs",
          "args": [
            "bh->b_bdev"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nbio *\nxfs_alloc_ioend_bio(\n\tstruct buffer_head\t*bh)\n{\n\tint\t\t\tnvecs = bio_get_nr_vecs(bh->b_bdev);\n\tstruct bio\t\t*bio = bio_alloc(GFP_NOIO, nvecs);\n\n\tASSERT(bio->bi_private == NULL);\n\tbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\n\tbio->bi_bdev = bh->b_bdev;\n\treturn bio;\n}"
  },
  {
    "function_name": "xfs_submit_ioend_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "371-381",
    "snippet": "STATIC void\nxfs_submit_ioend_bio(\n\tstruct writeback_control *wbc,\n\txfs_ioend_t\t\t*ioend,\n\tstruct bio\t\t*bio)\n{\n\tatomic_inc(&ioend->io_remaining);\n\tbio->bi_private = ioend;\n\tbio->bi_end_io = xfs_end_bio;\n\tsubmit_bio(wbc->sync_mode == WB_SYNC_ALL ? WRITE_SYNC : WRITE, bio);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "wbc->sync_mode == WB_SYNC_ALL ? WRITE_SYNC : WRITE",
            "bio"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-115",
          "snippet": "static struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ioend->io_remaining"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_submit_ioend_bio(\n\tstruct writeback_control *wbc,\n\txfs_ioend_t\t\t*ioend,\n\tstruct bio\t\t*bio)\n{\n\tatomic_inc(&ioend->io_remaining);\n\tbio->bi_private = ioend;\n\tbio->bi_end_io = xfs_end_bio;\n\tsubmit_bio(wbc->sync_mode == WB_SYNC_ALL ? WRITE_SYNC : WRITE, bio);\n}"
  },
  {
    "function_name": "xfs_end_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "353-369",
    "snippet": "STATIC void\nxfs_end_bio(\n\tstruct bio\t\t*bio,\n\tint\t\t\terror)\n{\n\txfs_ioend_t\t\t*ioend = bio->bi_private;\n\n\tASSERT(atomic_read(&bio->bi_cnt) >= 1);\n\tioend->io_error = test_bit(BIO_UPTODATE, &bio->bi_flags) ? 0 : error;\n\n\t/* Toss bio and pass work off to an xfsdatad thread */\n\tbio->bi_private = NULL;\n\tbio->bi_end_io = NULL;\n\tbio_put(bio);\n\n\txfs_finish_ioend(ioend);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_finish_ioend",
          "args": [
            "ioend"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_finish_ioend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "187-201",
          "snippet": "STATIC void\nxfs_finish_ioend(\n\tstruct xfs_ioend\t*ioend)\n{\n\tif (atomic_dec_and_test(&ioend->io_remaining)) {\n\t\tstruct xfs_mount\t*mp = XFS_I(ioend->io_inode)->i_mount;\n\n\t\tif (ioend->io_type == XFS_IO_UNWRITTEN)\n\t\t\tqueue_work(mp->m_unwritten_workqueue, &ioend->io_work);\n\t\telse if (ioend->io_append_trans)\n\t\t\tqueue_work(mp->m_data_workqueue, &ioend->io_work);\n\t\telse\n\t\t\txfs_destroy_ioend(ioend);\n\t}\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_finish_ioend(\n\tstruct xfs_ioend\t*ioend)\n{\n\tif (atomic_dec_and_test(&ioend->io_remaining)) {\n\t\tstruct xfs_mount\t*mp = XFS_I(ioend->io_inode)->i_mount;\n\n\t\tif (ioend->io_type == XFS_IO_UNWRITTEN)\n\t\t\tqueue_work(mp->m_unwritten_workqueue, &ioend->io_work);\n\t\telse if (ioend->io_append_trans)\n\t\t\tqueue_work(mp->m_data_workqueue, &ioend->io_work);\n\t\telse\n\t\t\txfs_destroy_ioend(ioend);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BIO_UPTODATE",
            "&bio->bi_flags"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bio->bi_cnt) >= 1"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bio->bi_cnt"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_end_bio(\n\tstruct bio\t\t*bio,\n\tint\t\t\terror)\n{\n\txfs_ioend_t\t\t*ioend = bio->bi_private;\n\n\tASSERT(atomic_read(&bio->bi_cnt) >= 1);\n\tioend->io_error = test_bit(BIO_UPTODATE, &bio->bi_flags) ? 0 : error;\n\n\t/* Toss bio and pass work off to an xfsdatad thread */\n\tbio->bi_private = NULL;\n\tbio->bi_end_io = NULL;\n\tbio_put(bio);\n\n\txfs_finish_ioend(ioend);\n}"
  },
  {
    "function_name": "xfs_imap_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "338-348",
    "snippet": "STATIC int\nxfs_imap_valid(\n\tstruct inode\t\t*inode,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_off_t\t\toffset)\n{\n\toffset >>= inode->i_blkbits;\n\n\treturn offset >= imap->br_startoff &&\n\t\toffset < imap->br_startoff + imap->br_blockcount;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_imap_valid(\n\tstruct inode\t\t*inode,\n\tstruct xfs_bmbt_irec\t*imap,\n\txfs_off_t\t\toffset)\n{\n\toffset >>= inode->i_blkbits;\n\n\treturn offset >= imap->br_startoff &&\n\t\toffset < imap->br_startoff + imap->br_blockcount;\n}"
  },
  {
    "function_name": "xfs_map_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "275-336",
    "snippet": "STATIC int\nxfs_map_blocks(\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\toffset,\n\tstruct xfs_bmbt_irec\t*imap,\n\tint\t\t\ttype,\n\tint\t\t\tnonblocking)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tssize_t\t\t\tcount = 1 << inode->i_blkbits;\n\txfs_fileoff_t\t\toffset_fsb, end_fsb;\n\tint\t\t\terror = 0;\n\tint\t\t\tbmapi_flags = XFS_BMAPI_ENTIRE;\n\tint\t\t\tnimaps = 1;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tif (type == XFS_IO_UNWRITTEN)\n\t\tbmapi_flags |= XFS_BMAPI_IGSTATE;\n\n\tif (!xfs_ilock_nowait(ip, XFS_ILOCK_SHARED)) {\n\t\tif (nonblocking)\n\t\t\treturn -EAGAIN;\n\t\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\t}\n\n\tASSERT(ip->i_d.di_format != XFS_DINODE_FMT_BTREE ||\n\t       (ip->i_df.if_flags & XFS_IFEXTENTS));\n\tASSERT(offset <= mp->m_super->s_maxbytes);\n\n\tif (offset + count > mp->m_super->s_maxbytes)\n\t\tcount = mp->m_super->s_maxbytes - offset;\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + count);\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\terror = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb,\n\t\t\t\timap, &nimaps, bmapi_flags);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (error)\n\t\treturn error;\n\n\tif (type == XFS_IO_DELALLOC &&\n\t    (!nimaps || isnullstartblock(imap->br_startblock))) {\n\t\terror = xfs_iomap_write_allocate(ip, offset, imap);\n\t\tif (!error)\n\t\t\ttrace_xfs_map_blocks_alloc(ip, offset, count, type, imap);\n\t\treturn error;\n\t}\n\n#ifdef DEBUG\n\tif (type == XFS_IO_UNWRITTEN) {\n\t\tASSERT(nimaps);\n\t\tASSERT(imap->br_startblock != HOLESTARTBLOCK);\n\t\tASSERT(imap->br_startblock != DELAYSTARTBLOCK);\n\t}\n#endif\n\tif (nimaps)\n\t\ttrace_xfs_map_blocks_found(ip, offset, count, type, imap);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_map_blocks_found",
          "args": [
            "ip",
            "offset",
            "count",
            "type",
            "imap"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "imap->br_startblock != DELAYSTARTBLOCK"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "imap->br_startblock != HOLESTARTBLOCK"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nimaps"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_map_blocks_alloc",
          "args": [
            "ip",
            "offset",
            "count",
            "type",
            "imap"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iomap_write_allocate",
          "args": [
            "ip",
            "offset",
            "imap"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iomap_write_allocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iomap.c",
          "lines": "646-799",
          "snippet": "int\nxfs_iomap_write_allocate(\n\txfs_inode_t\t*ip,\n\txfs_off_t\toffset,\n\txfs_bmbt_irec_t *imap)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_fileoff_t\toffset_fsb, last_block;\n\txfs_fileoff_t\tend_fsb, map_start_fsb;\n\txfs_fsblock_t\tfirst_block;\n\txfs_bmap_free_t\tfree_list;\n\txfs_filblks_t\tcount_fsb;\n\txfs_trans_t\t*tp;\n\tint\t\tnimaps, committed;\n\tint\t\terror = 0;\n\tint\t\tnres;\n\n\t/*\n\t * Make sure that the dquots are there.\n\t */\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\tcount_fsb = imap->br_blockcount;\n\tmap_start_fsb = imap->br_startoff;\n\n\tXFS_STATS_ADD(xs_xstrat_bytes, XFS_FSB_TO_B(mp, count_fsb));\n\n\twhile (count_fsb != 0) {\n\t\t/*\n\t\t * Set up a transaction with which to allocate the\n\t\t * backing store for the file.  Do allocations in a\n\t\t * loop until we get some space in the range we are\n\t\t * interested in.  The other space that might be allocated\n\t\t * is in the delayed allocation extent on which we sit\n\t\t * but before our buffer starts.\n\t\t */\n\n\t\tnimaps = 0;\n\t\twhile (nimaps == 0) {\n\t\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_STRAT_WRITE);\n\t\t\ttp->t_flags |= XFS_TRANS_RESERVE;\n\t\t\tnres = XFS_EXTENTADD_SPACE_RES(mp, XFS_DATA_FORK);\n\t\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\t\t\t  nres, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_trans_cancel(tp, 0);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t\txfs_bmap_init(&free_list, &first_block);\n\n\t\t\t/*\n\t\t\t * it is possible that the extents have changed since\n\t\t\t * we did the read call as we dropped the ilock for a\n\t\t\t * while. We have to be careful about truncates or hole\n\t\t\t * punchs here - we are not allowed to allocate\n\t\t\t * non-delalloc blocks here.\n\t\t\t *\n\t\t\t * The only protection against truncation is the pages\n\t\t\t * for the range we are being asked to convert are\n\t\t\t * locked and hence a truncate will block on them\n\t\t\t * first.\n\t\t\t *\n\t\t\t * As a result, if we go beyond the range we really\n\t\t\t * need and hit an delalloc extent boundary followed by\n\t\t\t * a hole while we have excess blocks in the map, we\n\t\t\t * will fill the hole incorrectly and overrun the\n\t\t\t * transaction reservation.\n\t\t\t *\n\t\t\t * Using a single map prevents this as we are forced to\n\t\t\t * check each map we look for overlap with the desired\n\t\t\t * range and abort as soon as we find it. Also, given\n\t\t\t * that we only return a single map, having one beyond\n\t\t\t * what we can return is probably a bit silly.\n\t\t\t *\n\t\t\t * We also need to check that we don't go beyond EOF;\n\t\t\t * this is a truncate optimisation as a truncate sets\n\t\t\t * the new file size before block on the pages we\n\t\t\t * currently have locked under writeback. Because they\n\t\t\t * are about to be tossed, we don't need to write them\n\t\t\t * back....\n\t\t\t */\n\t\t\tnimaps = 1;\n\t\t\tend_fsb = XFS_B_TO_FSB(mp, XFS_ISIZE(ip));\n\t\t\terror = xfs_bmap_last_offset(ip, &last_block,\n\t\t\t\t\t\t\tXFS_DATA_FORK);\n\t\t\tif (error)\n\t\t\t\tgoto trans_cancel;\n\n\t\t\tlast_block = XFS_FILEOFF_MAX(last_block, end_fsb);\n\t\t\tif ((map_start_fsb + count_fsb) > last_block) {\n\t\t\t\tcount_fsb = last_block - map_start_fsb;\n\t\t\t\tif (count_fsb == 0) {\n\t\t\t\t\terror = -EAGAIN;\n\t\t\t\t\tgoto trans_cancel;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * From this point onwards we overwrite the imap\n\t\t\t * pointer that the caller gave to us.\n\t\t\t */\n\t\t\terror = xfs_bmapi_write(tp, ip, map_start_fsb,\n\t\t\t\t\t\tcount_fsb, 0,\n\t\t\t\t\t\t&first_block, 1,\n\t\t\t\t\t\timap, &nimaps, &free_list);\n\t\t\tif (error)\n\t\t\t\tgoto trans_cancel;\n\n\t\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\t\tif (error)\n\t\t\t\tgoto trans_cancel;\n\n\t\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\n\t\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\t}\n\n\t\t/*\n\t\t * See if we were able to allocate an extent that\n\t\t * covers at least part of the callers request\n\t\t */\n\t\tif (!(imap->br_startblock || XFS_IS_REALTIME_INODE(ip)))\n\t\t\treturn xfs_alert_fsblock_zero(ip, imap);\n\n\t\tif ((offset_fsb >= imap->br_startoff) &&\n\t\t    (offset_fsb < (imap->br_startoff +\n\t\t\t\t   imap->br_blockcount))) {\n\t\t\tXFS_STATS_INC(xs_xstrat_quick);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * So far we have not mapped the requested part of the\n\t\t * file, just surrounding data, try again.\n\t\t */\n\t\tcount_fsb -= imap->br_blockcount;\n\t\tmap_start_fsb = imap->br_startoff + imap->br_blockcount;\n\t}\n\ntrans_cancel:\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\nerror0:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_iomap_write_allocate(\n\txfs_inode_t\t*ip,\n\txfs_off_t\toffset,\n\txfs_bmbt_irec_t *imap)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_fileoff_t\toffset_fsb, last_block;\n\txfs_fileoff_t\tend_fsb, map_start_fsb;\n\txfs_fsblock_t\tfirst_block;\n\txfs_bmap_free_t\tfree_list;\n\txfs_filblks_t\tcount_fsb;\n\txfs_trans_t\t*tp;\n\tint\t\tnimaps, committed;\n\tint\t\terror = 0;\n\tint\t\tnres;\n\n\t/*\n\t * Make sure that the dquots are there.\n\t */\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\tcount_fsb = imap->br_blockcount;\n\tmap_start_fsb = imap->br_startoff;\n\n\tXFS_STATS_ADD(xs_xstrat_bytes, XFS_FSB_TO_B(mp, count_fsb));\n\n\twhile (count_fsb != 0) {\n\t\t/*\n\t\t * Set up a transaction with which to allocate the\n\t\t * backing store for the file.  Do allocations in a\n\t\t * loop until we get some space in the range we are\n\t\t * interested in.  The other space that might be allocated\n\t\t * is in the delayed allocation extent on which we sit\n\t\t * but before our buffer starts.\n\t\t */\n\n\t\tnimaps = 0;\n\t\twhile (nimaps == 0) {\n\t\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_STRAT_WRITE);\n\t\t\ttp->t_flags |= XFS_TRANS_RESERVE;\n\t\t\tnres = XFS_EXTENTADD_SPACE_RES(mp, XFS_DATA_FORK);\n\t\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\t\t\t  nres, 0);\n\t\t\tif (error) {\n\t\t\t\txfs_trans_cancel(tp, 0);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t\txfs_bmap_init(&free_list, &first_block);\n\n\t\t\t/*\n\t\t\t * it is possible that the extents have changed since\n\t\t\t * we did the read call as we dropped the ilock for a\n\t\t\t * while. We have to be careful about truncates or hole\n\t\t\t * punchs here - we are not allowed to allocate\n\t\t\t * non-delalloc blocks here.\n\t\t\t *\n\t\t\t * The only protection against truncation is the pages\n\t\t\t * for the range we are being asked to convert are\n\t\t\t * locked and hence a truncate will block on them\n\t\t\t * first.\n\t\t\t *\n\t\t\t * As a result, if we go beyond the range we really\n\t\t\t * need and hit an delalloc extent boundary followed by\n\t\t\t * a hole while we have excess blocks in the map, we\n\t\t\t * will fill the hole incorrectly and overrun the\n\t\t\t * transaction reservation.\n\t\t\t *\n\t\t\t * Using a single map prevents this as we are forced to\n\t\t\t * check each map we look for overlap with the desired\n\t\t\t * range and abort as soon as we find it. Also, given\n\t\t\t * that we only return a single map, having one beyond\n\t\t\t * what we can return is probably a bit silly.\n\t\t\t *\n\t\t\t * We also need to check that we don't go beyond EOF;\n\t\t\t * this is a truncate optimisation as a truncate sets\n\t\t\t * the new file size before block on the pages we\n\t\t\t * currently have locked under writeback. Because they\n\t\t\t * are about to be tossed, we don't need to write them\n\t\t\t * back....\n\t\t\t */\n\t\t\tnimaps = 1;\n\t\t\tend_fsb = XFS_B_TO_FSB(mp, XFS_ISIZE(ip));\n\t\t\terror = xfs_bmap_last_offset(ip, &last_block,\n\t\t\t\t\t\t\tXFS_DATA_FORK);\n\t\t\tif (error)\n\t\t\t\tgoto trans_cancel;\n\n\t\t\tlast_block = XFS_FILEOFF_MAX(last_block, end_fsb);\n\t\t\tif ((map_start_fsb + count_fsb) > last_block) {\n\t\t\t\tcount_fsb = last_block - map_start_fsb;\n\t\t\t\tif (count_fsb == 0) {\n\t\t\t\t\terror = -EAGAIN;\n\t\t\t\t\tgoto trans_cancel;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * From this point onwards we overwrite the imap\n\t\t\t * pointer that the caller gave to us.\n\t\t\t */\n\t\t\terror = xfs_bmapi_write(tp, ip, map_start_fsb,\n\t\t\t\t\t\tcount_fsb, 0,\n\t\t\t\t\t\t&first_block, 1,\n\t\t\t\t\t\timap, &nimaps, &free_list);\n\t\t\tif (error)\n\t\t\t\tgoto trans_cancel;\n\n\t\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\t\tif (error)\n\t\t\t\tgoto trans_cancel;\n\n\t\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\n\t\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\t}\n\n\t\t/*\n\t\t * See if we were able to allocate an extent that\n\t\t * covers at least part of the callers request\n\t\t */\n\t\tif (!(imap->br_startblock || XFS_IS_REALTIME_INODE(ip)))\n\t\t\treturn xfs_alert_fsblock_zero(ip, imap);\n\n\t\tif ((offset_fsb >= imap->br_startoff) &&\n\t\t    (offset_fsb < (imap->br_startoff +\n\t\t\t\t   imap->br_blockcount))) {\n\t\t\tXFS_STATS_INC(xs_xstrat_quick);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * So far we have not mapped the requested part of the\n\t\t * file, just surrounding data, try again.\n\t\t */\n\t\tcount_fsb -= imap->br_blockcount;\n\t\tmap_start_fsb = imap->br_startoff + imap->br_blockcount;\n\t}\n\ntrans_cancel:\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\nerror0:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnullstartblock",
          "args": [
            "imap->br_startblock"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "isnullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1378-1381",
          "snippet": "static inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_SHARED"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "ip",
            "offset_fsb",
            "end_fsb - offset_fsb",
            "imap",
            "&nimaps",
            "bmapi_flags"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSBT",
          "args": [
            "mp",
            "offset"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "(xfs_ufsize_t)offset + count"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "offset <= mp->m_super->s_maxbytes"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_format != XFS_DINODE_FMT_BTREE ||\n\t       (ip->i_df.if_flags & XFS_IFEXTENTS)"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_SHARED"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock_nowait",
          "args": [
            "ip",
            "XFS_ILOCK_SHARED"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "180-221",
          "snippet": "int\nxfs_ilock_nowait(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock_nowait(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_iolock))\n\t\t\tgoto out;\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_iolock))\n\t\t\tgoto out;\n\t}\n\tif (lock_flags & XFS_ILOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t} else if (lock_flags & XFS_ILOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t}\n\treturn 1;\n\n out_undo_iolock:\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n out:\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_ilock_nowait(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock_nowait(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_iolock))\n\t\t\tgoto out;\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_iolock))\n\t\t\tgoto out;\n\t}\n\tif (lock_flags & XFS_ILOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t} else if (lock_flags & XFS_ILOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t}\n\treturn 1;\n\n out_undo_iolock:\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n out:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_map_blocks(\n\tstruct inode\t\t*inode,\n\tloff_t\t\t\toffset,\n\tstruct xfs_bmbt_irec\t*imap,\n\tint\t\t\ttype,\n\tint\t\t\tnonblocking)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tssize_t\t\t\tcount = 1 << inode->i_blkbits;\n\txfs_fileoff_t\t\toffset_fsb, end_fsb;\n\tint\t\t\terror = 0;\n\tint\t\t\tbmapi_flags = XFS_BMAPI_ENTIRE;\n\tint\t\t\tnimaps = 1;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tif (type == XFS_IO_UNWRITTEN)\n\t\tbmapi_flags |= XFS_BMAPI_IGSTATE;\n\n\tif (!xfs_ilock_nowait(ip, XFS_ILOCK_SHARED)) {\n\t\tif (nonblocking)\n\t\t\treturn -EAGAIN;\n\t\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\t}\n\n\tASSERT(ip->i_d.di_format != XFS_DINODE_FMT_BTREE ||\n\t       (ip->i_df.if_flags & XFS_IFEXTENTS));\n\tASSERT(offset <= mp->m_super->s_maxbytes);\n\n\tif (offset + count > mp->m_super->s_maxbytes)\n\t\tcount = mp->m_super->s_maxbytes - offset;\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + count);\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\terror = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb,\n\t\t\t\timap, &nimaps, bmapi_flags);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (error)\n\t\treturn error;\n\n\tif (type == XFS_IO_DELALLOC &&\n\t    (!nimaps || isnullstartblock(imap->br_startblock))) {\n\t\terror = xfs_iomap_write_allocate(ip, offset, imap);\n\t\tif (!error)\n\t\t\ttrace_xfs_map_blocks_alloc(ip, offset, count, type, imap);\n\t\treturn error;\n\t}\n\n#ifdef DEBUG\n\tif (type == XFS_IO_UNWRITTEN) {\n\t\tASSERT(nimaps);\n\t\tASSERT(imap->br_startblock != HOLESTARTBLOCK);\n\t\tASSERT(imap->br_startblock != DELAYSTARTBLOCK);\n\t}\n#endif\n\tif (nimaps)\n\t\ttrace_xfs_map_blocks_found(ip, offset, count, type, imap);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_alloc_ioend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "246-273",
    "snippet": "STATIC xfs_ioend_t *\nxfs_alloc_ioend(\n\tstruct inode\t\t*inode,\n\tunsigned int\t\ttype)\n{\n\txfs_ioend_t\t\t*ioend;\n\n\tioend = mempool_alloc(xfs_ioend_pool, GFP_NOFS);\n\n\t/*\n\t * Set the count to 1 initially, which will prevent an I/O\n\t * completion callback from happening before we have started\n\t * all the I/O from calling the completion routine too early.\n\t */\n\tatomic_set(&ioend->io_remaining, 1);\n\tioend->io_error = 0;\n\tioend->io_list = NULL;\n\tioend->io_type = type;\n\tioend->io_inode = inode;\n\tioend->io_buffer_head = NULL;\n\tioend->io_buffer_tail = NULL;\n\tioend->io_offset = 0;\n\tioend->io_size = 0;\n\tioend->io_append_trans = NULL;\n\n\tINIT_WORK(&ioend->io_work, xfs_end_io);\n\treturn ioend;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&ioend->io_work",
            "xfs_end_io"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ioend->io_remaining",
            "1"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_alloc",
          "args": [
            "xfs_ioend_pool",
            "GFP_NOFS"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC xfs_ioend_t *\nxfs_alloc_ioend(\n\tstruct inode\t\t*inode,\n\tunsigned int\t\ttype)\n{\n\txfs_ioend_t\t\t*ioend;\n\n\tioend = mempool_alloc(xfs_ioend_pool, GFP_NOFS);\n\n\t/*\n\t * Set the count to 1 initially, which will prevent an I/O\n\t * completion callback from happening before we have started\n\t * all the I/O from calling the completion routine too early.\n\t */\n\tatomic_set(&ioend->io_remaining, 1);\n\tioend->io_error = 0;\n\tioend->io_list = NULL;\n\tioend->io_type = type;\n\tioend->io_inode = inode;\n\tioend->io_buffer_head = NULL;\n\tioend->io_buffer_tail = NULL;\n\tioend->io_offset = 0;\n\tioend->io_size = 0;\n\tioend->io_append_trans = NULL;\n\n\tINIT_WORK(&ioend->io_work, xfs_end_io);\n\treturn ioend;\n}"
  },
  {
    "function_name": "xfs_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "206-238",
    "snippet": "STATIC void\nxfs_end_io(\n\tstruct work_struct *work)\n{\n\txfs_ioend_t\t*ioend = container_of(work, xfs_ioend_t, io_work);\n\tstruct xfs_inode *ip = XFS_I(ioend->io_inode);\n\tint\t\terror = 0;\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\tioend->io_error = -EIO;\n\t\tgoto done;\n\t}\n\tif (ioend->io_error)\n\t\tgoto done;\n\n\t/*\n\t * For unwritten extents we need to issue transactions to convert a\n\t * range to normal written extens after the data I/O has finished.\n\t */\n\tif (ioend->io_type == XFS_IO_UNWRITTEN) {\n\t\terror = xfs_iomap_write_unwritten(ip, ioend->io_offset,\n\t\t\t\t\t\t  ioend->io_size);\n\t} else if (ioend->io_append_trans) {\n\t\terror = xfs_setfilesize_ioend(ioend);\n\t} else {\n\t\tASSERT(!xfs_ioend_is_append(ioend));\n\t}\n\ndone:\n\tif (error)\n\t\tioend->io_error = error;\n\txfs_destroy_ioend(ioend);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_destroy_ioend",
          "args": [
            "ioend"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_destroy_ioend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "78-90",
          "snippet": "STATIC void\nxfs_destroy_ioend(\n\txfs_ioend_t\t\t*ioend)\n{\n\tstruct buffer_head\t*bh, *next;\n\n\tfor (bh = ioend->io_buffer_head; bh; bh = next) {\n\t\tnext = bh->b_private;\n\t\tbh->b_end_io(bh, !ioend->io_error);\n\t}\n\n\tmempool_free(ioend, xfs_ioend_pool);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_destroy_ioend(\n\txfs_ioend_t\t\t*ioend)\n{\n\tstruct buffer_head\t*bh, *next;\n\n\tfor (bh = ioend->io_buffer_head; bh; bh = next) {\n\t\tnext = bh->b_private;\n\t\tbh->b_end_io(bh, !ioend->io_error);\n\t}\n\n\tmempool_free(ioend, xfs_ioend_pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!xfs_ioend_is_append(ioend)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ioend_is_append",
          "args": [
            "ioend"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioend_is_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "95-99",
          "snippet": "static inline bool xfs_ioend_is_append(struct xfs_ioend *ioend)\n{\n\treturn ioend->io_offset + ioend->io_size >\n\t\tXFS_I(ioend->io_inode)->i_d.di_size;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic inline bool xfs_ioend_is_append(struct xfs_ioend *ioend)\n{\n\treturn ioend->io_offset + ioend->io_size >\n\t\tXFS_I(ioend->io_inode)->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_setfilesize_ioend",
          "args": [
            "ioend"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setfilesize_ioend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "162-179",
          "snippet": "STATIC int\nxfs_setfilesize_ioend(\n\tstruct xfs_ioend\t*ioend)\n{\n\tstruct xfs_inode\t*ip = XFS_I(ioend->io_inode);\n\tstruct xfs_trans\t*tp = ioend->io_append_trans;\n\n\t/*\n\t * The transaction may have been allocated in the I/O submission thread,\n\t * thus we need to mark ourselves as being in a transaction manually.\n\t * Similarly for freeze protection.\n\t */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\trwsem_acquire_read(&VFS_I(ip)->i_sb->s_writers.lock_map[SB_FREEZE_FS-1],\n\t\t\t   0, 1, _THIS_IP_);\n\n\treturn xfs_setfilesize(ip, tp, ioend->io_offset, ioend->io_size);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_setfilesize_ioend(\n\tstruct xfs_ioend\t*ioend)\n{\n\tstruct xfs_inode\t*ip = XFS_I(ioend->io_inode);\n\tstruct xfs_trans\t*tp = ioend->io_append_trans;\n\n\t/*\n\t * The transaction may have been allocated in the I/O submission thread,\n\t * thus we need to mark ourselves as being in a transaction manually.\n\t * Similarly for freeze protection.\n\t */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\trwsem_acquire_read(&VFS_I(ip)->i_sb->s_writers.lock_map[SB_FREEZE_FS-1],\n\t\t\t   0, 1, _THIS_IP_);\n\n\treturn xfs_setfilesize(ip, tp, ioend->io_offset, ioend->io_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iomap_write_unwritten",
          "args": [
            "ip",
            "ioend->io_offset",
            "ioend->io_size"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iomap_write_unwritten",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iomap.c",
          "lines": "801-921",
          "snippet": "int\nxfs_iomap_write_unwritten(\n\txfs_inode_t\t*ip,\n\txfs_off_t\toffset,\n\txfs_off_t\tcount)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_fileoff_t\toffset_fsb;\n\txfs_filblks_t\tcount_fsb;\n\txfs_filblks_t\tnumblks_fsb;\n\txfs_fsblock_t\tfirstfsb;\n\tint\t\tnimaps;\n\txfs_trans_t\t*tp;\n\txfs_bmbt_irec_t imap;\n\txfs_bmap_free_t free_list;\n\txfs_fsize_t\ti_size;\n\tuint\t\tresblks;\n\tint\t\tcommitted;\n\tint\t\terror;\n\n\ttrace_xfs_unwritten_convert(ip, offset, count);\n\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\tcount_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + count);\n\tcount_fsb = (xfs_filblks_t)(count_fsb - offset_fsb);\n\n\t/*\n\t * Reserve enough blocks in this transaction for two complete extent\n\t * btree splits.  We may be converting the middle part of an unwritten\n\t * extent and in this case we will insert two new extents in the btree\n\t * each of which could cause a full split.\n\t *\n\t * This reservation amount will be used in the first call to\n\t * xfs_bmbt_split() to select an AG with enough space to satisfy the\n\t * rest of the operation.\n\t */\n\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0) << 1;\n\n\tdo {\n\t\t/*\n\t\t * set up a transaction to convert the range of extents\n\t\t * from unwritten to real. Do allocations in a loop until\n\t\t * we have covered the range passed in.\n\t\t *\n\t\t * Note that we open code the transaction allocation here\n\t\t * to pass KM_NOFS--we can't risk to recursing back into\n\t\t * the filesystem here as we might be asked to write out\n\t\t * the same inode that we complete here and might deadlock\n\t\t * on the iolock.\n\t\t */\n\t\tsb_start_intwrite(mp->m_super);\n\t\ttp = _xfs_trans_alloc(mp, XFS_TRANS_STRAT_WRITE, KM_NOFS);\n\t\ttp->t_flags |= XFS_TRANS_RESERVE | XFS_TRANS_FREEZE_PROT;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\t\t  resblks, 0);\n\t\tif (error) {\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\treturn error;\n\t\t}\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * Modify the unwritten extent state of the buffer.\n\t\t */\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\tnimaps = 1;\n\t\terror = xfs_bmapi_write(tp, ip, offset_fsb, count_fsb,\n\t\t\t\t  XFS_BMAPI_CONVERT, &firstfsb,\n\t\t\t\t  1, &imap, &nimaps, &free_list);\n\t\tif (error)\n\t\t\tgoto error_on_bmapi_transaction;\n\n\t\t/*\n\t\t * Log the updated inode size as we go.  We have to be careful\n\t\t * to only log it up to the actual write offset if it is\n\t\t * halfway into a block.\n\t\t */\n\t\ti_size = XFS_FSB_TO_B(mp, offset_fsb + count_fsb);\n\t\tif (i_size > offset + count)\n\t\t\ti_size = offset + count;\n\n\t\ti_size = xfs_new_eof(ip, i_size);\n\t\tif (i_size) {\n\t\t\tip->i_d.di_size = i_size;\n\t\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t\t}\n\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error)\n\t\t\tgoto error_on_bmapi_transaction;\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (!(imap.br_startblock || XFS_IS_REALTIME_INODE(ip)))\n\t\t\treturn xfs_alert_fsblock_zero(ip, &imap);\n\n\t\tif ((numblks_fsb = imap.br_blockcount) == 0) {\n\t\t\t/*\n\t\t\t * The numblks_fsb value should always get\n\t\t\t * smaller, otherwise the loop is stuck.\n\t\t\t */\n\t\t\tASSERT(imap.br_blockcount);\n\t\t\tbreak;\n\t\t}\n\t\toffset_fsb += numblks_fsb;\n\t\tcount_fsb -= numblks_fsb;\n\t} while (count_fsb > 0);\n\n\treturn 0;\n\nerror_on_bmapi_transaction:\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_cancel(tp, (XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT));\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_iomap_write_unwritten(\n\txfs_inode_t\t*ip,\n\txfs_off_t\toffset,\n\txfs_off_t\tcount)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_fileoff_t\toffset_fsb;\n\txfs_filblks_t\tcount_fsb;\n\txfs_filblks_t\tnumblks_fsb;\n\txfs_fsblock_t\tfirstfsb;\n\tint\t\tnimaps;\n\txfs_trans_t\t*tp;\n\txfs_bmbt_irec_t imap;\n\txfs_bmap_free_t free_list;\n\txfs_fsize_t\ti_size;\n\tuint\t\tresblks;\n\tint\t\tcommitted;\n\tint\t\terror;\n\n\ttrace_xfs_unwritten_convert(ip, offset, count);\n\n\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\tcount_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + count);\n\tcount_fsb = (xfs_filblks_t)(count_fsb - offset_fsb);\n\n\t/*\n\t * Reserve enough blocks in this transaction for two complete extent\n\t * btree splits.  We may be converting the middle part of an unwritten\n\t * extent and in this case we will insert two new extents in the btree\n\t * each of which could cause a full split.\n\t *\n\t * This reservation amount will be used in the first call to\n\t * xfs_bmbt_split() to select an AG with enough space to satisfy the\n\t * rest of the operation.\n\t */\n\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0) << 1;\n\n\tdo {\n\t\t/*\n\t\t * set up a transaction to convert the range of extents\n\t\t * from unwritten to real. Do allocations in a loop until\n\t\t * we have covered the range passed in.\n\t\t *\n\t\t * Note that we open code the transaction allocation here\n\t\t * to pass KM_NOFS--we can't risk to recursing back into\n\t\t * the filesystem here as we might be asked to write out\n\t\t * the same inode that we complete here and might deadlock\n\t\t * on the iolock.\n\t\t */\n\t\tsb_start_intwrite(mp->m_super);\n\t\ttp = _xfs_trans_alloc(mp, XFS_TRANS_STRAT_WRITE, KM_NOFS);\n\t\ttp->t_flags |= XFS_TRANS_RESERVE | XFS_TRANS_FREEZE_PROT;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\t\t  resblks, 0);\n\t\tif (error) {\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\treturn error;\n\t\t}\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * Modify the unwritten extent state of the buffer.\n\t\t */\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\tnimaps = 1;\n\t\terror = xfs_bmapi_write(tp, ip, offset_fsb, count_fsb,\n\t\t\t\t  XFS_BMAPI_CONVERT, &firstfsb,\n\t\t\t\t  1, &imap, &nimaps, &free_list);\n\t\tif (error)\n\t\t\tgoto error_on_bmapi_transaction;\n\n\t\t/*\n\t\t * Log the updated inode size as we go.  We have to be careful\n\t\t * to only log it up to the actual write offset if it is\n\t\t * halfway into a block.\n\t\t */\n\t\ti_size = XFS_FSB_TO_B(mp, offset_fsb + count_fsb);\n\t\tif (i_size > offset + count)\n\t\t\ti_size = offset + count;\n\n\t\ti_size = xfs_new_eof(ip, i_size);\n\t\tif (i_size) {\n\t\t\tip->i_d.di_size = i_size;\n\t\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t\t}\n\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error)\n\t\t\tgoto error_on_bmapi_transaction;\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (!(imap.br_startblock || XFS_IS_REALTIME_INODE(ip)))\n\t\t\treturn xfs_alert_fsblock_zero(ip, &imap);\n\n\t\tif ((numblks_fsb = imap.br_blockcount) == 0) {\n\t\t\t/*\n\t\t\t * The numblks_fsb value should always get\n\t\t\t * smaller, otherwise the loop is stuck.\n\t\t\t */\n\t\t\tASSERT(imap.br_blockcount);\n\t\t\tbreak;\n\t\t}\n\t\toffset_fsb += numblks_fsb;\n\t\tcount_fsb -= numblks_fsb;\n\t} while (count_fsb > 0);\n\n\treturn 0;\n\nerror_on_bmapi_transaction:\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_cancel(tp, (XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT));\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "ip->i_mount"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "ioend->io_inode"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "xfs_ioend_t",
            "io_work"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_end_io(\n\tstruct work_struct *work)\n{\n\txfs_ioend_t\t*ioend = container_of(work, xfs_ioend_t, io_work);\n\tstruct xfs_inode *ip = XFS_I(ioend->io_inode);\n\tint\t\terror = 0;\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\tioend->io_error = -EIO;\n\t\tgoto done;\n\t}\n\tif (ioend->io_error)\n\t\tgoto done;\n\n\t/*\n\t * For unwritten extents we need to issue transactions to convert a\n\t * range to normal written extens after the data I/O has finished.\n\t */\n\tif (ioend->io_type == XFS_IO_UNWRITTEN) {\n\t\terror = xfs_iomap_write_unwritten(ip, ioend->io_offset,\n\t\t\t\t\t\t  ioend->io_size);\n\t} else if (ioend->io_append_trans) {\n\t\terror = xfs_setfilesize_ioend(ioend);\n\t} else {\n\t\tASSERT(!xfs_ioend_is_append(ioend));\n\t}\n\ndone:\n\tif (error)\n\t\tioend->io_error = error;\n\txfs_destroy_ioend(ioend);\n}"
  },
  {
    "function_name": "xfs_finish_ioend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "187-201",
    "snippet": "STATIC void\nxfs_finish_ioend(\n\tstruct xfs_ioend\t*ioend)\n{\n\tif (atomic_dec_and_test(&ioend->io_remaining)) {\n\t\tstruct xfs_mount\t*mp = XFS_I(ioend->io_inode)->i_mount;\n\n\t\tif (ioend->io_type == XFS_IO_UNWRITTEN)\n\t\t\tqueue_work(mp->m_unwritten_workqueue, &ioend->io_work);\n\t\telse if (ioend->io_append_trans)\n\t\t\tqueue_work(mp->m_data_workqueue, &ioend->io_work);\n\t\telse\n\t\t\txfs_destroy_ioend(ioend);\n\t}\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_destroy_ioend",
          "args": [
            "ioend"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_destroy_ioend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "78-90",
          "snippet": "STATIC void\nxfs_destroy_ioend(\n\txfs_ioend_t\t\t*ioend)\n{\n\tstruct buffer_head\t*bh, *next;\n\n\tfor (bh = ioend->io_buffer_head; bh; bh = next) {\n\t\tnext = bh->b_private;\n\t\tbh->b_end_io(bh, !ioend->io_error);\n\t}\n\n\tmempool_free(ioend, xfs_ioend_pool);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_destroy_ioend(\n\txfs_ioend_t\t\t*ioend)\n{\n\tstruct buffer_head\t*bh, *next;\n\n\tfor (bh = ioend->io_buffer_head; bh; bh = next) {\n\t\tnext = bh->b_private;\n\t\tbh->b_end_io(bh, !ioend->io_error);\n\t}\n\n\tmempool_free(ioend, xfs_ioend_pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "mp->m_data_workqueue",
            "&ioend->io_work"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "ioend->io_inode"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&ioend->io_remaining"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_finish_ioend(\n\tstruct xfs_ioend\t*ioend)\n{\n\tif (atomic_dec_and_test(&ioend->io_remaining)) {\n\t\tstruct xfs_mount\t*mp = XFS_I(ioend->io_inode)->i_mount;\n\n\t\tif (ioend->io_type == XFS_IO_UNWRITTEN)\n\t\t\tqueue_work(mp->m_unwritten_workqueue, &ioend->io_work);\n\t\telse if (ioend->io_append_trans)\n\t\t\tqueue_work(mp->m_data_workqueue, &ioend->io_work);\n\t\telse\n\t\t\txfs_destroy_ioend(ioend);\n\t}\n}"
  },
  {
    "function_name": "xfs_setfilesize_ioend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "162-179",
    "snippet": "STATIC int\nxfs_setfilesize_ioend(\n\tstruct xfs_ioend\t*ioend)\n{\n\tstruct xfs_inode\t*ip = XFS_I(ioend->io_inode);\n\tstruct xfs_trans\t*tp = ioend->io_append_trans;\n\n\t/*\n\t * The transaction may have been allocated in the I/O submission thread,\n\t * thus we need to mark ourselves as being in a transaction manually.\n\t * Similarly for freeze protection.\n\t */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\trwsem_acquire_read(&VFS_I(ip)->i_sb->s_writers.lock_map[SB_FREEZE_FS-1],\n\t\t\t   0, 1, _THIS_IP_);\n\n\treturn xfs_setfilesize(ip, tp, ioend->io_offset, ioend->io_size);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_setfilesize",
          "args": [
            "ip",
            "tp",
            "ioend->io_offset",
            "ioend->io_size"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setfilesize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
          "lines": "136-160",
          "snippet": "STATIC int\nxfs_setfilesize(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t*tp,\n\txfs_off_t\t\toffset,\n\tsize_t\t\t\tsize)\n{\n\txfs_fsize_t\t\tisize;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tisize = xfs_new_eof(ip, offset + size);\n\tif (!isize) {\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn 0;\n\t}\n\n\ttrace_xfs_setfilesize(ip, offset, size);\n\n\tip->i_d.di_size = isize;\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\treturn xfs_trans_commit(tp, 0);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_setfilesize(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t*tp,\n\txfs_off_t\t\toffset,\n\tsize_t\t\t\tsize)\n{\n\txfs_fsize_t\t\tisize;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tisize = xfs_new_eof(ip, offset + size);\n\tif (!isize) {\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn 0;\n\t}\n\n\ttrace_xfs_setfilesize(ip, offset, size);\n\n\tip->i_d.di_size = isize;\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\treturn xfs_trans_commit(tp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rwsem_acquire_read",
          "args": [
            "&VFS_I(ip)->i_sb->s_writers.lock_map[SB_FREEZE_FS-1]",
            "0",
            "1",
            "_THIS_IP_"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_set_flags_nested",
          "args": [
            "&tp->t_pflags",
            "PF_FSTRANS"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "ioend->io_inode"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_setfilesize_ioend(\n\tstruct xfs_ioend\t*ioend)\n{\n\tstruct xfs_inode\t*ip = XFS_I(ioend->io_inode);\n\tstruct xfs_trans\t*tp = ioend->io_append_trans;\n\n\t/*\n\t * The transaction may have been allocated in the I/O submission thread,\n\t * thus we need to mark ourselves as being in a transaction manually.\n\t * Similarly for freeze protection.\n\t */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\trwsem_acquire_read(&VFS_I(ip)->i_sb->s_writers.lock_map[SB_FREEZE_FS-1],\n\t\t\t   0, 1, _THIS_IP_);\n\n\treturn xfs_setfilesize(ip, tp, ioend->io_offset, ioend->io_size);\n}"
  },
  {
    "function_name": "xfs_setfilesize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "136-160",
    "snippet": "STATIC int\nxfs_setfilesize(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t*tp,\n\txfs_off_t\t\toffset,\n\tsize_t\t\t\tsize)\n{\n\txfs_fsize_t\t\tisize;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tisize = xfs_new_eof(ip, offset + size);\n\tif (!isize) {\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn 0;\n\t}\n\n\ttrace_xfs_setfilesize(ip, offset, size);\n\n\tip->i_d.di_size = isize;\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\treturn xfs_trans_commit(tp, 0);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "0"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "XFS_ILOG_CORE"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_setfilesize",
          "args": [
            "ip",
            "offset",
            "size"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "0"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_new_eof",
          "args": [
            "ip",
            "offset + size"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_new_eof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "99-107",
          "snippet": "static inline xfs_fsize_t\nxfs_new_eof(struct xfs_inode *ip, xfs_fsize_t new_size)\n{\n\txfs_fsize_t i_size = i_size_read(VFS_I(ip));\n\n\tif (new_size > i_size || new_size < 0)\n\t\tnew_size = i_size;\n\treturn new_size > ip->i_d.di_size ? new_size : 0;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t\nxfs_new_eof(struct xfs_inode *ip, xfs_fsize_t new_size)\n{\n\txfs_fsize_t i_size = i_size_read(VFS_I(ip));\n\n\tif (new_size > i_size || new_size < 0)\n\t\tnew_size = i_size;\n\treturn new_size > ip->i_d.di_size ? new_size : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_setfilesize(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t*tp,\n\txfs_off_t\t\toffset,\n\tsize_t\t\t\tsize)\n{\n\txfs_fsize_t\t\tisize;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tisize = xfs_new_eof(ip, offset + size);\n\tif (!isize) {\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn 0;\n\t}\n\n\ttrace_xfs_setfilesize(ip, offset, size);\n\n\tip->i_d.di_size = isize;\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\treturn xfs_trans_commit(tp, 0);\n}"
  },
  {
    "function_name": "xfs_setfilesize_trans_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "101-131",
    "snippet": "STATIC int\nxfs_setfilesize_trans_alloc(\n\tstruct xfs_ioend\t*ioend)\n{\n\tstruct xfs_mount\t*mp = XFS_I(ioend->io_inode)->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_FSYNC_TS);\n\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_fsyncts, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\tioend->io_append_trans = tp;\n\n\t/*\n\t * We may pass freeze protection with a transaction.  So tell lockdep\n\t * we released it.\n\t */\n\trwsem_release(&ioend->io_inode->i_sb->s_writers.lock_map[SB_FREEZE_FS-1],\n\t\t      1, _THIS_IP_);\n\t/*\n\t * We hand off the transaction to the completion thread now, so\n\t * clear the flag here.\n\t */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_restore_flags_nested",
          "args": [
            "&tp->t_pflags",
            "PF_FSTRANS"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_release",
          "args": [
            "&ioend->io_inode->i_sb->s_writers.lock_map[SB_FREEZE_FS-1]",
            "1",
            "_THIS_IP_"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "0"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_fsyncts",
            "0",
            "0"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_FSYNC_TS"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "ioend->io_inode"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_setfilesize_trans_alloc(\n\tstruct xfs_ioend\t*ioend)\n{\n\tstruct xfs_mount\t*mp = XFS_I(ioend->io_inode)->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_FSYNC_TS);\n\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_fsyncts, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\tioend->io_append_trans = tp;\n\n\t/*\n\t * We may pass freeze protection with a transaction.  So tell lockdep\n\t * we released it.\n\t */\n\trwsem_release(&ioend->io_inode->i_sb->s_writers.lock_map[SB_FREEZE_FS-1],\n\t\t      1, _THIS_IP_);\n\t/*\n\t * We hand off the transaction to the completion thread now, so\n\t * clear the flag here.\n\t */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ioend_is_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "95-99",
    "snippet": "static inline bool xfs_ioend_is_append(struct xfs_ioend *ioend)\n{\n\treturn ioend->io_offset + ioend->io_size >\n\t\tXFS_I(ioend->io_inode)->i_d.di_size;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "ioend->io_inode"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic inline bool xfs_ioend_is_append(struct xfs_ioend *ioend)\n{\n\treturn ioend->io_offset + ioend->io_size >\n\t\tXFS_I(ioend->io_inode)->i_d.di_size;\n}"
  },
  {
    "function_name": "xfs_destroy_ioend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "78-90",
    "snippet": "STATIC void\nxfs_destroy_ioend(\n\txfs_ioend_t\t\t*ioend)\n{\n\tstruct buffer_head\t*bh, *next;\n\n\tfor (bh = ioend->io_buffer_head; bh; bh = next) {\n\t\tnext = bh->b_private;\n\t\tbh->b_end_io(bh, !ioend->io_error);\n\t}\n\n\tmempool_free(ioend, xfs_ioend_pool);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mempool_free",
          "args": [
            "ioend",
            "xfs_ioend_pool"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh->b_end_io",
          "args": [
            "bh",
            "!ioend->io_error"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_destroy_ioend(\n\txfs_ioend_t\t\t*ioend)\n{\n\tstruct buffer_head\t*bh, *next;\n\n\tfor (bh = ioend->io_buffer_head; bh; bh = next) {\n\t\tnext = bh->b_private;\n\t\tbh->b_end_io(bh, !ioend->io_error);\n\t}\n\n\tmempool_free(ioend, xfs_ioend_pool);\n}"
  },
  {
    "function_name": "xfs_find_bdev_for_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "59-70",
    "snippet": "block_device *\nxfs_find_bdev_for_inode(\n\tstruct inode\t\t*inode)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn mp->m_rtdev_targp->bt_bdev;\n\telse\n\t\treturn mp->m_ddev_targp->bt_bdev;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nblock_device *\nxfs_find_bdev_for_inode(\n\tstruct inode\t\t*inode)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn mp->m_rtdev_targp->bt_bdev;\n\telse\n\t\treturn mp->m_ddev_targp->bt_bdev;\n}"
  },
  {
    "function_name": "xfs_count_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_aops.c",
    "lines": "40-57",
    "snippet": "void\nxfs_count_page_state(\n\tstruct page\t\t*page,\n\tint\t\t\t*delalloc,\n\tint\t\t\t*unwritten)\n{\n\tstruct buffer_head\t*bh, *head;\n\n\t*delalloc = *unwritten = 0;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_unwritten(bh))\n\t\t\t(*unwritten) = 1;\n\t\telse if (buffer_delay(bh))\n\t\t\t(*delalloc) = 1;\n\t} while ((bh = bh->b_this_page) != head);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/mpage.h>",
      "#include <linux/gfp.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_iomap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_count_page_state(\n\tstruct page\t\t*page,\n\tint\t\t\t*delalloc,\n\tint\t\t\t*unwritten)\n{\n\tstruct buffer_head\t*bh, *head;\n\n\t*delalloc = *unwritten = 0;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_unwritten(bh))\n\t\t\t(*unwritten) = 1;\n\t\telse if (buffer_delay(bh))\n\t\t\t(*delalloc) = 1;\n\t} while ((bh = bh->b_this_page) != head);\n}"
  }
]