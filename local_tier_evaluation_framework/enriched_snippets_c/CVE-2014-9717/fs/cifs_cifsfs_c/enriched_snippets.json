[
  {
    "function_name": "exit_cifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "1291-1309",
    "snippet": "static void __exit\nexit_cifs(void)\n{\n\tcifs_dbg(NOISY, \"exit_cifs\\n\");\n\tunregister_filesystem(&cifs_fs_type);\n\tcifs_dfs_release_automount_timer();\n#ifdef CONFIG_CIFS_ACL\n\texit_cifs_idmap();\n#endif\n#ifdef CONFIG_CIFS_UPCALL\n\tunregister_key_type(&cifs_spnego_key_type);\n#endif\n\tcifs_destroy_request_bufs();\n\tcifs_destroy_mids();\n\tcifs_destroy_inodecache();\n\tcifs_fscache_unregister();\n\tdestroy_workqueue(cifsiod_wq);\n\tcifs_proc_clean();\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct workqueue_struct\t*cifsiod_wq;",
      "struct file_system_type cifs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"cifs\",\n\t.mount = cifs_do_mount,\n\t.kill_sb = cifs_kill_sb,\n\t/*  .fs_flags */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_proc_clean",
          "args": [],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_proc_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "698-700",
          "snippet": "inline void cifs_proc_clean(void)\n{\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\ninline void cifs_proc_clean(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "cifsiod_wq"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_fscache_unregister",
          "args": [],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fscache_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cache.c",
          "lines": "43-46",
          "snippet": "void cifs_fscache_unregister(void)\n{\n\tfscache_unregister_netfs(&cifs_fscache_netfs);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct fscache_netfs cifs_fscache_netfs = {\n\t.name = \"cifs\",\n\t.version = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"fscache.h\"\n\nstruct fscache_netfs cifs_fscache_netfs = {\n\t.name = \"cifs\",\n\t.version = 0,\n};\n\nvoid cifs_fscache_unregister(void)\n{\n\tfscache_unregister_netfs(&cifs_fscache_netfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_destroy_inodecache",
          "args": [],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
          "lines": "1058-1067",
          "snippet": "static void\ncifs_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(cifs_inode_cachep);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_spnego.h\"",
            "#include <linux/key-type.h>",
            "#include <linux/mm.h>",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/vfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *cifs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *cifs_inode_cachep;\n\nstatic void\ncifs_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(cifs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_destroy_mids",
          "args": [],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_destroy_mids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
          "lines": "1178-1183",
          "snippet": "static void\ncifs_destroy_mids(void)\n{\n\tmempool_destroy(cifs_mid_poolp);\n\tkmem_cache_destroy(cifs_mid_cachep);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_spnego.h\"",
            "#include <linux/key-type.h>",
            "#include <linux/mm.h>",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/vfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_mid_poolp;",
            "static struct kmem_cache *cifs_mid_cachep;",
            "mempool_t *cifs_mid_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nextern mempool_t *cifs_mid_poolp;\nstatic struct kmem_cache *cifs_mid_cachep;\nmempool_t *cifs_mid_poolp;\n\nstatic void\ncifs_destroy_mids(void)\n{\n\tmempool_destroy(cifs_mid_poolp);\n\tkmem_cache_destroy(cifs_mid_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_destroy_request_bufs",
          "args": [],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_destroy_request_bufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
          "lines": "1150-1157",
          "snippet": "static void\ncifs_destroy_request_bufs(void)\n{\n\tmempool_destroy(cifs_req_poolp);\n\tkmem_cache_destroy(cifs_req_cachep);\n\tmempool_destroy(cifs_sm_req_poolp);\n\tkmem_cache_destroy(cifs_sm_req_cachep);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_spnego.h\"",
            "#include <linux/key-type.h>",
            "#include <linux/mm.h>",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/vfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;",
            "extern mempool_t *cifs_req_poolp;",
            "static struct kmem_cache *cifs_req_cachep;",
            "static struct kmem_cache *cifs_sm_req_cachep;",
            "mempool_t *cifs_sm_req_poolp;",
            "mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nextern mempool_t *cifs_sm_req_poolp;\nextern mempool_t *cifs_req_poolp;\nstatic struct kmem_cache *cifs_req_cachep;\nstatic struct kmem_cache *cifs_sm_req_cachep;\nmempool_t *cifs_sm_req_poolp;\nmempool_t *cifs_req_poolp;\n\nstatic void\ncifs_destroy_request_bufs(void)\n{\n\tmempool_destroy(cifs_req_poolp);\n\tkmem_cache_destroy(cifs_req_cachep);\n\tmempool_destroy(cifs_sm_req_poolp);\n\tkmem_cache_destroy(cifs_sm_req_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_key_type",
          "args": [
            "&cifs_spnego_key_type"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_cifs_idmap",
          "args": [],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "exit_cifs_idmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "391-398",
          "snippet": "void\nexit_cifs_idmap(void)\n{\n\tkey_revoke(root_cred->thread_keyring);\n\tunregister_key_type(&cifs_idmap_key_type);\n\tput_cred(root_cred);\n\tcifs_dbg(FYI, \"Unregistered %s key type\\n\", cifs_idmap_key_type.name);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct cred *root_cred;",
            "static struct key_type cifs_idmap_key_type = {\n\t.name        = \"cifs.idmap\",\n\t.instantiate = cifs_idmap_key_instantiate,\n\t.destroy     = cifs_idmap_key_destroy,\n\t.describe    = user_describe,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct cred *root_cred;\nstatic struct key_type cifs_idmap_key_type = {\n\t.name        = \"cifs.idmap\",\n\t.instantiate = cifs_idmap_key_instantiate,\n\t.destroy     = cifs_idmap_key_destroy,\n\t.describe    = user_describe,\n};\n\nvoid\nexit_cifs_idmap(void)\n{\n\tkey_revoke(root_cred->thread_keyring);\n\tunregister_key_type(&cifs_idmap_key_type);\n\tput_cred(root_cred);\n\tcifs_dbg(FYI, \"Unregistered %s key type\\n\", cifs_idmap_key_type.name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dfs_release_automount_timer",
          "args": [],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_dfs_release_automount_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_dfs_ref.c",
          "lines": "45-49",
          "snippet": "void cifs_dfs_release_automount_timer(void)\n{\n\tBUG_ON(!list_empty(&cifs_dfs_automount_list));\n\tcancel_delayed_work_sync(&cifs_dfs_automount_task);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"dns_resolve.h\"",
            "#include \"cifsfs.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(cifs_dfs_automount_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"dns_resolve.h\"\n#include \"cifsfs.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic LIST_HEAD(cifs_dfs_automount_list);\n\nvoid cifs_dfs_release_automount_timer(void)\n{\n\tBUG_ON(!list_empty(&cifs_dfs_automount_list));\n\tcancel_delayed_work_sync(&cifs_dfs_automount_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&cifs_fs_type"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "NOISY",
            "\"exit_cifs\\n\""
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct workqueue_struct\t*cifsiod_wq;\nstruct file_system_type cifs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"cifs\",\n\t.mount = cifs_do_mount,\n\t.kill_sb = cifs_kill_sb,\n\t/*  .fs_flags */\n};\n\nstatic void __exit\nexit_cifs(void)\n{\n\tcifs_dbg(NOISY, \"exit_cifs\\n\");\n\tunregister_filesystem(&cifs_fs_type);\n\tcifs_dfs_release_automount_timer();\n#ifdef CONFIG_CIFS_ACL\n\texit_cifs_idmap();\n#endif\n#ifdef CONFIG_CIFS_UPCALL\n\tunregister_key_type(&cifs_spnego_key_type);\n#endif\n\tcifs_destroy_request_bufs();\n\tcifs_destroy_mids();\n\tcifs_destroy_inodecache();\n\tcifs_fscache_unregister();\n\tdestroy_workqueue(cifsiod_wq);\n\tcifs_proc_clean();\n}"
  },
  {
    "function_name": "init_cifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "1185-1289",
    "snippet": "static int __init\ninit_cifs(void)\n{\n\tint rc = 0;\n\tcifs_proc_init();\n\tINIT_LIST_HEAD(&cifs_tcp_ses_list);\n#ifdef CONFIG_CIFS_DNOTIFY_EXPERIMENTAL /* unused temporarily */\n\tINIT_LIST_HEAD(&GlobalDnotifyReqList);\n\tINIT_LIST_HEAD(&GlobalDnotifyRsp_Q);\n#endif /* was needed for dnotify, and will be needed for inotify when VFS fix */\n/*\n *  Initialize Global counters\n */\n\tatomic_set(&sesInfoAllocCount, 0);\n\tatomic_set(&tconInfoAllocCount, 0);\n\tatomic_set(&tcpSesAllocCount, 0);\n\tatomic_set(&tcpSesReconnectCount, 0);\n\tatomic_set(&tconInfoReconnectCount, 0);\n\n\tatomic_set(&bufAllocCount, 0);\n\tatomic_set(&smBufAllocCount, 0);\n#ifdef CONFIG_CIFS_STATS2\n\tatomic_set(&totBufAllocCount, 0);\n\tatomic_set(&totSmBufAllocCount, 0);\n#endif /* CONFIG_CIFS_STATS2 */\n\n\tatomic_set(&midCount, 0);\n\tGlobalCurrentXid = 0;\n\tGlobalTotalActiveXid = 0;\n\tGlobalMaxActiveXid = 0;\n\tspin_lock_init(&cifs_tcp_ses_lock);\n\tspin_lock_init(&cifs_file_list_lock);\n\tspin_lock_init(&GlobalMid_Lock);\n\n\tif (cifs_max_pending < 2) {\n\t\tcifs_max_pending = 2;\n\t\tcifs_dbg(FYI, \"cifs_max_pending set to min of 2\\n\");\n\t} else if (cifs_max_pending > CIFS_MAX_REQ) {\n\t\tcifs_max_pending = CIFS_MAX_REQ;\n\t\tcifs_dbg(FYI, \"cifs_max_pending set to max of %u\\n\",\n\t\t\t CIFS_MAX_REQ);\n\t}\n\n\tcifsiod_wq = alloc_workqueue(\"cifsiod\", WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);\n\tif (!cifsiod_wq) {\n\t\trc = -ENOMEM;\n\t\tgoto out_clean_proc;\n\t}\n\n\trc = cifs_fscache_register();\n\tif (rc)\n\t\tgoto out_destroy_wq;\n\n\trc = cifs_init_inodecache();\n\tif (rc)\n\t\tgoto out_unreg_fscache;\n\n\trc = cifs_init_mids();\n\tif (rc)\n\t\tgoto out_destroy_inodecache;\n\n\trc = cifs_init_request_bufs();\n\tif (rc)\n\t\tgoto out_destroy_mids;\n\n#ifdef CONFIG_CIFS_UPCALL\n\trc = register_key_type(&cifs_spnego_key_type);\n\tif (rc)\n\t\tgoto out_destroy_request_bufs;\n#endif /* CONFIG_CIFS_UPCALL */\n\n#ifdef CONFIG_CIFS_ACL\n\trc = init_cifs_idmap();\n\tif (rc)\n\t\tgoto out_register_key_type;\n#endif /* CONFIG_CIFS_ACL */\n\n\trc = register_filesystem(&cifs_fs_type);\n\tif (rc)\n\t\tgoto out_init_cifs_idmap;\n\n\treturn 0;\n\nout_init_cifs_idmap:\n#ifdef CONFIG_CIFS_ACL\n\texit_cifs_idmap();\nout_register_key_type:\n#endif\n#ifdef CONFIG_CIFS_UPCALL\n\tunregister_key_type(&cifs_spnego_key_type);\nout_destroy_request_bufs:\n#endif\n\tcifs_destroy_request_bufs();\nout_destroy_mids:\n\tcifs_destroy_mids();\nout_destroy_inodecache:\n\tcifs_destroy_inodecache();\nout_unreg_fscache:\n\tcifs_fscache_unregister();\nout_destroy_wq:\n\tdestroy_workqueue(cifsiod_wq);\nout_clean_proc:\n\tcifs_proc_clean();\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int cifs_max_pending = CIFS_MAX_REQ;",
      "struct workqueue_struct\t*cifsiod_wq;",
      "struct file_system_type cifs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"cifs\",\n\t.mount = cifs_do_mount,\n\t.kill_sb = cifs_kill_sb,\n\t/*  .fs_flags */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_proc_clean",
          "args": [],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_proc_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "698-700",
          "snippet": "inline void cifs_proc_clean(void)\n{\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\ninline void cifs_proc_clean(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "cifsiod_wq"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_fscache_unregister",
          "args": [],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fscache_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cache.c",
          "lines": "43-46",
          "snippet": "void cifs_fscache_unregister(void)\n{\n\tfscache_unregister_netfs(&cifs_fscache_netfs);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct fscache_netfs cifs_fscache_netfs = {\n\t.name = \"cifs\",\n\t.version = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"fscache.h\"\n\nstruct fscache_netfs cifs_fscache_netfs = {\n\t.name = \"cifs\",\n\t.version = 0,\n};\n\nvoid cifs_fscache_unregister(void)\n{\n\tfscache_unregister_netfs(&cifs_fscache_netfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_destroy_inodecache",
          "args": [],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
          "lines": "1058-1067",
          "snippet": "static void\ncifs_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(cifs_inode_cachep);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_spnego.h\"",
            "#include <linux/key-type.h>",
            "#include <linux/mm.h>",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/vfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *cifs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *cifs_inode_cachep;\n\nstatic void\ncifs_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(cifs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_destroy_mids",
          "args": [],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_destroy_mids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
          "lines": "1178-1183",
          "snippet": "static void\ncifs_destroy_mids(void)\n{\n\tmempool_destroy(cifs_mid_poolp);\n\tkmem_cache_destroy(cifs_mid_cachep);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_spnego.h\"",
            "#include <linux/key-type.h>",
            "#include <linux/mm.h>",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/vfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_mid_poolp;",
            "static struct kmem_cache *cifs_mid_cachep;",
            "mempool_t *cifs_mid_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nextern mempool_t *cifs_mid_poolp;\nstatic struct kmem_cache *cifs_mid_cachep;\nmempool_t *cifs_mid_poolp;\n\nstatic void\ncifs_destroy_mids(void)\n{\n\tmempool_destroy(cifs_mid_poolp);\n\tkmem_cache_destroy(cifs_mid_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_destroy_request_bufs",
          "args": [],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_destroy_request_bufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
          "lines": "1150-1157",
          "snippet": "static void\ncifs_destroy_request_bufs(void)\n{\n\tmempool_destroy(cifs_req_poolp);\n\tkmem_cache_destroy(cifs_req_cachep);\n\tmempool_destroy(cifs_sm_req_poolp);\n\tkmem_cache_destroy(cifs_sm_req_cachep);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_spnego.h\"",
            "#include <linux/key-type.h>",
            "#include <linux/mm.h>",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/vfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;",
            "extern mempool_t *cifs_req_poolp;",
            "static struct kmem_cache *cifs_req_cachep;",
            "static struct kmem_cache *cifs_sm_req_cachep;",
            "mempool_t *cifs_sm_req_poolp;",
            "mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nextern mempool_t *cifs_sm_req_poolp;\nextern mempool_t *cifs_req_poolp;\nstatic struct kmem_cache *cifs_req_cachep;\nstatic struct kmem_cache *cifs_sm_req_cachep;\nmempool_t *cifs_sm_req_poolp;\nmempool_t *cifs_req_poolp;\n\nstatic void\ncifs_destroy_request_bufs(void)\n{\n\tmempool_destroy(cifs_req_poolp);\n\tkmem_cache_destroy(cifs_req_cachep);\n\tmempool_destroy(cifs_sm_req_poolp);\n\tkmem_cache_destroy(cifs_sm_req_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_key_type",
          "args": [
            "&cifs_spnego_key_type"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&cifs_fs_type"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_cifs_idmap",
          "args": [],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "init_cifs_idmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "340-389",
          "snippet": "int\ninit_cifs_idmap(void)\n{\n\tstruct cred *cred;\n\tstruct key *keyring;\n\tint ret;\n\n\tcifs_dbg(FYI, \"Registering the %s key type\\n\",\n\t\t cifs_idmap_key_type.name);\n\n\t/* create an override credential set with a special thread keyring in\n\t * which requests are cached\n\t *\n\t * this is used to prevent malicious redirections from being installed\n\t * with add_key().\n\t */\n\tcred = prepare_kernel_cred(NULL);\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tkeyring = keyring_alloc(\".cifs_idmap\",\n\t\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\t\t(KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\tKEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto failed_put_cred;\n\t}\n\n\tret = register_key_type(&cifs_idmap_key_type);\n\tif (ret < 0)\n\t\tgoto failed_put_key;\n\n\t/* instruct request_key() to use this special keyring as a cache for\n\t * the results it looks up */\n\tset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\n\tcred->thread_keyring = keyring;\n\tcred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n\troot_cred = cred;\n\n\tcifs_dbg(FYI, \"cifs idmap keyring: %d\\n\", key_serial(keyring));\n\treturn 0;\n\nfailed_put_key:\n\tkey_put(keyring);\nfailed_put_cred:\n\tput_cred(cred);\n\treturn ret;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct cred *root_cred;",
            "static struct key_type cifs_idmap_key_type = {\n\t.name        = \"cifs.idmap\",\n\t.instantiate = cifs_idmap_key_instantiate,\n\t.destroy     = cifs_idmap_key_destroy,\n\t.describe    = user_describe,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct cred *root_cred;\nstatic struct key_type cifs_idmap_key_type = {\n\t.name        = \"cifs.idmap\",\n\t.instantiate = cifs_idmap_key_instantiate,\n\t.destroy     = cifs_idmap_key_destroy,\n\t.describe    = user_describe,\n};\n\nint\ninit_cifs_idmap(void)\n{\n\tstruct cred *cred;\n\tstruct key *keyring;\n\tint ret;\n\n\tcifs_dbg(FYI, \"Registering the %s key type\\n\",\n\t\t cifs_idmap_key_type.name);\n\n\t/* create an override credential set with a special thread keyring in\n\t * which requests are cached\n\t *\n\t * this is used to prevent malicious redirections from being installed\n\t * with add_key().\n\t */\n\tcred = prepare_kernel_cred(NULL);\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tkeyring = keyring_alloc(\".cifs_idmap\",\n\t\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\t\t(KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\tKEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto failed_put_cred;\n\t}\n\n\tret = register_key_type(&cifs_idmap_key_type);\n\tif (ret < 0)\n\t\tgoto failed_put_key;\n\n\t/* instruct request_key() to use this special keyring as a cache for\n\t * the results it looks up */\n\tset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\n\tcred->thread_keyring = keyring;\n\tcred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n\troot_cred = cred;\n\n\tcifs_dbg(FYI, \"cifs idmap keyring: %d\\n\", key_serial(keyring));\n\treturn 0;\n\nfailed_put_key:\n\tkey_put(keyring);\nfailed_put_cred:\n\tput_cred(cred);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_key_type",
          "args": [
            "&cifs_spnego_key_type"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_init_request_bufs",
          "args": [],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_init_request_bufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
          "lines": "1069-1148",
          "snippet": "static int\ncifs_init_request_bufs(void)\n{\n\tsize_t max_hdr_size = MAX_CIFS_HDR_SIZE;\n#ifdef CONFIG_CIFS_SMB2\n\t/*\n\t * SMB2 maximum header size is bigger than CIFS one - no problems to\n\t * allocate some more bytes for CIFS.\n\t */\n\tmax_hdr_size = MAX_SMB2_HDR_SIZE;\n#endif\n\tif (CIFSMaxBufSize < 8192) {\n\t/* Buffer size can not be smaller than 2 * PATH_MAX since maximum\n\tUnicode path name has to fit in any SMB/CIFS path based frames */\n\t\tCIFSMaxBufSize = 8192;\n\t} else if (CIFSMaxBufSize > 1024*127) {\n\t\tCIFSMaxBufSize = 1024 * 127;\n\t} else {\n\t\tCIFSMaxBufSize &= 0x1FE00; /* Round size to even 512 byte mult*/\n\t}\n/*\n\tcifs_dbg(VFS, \"CIFSMaxBufSize %d 0x%x\\n\",\n\t\t CIFSMaxBufSize, CIFSMaxBufSize);\n*/\n\tcifs_req_cachep = kmem_cache_create(\"cifs_request\",\n\t\t\t\t\t    CIFSMaxBufSize + max_hdr_size, 0,\n\t\t\t\t\t    SLAB_HWCACHE_ALIGN, NULL);\n\tif (cifs_req_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\tif (cifs_min_rcv < 1)\n\t\tcifs_min_rcv = 1;\n\telse if (cifs_min_rcv > 64) {\n\t\tcifs_min_rcv = 64;\n\t\tcifs_dbg(VFS, \"cifs_min_rcv set to maximum (64)\\n\");\n\t}\n\n\tcifs_req_poolp = mempool_create_slab_pool(cifs_min_rcv,\n\t\t\t\t\t\t  cifs_req_cachep);\n\n\tif (cifs_req_poolp == NULL) {\n\t\tkmem_cache_destroy(cifs_req_cachep);\n\t\treturn -ENOMEM;\n\t}\n\t/* MAX_CIFS_SMALL_BUFFER_SIZE bytes is enough for most SMB responses and\n\talmost all handle based requests (but not write response, nor is it\n\tsufficient for path based requests).  A smaller size would have\n\tbeen more efficient (compacting multiple slab items on one 4k page)\n\tfor the case in which debug was on, but this larger size allows\n\tmore SMBs to use small buffer alloc and is still much more\n\tefficient to alloc 1 per page off the slab compared to 17K (5page)\n\talloc of large cifs buffers even when page debugging is on */\n\tcifs_sm_req_cachep = kmem_cache_create(\"cifs_small_rq\",\n\t\t\tMAX_CIFS_SMALL_BUFFER_SIZE, 0, SLAB_HWCACHE_ALIGN,\n\t\t\tNULL);\n\tif (cifs_sm_req_cachep == NULL) {\n\t\tmempool_destroy(cifs_req_poolp);\n\t\tkmem_cache_destroy(cifs_req_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (cifs_min_small < 2)\n\t\tcifs_min_small = 2;\n\telse if (cifs_min_small > 256) {\n\t\tcifs_min_small = 256;\n\t\tcifs_dbg(FYI, \"cifs_min_small set to maximum (256)\\n\");\n\t}\n\n\tcifs_sm_req_poolp = mempool_create_slab_pool(cifs_min_small,\n\t\t\t\t\t\t     cifs_sm_req_cachep);\n\n\tif (cifs_sm_req_poolp == NULL) {\n\t\tmempool_destroy(cifs_req_poolp);\n\t\tkmem_cache_destroy(cifs_req_cachep);\n\t\tkmem_cache_destroy(cifs_sm_req_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_spnego.h\"",
            "#include <linux/key-type.h>",
            "#include <linux/mm.h>",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/vfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;",
            "unsigned int cifs_min_rcv = CIFS_MIN_RCV_POOL;",
            "unsigned int cifs_min_small = 30;",
            "extern mempool_t *cifs_sm_req_poolp;",
            "extern mempool_t *cifs_req_poolp;",
            "static struct kmem_cache *cifs_req_cachep;",
            "static struct kmem_cache *cifs_sm_req_cachep;",
            "mempool_t *cifs_sm_req_poolp;",
            "mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nunsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;\nunsigned int cifs_min_rcv = CIFS_MIN_RCV_POOL;\nunsigned int cifs_min_small = 30;\nextern mempool_t *cifs_sm_req_poolp;\nextern mempool_t *cifs_req_poolp;\nstatic struct kmem_cache *cifs_req_cachep;\nstatic struct kmem_cache *cifs_sm_req_cachep;\nmempool_t *cifs_sm_req_poolp;\nmempool_t *cifs_req_poolp;\n\nstatic int\ncifs_init_request_bufs(void)\n{\n\tsize_t max_hdr_size = MAX_CIFS_HDR_SIZE;\n#ifdef CONFIG_CIFS_SMB2\n\t/*\n\t * SMB2 maximum header size is bigger than CIFS one - no problems to\n\t * allocate some more bytes for CIFS.\n\t */\n\tmax_hdr_size = MAX_SMB2_HDR_SIZE;\n#endif\n\tif (CIFSMaxBufSize < 8192) {\n\t/* Buffer size can not be smaller than 2 * PATH_MAX since maximum\n\tUnicode path name has to fit in any SMB/CIFS path based frames */\n\t\tCIFSMaxBufSize = 8192;\n\t} else if (CIFSMaxBufSize > 1024*127) {\n\t\tCIFSMaxBufSize = 1024 * 127;\n\t} else {\n\t\tCIFSMaxBufSize &= 0x1FE00; /* Round size to even 512 byte mult*/\n\t}\n/*\n\tcifs_dbg(VFS, \"CIFSMaxBufSize %d 0x%x\\n\",\n\t\t CIFSMaxBufSize, CIFSMaxBufSize);\n*/\n\tcifs_req_cachep = kmem_cache_create(\"cifs_request\",\n\t\t\t\t\t    CIFSMaxBufSize + max_hdr_size, 0,\n\t\t\t\t\t    SLAB_HWCACHE_ALIGN, NULL);\n\tif (cifs_req_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\tif (cifs_min_rcv < 1)\n\t\tcifs_min_rcv = 1;\n\telse if (cifs_min_rcv > 64) {\n\t\tcifs_min_rcv = 64;\n\t\tcifs_dbg(VFS, \"cifs_min_rcv set to maximum (64)\\n\");\n\t}\n\n\tcifs_req_poolp = mempool_create_slab_pool(cifs_min_rcv,\n\t\t\t\t\t\t  cifs_req_cachep);\n\n\tif (cifs_req_poolp == NULL) {\n\t\tkmem_cache_destroy(cifs_req_cachep);\n\t\treturn -ENOMEM;\n\t}\n\t/* MAX_CIFS_SMALL_BUFFER_SIZE bytes is enough for most SMB responses and\n\talmost all handle based requests (but not write response, nor is it\n\tsufficient for path based requests).  A smaller size would have\n\tbeen more efficient (compacting multiple slab items on one 4k page)\n\tfor the case in which debug was on, but this larger size allows\n\tmore SMBs to use small buffer alloc and is still much more\n\tefficient to alloc 1 per page off the slab compared to 17K (5page)\n\talloc of large cifs buffers even when page debugging is on */\n\tcifs_sm_req_cachep = kmem_cache_create(\"cifs_small_rq\",\n\t\t\tMAX_CIFS_SMALL_BUFFER_SIZE, 0, SLAB_HWCACHE_ALIGN,\n\t\t\tNULL);\n\tif (cifs_sm_req_cachep == NULL) {\n\t\tmempool_destroy(cifs_req_poolp);\n\t\tkmem_cache_destroy(cifs_req_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (cifs_min_small < 2)\n\t\tcifs_min_small = 2;\n\telse if (cifs_min_small > 256) {\n\t\tcifs_min_small = 256;\n\t\tcifs_dbg(FYI, \"cifs_min_small set to maximum (256)\\n\");\n\t}\n\n\tcifs_sm_req_poolp = mempool_create_slab_pool(cifs_min_small,\n\t\t\t\t\t\t     cifs_sm_req_cachep);\n\n\tif (cifs_sm_req_poolp == NULL) {\n\t\tmempool_destroy(cifs_req_poolp);\n\t\tkmem_cache_destroy(cifs_req_cachep);\n\t\tkmem_cache_destroy(cifs_sm_req_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_init_mids",
          "args": [],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_init_mids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
          "lines": "1159-1176",
          "snippet": "static int\ncifs_init_mids(void)\n{\n\tcifs_mid_cachep = kmem_cache_create(\"cifs_mpx_ids\",\n\t\t\t\t\t    sizeof(struct mid_q_entry), 0,\n\t\t\t\t\t    SLAB_HWCACHE_ALIGN, NULL);\n\tif (cifs_mid_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\t/* 3 is a reasonable minimum number of simultaneous operations */\n\tcifs_mid_poolp = mempool_create_slab_pool(3, cifs_mid_cachep);\n\tif (cifs_mid_poolp == NULL) {\n\t\tkmem_cache_destroy(cifs_mid_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_spnego.h\"",
            "#include <linux/key-type.h>",
            "#include <linux/mm.h>",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/vfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_mid_poolp;",
            "static struct kmem_cache *cifs_mid_cachep;",
            "mempool_t *cifs_mid_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nextern mempool_t *cifs_mid_poolp;\nstatic struct kmem_cache *cifs_mid_cachep;\nmempool_t *cifs_mid_poolp;\n\nstatic int\ncifs_init_mids(void)\n{\n\tcifs_mid_cachep = kmem_cache_create(\"cifs_mpx_ids\",\n\t\t\t\t\t    sizeof(struct mid_q_entry), 0,\n\t\t\t\t\t    SLAB_HWCACHE_ALIGN, NULL);\n\tif (cifs_mid_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\t/* 3 is a reasonable minimum number of simultaneous operations */\n\tcifs_mid_poolp = mempool_create_slab_pool(3, cifs_mid_cachep);\n\tif (cifs_mid_poolp == NULL) {\n\t\tkmem_cache_destroy(cifs_mid_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_init_inodecache",
          "args": [],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
          "lines": "1044-1056",
          "snippet": "static int __init\ncifs_init_inodecache(void)\n{\n\tcifs_inode_cachep = kmem_cache_create(\"cifs_inode_cache\",\n\t\t\t\t\t      sizeof(struct cifsInodeInfo),\n\t\t\t\t\t      0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t      cifs_init_once);\n\tif (cifs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_spnego.h\"",
            "#include <linux/key-type.h>",
            "#include <linux/mm.h>",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/vfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *cifs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *cifs_inode_cachep;\n\nstatic int __init\ncifs_init_inodecache(void)\n{\n\tcifs_inode_cachep = kmem_cache_create(\"cifs_inode_cache\",\n\t\t\t\t\t      sizeof(struct cifsInodeInfo),\n\t\t\t\t\t      0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t      cifs_init_once);\n\tif (cifs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_fscache_register",
          "args": [],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fscache_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cache.c",
          "lines": "35-38",
          "snippet": "int cifs_fscache_register(void)\n{\n\treturn fscache_register_netfs(&cifs_fscache_netfs);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct fscache_netfs cifs_fscache_netfs = {\n\t.name = \"cifs\",\n\t.version = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"fscache.h\"\n\nstruct fscache_netfs cifs_fscache_netfs = {\n\t.name = \"cifs\",\n\t.version = 0,\n};\n\nint cifs_fscache_register(void)\n{\n\treturn fscache_register_netfs(&cifs_fscache_netfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"cifsiod\"",
            "WQ_FREEZABLE|WQ_MEM_RECLAIM",
            "0"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"cifs_max_pending set to max of %u\\n\"",
            "CIFS_MAX_REQ"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"cifs_max_pending set to min of 2\\n\""
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&midCount",
            "0"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&totSmBufAllocCount",
            "0"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&totBufAllocCount",
            "0"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&smBufAllocCount",
            "0"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&bufAllocCount",
            "0"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tconInfoReconnectCount",
            "0"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcpSesReconnectCount",
            "0"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcpSesAllocCount",
            "0"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tconInfoAllocCount",
            "0"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sesInfoAllocCount",
            "0"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&GlobalDnotifyRsp_Q"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&GlobalDnotifyReqList"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cifs_tcp_ses_list"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_proc_init",
          "args": [],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_proc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "694-696",
          "snippet": "inline void cifs_proc_init(void)\n{\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\ninline void cifs_proc_init(void)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nunsigned int cifs_max_pending = CIFS_MAX_REQ;\nstruct workqueue_struct\t*cifsiod_wq;\nstruct file_system_type cifs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"cifs\",\n\t.mount = cifs_do_mount,\n\t.kill_sb = cifs_kill_sb,\n\t/*  .fs_flags */\n};\n\nstatic int __init\ninit_cifs(void)\n{\n\tint rc = 0;\n\tcifs_proc_init();\n\tINIT_LIST_HEAD(&cifs_tcp_ses_list);\n#ifdef CONFIG_CIFS_DNOTIFY_EXPERIMENTAL /* unused temporarily */\n\tINIT_LIST_HEAD(&GlobalDnotifyReqList);\n\tINIT_LIST_HEAD(&GlobalDnotifyRsp_Q);\n#endif /* was needed for dnotify, and will be needed for inotify when VFS fix */\n/*\n *  Initialize Global counters\n */\n\tatomic_set(&sesInfoAllocCount, 0);\n\tatomic_set(&tconInfoAllocCount, 0);\n\tatomic_set(&tcpSesAllocCount, 0);\n\tatomic_set(&tcpSesReconnectCount, 0);\n\tatomic_set(&tconInfoReconnectCount, 0);\n\n\tatomic_set(&bufAllocCount, 0);\n\tatomic_set(&smBufAllocCount, 0);\n#ifdef CONFIG_CIFS_STATS2\n\tatomic_set(&totBufAllocCount, 0);\n\tatomic_set(&totSmBufAllocCount, 0);\n#endif /* CONFIG_CIFS_STATS2 */\n\n\tatomic_set(&midCount, 0);\n\tGlobalCurrentXid = 0;\n\tGlobalTotalActiveXid = 0;\n\tGlobalMaxActiveXid = 0;\n\tspin_lock_init(&cifs_tcp_ses_lock);\n\tspin_lock_init(&cifs_file_list_lock);\n\tspin_lock_init(&GlobalMid_Lock);\n\n\tif (cifs_max_pending < 2) {\n\t\tcifs_max_pending = 2;\n\t\tcifs_dbg(FYI, \"cifs_max_pending set to min of 2\\n\");\n\t} else if (cifs_max_pending > CIFS_MAX_REQ) {\n\t\tcifs_max_pending = CIFS_MAX_REQ;\n\t\tcifs_dbg(FYI, \"cifs_max_pending set to max of %u\\n\",\n\t\t\t CIFS_MAX_REQ);\n\t}\n\n\tcifsiod_wq = alloc_workqueue(\"cifsiod\", WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);\n\tif (!cifsiod_wq) {\n\t\trc = -ENOMEM;\n\t\tgoto out_clean_proc;\n\t}\n\n\trc = cifs_fscache_register();\n\tif (rc)\n\t\tgoto out_destroy_wq;\n\n\trc = cifs_init_inodecache();\n\tif (rc)\n\t\tgoto out_unreg_fscache;\n\n\trc = cifs_init_mids();\n\tif (rc)\n\t\tgoto out_destroy_inodecache;\n\n\trc = cifs_init_request_bufs();\n\tif (rc)\n\t\tgoto out_destroy_mids;\n\n#ifdef CONFIG_CIFS_UPCALL\n\trc = register_key_type(&cifs_spnego_key_type);\n\tif (rc)\n\t\tgoto out_destroy_request_bufs;\n#endif /* CONFIG_CIFS_UPCALL */\n\n#ifdef CONFIG_CIFS_ACL\n\trc = init_cifs_idmap();\n\tif (rc)\n\t\tgoto out_register_key_type;\n#endif /* CONFIG_CIFS_ACL */\n\n\trc = register_filesystem(&cifs_fs_type);\n\tif (rc)\n\t\tgoto out_init_cifs_idmap;\n\n\treturn 0;\n\nout_init_cifs_idmap:\n#ifdef CONFIG_CIFS_ACL\n\texit_cifs_idmap();\nout_register_key_type:\n#endif\n#ifdef CONFIG_CIFS_UPCALL\n\tunregister_key_type(&cifs_spnego_key_type);\nout_destroy_request_bufs:\n#endif\n\tcifs_destroy_request_bufs();\nout_destroy_mids:\n\tcifs_destroy_mids();\nout_destroy_inodecache:\n\tcifs_destroy_inodecache();\nout_unreg_fscache:\n\tcifs_fscache_unregister();\nout_destroy_wq:\n\tdestroy_workqueue(cifsiod_wq);\nout_clean_proc:\n\tcifs_proc_clean();\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_destroy_mids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "1178-1183",
    "snippet": "static void\ncifs_destroy_mids(void)\n{\n\tmempool_destroy(cifs_mid_poolp);\n\tkmem_cache_destroy(cifs_mid_cachep);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern mempool_t *cifs_mid_poolp;",
      "static struct kmem_cache *cifs_mid_cachep;",
      "mempool_t *cifs_mid_poolp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "cifs_mid_cachep"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_destroy",
          "args": [
            "cifs_mid_poolp"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mempool_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "730-734",
          "snippet": "static inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nextern mempool_t *cifs_mid_poolp;\nstatic struct kmem_cache *cifs_mid_cachep;\nmempool_t *cifs_mid_poolp;\n\nstatic void\ncifs_destroy_mids(void)\n{\n\tmempool_destroy(cifs_mid_poolp);\n\tkmem_cache_destroy(cifs_mid_cachep);\n}"
  },
  {
    "function_name": "cifs_init_mids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "1159-1176",
    "snippet": "static int\ncifs_init_mids(void)\n{\n\tcifs_mid_cachep = kmem_cache_create(\"cifs_mpx_ids\",\n\t\t\t\t\t    sizeof(struct mid_q_entry), 0,\n\t\t\t\t\t    SLAB_HWCACHE_ALIGN, NULL);\n\tif (cifs_mid_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\t/* 3 is a reasonable minimum number of simultaneous operations */\n\tcifs_mid_poolp = mempool_create_slab_pool(3, cifs_mid_cachep);\n\tif (cifs_mid_poolp == NULL) {\n\t\tkmem_cache_destroy(cifs_mid_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern mempool_t *cifs_mid_poolp;",
      "static struct kmem_cache *cifs_mid_cachep;",
      "mempool_t *cifs_mid_poolp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "cifs_mid_cachep"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_create_slab_pool",
          "args": [
            "3",
            "cifs_mid_cachep"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"cifs_mpx_ids\"",
            "sizeof(struct mid_q_entry)",
            "0",
            "SLAB_HWCACHE_ALIGN",
            "NULL"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nextern mempool_t *cifs_mid_poolp;\nstatic struct kmem_cache *cifs_mid_cachep;\nmempool_t *cifs_mid_poolp;\n\nstatic int\ncifs_init_mids(void)\n{\n\tcifs_mid_cachep = kmem_cache_create(\"cifs_mpx_ids\",\n\t\t\t\t\t    sizeof(struct mid_q_entry), 0,\n\t\t\t\t\t    SLAB_HWCACHE_ALIGN, NULL);\n\tif (cifs_mid_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\t/* 3 is a reasonable minimum number of simultaneous operations */\n\tcifs_mid_poolp = mempool_create_slab_pool(3, cifs_mid_cachep);\n\tif (cifs_mid_poolp == NULL) {\n\t\tkmem_cache_destroy(cifs_mid_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_destroy_request_bufs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "1150-1157",
    "snippet": "static void\ncifs_destroy_request_bufs(void)\n{\n\tmempool_destroy(cifs_req_poolp);\n\tkmem_cache_destroy(cifs_req_cachep);\n\tmempool_destroy(cifs_sm_req_poolp);\n\tkmem_cache_destroy(cifs_sm_req_cachep);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern mempool_t *cifs_sm_req_poolp;",
      "extern mempool_t *cifs_req_poolp;",
      "static struct kmem_cache *cifs_req_cachep;",
      "static struct kmem_cache *cifs_sm_req_cachep;",
      "mempool_t *cifs_sm_req_poolp;",
      "mempool_t *cifs_req_poolp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "cifs_sm_req_cachep"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_destroy",
          "args": [
            "cifs_sm_req_poolp"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mempool_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "730-734",
          "snippet": "static inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "cifs_req_cachep"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nextern mempool_t *cifs_sm_req_poolp;\nextern mempool_t *cifs_req_poolp;\nstatic struct kmem_cache *cifs_req_cachep;\nstatic struct kmem_cache *cifs_sm_req_cachep;\nmempool_t *cifs_sm_req_poolp;\nmempool_t *cifs_req_poolp;\n\nstatic void\ncifs_destroy_request_bufs(void)\n{\n\tmempool_destroy(cifs_req_poolp);\n\tkmem_cache_destroy(cifs_req_cachep);\n\tmempool_destroy(cifs_sm_req_poolp);\n\tkmem_cache_destroy(cifs_sm_req_cachep);\n}"
  },
  {
    "function_name": "cifs_init_request_bufs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "1069-1148",
    "snippet": "static int\ncifs_init_request_bufs(void)\n{\n\tsize_t max_hdr_size = MAX_CIFS_HDR_SIZE;\n#ifdef CONFIG_CIFS_SMB2\n\t/*\n\t * SMB2 maximum header size is bigger than CIFS one - no problems to\n\t * allocate some more bytes for CIFS.\n\t */\n\tmax_hdr_size = MAX_SMB2_HDR_SIZE;\n#endif\n\tif (CIFSMaxBufSize < 8192) {\n\t/* Buffer size can not be smaller than 2 * PATH_MAX since maximum\n\tUnicode path name has to fit in any SMB/CIFS path based frames */\n\t\tCIFSMaxBufSize = 8192;\n\t} else if (CIFSMaxBufSize > 1024*127) {\n\t\tCIFSMaxBufSize = 1024 * 127;\n\t} else {\n\t\tCIFSMaxBufSize &= 0x1FE00; /* Round size to even 512 byte mult*/\n\t}\n/*\n\tcifs_dbg(VFS, \"CIFSMaxBufSize %d 0x%x\\n\",\n\t\t CIFSMaxBufSize, CIFSMaxBufSize);\n*/\n\tcifs_req_cachep = kmem_cache_create(\"cifs_request\",\n\t\t\t\t\t    CIFSMaxBufSize + max_hdr_size, 0,\n\t\t\t\t\t    SLAB_HWCACHE_ALIGN, NULL);\n\tif (cifs_req_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\tif (cifs_min_rcv < 1)\n\t\tcifs_min_rcv = 1;\n\telse if (cifs_min_rcv > 64) {\n\t\tcifs_min_rcv = 64;\n\t\tcifs_dbg(VFS, \"cifs_min_rcv set to maximum (64)\\n\");\n\t}\n\n\tcifs_req_poolp = mempool_create_slab_pool(cifs_min_rcv,\n\t\t\t\t\t\t  cifs_req_cachep);\n\n\tif (cifs_req_poolp == NULL) {\n\t\tkmem_cache_destroy(cifs_req_cachep);\n\t\treturn -ENOMEM;\n\t}\n\t/* MAX_CIFS_SMALL_BUFFER_SIZE bytes is enough for most SMB responses and\n\talmost all handle based requests (but not write response, nor is it\n\tsufficient for path based requests).  A smaller size would have\n\tbeen more efficient (compacting multiple slab items on one 4k page)\n\tfor the case in which debug was on, but this larger size allows\n\tmore SMBs to use small buffer alloc and is still much more\n\tefficient to alloc 1 per page off the slab compared to 17K (5page)\n\talloc of large cifs buffers even when page debugging is on */\n\tcifs_sm_req_cachep = kmem_cache_create(\"cifs_small_rq\",\n\t\t\tMAX_CIFS_SMALL_BUFFER_SIZE, 0, SLAB_HWCACHE_ALIGN,\n\t\t\tNULL);\n\tif (cifs_sm_req_cachep == NULL) {\n\t\tmempool_destroy(cifs_req_poolp);\n\t\tkmem_cache_destroy(cifs_req_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (cifs_min_small < 2)\n\t\tcifs_min_small = 2;\n\telse if (cifs_min_small > 256) {\n\t\tcifs_min_small = 256;\n\t\tcifs_dbg(FYI, \"cifs_min_small set to maximum (256)\\n\");\n\t}\n\n\tcifs_sm_req_poolp = mempool_create_slab_pool(cifs_min_small,\n\t\t\t\t\t\t     cifs_sm_req_cachep);\n\n\tif (cifs_sm_req_poolp == NULL) {\n\t\tmempool_destroy(cifs_req_poolp);\n\t\tkmem_cache_destroy(cifs_req_cachep);\n\t\tkmem_cache_destroy(cifs_sm_req_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;",
      "unsigned int cifs_min_rcv = CIFS_MIN_RCV_POOL;",
      "unsigned int cifs_min_small = 30;",
      "extern mempool_t *cifs_sm_req_poolp;",
      "extern mempool_t *cifs_req_poolp;",
      "static struct kmem_cache *cifs_req_cachep;",
      "static struct kmem_cache *cifs_sm_req_cachep;",
      "mempool_t *cifs_sm_req_poolp;",
      "mempool_t *cifs_req_poolp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "cifs_sm_req_cachep"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "cifs_req_cachep"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_destroy",
          "args": [
            "cifs_req_poolp"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mempool_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "730-734",
          "snippet": "static inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mempool_create_slab_pool",
          "args": [
            "cifs_min_small",
            "cifs_sm_req_cachep"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"cifs_min_small set to maximum (256)\\n\""
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "cifs_req_cachep"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"cifs_small_rq\"",
            "MAX_CIFS_SMALL_BUFFER_SIZE",
            "0",
            "SLAB_HWCACHE_ALIGN",
            "NULL"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "cifs_req_cachep"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_create_slab_pool",
          "args": [
            "cifs_min_rcv",
            "cifs_req_cachep"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"cifs_min_rcv set to maximum (64)\\n\""
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"cifs_request\"",
            "CIFSMaxBufSize + max_hdr_size",
            "0",
            "SLAB_HWCACHE_ALIGN",
            "NULL"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nunsigned int CIFSMaxBufSize = CIFS_MAX_MSGSIZE;\nunsigned int cifs_min_rcv = CIFS_MIN_RCV_POOL;\nunsigned int cifs_min_small = 30;\nextern mempool_t *cifs_sm_req_poolp;\nextern mempool_t *cifs_req_poolp;\nstatic struct kmem_cache *cifs_req_cachep;\nstatic struct kmem_cache *cifs_sm_req_cachep;\nmempool_t *cifs_sm_req_poolp;\nmempool_t *cifs_req_poolp;\n\nstatic int\ncifs_init_request_bufs(void)\n{\n\tsize_t max_hdr_size = MAX_CIFS_HDR_SIZE;\n#ifdef CONFIG_CIFS_SMB2\n\t/*\n\t * SMB2 maximum header size is bigger than CIFS one - no problems to\n\t * allocate some more bytes for CIFS.\n\t */\n\tmax_hdr_size = MAX_SMB2_HDR_SIZE;\n#endif\n\tif (CIFSMaxBufSize < 8192) {\n\t/* Buffer size can not be smaller than 2 * PATH_MAX since maximum\n\tUnicode path name has to fit in any SMB/CIFS path based frames */\n\t\tCIFSMaxBufSize = 8192;\n\t} else if (CIFSMaxBufSize > 1024*127) {\n\t\tCIFSMaxBufSize = 1024 * 127;\n\t} else {\n\t\tCIFSMaxBufSize &= 0x1FE00; /* Round size to even 512 byte mult*/\n\t}\n/*\n\tcifs_dbg(VFS, \"CIFSMaxBufSize %d 0x%x\\n\",\n\t\t CIFSMaxBufSize, CIFSMaxBufSize);\n*/\n\tcifs_req_cachep = kmem_cache_create(\"cifs_request\",\n\t\t\t\t\t    CIFSMaxBufSize + max_hdr_size, 0,\n\t\t\t\t\t    SLAB_HWCACHE_ALIGN, NULL);\n\tif (cifs_req_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\tif (cifs_min_rcv < 1)\n\t\tcifs_min_rcv = 1;\n\telse if (cifs_min_rcv > 64) {\n\t\tcifs_min_rcv = 64;\n\t\tcifs_dbg(VFS, \"cifs_min_rcv set to maximum (64)\\n\");\n\t}\n\n\tcifs_req_poolp = mempool_create_slab_pool(cifs_min_rcv,\n\t\t\t\t\t\t  cifs_req_cachep);\n\n\tif (cifs_req_poolp == NULL) {\n\t\tkmem_cache_destroy(cifs_req_cachep);\n\t\treturn -ENOMEM;\n\t}\n\t/* MAX_CIFS_SMALL_BUFFER_SIZE bytes is enough for most SMB responses and\n\talmost all handle based requests (but not write response, nor is it\n\tsufficient for path based requests).  A smaller size would have\n\tbeen more efficient (compacting multiple slab items on one 4k page)\n\tfor the case in which debug was on, but this larger size allows\n\tmore SMBs to use small buffer alloc and is still much more\n\tefficient to alloc 1 per page off the slab compared to 17K (5page)\n\talloc of large cifs buffers even when page debugging is on */\n\tcifs_sm_req_cachep = kmem_cache_create(\"cifs_small_rq\",\n\t\t\tMAX_CIFS_SMALL_BUFFER_SIZE, 0, SLAB_HWCACHE_ALIGN,\n\t\t\tNULL);\n\tif (cifs_sm_req_cachep == NULL) {\n\t\tmempool_destroy(cifs_req_poolp);\n\t\tkmem_cache_destroy(cifs_req_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (cifs_min_small < 2)\n\t\tcifs_min_small = 2;\n\telse if (cifs_min_small > 256) {\n\t\tcifs_min_small = 256;\n\t\tcifs_dbg(FYI, \"cifs_min_small set to maximum (256)\\n\");\n\t}\n\n\tcifs_sm_req_poolp = mempool_create_slab_pool(cifs_min_small,\n\t\t\t\t\t\t     cifs_sm_req_cachep);\n\n\tif (cifs_sm_req_poolp == NULL) {\n\t\tmempool_destroy(cifs_req_poolp);\n\t\tkmem_cache_destroy(cifs_req_cachep);\n\t\tkmem_cache_destroy(cifs_sm_req_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "1058-1067",
    "snippet": "static void\ncifs_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(cifs_inode_cachep);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *cifs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "cifs_inode_cachep"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *cifs_inode_cachep;\n\nstatic void\ncifs_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(cifs_inode_cachep);\n}"
  },
  {
    "function_name": "cifs_init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "1044-1056",
    "snippet": "static int __init\ncifs_init_inodecache(void)\n{\n\tcifs_inode_cachep = kmem_cache_create(\"cifs_inode_cache\",\n\t\t\t\t\t      sizeof(struct cifsInodeInfo),\n\t\t\t\t\t      0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t      cifs_init_once);\n\tif (cifs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *cifs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"cifs_inode_cache\"",
            "sizeof(struct cifsInodeInfo)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD)",
            "cifs_init_once"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *cifs_inode_cachep;\n\nstatic int __init\ncifs_init_inodecache(void)\n{\n\tcifs_inode_cachep = kmem_cache_create(\"cifs_inode_cache\",\n\t\t\t\t\t      sizeof(struct cifsInodeInfo),\n\t\t\t\t\t      0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t      cifs_init_once);\n\tif (cifs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "1035-1042",
    "snippet": "static void\ncifs_init_once(void *inode)\n{\n\tstruct cifsInodeInfo *cifsi = inode;\n\n\tinode_init_once(&cifsi->vfs_inode);\n\tinit_rwsem(&cifsi->lock_sem);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&cifsi->lock_sem"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&cifsi->vfs_inode"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "355-367",
          "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void\ncifs_init_once(void *inode)\n{\n\tstruct cifsInodeInfo *cifsi = inode;\n\n\tinode_init_once(&cifsi->vfs_inode);\n\tinit_rwsem(&cifsi->lock_sem);\n}"
  },
  {
    "function_name": "cifs_setlease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "815-846",
    "snippet": "static int\ncifs_setlease(struct file *file, long arg, struct file_lock **lease, void **priv)\n{\n\t/*\n\t * Note that this is called by vfs setlease with i_lock held to\n\t * protect *lease from going away.\n\t */\n\tstruct inode *inode = file_inode(file);\n\tstruct cifsFileInfo *cfile = file->private_data;\n\n\tif (!(S_ISREG(inode->i_mode)))\n\t\treturn -EINVAL;\n\n\t/* Check if file is oplocked if this is request for new lease */\n\tif (arg == F_UNLCK ||\n\t    ((arg == F_RDLCK) && CIFS_CACHE_READ(CIFS_I(inode))) ||\n\t    ((arg == F_WRLCK) && CIFS_CACHE_WRITE(CIFS_I(inode))))\n\t\treturn generic_setlease(file, arg, lease, priv);\n\telse if (tlink_tcon(cfile->tlink)->local_lease &&\n\t\t !CIFS_CACHE_READ(CIFS_I(inode)))\n\t\t/*\n\t\t * If the server claims to support oplock on this file, then we\n\t\t * still need to check oplock even if the local_lease mount\n\t\t * option is set, but there are servers which do not support\n\t\t * oplock for which this mount option may be useful if the user\n\t\t * knows that the file won't be changed on the server by anyone\n\t\t * else.\n\t\t */\n\t\treturn generic_setlease(file, arg, lease, priv);\n\telse\n\t\treturn -EAGAIN;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_setlease",
          "args": [
            "file",
            "arg",
            "lease",
            "priv"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "generic_setlease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1750-1779",
          "snippet": "int generic_setlease(struct file *filp, long arg, struct file_lock **flp,\n\t\t\tvoid **priv)\n{\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif ((!uid_eq(current_fsuid(), inode->i_uid)) && !capable(CAP_LEASE))\n\t\treturn -EACCES;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\terror = security_file_lock(filp, arg);\n\tif (error)\n\t\treturn error;\n\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\treturn generic_delete_lease(filp, *priv);\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (!(*flp)->fl_lmops->lm_break) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn -ENOLCK;\n\t\t}\n\n\t\treturn generic_add_lease(filp, arg, flp, priv);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint generic_setlease(struct file *filp, long arg, struct file_lock **flp,\n\t\t\tvoid **priv)\n{\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif ((!uid_eq(current_fsuid(), inode->i_uid)) && !capable(CAP_LEASE))\n\t\treturn -EACCES;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\terror = security_file_lock(filp, arg);\n\tif (error)\n\t\treturn error;\n\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\treturn generic_delete_lease(filp, *priv);\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (!(*flp)->fl_lmops->lm_break) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn -ENOLCK;\n\t\t}\n\n\t\treturn generic_add_lease(filp, arg, flp, priv);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "CIFS_I(inode)"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_WRITE",
          "args": [
            "CIFS_I(inode)"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "CIFS_I(inode)"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int\ncifs_setlease(struct file *file, long arg, struct file_lock **lease, void **priv)\n{\n\t/*\n\t * Note that this is called by vfs setlease with i_lock held to\n\t * protect *lease from going away.\n\t */\n\tstruct inode *inode = file_inode(file);\n\tstruct cifsFileInfo *cfile = file->private_data;\n\n\tif (!(S_ISREG(inode->i_mode)))\n\t\treturn -EINVAL;\n\n\t/* Check if file is oplocked if this is request for new lease */\n\tif (arg == F_UNLCK ||\n\t    ((arg == F_RDLCK) && CIFS_CACHE_READ(CIFS_I(inode))) ||\n\t    ((arg == F_WRLCK) && CIFS_CACHE_WRITE(CIFS_I(inode))))\n\t\treturn generic_setlease(file, arg, lease, priv);\n\telse if (tlink_tcon(cfile->tlink)->local_lease &&\n\t\t !CIFS_CACHE_READ(CIFS_I(inode)))\n\t\t/*\n\t\t * If the server claims to support oplock on this file, then we\n\t\t * still need to check oplock even if the local_lease mount\n\t\t * option is set, but there are servers which do not support\n\t\t * oplock for which this mount option may be useful if the user\n\t\t * knows that the file won't be changed on the server by anyone\n\t\t * else.\n\t\t */\n\t\treturn generic_setlease(file, arg, lease, priv);\n\telse\n\t\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "cifs_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "779-813",
    "snippet": "static loff_t cifs_llseek(struct file *file, loff_t offset, int whence)\n{\n\t/*\n\t * whence == SEEK_END || SEEK_DATA || SEEK_HOLE => we must revalidate\n\t * the cached file length\n\t */\n\tif (whence != SEEK_SET && whence != SEEK_CUR) {\n\t\tint rc;\n\t\tstruct inode *inode = file_inode(file);\n\n\t\t/*\n\t\t * We need to be sure that all dirty pages are written and the\n\t\t * server has the newest file length.\n\t\t */\n\t\tif (!CIFS_CACHE_READ(CIFS_I(inode)) && inode->i_mapping &&\n\t\t    inode->i_mapping->nrpages != 0) {\n\t\t\trc = filemap_fdatawait(inode->i_mapping);\n\t\t\tif (rc) {\n\t\t\t\tmapping_set_error(inode->i_mapping, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Some applications poll for the file length in this strange\n\t\t * way so we must seek to end on non-oplocked files by\n\t\t * setting the revalidate time to zero.\n\t\t */\n\t\tCIFS_I(inode)->time = 0;\n\n\t\trc = cifs_revalidate_file_attr(file);\n\t\tif (rc < 0)\n\t\t\treturn (loff_t)rc;\n\t}\n\treturn generic_file_llseek(file, offset, whence);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_llseek",
          "args": [
            "file",
            "offset",
            "whence"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "147-154",
          "snippet": "loff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_revalidate_file_attr",
          "args": [
            "file"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "inode->i_mapping",
            "rc"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait",
          "args": [
            "inode->i_mapping"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "CIFS_I(inode)"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic loff_t cifs_llseek(struct file *file, loff_t offset, int whence)\n{\n\t/*\n\t * whence == SEEK_END || SEEK_DATA || SEEK_HOLE => we must revalidate\n\t * the cached file length\n\t */\n\tif (whence != SEEK_SET && whence != SEEK_CUR) {\n\t\tint rc;\n\t\tstruct inode *inode = file_inode(file);\n\n\t\t/*\n\t\t * We need to be sure that all dirty pages are written and the\n\t\t * server has the newest file length.\n\t\t */\n\t\tif (!CIFS_CACHE_READ(CIFS_I(inode)) && inode->i_mapping &&\n\t\t    inode->i_mapping->nrpages != 0) {\n\t\t\trc = filemap_fdatawait(inode->i_mapping);\n\t\t\tif (rc) {\n\t\t\t\tmapping_set_error(inode->i_mapping, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Some applications poll for the file length in this strange\n\t\t * way so we must seek to end on non-oplocked files by\n\t\t * setting the revalidate time to zero.\n\t\t */\n\t\tCIFS_I(inode)->time = 0;\n\n\t\trc = cifs_revalidate_file_attr(file);\n\t\tif (rc < 0)\n\t\t\treturn (loff_t)rc;\n\t}\n\treturn generic_file_llseek(file, offset, whence);\n}"
  },
  {
    "function_name": "cifs_file_write_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "753-777",
    "snippet": "static ssize_t cifs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tssize_t written;\n\tint rc;\n\n\twritten = cifs_get_writer(cinode);\n\tif (written)\n\t\treturn written;\n\n\twritten = generic_file_write_iter(iocb, from);\n\n\tif (CIFS_CACHE_WRITE(CIFS_I(inode)))\n\t\tgoto out;\n\n\trc = filemap_fdatawrite(inode->i_mapping);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"cifs_file_write_iter: %d rc on %p inode\\n\",\n\t\t\t rc, inode);\n\nout:\n\tcifs_put_writer(cinode);\n\treturn written;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_put_writer",
          "args": [
            "cinode"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "581-590",
          "snippet": "void cifs_put_writer(struct cifsInodeInfo *cinode)\n{\n\tspin_lock(&cinode->writers_lock);\n\tcinode->writers--;\n\tif (cinode->writers == 0) {\n\t\tclear_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\t\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_WRITERS);\n\t}\n\tspin_unlock(&cinode->writers_lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid cifs_put_writer(struct cifsInodeInfo *cinode)\n{\n\tspin_lock(&cinode->writers_lock);\n\tcinode->writers--;\n\tif (cinode->writers == 0) {\n\t\tclear_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\t\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_WRITERS);\n\t}\n\tspin_unlock(&cinode->writers_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"cifs_file_write_iter: %d rc on %p inode\\n\"",
            "rc",
            "inode"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite",
          "args": [
            "inode->i_mapping"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_WRITE",
          "args": [
            "CIFS_I(inode)"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_file_write_iter",
          "args": [
            "iocb",
            "from"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_writer",
          "args": [
            "cinode"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "553-579",
          "snippet": "int cifs_get_writer(struct cifsInodeInfo *cinode)\n{\n\tint rc;\n\nstart:\n\trc = wait_on_bit(&cinode->flags, CIFS_INODE_PENDING_OPLOCK_BREAK,\n\t\t\t TASK_KILLABLE);\n\tif (rc)\n\t\treturn rc;\n\n\tspin_lock(&cinode->writers_lock);\n\tif (!cinode->writers)\n\t\tset_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\tcinode->writers++;\n\t/* Check to see if we have started servicing an oplock break */\n\tif (test_bit(CIFS_INODE_PENDING_OPLOCK_BREAK, &cinode->flags)) {\n\t\tcinode->writers--;\n\t\tif (cinode->writers == 0) {\n\t\t\tclear_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\t\t\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_WRITERS);\n\t\t}\n\t\tspin_unlock(&cinode->writers_lock);\n\t\tgoto start;\n\t}\n\tspin_unlock(&cinode->writers_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nint cifs_get_writer(struct cifsInodeInfo *cinode)\n{\n\tint rc;\n\nstart:\n\trc = wait_on_bit(&cinode->flags, CIFS_INODE_PENDING_OPLOCK_BREAK,\n\t\t\t TASK_KILLABLE);\n\tif (rc)\n\t\treturn rc;\n\n\tspin_lock(&cinode->writers_lock);\n\tif (!cinode->writers)\n\t\tset_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\tcinode->writers++;\n\t/* Check to see if we have started servicing an oplock break */\n\tif (test_bit(CIFS_INODE_PENDING_OPLOCK_BREAK, &cinode->flags)) {\n\t\tcinode->writers--;\n\t\tif (cinode->writers == 0) {\n\t\t\tclear_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\t\t\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_WRITERS);\n\t\t}\n\t\tspin_unlock(&cinode->writers_lock);\n\t\tgoto start;\n\t}\n\tspin_unlock(&cinode->writers_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "iocb->ki_filp"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic ssize_t cifs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tssize_t written;\n\tint rc;\n\n\twritten = cifs_get_writer(cinode);\n\tif (written)\n\t\treturn written;\n\n\twritten = generic_file_write_iter(iocb, from);\n\n\tif (CIFS_CACHE_WRITE(CIFS_I(inode)))\n\t\tgoto out;\n\n\trc = filemap_fdatawrite(inode->i_mapping);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"cifs_file_write_iter: %d rc on %p inode\\n\",\n\t\t\t rc, inode);\n\nout:\n\tcifs_put_writer(cinode);\n\treturn written;\n}"
  },
  {
    "function_name": "cifs_loose_read_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "740-751",
    "snippet": "static ssize_t\ncifs_loose_read_iter(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tssize_t rc;\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\n\trc = cifs_revalidate_mapping(inode);\n\tif (rc)\n\t\treturn rc;\n\n\treturn generic_file_read_iter(iocb, iter);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_read_iter",
          "args": [
            "iocb",
            "iter"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_revalidate_mapping",
          "args": [
            "inode"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "iocb->ki_filp"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic ssize_t\ncifs_loose_read_iter(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tssize_t rc;\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\n\trc = cifs_revalidate_mapping(inode);\n\tif (rc)\n\t\treturn rc;\n\n\treturn generic_file_read_iter(iocb, iter);\n}"
  },
  {
    "function_name": "cifs_do_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "651-738",
    "snippet": "static struct dentry *\ncifs_do_mount(struct file_system_type *fs_type,\n\t      int flags, const char *dev_name, void *data)\n{\n\tint rc;\n\tstruct super_block *sb;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct smb_vol *volume_info;\n\tstruct cifs_mnt_data mnt_data;\n\tstruct dentry *root;\n\n\tcifs_dbg(FYI, \"Devname: %s flags: %d\\n\", dev_name, flags);\n\n\tvolume_info = cifs_get_volume_info((char *)data, dev_name);\n\tif (IS_ERR(volume_info))\n\t\treturn ERR_CAST(volume_info);\n\n\tcifs_sb = kzalloc(sizeof(struct cifs_sb_info), GFP_KERNEL);\n\tif (cifs_sb == NULL) {\n\t\troot = ERR_PTR(-ENOMEM);\n\t\tgoto out_nls;\n\t}\n\n\tcifs_sb->mountdata = kstrndup(data, PAGE_SIZE, GFP_KERNEL);\n\tif (cifs_sb->mountdata == NULL) {\n\t\troot = ERR_PTR(-ENOMEM);\n\t\tgoto out_cifs_sb;\n\t}\n\n\tcifs_setup_cifs_sb(volume_info, cifs_sb);\n\n\trc = cifs_mount(cifs_sb, volume_info);\n\tif (rc) {\n\t\tif (!(flags & MS_SILENT))\n\t\t\tcifs_dbg(VFS, \"cifs_mount failed w/return code = %d\\n\",\n\t\t\t\t rc);\n\t\troot = ERR_PTR(rc);\n\t\tgoto out_mountdata;\n\t}\n\n\tmnt_data.vol = volume_info;\n\tmnt_data.cifs_sb = cifs_sb;\n\tmnt_data.flags = flags;\n\n\t/* BB should we make this contingent on mount parm? */\n\tflags |= MS_NODIRATIME | MS_NOATIME;\n\n\tsb = sget(fs_type, cifs_match_super, cifs_set_super, flags, &mnt_data);\n\tif (IS_ERR(sb)) {\n\t\troot = ERR_CAST(sb);\n\t\tcifs_umount(cifs_sb);\n\t\tgoto out;\n\t}\n\n\tif (sb->s_root) {\n\t\tcifs_dbg(FYI, \"Use existing superblock\\n\");\n\t\tcifs_umount(cifs_sb);\n\t} else {\n\t\trc = cifs_read_super(sb);\n\t\tif (rc) {\n\t\t\troot = ERR_PTR(rc);\n\t\t\tgoto out_super;\n\t\t}\n\n\t\tsb->s_flags |= MS_ACTIVE;\n\t}\n\n\troot = cifs_get_root(volume_info, sb);\n\tif (IS_ERR(root))\n\t\tgoto out_super;\n\n\tcifs_dbg(FYI, \"dentry root is: %p\\n\", root);\n\tgoto out;\n\nout_super:\n\tdeactivate_locked_super(sb);\nout:\n\tcifs_cleanup_volume_info(volume_info);\n\treturn root;\n\nout_mountdata:\n\tkfree(cifs_sb->mountdata);\nout_cifs_sb:\n\tkfree(cifs_sb);\nout_nls:\n\tunload_nls(volume_info->local_nls);\n\tgoto out;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "volume_info->local_nls"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cifs_sb"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cifs_sb->mountdata"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_cleanup_volume_info",
          "args": [
            "volume_info"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_cleanup_volume_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3279-3286",
          "snippet": "void\ncifs_cleanup_volume_info(struct smb_vol *volume_info)\n{\n\tif (!volume_info)\n\t\treturn;\n\tcleanup_volume_info_contents(volume_info);\n\tkfree(volume_info);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_cleanup_volume_info(struct smb_vol *volume_info)\n{\n\tif (!volume_info)\n\t\treturn;\n\tcleanup_volume_info_contents(volume_info);\n\tkfree(volume_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "sb"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"dentry root is: %p\\n\"",
            "root"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_root",
          "args": [
            "volume_info",
            "sb"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
          "lines": "589-642",
          "snippet": "static struct dentry *\ncifs_get_root(struct smb_vol *vol, struct super_block *sb)\n{\n\tstruct dentry *dentry;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tchar *full_path = NULL;\n\tchar *s, *p;\n\tchar sep;\n\n\tfull_path = cifs_build_path_to_root(vol, cifs_sb,\n\t\t\t\t\t    cifs_sb_master_tcon(cifs_sb));\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcifs_dbg(FYI, \"Get root dentry for %s\\n\", full_path);\n\n\tsep = CIFS_DIR_SEP(cifs_sb);\n\tdentry = dget(sb->s_root);\n\tp = s = full_path;\n\n\tdo {\n\t\tstruct inode *dir = dentry->d_inode;\n\t\tstruct dentry *child;\n\n\t\tif (!dir) {\n\t\t\tdput(dentry);\n\t\t\tdentry = ERR_PTR(-ENOENT);\n\t\t\tbreak;\n\t\t}\n\t\tif (!S_ISDIR(dir->i_mode)) {\n\t\t\tdput(dentry);\n\t\t\tdentry = ERR_PTR(-ENOTDIR);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* skip separators */\n\t\twhile (*s == sep)\n\t\t\ts++;\n\t\tif (!*s)\n\t\t\tbreak;\n\t\tp = s++;\n\t\t/* next separator */\n\t\twhile (*s && *s != sep)\n\t\t\ts++;\n\n\t\tmutex_lock(&dir->i_mutex);\n\t\tchild = lookup_one_len(p, dentry, s - p);\n\t\tmutex_unlock(&dir->i_mutex);\n\t\tdput(dentry);\n\t\tdentry = child;\n\t} while (!IS_ERR(dentry));\n\tkfree(full_path);\n\treturn dentry;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_spnego.h\"",
            "#include <linux/key-type.h>",
            "#include <linux/mm.h>",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/vfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct dentry *\ncifs_get_root(struct smb_vol *vol, struct super_block *sb)\n{\n\tstruct dentry *dentry;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tchar *full_path = NULL;\n\tchar *s, *p;\n\tchar sep;\n\n\tfull_path = cifs_build_path_to_root(vol, cifs_sb,\n\t\t\t\t\t    cifs_sb_master_tcon(cifs_sb));\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcifs_dbg(FYI, \"Get root dentry for %s\\n\", full_path);\n\n\tsep = CIFS_DIR_SEP(cifs_sb);\n\tdentry = dget(sb->s_root);\n\tp = s = full_path;\n\n\tdo {\n\t\tstruct inode *dir = dentry->d_inode;\n\t\tstruct dentry *child;\n\n\t\tif (!dir) {\n\t\t\tdput(dentry);\n\t\t\tdentry = ERR_PTR(-ENOENT);\n\t\t\tbreak;\n\t\t}\n\t\tif (!S_ISDIR(dir->i_mode)) {\n\t\t\tdput(dentry);\n\t\t\tdentry = ERR_PTR(-ENOTDIR);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* skip separators */\n\t\twhile (*s == sep)\n\t\t\ts++;\n\t\tif (!*s)\n\t\t\tbreak;\n\t\tp = s++;\n\t\t/* next separator */\n\t\twhile (*s && *s != sep)\n\t\t\ts++;\n\n\t\tmutex_lock(&dir->i_mutex);\n\t\tchild = lookup_one_len(p, dentry, s - p);\n\t\tmutex_unlock(&dir->i_mutex);\n\t\tdput(dentry);\n\t\tdentry = child;\n\t} while (!IS_ERR(dentry));\n\tkfree(full_path);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_read_super",
          "args": [
            "sb"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_read_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
          "lines": "114-171",
          "snippet": "static int\ncifs_read_super(struct super_block *sb)\n{\n\tstruct inode *inode;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tint rc = 0;\n\n\tcifs_sb = CIFS_SB(sb);\n\ttcon = cifs_sb_master_tcon(cifs_sb);\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIXACL)\n\t\tsb->s_flags |= MS_POSIXACL;\n\n\tif (tcon->ses->capabilities & tcon->ses->server->vals->cap_large_files)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\telse\n\t\tsb->s_maxbytes = MAX_NON_LFS;\n\n\t/* BB FIXME fix time_gran to be larger for LANMAN sessions */\n\tsb->s_time_gran = 100;\n\n\tsb->s_magic = CIFS_MAGIC_NUMBER;\n\tsb->s_op = &cifs_super_ops;\n\tsb->s_bdi = &cifs_sb->bdi;\n\tsb->s_blocksize = CIFS_MAX_MSGSIZE;\n\tsb->s_blocksize_bits = 14;\t/* default 2**14 = CIFS_MAX_MSGSIZE */\n\tinode = cifs_root_iget(sb);\n\n\tif (IS_ERR(inode)) {\n\t\trc = PTR_ERR(inode);\n\t\tgoto out_no_root;\n\t}\n\n\tif (tcon->nocase)\n\t\tsb->s_d_op = &cifs_ci_dentry_ops;\n\telse\n\t\tsb->s_d_op = &cifs_dentry_ops;\n\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root) {\n\t\trc = -ENOMEM;\n\t\tgoto out_no_root;\n\t}\n\n#ifdef CONFIG_CIFS_NFSD_EXPORT\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\tcifs_dbg(FYI, \"export ops supported\\n\");\n\t\tsb->s_export_op = &cifs_export_ops;\n\t}\n#endif /* CONFIG_CIFS_NFSD_EXPORT */\n\n\treturn 0;\n\nout_no_root:\n\tcifs_dbg(VFS, \"%s: get root inode failed\\n\", __func__);\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_spnego.h\"",
            "#include <linux/key-type.h>",
            "#include <linux/mm.h>",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/vfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct super_operations cifs_super_ops;",
            "static const struct super_operations cifs_super_ops = {\n\t.statfs = cifs_statfs,\n\t.alloc_inode = cifs_alloc_inode,\n\t.destroy_inode = cifs_destroy_inode,\n\t.drop_inode\t= cifs_drop_inode,\n\t.evict_inode\t= cifs_evict_inode,\n/*\t.delete_inode\t= cifs_delete_inode,  */  /* Do not need above\n\tfunction unless later we add lazy close of inodes or unless the\n\tkernel forgets to call us with the same number of releases (closes)\n\tas opens */\n\t.show_options = cifs_show_options,\n\t.umount_begin   = cifs_umount_begin,\n\t.remount_fs = cifs_remount,\n#ifdef CONFIG_CIFS_STATS2\n\t.show_stats = cifs_show_stats,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct super_operations cifs_super_ops;\nstatic const struct super_operations cifs_super_ops = {\n\t.statfs = cifs_statfs,\n\t.alloc_inode = cifs_alloc_inode,\n\t.destroy_inode = cifs_destroy_inode,\n\t.drop_inode\t= cifs_drop_inode,\n\t.evict_inode\t= cifs_evict_inode,\n/*\t.delete_inode\t= cifs_delete_inode,  */  /* Do not need above\n\tfunction unless later we add lazy close of inodes or unless the\n\tkernel forgets to call us with the same number of releases (closes)\n\tas opens */\n\t.show_options = cifs_show_options,\n\t.umount_begin   = cifs_umount_begin,\n\t.remount_fs = cifs_remount,\n#ifdef CONFIG_CIFS_STATS2\n\t.show_stats = cifs_show_stats,\n#endif\n};\n\nstatic int\ncifs_read_super(struct super_block *sb)\n{\n\tstruct inode *inode;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tint rc = 0;\n\n\tcifs_sb = CIFS_SB(sb);\n\ttcon = cifs_sb_master_tcon(cifs_sb);\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIXACL)\n\t\tsb->s_flags |= MS_POSIXACL;\n\n\tif (tcon->ses->capabilities & tcon->ses->server->vals->cap_large_files)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\telse\n\t\tsb->s_maxbytes = MAX_NON_LFS;\n\n\t/* BB FIXME fix time_gran to be larger for LANMAN sessions */\n\tsb->s_time_gran = 100;\n\n\tsb->s_magic = CIFS_MAGIC_NUMBER;\n\tsb->s_op = &cifs_super_ops;\n\tsb->s_bdi = &cifs_sb->bdi;\n\tsb->s_blocksize = CIFS_MAX_MSGSIZE;\n\tsb->s_blocksize_bits = 14;\t/* default 2**14 = CIFS_MAX_MSGSIZE */\n\tinode = cifs_root_iget(sb);\n\n\tif (IS_ERR(inode)) {\n\t\trc = PTR_ERR(inode);\n\t\tgoto out_no_root;\n\t}\n\n\tif (tcon->nocase)\n\t\tsb->s_d_op = &cifs_ci_dentry_ops;\n\telse\n\t\tsb->s_d_op = &cifs_dentry_ops;\n\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root) {\n\t\trc = -ENOMEM;\n\t\tgoto out_no_root;\n\t}\n\n#ifdef CONFIG_CIFS_NFSD_EXPORT\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\tcifs_dbg(FYI, \"export ops supported\\n\");\n\t\tsb->s_export_op = &cifs_export_ops;\n\t}\n#endif /* CONFIG_CIFS_NFSD_EXPORT */\n\n\treturn 0;\n\nout_no_root:\n\tcifs_dbg(VFS, \"%s: get root inode failed\\n\", __func__);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_umount",
          "args": [
            "cifs_sb"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_umount_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
          "lines": "507-541",
          "snippet": "static void cifs_umount_begin(struct super_block *sb)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_tcon *tcon;\n\n\tif (cifs_sb == NULL)\n\t\treturn;\n\n\ttcon = cifs_sb_master_tcon(cifs_sb);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif ((tcon->tc_count > 1) || (tcon->tidStatus == CifsExiting)) {\n\t\t/* we have other mounts to same share or we have\n\t\t   already tried to force umount this and woken up\n\t\t   all waiting network requests, nothing to do */\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t} else if (tcon->tc_count == 1)\n\t\ttcon->tidStatus = CifsExiting;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* cancel_brl_requests(tcon); */ /* BB mark all brl mids as exiting */\n\t/* cancel_notify_requests(tcon); */\n\tif (tcon->ses && tcon->ses->server) {\n\t\tcifs_dbg(FYI, \"wake up tasks now - umount begin not complete\\n\");\n\t\twake_up_all(&tcon->ses->server->request_q);\n\t\twake_up_all(&tcon->ses->server->response_q);\n\t\tmsleep(1); /* yield */\n\t\t/* we have to kick the requests once more */\n\t\twake_up_all(&tcon->ses->server->response_q);\n\t\tmsleep(1);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_spnego.h\"",
            "#include <linux/key-type.h>",
            "#include <linux/mm.h>",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/vfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void cifs_umount_begin(struct super_block *sb)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_tcon *tcon;\n\n\tif (cifs_sb == NULL)\n\t\treturn;\n\n\ttcon = cifs_sb_master_tcon(cifs_sb);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif ((tcon->tc_count > 1) || (tcon->tidStatus == CifsExiting)) {\n\t\t/* we have other mounts to same share or we have\n\t\t   already tried to force umount this and woken up\n\t\t   all waiting network requests, nothing to do */\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t} else if (tcon->tc_count == 1)\n\t\ttcon->tidStatus = CifsExiting;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* cancel_brl_requests(tcon); */ /* BB mark all brl mids as exiting */\n\t/* cancel_notify_requests(tcon); */\n\tif (tcon->ses && tcon->ses->server) {\n\t\tcifs_dbg(FYI, \"wake up tasks now - umount begin not complete\\n\");\n\t\twake_up_all(&tcon->ses->server->request_q);\n\t\twake_up_all(&tcon->ses->server->response_q);\n\t\tmsleep(1); /* yield */\n\t\t/* we have to kick the requests once more */\n\t\twake_up_all(&tcon->ses->server->response_q);\n\t\tmsleep(1);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Use existing superblock\\n\""
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "sb"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sb"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sget",
          "args": [
            "fs_type",
            "cifs_match_super",
            "cifs_set_super",
            "flags",
            "&mnt_data"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"cifs_mount failed w/return code = %d\\n\"",
            "rc"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_mount",
          "args": [
            "cifs_sb",
            "volume_info"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3435-3631",
          "snippet": "int\ncifs_mount(struct cifs_sb_info *cifs_sb, struct smb_vol *volume_info)\n{\n\tint rc;\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tchar   *full_path;\n\tstruct tcon_link *tlink;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tint referral_walks_count = 0;\n#endif\n\n\trc = bdi_setup_and_register(&cifs_sb->bdi, \"cifs\");\n\tif (rc)\n\t\treturn rc;\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\ntry_mount_again:\n\t/* cleanup activities if we're chasing a referral */\n\tif (referral_walks_count) {\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (ses)\n\t\t\tcifs_put_smb_ses(ses);\n\n\t\tfree_xid(xid);\n\t}\n#endif\n\trc = 0;\n\ttcon = NULL;\n\tses = NULL;\n\tserver = NULL;\n\tfull_path = NULL;\n\ttlink = NULL;\n\n\txid = get_xid();\n\n\t/* get a reference to a tcp session */\n\tserver = cifs_get_tcp_session(volume_info);\n\tif (IS_ERR(server)) {\n\t\trc = PTR_ERR(server);\n\t\tbdi_destroy(&cifs_sb->bdi);\n\t\tgoto out;\n\t}\n\n\t/* get a reference to a SMB session */\n\tses = cifs_get_smb_ses(server, volume_info);\n\tif (IS_ERR(ses)) {\n\t\trc = PTR_ERR(ses);\n\t\tses = NULL;\n\t\tgoto mount_fail_check;\n\t}\n\n\t/* search for existing tcon to this server share */\n\ttcon = cifs_get_tcon(ses, volume_info);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto remote_path_check;\n\t}\n\n\t/* tell server which Unix caps we support */\n\tif (cap_unix(tcon->ses)) {\n\t\t/* reset of caps checks mount to see if unix extensions\n\t\t   disabled for just this mount */\n\t\treset_cifs_unix_caps(xid, tcon, cifs_sb, volume_info);\n\t\tif ((tcon->ses->server->tcpStatus == CifsNeedReconnect) &&\n\t\t    (le64_to_cpu(tcon->fsUnixInfo.Capability) &\n\t\t     CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)) {\n\t\t\trc = -EACCES;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t} else\n\t\ttcon->unix_ext = 0; /* server does not support them */\n\n\t/* do not care if a following call succeed - informational */\n\tif (!tcon->ipc && server->ops->qfs_tcon)\n\t\tserver->ops->qfs_tcon(xid, tcon);\n\n\tcifs_sb->wsize = server->ops->negotiate_wsize(tcon, volume_info);\n\tcifs_sb->rsize = server->ops->negotiate_rsize(tcon, volume_info);\n\n\t/* tune readahead according to rsize */\n\tcifs_sb->bdi.ra_pages = cifs_sb->rsize / PAGE_CACHE_SIZE;\n\nremote_path_check:\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t/*\n\t * Perform an unconditional check for whether there are DFS\n\t * referrals for this path without prefix, to provide support\n\t * for DFS referrals from w2k8 servers which don't seem to respond\n\t * with PATH_NOT_COVERED to requests that include the prefix.\n\t * Chase the referral if found, otherwise continue normally.\n\t */\n\tif (referral_walks_count == 0) {\n\t\tint refrc = expand_dfs_referral(xid, ses, volume_info, cifs_sb,\n\t\t\t\t\t\tfalse);\n\t\tif (!refrc) {\n\t\t\treferral_walks_count++;\n\t\t\tgoto try_mount_again;\n\t\t}\n\t}\n#endif\n\n\t/* check if a whole path is not remote */\n\tif (!rc && tcon) {\n\t\tif (!server->ops->is_path_accessible) {\n\t\t\trc = -ENOSYS;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\t/*\n\t\t * cifs_build_path_to_root works only when we have a valid tcon\n\t\t */\n\t\tfull_path = cifs_build_path_to_root(volume_info, cifs_sb, tcon);\n\t\tif (full_path == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\trc = server->ops->is_path_accessible(xid, tcon, cifs_sb,\n\t\t\t\t\t\t     full_path);\n\t\tif (rc != 0 && rc != -EREMOTE) {\n\t\t\tkfree(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\tkfree(full_path);\n\t}\n\n\t/* get referral if needed */\n\tif (rc == -EREMOTE) {\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (referral_walks_count > MAX_NESTED_LINKS) {\n\t\t\t/*\n\t\t\t * BB: when we implement proper loop detection,\n\t\t\t *     we will remove this check. But now we need it\n\t\t\t *     to prevent an indefinite loop if 'DFS tree' is\n\t\t\t *     misconfigured (i.e. has loops).\n\t\t\t */\n\t\t\trc = -ELOOP;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\n\t\trc = expand_dfs_referral(xid, ses, volume_info, cifs_sb, true);\n\n\t\tif (!rc) {\n\t\t\treferral_walks_count++;\n\t\t\tgoto try_mount_again;\n\t\t}\n\t\tgoto mount_fail_check;\n#else /* No DFS support, return error on mount */\n\t\trc = -EOPNOTSUPP;\n#endif\n\t}\n\n\tif (rc)\n\t\tgoto mount_fail_check;\n\n\t/* now, hang the tcon off of the superblock */\n\ttlink = kzalloc(sizeof *tlink, GFP_KERNEL);\n\tif (tlink == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mount_fail_check;\n\t}\n\n\ttlink->tl_uid = ses->linux_uid;\n\ttlink->tl_tcon = tcon;\n\ttlink->tl_time = jiffies;\n\tset_bit(TCON_LINK_MASTER, &tlink->tl_flags);\n\tset_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\n\tcifs_sb->master_tlink = tlink;\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n\nmount_fail_check:\n\t/* on error free sesinfo and tcon struct if needed */\n\tif (rc) {\n\t\t/* If find_unc succeeded then rc == 0 so we can not end */\n\t\t/* up accidentally freeing someone elses tcon struct */\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (ses)\n\t\t\tcifs_put_smb_ses(ses);\n\t\telse\n\t\t\tcifs_put_tcp_session(server);\n\t\tbdi_destroy(&cifs_sb->bdi);\n\t}\n\nout:\n\tfree_xid(xid);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_IDLE_EXPIRE\t(600 * HZ)"
          ],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_IDLE_EXPIRE\t(600 * HZ)\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_mount(struct cifs_sb_info *cifs_sb, struct smb_vol *volume_info)\n{\n\tint rc;\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tchar   *full_path;\n\tstruct tcon_link *tlink;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tint referral_walks_count = 0;\n#endif\n\n\trc = bdi_setup_and_register(&cifs_sb->bdi, \"cifs\");\n\tif (rc)\n\t\treturn rc;\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\ntry_mount_again:\n\t/* cleanup activities if we're chasing a referral */\n\tif (referral_walks_count) {\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (ses)\n\t\t\tcifs_put_smb_ses(ses);\n\n\t\tfree_xid(xid);\n\t}\n#endif\n\trc = 0;\n\ttcon = NULL;\n\tses = NULL;\n\tserver = NULL;\n\tfull_path = NULL;\n\ttlink = NULL;\n\n\txid = get_xid();\n\n\t/* get a reference to a tcp session */\n\tserver = cifs_get_tcp_session(volume_info);\n\tif (IS_ERR(server)) {\n\t\trc = PTR_ERR(server);\n\t\tbdi_destroy(&cifs_sb->bdi);\n\t\tgoto out;\n\t}\n\n\t/* get a reference to a SMB session */\n\tses = cifs_get_smb_ses(server, volume_info);\n\tif (IS_ERR(ses)) {\n\t\trc = PTR_ERR(ses);\n\t\tses = NULL;\n\t\tgoto mount_fail_check;\n\t}\n\n\t/* search for existing tcon to this server share */\n\ttcon = cifs_get_tcon(ses, volume_info);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto remote_path_check;\n\t}\n\n\t/* tell server which Unix caps we support */\n\tif (cap_unix(tcon->ses)) {\n\t\t/* reset of caps checks mount to see if unix extensions\n\t\t   disabled for just this mount */\n\t\treset_cifs_unix_caps(xid, tcon, cifs_sb, volume_info);\n\t\tif ((tcon->ses->server->tcpStatus == CifsNeedReconnect) &&\n\t\t    (le64_to_cpu(tcon->fsUnixInfo.Capability) &\n\t\t     CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)) {\n\t\t\trc = -EACCES;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t} else\n\t\ttcon->unix_ext = 0; /* server does not support them */\n\n\t/* do not care if a following call succeed - informational */\n\tif (!tcon->ipc && server->ops->qfs_tcon)\n\t\tserver->ops->qfs_tcon(xid, tcon);\n\n\tcifs_sb->wsize = server->ops->negotiate_wsize(tcon, volume_info);\n\tcifs_sb->rsize = server->ops->negotiate_rsize(tcon, volume_info);\n\n\t/* tune readahead according to rsize */\n\tcifs_sb->bdi.ra_pages = cifs_sb->rsize / PAGE_CACHE_SIZE;\n\nremote_path_check:\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t/*\n\t * Perform an unconditional check for whether there are DFS\n\t * referrals for this path without prefix, to provide support\n\t * for DFS referrals from w2k8 servers which don't seem to respond\n\t * with PATH_NOT_COVERED to requests that include the prefix.\n\t * Chase the referral if found, otherwise continue normally.\n\t */\n\tif (referral_walks_count == 0) {\n\t\tint refrc = expand_dfs_referral(xid, ses, volume_info, cifs_sb,\n\t\t\t\t\t\tfalse);\n\t\tif (!refrc) {\n\t\t\treferral_walks_count++;\n\t\t\tgoto try_mount_again;\n\t\t}\n\t}\n#endif\n\n\t/* check if a whole path is not remote */\n\tif (!rc && tcon) {\n\t\tif (!server->ops->is_path_accessible) {\n\t\t\trc = -ENOSYS;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\t/*\n\t\t * cifs_build_path_to_root works only when we have a valid tcon\n\t\t */\n\t\tfull_path = cifs_build_path_to_root(volume_info, cifs_sb, tcon);\n\t\tif (full_path == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\trc = server->ops->is_path_accessible(xid, tcon, cifs_sb,\n\t\t\t\t\t\t     full_path);\n\t\tif (rc != 0 && rc != -EREMOTE) {\n\t\t\tkfree(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\tkfree(full_path);\n\t}\n\n\t/* get referral if needed */\n\tif (rc == -EREMOTE) {\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (referral_walks_count > MAX_NESTED_LINKS) {\n\t\t\t/*\n\t\t\t * BB: when we implement proper loop detection,\n\t\t\t *     we will remove this check. But now we need it\n\t\t\t *     to prevent an indefinite loop if 'DFS tree' is\n\t\t\t *     misconfigured (i.e. has loops).\n\t\t\t */\n\t\t\trc = -ELOOP;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\n\t\trc = expand_dfs_referral(xid, ses, volume_info, cifs_sb, true);\n\n\t\tif (!rc) {\n\t\t\treferral_walks_count++;\n\t\t\tgoto try_mount_again;\n\t\t}\n\t\tgoto mount_fail_check;\n#else /* No DFS support, return error on mount */\n\t\trc = -EOPNOTSUPP;\n#endif\n\t}\n\n\tif (rc)\n\t\tgoto mount_fail_check;\n\n\t/* now, hang the tcon off of the superblock */\n\ttlink = kzalloc(sizeof *tlink, GFP_KERNEL);\n\tif (tlink == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mount_fail_check;\n\t}\n\n\ttlink->tl_uid = ses->linux_uid;\n\ttlink->tl_tcon = tcon;\n\ttlink->tl_time = jiffies;\n\tset_bit(TCON_LINK_MASTER, &tlink->tl_flags);\n\tset_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\n\tcifs_sb->master_tlink = tlink;\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n\nmount_fail_check:\n\t/* on error free sesinfo and tcon struct if needed */\n\tif (rc) {\n\t\t/* If find_unc succeeded then rc == 0 so we can not end */\n\t\t/* up accidentally freeing someone elses tcon struct */\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (ses)\n\t\t\tcifs_put_smb_ses(ses);\n\t\telse\n\t\t\tcifs_put_tcp_session(server);\n\t\tbdi_destroy(&cifs_sb->bdi);\n\t}\n\nout:\n\tfree_xid(xid);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_setup_cifs_sb",
          "args": [
            "volume_info",
            "cifs_sb"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_setup_cifs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3172-3266",
          "snippet": "void cifs_setup_cifs_sb(struct smb_vol *pvolume_info,\n\t\t\tstruct cifs_sb_info *cifs_sb)\n{\n\tINIT_DELAYED_WORK(&cifs_sb->prune_tlinks, cifs_prune_tlinks);\n\n\tspin_lock_init(&cifs_sb->tlink_tree_lock);\n\tcifs_sb->tlink_tree = RB_ROOT;\n\n\t/*\n\t * Temporarily set r/wsize for matching superblock. If we end up using\n\t * new sb then client will later negotiate it downward if needed.\n\t */\n\tcifs_sb->rsize = pvolume_info->rsize;\n\tcifs_sb->wsize = pvolume_info->wsize;\n\n\tcifs_sb->mnt_uid = pvolume_info->linux_uid;\n\tcifs_sb->mnt_gid = pvolume_info->linux_gid;\n\tcifs_sb->mnt_file_mode = pvolume_info->file_mode;\n\tcifs_sb->mnt_dir_mode = pvolume_info->dir_mode;\n\tcifs_dbg(FYI, \"file mode: 0x%hx  dir mode: 0x%hx\\n\",\n\t\t cifs_sb->mnt_file_mode, cifs_sb->mnt_dir_mode);\n\n\tcifs_sb->actimeo = pvolume_info->actimeo;\n\tcifs_sb->local_nls = pvolume_info->local_nls;\n\n\tif (pvolume_info->noperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_PERM;\n\tif (pvolume_info->setuids)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SET_UID;\n\tif (pvolume_info->server_ino)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SERVER_INUM;\n\tif (pvolume_info->remap)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SFM_CHR;\n\tif (pvolume_info->sfu_remap)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SPECIAL_CHR;\n\tif (pvolume_info->no_xattr)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_XATTR;\n\tif (pvolume_info->sfu_emul)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_UNX_EMUL;\n\tif (pvolume_info->nobrl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_BRL;\n\tif (pvolume_info->nostrictsync)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOSSYNC;\n\tif (pvolume_info->mand_lock)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOPOSIXBRL;\n\tif (pvolume_info->rwpidforward)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_RWPIDFORWARD;\n\tif (pvolume_info->cifs_acl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_ACL;\n\tif (pvolume_info->backupuid_specified) {\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_BACKUPUID;\n\t\tcifs_sb->mnt_backupuid = pvolume_info->backupuid;\n\t}\n\tif (pvolume_info->backupgid_specified) {\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_BACKUPGID;\n\t\tcifs_sb->mnt_backupgid = pvolume_info->backupgid;\n\t}\n\tif (pvolume_info->override_uid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_UID;\n\tif (pvolume_info->override_gid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_GID;\n\tif (pvolume_info->dynperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DYNPERM;\n\tif (pvolume_info->fsc)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_FSCACHE;\n\tif (pvolume_info->multiuser)\n\t\tcifs_sb->mnt_cifs_flags |= (CIFS_MOUNT_MULTIUSER |\n\t\t\t\t\t    CIFS_MOUNT_NO_PERM);\n\tif (pvolume_info->strict_io)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_STRICT_IO;\n\tif (pvolume_info->direct_io) {\n\t\tcifs_dbg(FYI, \"mounting share using direct i/o\\n\");\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DIRECT_IO;\n\t}\n\tif (pvolume_info->mfsymlinks) {\n\t\tif (pvolume_info->sfu_emul) {\n\t\t\t/*\n\t\t\t * Our SFU (\"Services for Unix\" emulation does not allow\n\t\t\t * creating symlinks but does allow reading existing SFU\n\t\t\t * symlinks (it does allow both creating and reading SFU\n\t\t\t * style mknod and FIFOs though). When \"mfsymlinks\" and\n\t\t\t * \"sfu\" are both enabled at the same time, it allows\n\t\t\t * reading both types of symlinks, but will only create\n\t\t\t * them with mfsymlinks format. This allows better\n\t\t\t * Apple compatibility (probably better for Samba too)\n\t\t\t * while still recognizing old Windows style symlinks.\n\t\t\t */\n\t\t\tcifs_dbg(VFS, \"mount options mfsymlinks and sfu both enabled\\n\");\n\t\t}\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MF_SYMLINKS;\n\t}\n\n\tif ((pvolume_info->cifs_acl) && (pvolume_info->dynperm))\n\t\tcifs_dbg(VFS, \"mount option dynperm ignored if cifsacl mount option supported\\n\");\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid cifs_setup_cifs_sb(struct smb_vol *pvolume_info,\n\t\t\tstruct cifs_sb_info *cifs_sb)\n{\n\tINIT_DELAYED_WORK(&cifs_sb->prune_tlinks, cifs_prune_tlinks);\n\n\tspin_lock_init(&cifs_sb->tlink_tree_lock);\n\tcifs_sb->tlink_tree = RB_ROOT;\n\n\t/*\n\t * Temporarily set r/wsize for matching superblock. If we end up using\n\t * new sb then client will later negotiate it downward if needed.\n\t */\n\tcifs_sb->rsize = pvolume_info->rsize;\n\tcifs_sb->wsize = pvolume_info->wsize;\n\n\tcifs_sb->mnt_uid = pvolume_info->linux_uid;\n\tcifs_sb->mnt_gid = pvolume_info->linux_gid;\n\tcifs_sb->mnt_file_mode = pvolume_info->file_mode;\n\tcifs_sb->mnt_dir_mode = pvolume_info->dir_mode;\n\tcifs_dbg(FYI, \"file mode: 0x%hx  dir mode: 0x%hx\\n\",\n\t\t cifs_sb->mnt_file_mode, cifs_sb->mnt_dir_mode);\n\n\tcifs_sb->actimeo = pvolume_info->actimeo;\n\tcifs_sb->local_nls = pvolume_info->local_nls;\n\n\tif (pvolume_info->noperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_PERM;\n\tif (pvolume_info->setuids)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SET_UID;\n\tif (pvolume_info->server_ino)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SERVER_INUM;\n\tif (pvolume_info->remap)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SFM_CHR;\n\tif (pvolume_info->sfu_remap)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SPECIAL_CHR;\n\tif (pvolume_info->no_xattr)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_XATTR;\n\tif (pvolume_info->sfu_emul)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_UNX_EMUL;\n\tif (pvolume_info->nobrl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_BRL;\n\tif (pvolume_info->nostrictsync)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOSSYNC;\n\tif (pvolume_info->mand_lock)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOPOSIXBRL;\n\tif (pvolume_info->rwpidforward)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_RWPIDFORWARD;\n\tif (pvolume_info->cifs_acl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_ACL;\n\tif (pvolume_info->backupuid_specified) {\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_BACKUPUID;\n\t\tcifs_sb->mnt_backupuid = pvolume_info->backupuid;\n\t}\n\tif (pvolume_info->backupgid_specified) {\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_BACKUPGID;\n\t\tcifs_sb->mnt_backupgid = pvolume_info->backupgid;\n\t}\n\tif (pvolume_info->override_uid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_UID;\n\tif (pvolume_info->override_gid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_GID;\n\tif (pvolume_info->dynperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DYNPERM;\n\tif (pvolume_info->fsc)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_FSCACHE;\n\tif (pvolume_info->multiuser)\n\t\tcifs_sb->mnt_cifs_flags |= (CIFS_MOUNT_MULTIUSER |\n\t\t\t\t\t    CIFS_MOUNT_NO_PERM);\n\tif (pvolume_info->strict_io)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_STRICT_IO;\n\tif (pvolume_info->direct_io) {\n\t\tcifs_dbg(FYI, \"mounting share using direct i/o\\n\");\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DIRECT_IO;\n\t}\n\tif (pvolume_info->mfsymlinks) {\n\t\tif (pvolume_info->sfu_emul) {\n\t\t\t/*\n\t\t\t * Our SFU (\"Services for Unix\" emulation does not allow\n\t\t\t * creating symlinks but does allow reading existing SFU\n\t\t\t * symlinks (it does allow both creating and reading SFU\n\t\t\t * style mknod and FIFOs though). When \"mfsymlinks\" and\n\t\t\t * \"sfu\" are both enabled at the same time, it allows\n\t\t\t * reading both types of symlinks, but will only create\n\t\t\t * them with mfsymlinks format. This allows better\n\t\t\t * Apple compatibility (probably better for Samba too)\n\t\t\t * while still recognizing old Windows style symlinks.\n\t\t\t */\n\t\t\tcifs_dbg(VFS, \"mount options mfsymlinks and sfu both enabled\\n\");\n\t\t}\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MF_SYMLINKS;\n\t}\n\n\tif ((pvolume_info->cifs_acl) && (pvolume_info->dynperm))\n\t\tcifs_dbg(VFS, \"mount option dynperm ignored if cifsacl mount option supported\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "data",
            "PAGE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct cifs_sb_info)",
            "GFP_KERNEL"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "volume_info"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "volume_info"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_volume_info",
          "args": [
            "(char *)data",
            "dev_name"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_volume_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3416-3433",
          "snippet": "struct smb_vol *\ncifs_get_volume_info(char *mount_data, const char *devname)\n{\n\tint rc;\n\tstruct smb_vol *volume_info;\n\n\tvolume_info = kmalloc(sizeof(struct smb_vol), GFP_KERNEL);\n\tif (!volume_info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc = cifs_setup_volume_info(volume_info, mount_data, devname);\n\tif (rc) {\n\t\tcifs_cleanup_volume_info(volume_info);\n\t\tvolume_info = ERR_PTR(rc);\n\t}\n\n\treturn volume_info;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);\n\nstruct smb_vol *\ncifs_get_volume_info(char *mount_data, const char *devname)\n{\n\tint rc;\n\tstruct smb_vol *volume_info;\n\n\tvolume_info = kmalloc(sizeof(struct smb_vol), GFP_KERNEL);\n\tif (!volume_info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc = cifs_setup_volume_info(volume_info, mount_data, devname);\n\tif (rc) {\n\t\tcifs_cleanup_volume_info(volume_info);\n\t\tvolume_info = ERR_PTR(rc);\n\t}\n\n\treturn volume_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Devname: %s flags: %d\\n\"",
            "dev_name",
            "flags"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct dentry *\ncifs_do_mount(struct file_system_type *fs_type,\n\t      int flags, const char *dev_name, void *data)\n{\n\tint rc;\n\tstruct super_block *sb;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct smb_vol *volume_info;\n\tstruct cifs_mnt_data mnt_data;\n\tstruct dentry *root;\n\n\tcifs_dbg(FYI, \"Devname: %s flags: %d\\n\", dev_name, flags);\n\n\tvolume_info = cifs_get_volume_info((char *)data, dev_name);\n\tif (IS_ERR(volume_info))\n\t\treturn ERR_CAST(volume_info);\n\n\tcifs_sb = kzalloc(sizeof(struct cifs_sb_info), GFP_KERNEL);\n\tif (cifs_sb == NULL) {\n\t\troot = ERR_PTR(-ENOMEM);\n\t\tgoto out_nls;\n\t}\n\n\tcifs_sb->mountdata = kstrndup(data, PAGE_SIZE, GFP_KERNEL);\n\tif (cifs_sb->mountdata == NULL) {\n\t\troot = ERR_PTR(-ENOMEM);\n\t\tgoto out_cifs_sb;\n\t}\n\n\tcifs_setup_cifs_sb(volume_info, cifs_sb);\n\n\trc = cifs_mount(cifs_sb, volume_info);\n\tif (rc) {\n\t\tif (!(flags & MS_SILENT))\n\t\t\tcifs_dbg(VFS, \"cifs_mount failed w/return code = %d\\n\",\n\t\t\t\t rc);\n\t\troot = ERR_PTR(rc);\n\t\tgoto out_mountdata;\n\t}\n\n\tmnt_data.vol = volume_info;\n\tmnt_data.cifs_sb = cifs_sb;\n\tmnt_data.flags = flags;\n\n\t/* BB should we make this contingent on mount parm? */\n\tflags |= MS_NODIRATIME | MS_NOATIME;\n\n\tsb = sget(fs_type, cifs_match_super, cifs_set_super, flags, &mnt_data);\n\tif (IS_ERR(sb)) {\n\t\troot = ERR_CAST(sb);\n\t\tcifs_umount(cifs_sb);\n\t\tgoto out;\n\t}\n\n\tif (sb->s_root) {\n\t\tcifs_dbg(FYI, \"Use existing superblock\\n\");\n\t\tcifs_umount(cifs_sb);\n\t} else {\n\t\trc = cifs_read_super(sb);\n\t\tif (rc) {\n\t\t\troot = ERR_PTR(rc);\n\t\t\tgoto out_super;\n\t\t}\n\n\t\tsb->s_flags |= MS_ACTIVE;\n\t}\n\n\troot = cifs_get_root(volume_info, sb);\n\tif (IS_ERR(root))\n\t\tgoto out_super;\n\n\tcifs_dbg(FYI, \"dentry root is: %p\\n\", root);\n\tgoto out;\n\nout_super:\n\tdeactivate_locked_super(sb);\nout:\n\tcifs_cleanup_volume_info(volume_info);\n\treturn root;\n\nout_mountdata:\n\tkfree(cifs_sb->mountdata);\nout_cifs_sb:\n\tkfree(cifs_sb);\nout_nls:\n\tunload_nls(volume_info->local_nls);\n\tgoto out;\n}"
  },
  {
    "function_name": "cifs_set_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "644-649",
    "snippet": "static int cifs_set_super(struct super_block *sb, void *data)\n{\n\tstruct cifs_mnt_data *mnt_data = data;\n\tsb->s_fs_info = mnt_data->cifs_sb;\n\treturn set_anon_super(sb, NULL);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_anon_super",
          "args": [
            "sb",
            "NULL"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int cifs_set_super(struct super_block *sb, void *data)\n{\n\tstruct cifs_mnt_data *mnt_data = data;\n\tsb->s_fs_info = mnt_data->cifs_sb;\n\treturn set_anon_super(sb, NULL);\n}"
  },
  {
    "function_name": "cifs_get_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "589-642",
    "snippet": "static struct dentry *\ncifs_get_root(struct smb_vol *vol, struct super_block *sb)\n{\n\tstruct dentry *dentry;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tchar *full_path = NULL;\n\tchar *s, *p;\n\tchar sep;\n\n\tfull_path = cifs_build_path_to_root(vol, cifs_sb,\n\t\t\t\t\t    cifs_sb_master_tcon(cifs_sb));\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcifs_dbg(FYI, \"Get root dentry for %s\\n\", full_path);\n\n\tsep = CIFS_DIR_SEP(cifs_sb);\n\tdentry = dget(sb->s_root);\n\tp = s = full_path;\n\n\tdo {\n\t\tstruct inode *dir = dentry->d_inode;\n\t\tstruct dentry *child;\n\n\t\tif (!dir) {\n\t\t\tdput(dentry);\n\t\t\tdentry = ERR_PTR(-ENOENT);\n\t\t\tbreak;\n\t\t}\n\t\tif (!S_ISDIR(dir->i_mode)) {\n\t\t\tdput(dentry);\n\t\t\tdentry = ERR_PTR(-ENOTDIR);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* skip separators */\n\t\twhile (*s == sep)\n\t\t\ts++;\n\t\tif (!*s)\n\t\t\tbreak;\n\t\tp = s++;\n\t\t/* next separator */\n\t\twhile (*s && *s != sep)\n\t\t\ts++;\n\n\t\tmutex_lock(&dir->i_mutex);\n\t\tchild = lookup_one_len(p, dentry, s - p);\n\t\tmutex_unlock(&dir->i_mutex);\n\t\tdput(dentry);\n\t\tdentry = child;\n\t} while (!IS_ERR(dentry));\n\tkfree(full_path);\n\treturn dentry;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->i_mutex"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "p",
            "dentry",
            "s - p"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dir->i_mutex"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOTDIR"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "dir->i_mode"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "sb->s_root"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_DIR_SEP",
          "args": [
            "cifs_sb"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_DIR_SEP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1177-1183",
          "snippet": "static inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)\n\t\treturn '/';\n\telse\n\t\treturn '\\\\';\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)\n\t\treturn '/';\n\telse\n\t\treturn '\\\\';\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Get root dentry for %s\\n\"",
            "full_path"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_build_path_to_root",
          "args": [
            "vol",
            "cifs_sb",
            "cifs_sb_master_tcon(cifs_sb)"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_build_path_to_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
          "lines": "48-78",
          "snippet": "char *\ncifs_build_path_to_root(struct smb_vol *vol, struct cifs_sb_info *cifs_sb,\n\t\t\tstruct cifs_tcon *tcon)\n{\n\tint pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tint dfsplen;\n\tchar *full_path = NULL;\n\n\t/* if no prefix path, simply set path to the root of share to \"\" */\n\tif (pplen == 0) {\n\t\tfull_path = kzalloc(1, GFP_KERNEL);\n\t\treturn full_path;\n\t}\n\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\n\n\tfull_path = kmalloc(dfsplen + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\n\tif (dfsplen)\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\tfull_path[dfsplen] = CIFS_DIR_SEP(cifs_sb);\n\tstrncpy(full_path + dfsplen + 1, vol->prepath, pplen);\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tfull_path[dfsplen + pplen] = 0; /* add trailing null */\n\treturn full_path;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nchar *\ncifs_build_path_to_root(struct smb_vol *vol, struct cifs_sb_info *cifs_sb,\n\t\t\tstruct cifs_tcon *tcon)\n{\n\tint pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tint dfsplen;\n\tchar *full_path = NULL;\n\n\t/* if no prefix path, simply set path to the root of share to \"\" */\n\tif (pplen == 0) {\n\t\tfull_path = kzalloc(1, GFP_KERNEL);\n\t\treturn full_path;\n\t}\n\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\n\n\tfull_path = kmalloc(dfsplen + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\n\tif (dfsplen)\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\tfull_path[dfsplen] = CIFS_DIR_SEP(cifs_sb);\n\tstrncpy(full_path + dfsplen + 1, vol->prepath, pplen);\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tfull_path[dfsplen + pplen] = 0; /* add trailing null */\n\treturn full_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_sb_master_tcon",
          "args": [
            "cifs_sb"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_master_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3948-3952",
          "snippet": "struct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "sb"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct dentry *\ncifs_get_root(struct smb_vol *vol, struct super_block *sb)\n{\n\tstruct dentry *dentry;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tchar *full_path = NULL;\n\tchar *s, *p;\n\tchar sep;\n\n\tfull_path = cifs_build_path_to_root(vol, cifs_sb,\n\t\t\t\t\t    cifs_sb_master_tcon(cifs_sb));\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcifs_dbg(FYI, \"Get root dentry for %s\\n\", full_path);\n\n\tsep = CIFS_DIR_SEP(cifs_sb);\n\tdentry = dget(sb->s_root);\n\tp = s = full_path;\n\n\tdo {\n\t\tstruct inode *dir = dentry->d_inode;\n\t\tstruct dentry *child;\n\n\t\tif (!dir) {\n\t\t\tdput(dentry);\n\t\t\tdentry = ERR_PTR(-ENOENT);\n\t\t\tbreak;\n\t\t}\n\t\tif (!S_ISDIR(dir->i_mode)) {\n\t\t\tdput(dentry);\n\t\t\tdentry = ERR_PTR(-ENOTDIR);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* skip separators */\n\t\twhile (*s == sep)\n\t\t\ts++;\n\t\tif (!*s)\n\t\t\tbreak;\n\t\tp = s++;\n\t\t/* next separator */\n\t\twhile (*s && *s != sep)\n\t\t\ts++;\n\n\t\tmutex_lock(&dir->i_mutex);\n\t\tchild = lookup_one_len(p, dentry, s - p);\n\t\tmutex_unlock(&dir->i_mutex);\n\t\tdput(dentry);\n\t\tdentry = child;\n\t} while (!IS_ERR(dentry));\n\tkfree(full_path);\n\treturn dentry;\n}"
  },
  {
    "function_name": "cifs_drop_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "558-565",
    "snippet": "static int cifs_drop_inode(struct inode *inode)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\n\t/* no serverino => unconditional eviction */\n\treturn !(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) ||\n\t\tgeneric_drop_inode(inode);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_drop_inode",
          "args": [
            "inode"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int cifs_drop_inode(struct inode *inode)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\n\t/* no serverino => unconditional eviction */\n\treturn !(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) ||\n\t\tgeneric_drop_inode(inode);\n}"
  },
  {
    "function_name": "cifs_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "551-556",
    "snippet": "static int cifs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= MS_NODIRATIME;\n\treturn 0;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int cifs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= MS_NODIRATIME;\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_show_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "544-548",
    "snippet": "static int cifs_show_stats(struct seq_file *s, struct dentry *root)\n{\n\t/* BB FIXME */\n\treturn 0;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int cifs_show_stats(struct seq_file *s, struct dentry *root)\n{\n\t/* BB FIXME */\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_umount_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "507-541",
    "snippet": "static void cifs_umount_begin(struct super_block *sb)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_tcon *tcon;\n\n\tif (cifs_sb == NULL)\n\t\treturn;\n\n\ttcon = cifs_sb_master_tcon(cifs_sb);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif ((tcon->tc_count > 1) || (tcon->tidStatus == CifsExiting)) {\n\t\t/* we have other mounts to same share or we have\n\t\t   already tried to force umount this and woken up\n\t\t   all waiting network requests, nothing to do */\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t} else if (tcon->tc_count == 1)\n\t\ttcon->tidStatus = CifsExiting;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* cancel_brl_requests(tcon); */ /* BB mark all brl mids as exiting */\n\t/* cancel_notify_requests(tcon); */\n\tif (tcon->ses && tcon->ses->server) {\n\t\tcifs_dbg(FYI, \"wake up tasks now - umount begin not complete\\n\");\n\t\twake_up_all(&tcon->ses->server->request_q);\n\t\twake_up_all(&tcon->ses->server->response_q);\n\t\tmsleep(1); /* yield */\n\t\t/* we have to kick the requests once more */\n\t\twake_up_all(&tcon->ses->server->response_q);\n\t\tmsleep(1);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "1"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&tcon->ses->server->response_q"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "1"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&tcon->ses->server->response_q"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&tcon->ses->server->request_q"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"wake up tasks now - umount begin not complete\\n\""
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_sb_master_tcon",
          "args": [
            "cifs_sb"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_master_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3948-3952",
          "snippet": "struct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "sb"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void cifs_umount_begin(struct super_block *sb)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_tcon *tcon;\n\n\tif (cifs_sb == NULL)\n\t\treturn;\n\n\ttcon = cifs_sb_master_tcon(cifs_sb);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif ((tcon->tc_count > 1) || (tcon->tidStatus == CifsExiting)) {\n\t\t/* we have other mounts to same share or we have\n\t\t   already tried to force umount this and woken up\n\t\t   all waiting network requests, nothing to do */\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t} else if (tcon->tc_count == 1)\n\t\ttcon->tidStatus = CifsExiting;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* cancel_brl_requests(tcon); */ /* BB mark all brl mids as exiting */\n\t/* cancel_notify_requests(tcon); */\n\tif (tcon->ses && tcon->ses->server) {\n\t\tcifs_dbg(FYI, \"wake up tasks now - umount begin not complete\\n\");\n\t\twake_up_all(&tcon->ses->server->request_q);\n\t\twake_up_all(&tcon->ses->server->response_q);\n\t\tmsleep(1); /* yield */\n\t\t/* we have to kick the requests once more */\n\t\twake_up_all(&tcon->ses->server->response_q);\n\t\tmsleep(1);\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "cifs_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "389-505",
    "snippet": "static int\ncifs_show_options(struct seq_file *s, struct dentry *root)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(root->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct sockaddr *srcaddr;\n\tsrcaddr = (struct sockaddr *)&tcon->ses->server->srcaddr;\n\n\tseq_printf(s, \",vers=%s\", tcon->ses->server->vals->version_string);\n\tcifs_show_security(s, tcon->ses);\n\tcifs_show_cache_flavor(s, cifs_sb);\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER)\n\t\tseq_puts(s, \",multiuser\");\n\telse if (tcon->ses->user_name)\n\t\tseq_printf(s, \",username=%s\", tcon->ses->user_name);\n\n\tif (tcon->ses->domainName)\n\t\tseq_printf(s, \",domain=%s\", tcon->ses->domainName);\n\n\tif (srcaddr->sa_family != AF_UNSPEC) {\n\t\tstruct sockaddr_in *saddr4;\n\t\tstruct sockaddr_in6 *saddr6;\n\t\tsaddr4 = (struct sockaddr_in *)srcaddr;\n\t\tsaddr6 = (struct sockaddr_in6 *)srcaddr;\n\t\tif (srcaddr->sa_family == AF_INET6)\n\t\t\tseq_printf(s, \",srcaddr=%pI6c\",\n\t\t\t\t   &saddr6->sin6_addr);\n\t\telse if (srcaddr->sa_family == AF_INET)\n\t\t\tseq_printf(s, \",srcaddr=%pI4\",\n\t\t\t\t   &saddr4->sin_addr.s_addr);\n\t\telse\n\t\t\tseq_printf(s, \",srcaddr=BAD-AF:%i\",\n\t\t\t\t   (int)(srcaddr->sa_family));\n\t}\n\n\tseq_printf(s, \",uid=%u\",\n\t\t   from_kuid_munged(&init_user_ns, cifs_sb->mnt_uid));\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID)\n\t\tseq_puts(s, \",forceuid\");\n\telse\n\t\tseq_puts(s, \",noforceuid\");\n\n\tseq_printf(s, \",gid=%u\",\n\t\t   from_kgid_munged(&init_user_ns, cifs_sb->mnt_gid));\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID)\n\t\tseq_puts(s, \",forcegid\");\n\telse\n\t\tseq_puts(s, \",noforcegid\");\n\n\tcifs_show_address(s, tcon->ses->server);\n\n\tif (!tcon->unix_ext)\n\t\tseq_printf(s, \",file_mode=0%ho,dir_mode=0%ho\",\n\t\t\t\t\t   cifs_sb->mnt_file_mode,\n\t\t\t\t\t   cifs_sb->mnt_dir_mode);\n\n\tcifs_show_nls(s, cifs_sb->local_nls);\n\n\tif (tcon->seal)\n\t\tseq_puts(s, \",seal\");\n\tif (tcon->nocase)\n\t\tseq_puts(s, \",nocase\");\n\tif (tcon->retry)\n\t\tseq_puts(s, \",hard\");\n\tif (tcon->unix_ext)\n\t\tseq_puts(s, \",unix\");\n\telse\n\t\tseq_puts(s, \",nounix\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)\n\t\tseq_puts(s, \",posixpaths\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)\n\t\tseq_puts(s, \",setuids\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)\n\t\tseq_puts(s, \",serverino\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tseq_puts(s, \",rwpidforward\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL)\n\t\tseq_puts(s, \",forcemand\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_XATTR)\n\t\tseq_puts(s, \",nouser_xattr\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tseq_puts(s, \",mapchars\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL)\n\t\tseq_puts(s, \",sfu\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\tseq_puts(s, \",nobrl\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL)\n\t\tseq_puts(s, \",cifsacl\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)\n\t\tseq_puts(s, \",dynperm\");\n\tif (root->d_sb->s_flags & MS_POSIXACL)\n\t\tseq_puts(s, \",acl\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS)\n\t\tseq_puts(s, \",mfsymlinks\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_FSCACHE)\n\t\tseq_puts(s, \",fsc\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOSSYNC)\n\t\tseq_puts(s, \",nostrictsync\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM)\n\t\tseq_puts(s, \",noperm\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID)\n\t\tseq_printf(s, \",backupuid=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns,\n\t\t\t\t\t    cifs_sb->mnt_backupuid));\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID)\n\t\tseq_printf(s, \",backupgid=%u\",\n\t\t\t   from_kgid_munged(&init_user_ns,\n\t\t\t\t\t    cifs_sb->mnt_backupgid));\n\n\tseq_printf(s, \",rsize=%u\", cifs_sb->rsize);\n\tseq_printf(s, \",wsize=%u\", cifs_sb->wsize);\n\t/* convert actimeo and display it in seconds */\n\tseq_printf(s, \",actimeo=%lu\", cifs_sb->actimeo / HZ);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\",actimeo=%lu\"",
            "cifs_sb->actimeo / HZ"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "&init_user_ns",
            "cifs_sb->mnt_backupgid"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "cifs_sb->mnt_backupuid"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\",noperm\""
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_show_nls",
          "args": [
            "s",
            "cifs_sb->local_nls"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_show_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
          "lines": "372-382",
          "snippet": "static void\ncifs_show_nls(struct seq_file *s, struct nls_table *cur)\n{\n\tstruct nls_table *def;\n\n\t/* Display iocharset= option if it's not default charset */\n\tdef = load_nls_default();\n\tif (def != cur)\n\t\tseq_printf(s, \",iocharset=%s\", cur->charset);\n\tunload_nls(def);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_spnego.h\"",
            "#include <linux/key-type.h>",
            "#include <linux/mm.h>",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/vfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void\ncifs_show_nls(struct seq_file *s, struct nls_table *cur)\n{\n\tstruct nls_table *def;\n\n\t/* Display iocharset= option if it's not default charset */\n\tdef = load_nls_default();\n\tif (def != cur)\n\t\tseq_printf(s, \",iocharset=%s\", cur->charset);\n\tunload_nls(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_show_address",
          "args": [
            "s",
            "tcon->ses->server"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_show_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
          "lines": "303-323",
          "snippet": "static void\ncifs_show_address(struct seq_file *s, struct TCP_Server_Info *server)\n{\n\tstruct sockaddr_in *sa = (struct sockaddr_in *) &server->dstaddr;\n\tstruct sockaddr_in6 *sa6 = (struct sockaddr_in6 *) &server->dstaddr;\n\n\tseq_puts(s, \",addr=\");\n\n\tswitch (server->dstaddr.ss_family) {\n\tcase AF_INET:\n\t\tseq_printf(s, \"%pI4\", &sa->sin_addr.s_addr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tseq_printf(s, \"%pI6\", &sa6->sin6_addr.s6_addr);\n\t\tif (sa6->sin6_scope_id)\n\t\t\tseq_printf(s, \"%%%u\", sa6->sin6_scope_id);\n\t\tbreak;\n\tdefault:\n\t\tseq_puts(s, \"(unknown)\");\n\t}\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_spnego.h\"",
            "#include <linux/key-type.h>",
            "#include <linux/mm.h>",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/vfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void\ncifs_show_address(struct seq_file *s, struct TCP_Server_Info *server)\n{\n\tstruct sockaddr_in *sa = (struct sockaddr_in *) &server->dstaddr;\n\tstruct sockaddr_in6 *sa6 = (struct sockaddr_in6 *) &server->dstaddr;\n\n\tseq_puts(s, \",addr=\");\n\n\tswitch (server->dstaddr.ss_family) {\n\tcase AF_INET:\n\t\tseq_printf(s, \"%pI4\", &sa->sin_addr.s_addr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tseq_printf(s, \"%pI6\", &sa6->sin6_addr.s6_addr);\n\t\tif (sa6->sin6_scope_id)\n\t\t\tseq_printf(s, \"%%%u\", sa6->sin6_scope_id);\n\t\tbreak;\n\tdefault:\n\t\tseq_puts(s, \"(unknown)\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "&init_user_ns",
            "cifs_sb->mnt_gid"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "cifs_sb->mnt_uid"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_show_cache_flavor",
          "args": [
            "s",
            "cifs_sb"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_show_cache_flavor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
          "lines": "359-370",
          "snippet": "static void\ncifs_show_cache_flavor(struct seq_file *s, struct cifs_sb_info *cifs_sb)\n{\n\tseq_puts(s, \",cache=\");\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\tseq_puts(s, \"strict\");\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO)\n\t\tseq_puts(s, \"none\");\n\telse\n\t\tseq_puts(s, \"loose\");\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_spnego.h\"",
            "#include <linux/key-type.h>",
            "#include <linux/mm.h>",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/vfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void\ncifs_show_cache_flavor(struct seq_file *s, struct cifs_sb_info *cifs_sb)\n{\n\tseq_puts(s, \",cache=\");\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\tseq_puts(s, \"strict\");\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO)\n\t\tseq_puts(s, \"none\");\n\telse\n\t\tseq_puts(s, \"loose\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_show_security",
          "args": [
            "s",
            "tcon->ses"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_show_security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
          "lines": "325-357",
          "snippet": "static void\ncifs_show_security(struct seq_file *s, struct cifs_ses *ses)\n{\n\tif (ses->sectype == Unspecified)\n\t\treturn;\n\n\tseq_puts(s, \",sec=\");\n\n\tswitch (ses->sectype) {\n\tcase LANMAN:\n\t\tseq_puts(s, \"lanman\");\n\t\tbreak;\n\tcase NTLMv2:\n\t\tseq_puts(s, \"ntlmv2\");\n\t\tbreak;\n\tcase NTLM:\n\t\tseq_puts(s, \"ntlm\");\n\t\tbreak;\n\tcase Kerberos:\n\t\tseq_puts(s, \"krb5\");\n\t\tbreak;\n\tcase RawNTLMSSP:\n\t\tseq_puts(s, \"ntlmssp\");\n\t\tbreak;\n\tdefault:\n\t\t/* shouldn't ever happen */\n\t\tseq_puts(s, \"unknown\");\n\t\tbreak;\n\t}\n\n\tif (ses->sign)\n\t\tseq_puts(s, \"i\");\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_spnego.h\"",
            "#include <linux/key-type.h>",
            "#include <linux/mm.h>",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/vfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void\ncifs_show_security(struct seq_file *s, struct cifs_ses *ses)\n{\n\tif (ses->sectype == Unspecified)\n\t\treturn;\n\n\tseq_puts(s, \",sec=\");\n\n\tswitch (ses->sectype) {\n\tcase LANMAN:\n\t\tseq_puts(s, \"lanman\");\n\t\tbreak;\n\tcase NTLMv2:\n\t\tseq_puts(s, \"ntlmv2\");\n\t\tbreak;\n\tcase NTLM:\n\t\tseq_puts(s, \"ntlm\");\n\t\tbreak;\n\tcase Kerberos:\n\t\tseq_puts(s, \"krb5\");\n\t\tbreak;\n\tcase RawNTLMSSP:\n\t\tseq_puts(s, \"ntlmssp\");\n\t\tbreak;\n\tdefault:\n\t\t/* shouldn't ever happen */\n\t\tseq_puts(s, \"unknown\");\n\t\tbreak;\n\t}\n\n\tif (ses->sign)\n\t\tseq_puts(s, \"i\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_sb_master_tcon",
          "args": [
            "cifs_sb"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_master_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3948-3952",
          "snippet": "struct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "root->d_sb"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int\ncifs_show_options(struct seq_file *s, struct dentry *root)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(root->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct sockaddr *srcaddr;\n\tsrcaddr = (struct sockaddr *)&tcon->ses->server->srcaddr;\n\n\tseq_printf(s, \",vers=%s\", tcon->ses->server->vals->version_string);\n\tcifs_show_security(s, tcon->ses);\n\tcifs_show_cache_flavor(s, cifs_sb);\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER)\n\t\tseq_puts(s, \",multiuser\");\n\telse if (tcon->ses->user_name)\n\t\tseq_printf(s, \",username=%s\", tcon->ses->user_name);\n\n\tif (tcon->ses->domainName)\n\t\tseq_printf(s, \",domain=%s\", tcon->ses->domainName);\n\n\tif (srcaddr->sa_family != AF_UNSPEC) {\n\t\tstruct sockaddr_in *saddr4;\n\t\tstruct sockaddr_in6 *saddr6;\n\t\tsaddr4 = (struct sockaddr_in *)srcaddr;\n\t\tsaddr6 = (struct sockaddr_in6 *)srcaddr;\n\t\tif (srcaddr->sa_family == AF_INET6)\n\t\t\tseq_printf(s, \",srcaddr=%pI6c\",\n\t\t\t\t   &saddr6->sin6_addr);\n\t\telse if (srcaddr->sa_family == AF_INET)\n\t\t\tseq_printf(s, \",srcaddr=%pI4\",\n\t\t\t\t   &saddr4->sin_addr.s_addr);\n\t\telse\n\t\t\tseq_printf(s, \",srcaddr=BAD-AF:%i\",\n\t\t\t\t   (int)(srcaddr->sa_family));\n\t}\n\n\tseq_printf(s, \",uid=%u\",\n\t\t   from_kuid_munged(&init_user_ns, cifs_sb->mnt_uid));\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID)\n\t\tseq_puts(s, \",forceuid\");\n\telse\n\t\tseq_puts(s, \",noforceuid\");\n\n\tseq_printf(s, \",gid=%u\",\n\t\t   from_kgid_munged(&init_user_ns, cifs_sb->mnt_gid));\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID)\n\t\tseq_puts(s, \",forcegid\");\n\telse\n\t\tseq_puts(s, \",noforcegid\");\n\n\tcifs_show_address(s, tcon->ses->server);\n\n\tif (!tcon->unix_ext)\n\t\tseq_printf(s, \",file_mode=0%ho,dir_mode=0%ho\",\n\t\t\t\t\t   cifs_sb->mnt_file_mode,\n\t\t\t\t\t   cifs_sb->mnt_dir_mode);\n\n\tcifs_show_nls(s, cifs_sb->local_nls);\n\n\tif (tcon->seal)\n\t\tseq_puts(s, \",seal\");\n\tif (tcon->nocase)\n\t\tseq_puts(s, \",nocase\");\n\tif (tcon->retry)\n\t\tseq_puts(s, \",hard\");\n\tif (tcon->unix_ext)\n\t\tseq_puts(s, \",unix\");\n\telse\n\t\tseq_puts(s, \",nounix\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)\n\t\tseq_puts(s, \",posixpaths\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)\n\t\tseq_puts(s, \",setuids\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)\n\t\tseq_puts(s, \",serverino\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tseq_puts(s, \",rwpidforward\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL)\n\t\tseq_puts(s, \",forcemand\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_XATTR)\n\t\tseq_puts(s, \",nouser_xattr\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tseq_puts(s, \",mapchars\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL)\n\t\tseq_puts(s, \",sfu\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\tseq_puts(s, \",nobrl\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL)\n\t\tseq_puts(s, \",cifsacl\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)\n\t\tseq_puts(s, \",dynperm\");\n\tif (root->d_sb->s_flags & MS_POSIXACL)\n\t\tseq_puts(s, \",acl\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS)\n\t\tseq_puts(s, \",mfsymlinks\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_FSCACHE)\n\t\tseq_puts(s, \",fsc\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOSSYNC)\n\t\tseq_puts(s, \",nostrictsync\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM)\n\t\tseq_puts(s, \",noperm\");\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID)\n\t\tseq_printf(s, \",backupuid=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns,\n\t\t\t\t\t    cifs_sb->mnt_backupuid));\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID)\n\t\tseq_printf(s, \",backupgid=%u\",\n\t\t\t   from_kgid_munged(&init_user_ns,\n\t\t\t\t\t    cifs_sb->mnt_backupgid));\n\n\tseq_printf(s, \",rsize=%u\", cifs_sb->rsize);\n\tseq_printf(s, \",wsize=%u\", cifs_sb->wsize);\n\t/* convert actimeo and display it in seconds */\n\tseq_printf(s, \",actimeo=%lu\", cifs_sb->actimeo / HZ);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_show_nls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "372-382",
    "snippet": "static void\ncifs_show_nls(struct seq_file *s, struct nls_table *cur)\n{\n\tstruct nls_table *def;\n\n\t/* Display iocharset= option if it's not default charset */\n\tdef = load_nls_default();\n\tif (def != cur)\n\t\tseq_printf(s, \",iocharset=%s\", cur->charset);\n\tunload_nls(def);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "def"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\",iocharset=%s\"",
            "cur->charset"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_nls_default",
          "args": [],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "load_nls_default",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "532-541",
          "snippet": "struct nls_table *load_nls_default(void)\n{\n\tstruct nls_table *default_nls;\n\t\n\tdefault_nls = load_nls(CONFIG_NLS_DEFAULT);\n\tif (default_nls != NULL)\n\t\treturn default_nls;\n\telse\n\t\treturn &default_table;\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nls_table default_table;",
            "static struct nls_table default_table = {\n\t.charset\t= \"default\",\n\t.uni2char\t= uni2char,\n\t.char2uni\t= char2uni,\n\t.charset2lower\t= charset2lower,\n\t.charset2upper\t= charset2upper,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct nls_table default_table;\nstatic struct nls_table default_table = {\n\t.charset\t= \"default\",\n\t.uni2char\t= uni2char,\n\t.char2uni\t= char2uni,\n\t.charset2lower\t= charset2lower,\n\t.charset2upper\t= charset2upper,\n};\n\nstruct nls_table *load_nls_default(void)\n{\n\tstruct nls_table *default_nls;\n\t\n\tdefault_nls = load_nls(CONFIG_NLS_DEFAULT);\n\tif (default_nls != NULL)\n\t\treturn default_nls;\n\telse\n\t\treturn &default_table;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void\ncifs_show_nls(struct seq_file *s, struct nls_table *cur)\n{\n\tstruct nls_table *def;\n\n\t/* Display iocharset= option if it's not default charset */\n\tdef = load_nls_default();\n\tif (def != cur)\n\t\tseq_printf(s, \",iocharset=%s\", cur->charset);\n\tunload_nls(def);\n}"
  },
  {
    "function_name": "cifs_show_cache_flavor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "359-370",
    "snippet": "static void\ncifs_show_cache_flavor(struct seq_file *s, struct cifs_sb_info *cifs_sb)\n{\n\tseq_puts(s, \",cache=\");\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\tseq_puts(s, \"strict\");\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO)\n\t\tseq_puts(s, \"none\");\n\telse\n\t\tseq_puts(s, \"loose\");\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\"loose\""
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void\ncifs_show_cache_flavor(struct seq_file *s, struct cifs_sb_info *cifs_sb)\n{\n\tseq_puts(s, \",cache=\");\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\tseq_puts(s, \"strict\");\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO)\n\t\tseq_puts(s, \"none\");\n\telse\n\t\tseq_puts(s, \"loose\");\n}"
  },
  {
    "function_name": "cifs_show_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "325-357",
    "snippet": "static void\ncifs_show_security(struct seq_file *s, struct cifs_ses *ses)\n{\n\tif (ses->sectype == Unspecified)\n\t\treturn;\n\n\tseq_puts(s, \",sec=\");\n\n\tswitch (ses->sectype) {\n\tcase LANMAN:\n\t\tseq_puts(s, \"lanman\");\n\t\tbreak;\n\tcase NTLMv2:\n\t\tseq_puts(s, \"ntlmv2\");\n\t\tbreak;\n\tcase NTLM:\n\t\tseq_puts(s, \"ntlm\");\n\t\tbreak;\n\tcase Kerberos:\n\t\tseq_puts(s, \"krb5\");\n\t\tbreak;\n\tcase RawNTLMSSP:\n\t\tseq_puts(s, \"ntlmssp\");\n\t\tbreak;\n\tdefault:\n\t\t/* shouldn't ever happen */\n\t\tseq_puts(s, \"unknown\");\n\t\tbreak;\n\t}\n\n\tif (ses->sign)\n\t\tseq_puts(s, \"i\");\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\"i\""
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void\ncifs_show_security(struct seq_file *s, struct cifs_ses *ses)\n{\n\tif (ses->sectype == Unspecified)\n\t\treturn;\n\n\tseq_puts(s, \",sec=\");\n\n\tswitch (ses->sectype) {\n\tcase LANMAN:\n\t\tseq_puts(s, \"lanman\");\n\t\tbreak;\n\tcase NTLMv2:\n\t\tseq_puts(s, \"ntlmv2\");\n\t\tbreak;\n\tcase NTLM:\n\t\tseq_puts(s, \"ntlm\");\n\t\tbreak;\n\tcase Kerberos:\n\t\tseq_puts(s, \"krb5\");\n\t\tbreak;\n\tcase RawNTLMSSP:\n\t\tseq_puts(s, \"ntlmssp\");\n\t\tbreak;\n\tdefault:\n\t\t/* shouldn't ever happen */\n\t\tseq_puts(s, \"unknown\");\n\t\tbreak;\n\t}\n\n\tif (ses->sign)\n\t\tseq_puts(s, \"i\");\n}"
  },
  {
    "function_name": "cifs_show_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "303-323",
    "snippet": "static void\ncifs_show_address(struct seq_file *s, struct TCP_Server_Info *server)\n{\n\tstruct sockaddr_in *sa = (struct sockaddr_in *) &server->dstaddr;\n\tstruct sockaddr_in6 *sa6 = (struct sockaddr_in6 *) &server->dstaddr;\n\n\tseq_puts(s, \",addr=\");\n\n\tswitch (server->dstaddr.ss_family) {\n\tcase AF_INET:\n\t\tseq_printf(s, \"%pI4\", &sa->sin_addr.s_addr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tseq_printf(s, \"%pI6\", &sa6->sin6_addr.s6_addr);\n\t\tif (sa6->sin6_scope_id)\n\t\t\tseq_printf(s, \"%%%u\", sa6->sin6_scope_id);\n\t\tbreak;\n\tdefault:\n\t\tseq_puts(s, \"(unknown)\");\n\t}\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\"(unknown)\""
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"%%%u\"",
            "sa6->sin6_scope_id"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void\ncifs_show_address(struct seq_file *s, struct TCP_Server_Info *server)\n{\n\tstruct sockaddr_in *sa = (struct sockaddr_in *) &server->dstaddr;\n\tstruct sockaddr_in6 *sa6 = (struct sockaddr_in6 *) &server->dstaddr;\n\n\tseq_puts(s, \",addr=\");\n\n\tswitch (server->dstaddr.ss_family) {\n\tcase AF_INET:\n\t\tseq_printf(s, \"%pI4\", &sa->sin_addr.s_addr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tseq_printf(s, \"%pI6\", &sa6->sin6_addr.s6_addr);\n\t\tif (sa6->sin6_scope_id)\n\t\t\tseq_printf(s, \"%%%u\", sa6->sin6_scope_id);\n\t\tbreak;\n\tdefault:\n\t\tseq_puts(s, \"(unknown)\");\n\t}\n}"
  },
  {
    "function_name": "cifs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "295-301",
    "snippet": "static void\ncifs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tcifs_fscache_release_inode_cookie(inode);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_fscache_release_inode_cookie",
          "args": [
            "inode"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fscache_release_inode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
          "lines": "78-87",
          "snippet": "void cifs_fscache_release_inode_cookie(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\n\tif (cifsi->fscache) {\n\t\tcifs_dbg(FYI, \"%s: (0x%p)\\n\", __func__, cifsi->fscache);\n\t\tfscache_relinquish_cookie(cifsi->fscache, 0);\n\t\tcifsi->fscache = NULL;\n\t}\n}",
          "includes": [
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid cifs_fscache_release_inode_cookie(struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\n\tif (cifsi->fscache) {\n\t\tcifs_dbg(FYI, \"%s: (0x%p)\\n\", __func__, cifsi->fscache);\n\t\tfscache_relinquish_cookie(cifsi->fscache, 0);\n\t\tcifsi->fscache = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void\ncifs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tcifs_fscache_release_inode_cookie(inode);\n}"
  },
  {
    "function_name": "cifs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "289-293",
    "snippet": "static void\ncifs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, cifs_i_callback);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "cifs_i_callback"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void\ncifs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, cifs_i_callback);\n}"
  },
  {
    "function_name": "cifs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "283-287",
    "snippet": "static void cifs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(cifs_inode_cachep, CIFS_I(inode));\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *cifs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "cifs_inode_cachep",
            "CIFS_I(inode)"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *cifs_inode_cachep;\n\nstatic void cifs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(cifs_inode_cachep, CIFS_I(inode));\n}"
  },
  {
    "function_name": "cifs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "248-281",
    "snippet": "static struct inode *\ncifs_alloc_inode(struct super_block *sb)\n{\n\tstruct cifsInodeInfo *cifs_inode;\n\tcifs_inode = kmem_cache_alloc(cifs_inode_cachep, GFP_KERNEL);\n\tif (!cifs_inode)\n\t\treturn NULL;\n\tcifs_inode->cifsAttrs = 0x20;\t/* default */\n\tcifs_inode->time = 0;\n\t/*\n\t * Until the file is open and we have gotten oplock info back from the\n\t * server, can not assume caching of file data or metadata.\n\t */\n\tcifs_set_oplock_level(cifs_inode, 0);\n\tcifs_inode->flags = 0;\n\tspin_lock_init(&cifs_inode->writers_lock);\n\tcifs_inode->writers = 0;\n\tcifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */\n\tcifs_inode->server_eof = 0;\n\tcifs_inode->uniqueid = 0;\n\tcifs_inode->createtime = 0;\n\tcifs_inode->epoch = 0;\n#ifdef CONFIG_CIFS_SMB2\n\tget_random_bytes(cifs_inode->lease_key, SMB2_LEASE_KEY_SIZE);\n#endif\n\t/*\n\t * Can not set i_flags here - they get immediately overwritten to zero\n\t * by the VFS.\n\t */\n\t/* cifs_inode->vfs_inode.i_flags = S_NOATIME | S_NOCMTIME; */\n\tINIT_LIST_HEAD(&cifs_inode->openFileList);\n\tINIT_LIST_HEAD(&cifs_inode->llist);\n\treturn &cifs_inode->vfs_inode;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *cifs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cifs_inode->llist"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cifs_inode->openFileList"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "cifs_inode->lease_key",
            "SMB2_LEASE_KEY_SIZE"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cifs_inode->writers_lock"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_set_oplock_level",
          "args": [
            "cifs_inode",
            "0"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_set_oplock_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "533-547",
          "snippet": "void cifs_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)\n{\n\toplock &= 0xF;\n\n\tif (oplock == OPLOCK_EXCLUSIVE) {\n\t\tcinode->oplock = CIFS_CACHE_WRITE_FLG | CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Exclusive Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else if (oplock == OPLOCK_READ) {\n\t\tcinode->oplock = CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Level II Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else\n\t\tcinode->oplock = 0;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid cifs_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)\n{\n\toplock &= 0xF;\n\n\tif (oplock == OPLOCK_EXCLUSIVE) {\n\t\tcinode->oplock = CIFS_CACHE_WRITE_FLG | CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Exclusive Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else if (oplock == OPLOCK_READ) {\n\t\tcinode->oplock = CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Level II Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else\n\t\tcinode->oplock = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "cifs_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *cifs_inode_cachep;\n\nstatic struct inode *\ncifs_alloc_inode(struct super_block *sb)\n{\n\tstruct cifsInodeInfo *cifs_inode;\n\tcifs_inode = kmem_cache_alloc(cifs_inode_cachep, GFP_KERNEL);\n\tif (!cifs_inode)\n\t\treturn NULL;\n\tcifs_inode->cifsAttrs = 0x20;\t/* default */\n\tcifs_inode->time = 0;\n\t/*\n\t * Until the file is open and we have gotten oplock info back from the\n\t * server, can not assume caching of file data or metadata.\n\t */\n\tcifs_set_oplock_level(cifs_inode, 0);\n\tcifs_inode->flags = 0;\n\tspin_lock_init(&cifs_inode->writers_lock);\n\tcifs_inode->writers = 0;\n\tcifs_inode->vfs_inode.i_blkbits = 14;  /* 2**14 = CIFS_MAX_MSGSIZE */\n\tcifs_inode->server_eof = 0;\n\tcifs_inode->uniqueid = 0;\n\tcifs_inode->createtime = 0;\n\tcifs_inode->epoch = 0;\n#ifdef CONFIG_CIFS_SMB2\n\tget_random_bytes(cifs_inode->lease_key, SMB2_LEASE_KEY_SIZE);\n#endif\n\t/*\n\t * Can not set i_flags here - they get immediately overwritten to zero\n\t * by the VFS.\n\t */\n\t/* cifs_inode->vfs_inode.i_flags = S_NOATIME | S_NOCMTIME; */\n\tINIT_LIST_HEAD(&cifs_inode->openFileList);\n\tINIT_LIST_HEAD(&cifs_inode->llist);\n\treturn &cifs_inode->vfs_inode;\n}"
  },
  {
    "function_name": "cifs_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "222-238",
    "snippet": "static int cifs_permission(struct inode *inode, int mask)\n{\n\tstruct cifs_sb_info *cifs_sb;\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM) {\n\t\tif ((mask & MAY_EXEC) && !execute_ok(inode))\n\t\t\treturn -EACCES;\n\t\telse\n\t\t\treturn 0;\n\t} else /* file mode might have been restricted at mount time\n\t\ton the client (above and beyond ACL on servers) for\n\t\tservers which do not support setting and viewing mode bits,\n\t\tso allowing client to check permissions is useful */\n\t\treturn generic_permission(inode, mask);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_permission",
          "args": [
            "inode",
            "mask"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "generic_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "329-368",
          "snippet": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execute_ok",
          "args": [
            "inode"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int cifs_permission(struct inode *inode, int mask)\n{\n\tstruct cifs_sb_info *cifs_sb;\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM) {\n\t\tif ((mask & MAY_EXEC) && !execute_ok(inode))\n\t\t\treturn -EACCES;\n\t\telse\n\t\t\treturn 0;\n\t} else /* file mode might have been restricted at mount time\n\t\ton the client (above and beyond ACL on servers) for\n\t\tservers which do not support setting and viewing mode bits,\n\t\tso allowing client to check permissions is useful */\n\t\treturn generic_permission(inode, mask);\n}"
  },
  {
    "function_name": "cifs_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "210-220",
    "snippet": "static long cifs_fallocate(struct file *file, int mode, loff_t off, loff_t len)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\tif (server->ops->fallocate)\n\t\treturn server->ops->fallocate(file, tcon, mode, off, len);\n\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "server->ops->fallocate",
          "args": [
            "file",
            "tcon",
            "mode",
            "off",
            "len"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_master_tcon",
          "args": [
            "cifs_sb"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_master_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3948-3952",
          "snippet": "struct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_FILE_SB",
          "args": [
            "file"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_FILE_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1171-1175",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_FILE_SB(struct file *file)\n{\n\treturn CIFS_SB(file_inode(file)->i_sb);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_FILE_SB(struct file *file)\n{\n\treturn CIFS_SB(file_inode(file)->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic long cifs_fallocate(struct file *file, int mode, loff_t off, loff_t len)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\tif (server->ops->fallocate)\n\t\treturn server->ops->fallocate(file, tcon, mode, off, len);\n\n\treturn -EOPNOTSUPP;\n}"
  },
  {
    "function_name": "cifs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "180-208",
    "snippet": "static int\ncifs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int xid;\n\tint rc = 0;\n\n\txid = get_xid();\n\n\t/*\n\t * PATH_MAX may be too long - it would presumably be total path,\n\t * but note that some servers (includinng Samba 3) have a shorter\n\t * maximum path.\n\t *\n\t * Instead could get the real value via SMB_QUERY_FS_ATTRIBUTE_INFO.\n\t */\n\tbuf->f_namelen = PATH_MAX;\n\tbuf->f_files = 0;\t/* undefined */\n\tbuf->f_ffree = 0;\t/* unlimited */\n\n\tif (server->ops->queryfs)\n\t\trc = server->ops->queryfs(xid, tcon, buf);\n\n\tfree_xid(xid);\n\treturn 0;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->queryfs",
          "args": [
            "xid",
            "tcon",
            "buf"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_sb_master_tcon",
          "args": [
            "cifs_sb"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_master_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3948-3952",
          "snippet": "struct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "sb"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int\ncifs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int xid;\n\tint rc = 0;\n\n\txid = get_xid();\n\n\t/*\n\t * PATH_MAX may be too long - it would presumably be total path,\n\t * but note that some servers (includinng Samba 3) have a shorter\n\t * maximum path.\n\t *\n\t * Instead could get the real value via SMB_QUERY_FS_ATTRIBUTE_INFO.\n\t */\n\tbuf->f_namelen = PATH_MAX;\n\tbuf->f_files = 0;\t/* undefined */\n\tbuf->f_ffree = 0;\t/* unlimited */\n\n\tif (server->ops->queryfs)\n\t\trc = server->ops->queryfs(xid, tcon, buf);\n\n\tfree_xid(xid);\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "173-178",
    "snippet": "static void cifs_kill_sb(struct super_block *sb)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tkill_anon_super(sb);\n\tcifs_umount(cifs_sb);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_umount",
          "args": [
            "cifs_sb"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_umount_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
          "lines": "507-541",
          "snippet": "static void cifs_umount_begin(struct super_block *sb)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_tcon *tcon;\n\n\tif (cifs_sb == NULL)\n\t\treturn;\n\n\ttcon = cifs_sb_master_tcon(cifs_sb);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif ((tcon->tc_count > 1) || (tcon->tidStatus == CifsExiting)) {\n\t\t/* we have other mounts to same share or we have\n\t\t   already tried to force umount this and woken up\n\t\t   all waiting network requests, nothing to do */\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t} else if (tcon->tc_count == 1)\n\t\ttcon->tidStatus = CifsExiting;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* cancel_brl_requests(tcon); */ /* BB mark all brl mids as exiting */\n\t/* cancel_notify_requests(tcon); */\n\tif (tcon->ses && tcon->ses->server) {\n\t\tcifs_dbg(FYI, \"wake up tasks now - umount begin not complete\\n\");\n\t\twake_up_all(&tcon->ses->server->request_q);\n\t\twake_up_all(&tcon->ses->server->response_q);\n\t\tmsleep(1); /* yield */\n\t\t/* we have to kick the requests once more */\n\t\twake_up_all(&tcon->ses->server->response_q);\n\t\tmsleep(1);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_spnego.h\"",
            "#include <linux/key-type.h>",
            "#include <linux/mm.h>",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/vfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void cifs_umount_begin(struct super_block *sb)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_tcon *tcon;\n\n\tif (cifs_sb == NULL)\n\t\treturn;\n\n\ttcon = cifs_sb_master_tcon(cifs_sb);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif ((tcon->tc_count > 1) || (tcon->tidStatus == CifsExiting)) {\n\t\t/* we have other mounts to same share or we have\n\t\t   already tried to force umount this and woken up\n\t\t   all waiting network requests, nothing to do */\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t} else if (tcon->tc_count == 1)\n\t\ttcon->tidStatus = CifsExiting;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* cancel_brl_requests(tcon); */ /* BB mark all brl mids as exiting */\n\t/* cancel_notify_requests(tcon); */\n\tif (tcon->ses && tcon->ses->server) {\n\t\tcifs_dbg(FYI, \"wake up tasks now - umount begin not complete\\n\");\n\t\twake_up_all(&tcon->ses->server->request_q);\n\t\twake_up_all(&tcon->ses->server->response_q);\n\t\tmsleep(1); /* yield */\n\t\t/* we have to kick the requests once more */\n\t\twake_up_all(&tcon->ses->server->response_q);\n\t\tmsleep(1);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_anon_super",
          "args": [
            "sb"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "sb"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void cifs_kill_sb(struct super_block *sb)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tkill_anon_super(sb);\n\tcifs_umount(cifs_sb);\n}"
  },
  {
    "function_name": "cifs_read_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "114-171",
    "snippet": "static int\ncifs_read_super(struct super_block *sb)\n{\n\tstruct inode *inode;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tint rc = 0;\n\n\tcifs_sb = CIFS_SB(sb);\n\ttcon = cifs_sb_master_tcon(cifs_sb);\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIXACL)\n\t\tsb->s_flags |= MS_POSIXACL;\n\n\tif (tcon->ses->capabilities & tcon->ses->server->vals->cap_large_files)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\telse\n\t\tsb->s_maxbytes = MAX_NON_LFS;\n\n\t/* BB FIXME fix time_gran to be larger for LANMAN sessions */\n\tsb->s_time_gran = 100;\n\n\tsb->s_magic = CIFS_MAGIC_NUMBER;\n\tsb->s_op = &cifs_super_ops;\n\tsb->s_bdi = &cifs_sb->bdi;\n\tsb->s_blocksize = CIFS_MAX_MSGSIZE;\n\tsb->s_blocksize_bits = 14;\t/* default 2**14 = CIFS_MAX_MSGSIZE */\n\tinode = cifs_root_iget(sb);\n\n\tif (IS_ERR(inode)) {\n\t\trc = PTR_ERR(inode);\n\t\tgoto out_no_root;\n\t}\n\n\tif (tcon->nocase)\n\t\tsb->s_d_op = &cifs_ci_dentry_ops;\n\telse\n\t\tsb->s_d_op = &cifs_dentry_ops;\n\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root) {\n\t\trc = -ENOMEM;\n\t\tgoto out_no_root;\n\t}\n\n#ifdef CONFIG_CIFS_NFSD_EXPORT\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\tcifs_dbg(FYI, \"export ops supported\\n\");\n\t\tsb->s_export_op = &cifs_export_ops;\n\t}\n#endif /* CONFIG_CIFS_NFSD_EXPORT */\n\n\treturn 0;\n\nout_no_root:\n\tcifs_dbg(VFS, \"%s: get root inode failed\\n\", __func__);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations cifs_super_ops;",
      "static const struct super_operations cifs_super_ops = {\n\t.statfs = cifs_statfs,\n\t.alloc_inode = cifs_alloc_inode,\n\t.destroy_inode = cifs_destroy_inode,\n\t.drop_inode\t= cifs_drop_inode,\n\t.evict_inode\t= cifs_evict_inode,\n/*\t.delete_inode\t= cifs_delete_inode,  */  /* Do not need above\n\tfunction unless later we add lazy close of inodes or unless the\n\tkernel forgets to call us with the same number of releases (closes)\n\tas opens */\n\t.show_options = cifs_show_options,\n\t.umount_begin   = cifs_umount_begin,\n\t.remount_fs = cifs_remount,\n#ifdef CONFIG_CIFS_STATS2\n\t.show_stats = cifs_show_stats,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: get root inode failed\\n\"",
            "__func__"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"export ops supported\\n\""
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_root_iget",
          "args": [
            "sb"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_master_tcon",
          "args": [
            "cifs_sb"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_master_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3948-3952",
          "snippet": "struct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "sb"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct super_operations cifs_super_ops;\nstatic const struct super_operations cifs_super_ops = {\n\t.statfs = cifs_statfs,\n\t.alloc_inode = cifs_alloc_inode,\n\t.destroy_inode = cifs_destroy_inode,\n\t.drop_inode\t= cifs_drop_inode,\n\t.evict_inode\t= cifs_evict_inode,\n/*\t.delete_inode\t= cifs_delete_inode,  */  /* Do not need above\n\tfunction unless later we add lazy close of inodes or unless the\n\tkernel forgets to call us with the same number of releases (closes)\n\tas opens */\n\t.show_options = cifs_show_options,\n\t.umount_begin   = cifs_umount_begin,\n\t.remount_fs = cifs_remount,\n#ifdef CONFIG_CIFS_STATS2\n\t.show_stats = cifs_show_stats,\n#endif\n};\n\nstatic int\ncifs_read_super(struct super_block *sb)\n{\n\tstruct inode *inode;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tint rc = 0;\n\n\tcifs_sb = CIFS_SB(sb);\n\ttcon = cifs_sb_master_tcon(cifs_sb);\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIXACL)\n\t\tsb->s_flags |= MS_POSIXACL;\n\n\tif (tcon->ses->capabilities & tcon->ses->server->vals->cap_large_files)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\telse\n\t\tsb->s_maxbytes = MAX_NON_LFS;\n\n\t/* BB FIXME fix time_gran to be larger for LANMAN sessions */\n\tsb->s_time_gran = 100;\n\n\tsb->s_magic = CIFS_MAGIC_NUMBER;\n\tsb->s_op = &cifs_super_ops;\n\tsb->s_bdi = &cifs_sb->bdi;\n\tsb->s_blocksize = CIFS_MAX_MSGSIZE;\n\tsb->s_blocksize_bits = 14;\t/* default 2**14 = CIFS_MAX_MSGSIZE */\n\tinode = cifs_root_iget(sb);\n\n\tif (IS_ERR(inode)) {\n\t\trc = PTR_ERR(inode);\n\t\tgoto out_no_root;\n\t}\n\n\tif (tcon->nocase)\n\t\tsb->s_d_op = &cifs_ci_dentry_ops;\n\telse\n\t\tsb->s_d_op = &cifs_dentry_ops;\n\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root) {\n\t\trc = -ENOMEM;\n\t\tgoto out_no_root;\n\t}\n\n#ifdef CONFIG_CIFS_NFSD_EXPORT\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\n\t\tcifs_dbg(FYI, \"export ops supported\\n\");\n\t\tsb->s_export_op = &cifs_export_ops;\n\t}\n#endif /* CONFIG_CIFS_NFSD_EXPORT */\n\n\treturn 0;\n\nout_no_root:\n\tcifs_dbg(VFS, \"%s: get root inode failed\\n\", __func__);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_sb_deactive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "105-112",
    "snippet": "void\ncifs_sb_deactive(struct super_block *sb)\n{\n\tstruct cifs_sb_info *server = CIFS_SB(sb);\n\n\tif (atomic_dec_and_test(&server->active))\n\t\tdeactivate_super(sb);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "deactivate_super",
          "args": [
            "sb"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&server->active"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "sb"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid\ncifs_sb_deactive(struct super_block *sb)\n{\n\tstruct cifs_sb_info *server = CIFS_SB(sb);\n\n\tif (atomic_dec_and_test(&server->active))\n\t\tdeactivate_super(sb);\n}"
  },
  {
    "function_name": "cifs_sb_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
    "lines": "96-103",
    "snippet": "void\ncifs_sb_active(struct super_block *sb)\n{\n\tstruct cifs_sb_info *server = CIFS_SB(sb);\n\n\tif (atomic_inc_return(&server->active) == 1)\n\t\tatomic_inc(&sb->s_active);\n}",
    "includes": [
      "#include \"smb2pdu.h\"",
      "#include \"fscache.h\"",
      "#include \"cifs_spnego.h\"",
      "#include <linux/key-type.h>",
      "#include <linux/mm.h>",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/random.h>",
      "#include <linux/namei.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/mempool.h>",
      "#include <linux/vfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sb->s_active"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&server->active"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "sb"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid\ncifs_sb_active(struct super_block *sb)\n{\n\tstruct cifs_sb_info *server = CIFS_SB(sb);\n\n\tif (atomic_inc_return(&server->active) == 1)\n\t\tatomic_inc(&sb->s_active);\n}"
  }
]