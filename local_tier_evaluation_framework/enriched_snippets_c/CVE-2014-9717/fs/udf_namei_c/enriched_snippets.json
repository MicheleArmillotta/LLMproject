[
  {
    "function_name": "udf_encode_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "1239-1271",
    "snippet": "static int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,\n\t\t\t struct inode *parent)\n{\n\tint len = *lenp;\n\tstruct kernel_lb_addr location = UDF_I(inode)->i_location;\n\tstruct fid *fid = (struct fid *)fh;\n\tint type = FILEID_UDF_WITHOUT_PARENT;\n\n\tif (parent && (len < 5)) {\n\t\t*lenp = 5;\n\t\treturn FILEID_INVALID;\n\t} else if (len < 3) {\n\t\t*lenp = 3;\n\t\treturn FILEID_INVALID;\n\t}\n\n\t*lenp = 3;\n\tfid->udf.block = location.logicalBlockNum;\n\tfid->udf.partref = location.partitionReferenceNum;\n\tfid->udf.parent_partref = 0;\n\tfid->udf.generation = inode->i_generation;\n\n\tif (parent) {\n\t\tlocation = UDF_I(parent)->i_location;\n\t\tfid->udf.parent_block = location.logicalBlockNum;\n\t\tfid->udf.parent_partref = location.partitionReferenceNum;\n\t\tfid->udf.parent_generation = inode->i_generation;\n\t\t*lenp = 5;\n\t\ttype = FILEID_UDF_WITH_PARENT;\n\t}\n\n\treturn type;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "parent"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,\n\t\t\t struct inode *parent)\n{\n\tint len = *lenp;\n\tstruct kernel_lb_addr location = UDF_I(inode)->i_location;\n\tstruct fid *fid = (struct fid *)fh;\n\tint type = FILEID_UDF_WITHOUT_PARENT;\n\n\tif (parent && (len < 5)) {\n\t\t*lenp = 5;\n\t\treturn FILEID_INVALID;\n\t} else if (len < 3) {\n\t\t*lenp = 3;\n\t\treturn FILEID_INVALID;\n\t}\n\n\t*lenp = 3;\n\tfid->udf.block = location.logicalBlockNum;\n\tfid->udf.partref = location.partitionReferenceNum;\n\tfid->udf.parent_partref = 0;\n\tfid->udf.generation = inode->i_generation;\n\n\tif (parent) {\n\t\tlocation = UDF_I(parent)->i_location;\n\t\tfid->udf.parent_block = location.logicalBlockNum;\n\t\tfid->udf.parent_partref = location.partitionReferenceNum;\n\t\tfid->udf.parent_generation = inode->i_generation;\n\t\t*lenp = 5;\n\t\ttype = FILEID_UDF_WITH_PARENT;\n\t}\n\n\treturn type;\n}"
  },
  {
    "function_name": "udf_fh_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "1229-1238",
    "snippet": "static struct dentry *udf_fh_to_parent(struct super_block *sb,\n\t\t\t\t       struct fid *fid, int fh_len, int fh_type)\n{\n\tif (fh_len != 5 || fh_type != FILEID_UDF_WITH_PARENT)\n\t\treturn NULL;\n\n\treturn udf_nfs_get_inode(sb, fid->udf.parent_block,\n\t\t\t\t fid->udf.parent_partref,\n\t\t\t\t fid->udf.parent_generation);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_nfs_get_inode",
          "args": [
            "sb",
            "fid->udf.parent_block",
            "fid->udf.parent_partref",
            "fid->udf.parent_generation"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "udf_nfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "1194-1215",
          "snippet": "static struct dentry *udf_nfs_get_inode(struct super_block *sb, u32 block,\n\t\t\t\t\tu16 partref, __u32 generation)\n{\n\tstruct inode *inode;\n\tstruct kernel_lb_addr loc;\n\n\tif (block == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\n\tloc.logicalBlockNum = block;\n\tloc.partitionReferenceNum = partref;\n\tinode = udf_iget(sb, &loc);\n\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic struct dentry *udf_nfs_get_inode(struct super_block *sb, u32 block,\n\t\t\t\t\tu16 partref, __u32 generation)\n{\n\tstruct inode *inode;\n\tstruct kernel_lb_addr loc;\n\n\tif (block == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\n\tloc.logicalBlockNum = block;\n\tloc.partitionReferenceNum = partref;\n\tinode = udf_iget(sb, &loc);\n\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic struct dentry *udf_fh_to_parent(struct super_block *sb,\n\t\t\t\t       struct fid *fid, int fh_len, int fh_type)\n{\n\tif (fh_len != 5 || fh_type != FILEID_UDF_WITH_PARENT)\n\t\treturn NULL;\n\n\treturn udf_nfs_get_inode(sb, fid->udf.parent_block,\n\t\t\t\t fid->udf.parent_partref,\n\t\t\t\t fid->udf.parent_generation);\n}"
  },
  {
    "function_name": "udf_fh_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "1217-1227",
    "snippet": "static struct dentry *udf_fh_to_dentry(struct super_block *sb,\n\t\t\t\t       struct fid *fid, int fh_len, int fh_type)\n{\n\tif ((fh_len != 3 && fh_len != 5) ||\n\t    (fh_type != FILEID_UDF_WITH_PARENT &&\n\t     fh_type != FILEID_UDF_WITHOUT_PARENT))\n\t\treturn NULL;\n\n\treturn udf_nfs_get_inode(sb, fid->udf.block, fid->udf.partref,\n\t\t\tfid->udf.generation);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_nfs_get_inode",
          "args": [
            "sb",
            "fid->udf.block",
            "fid->udf.partref",
            "fid->udf.generation"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "udf_nfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "1194-1215",
          "snippet": "static struct dentry *udf_nfs_get_inode(struct super_block *sb, u32 block,\n\t\t\t\t\tu16 partref, __u32 generation)\n{\n\tstruct inode *inode;\n\tstruct kernel_lb_addr loc;\n\n\tif (block == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\n\tloc.logicalBlockNum = block;\n\tloc.partitionReferenceNum = partref;\n\tinode = udf_iget(sb, &loc);\n\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic struct dentry *udf_nfs_get_inode(struct super_block *sb, u32 block,\n\t\t\t\t\tu16 partref, __u32 generation)\n{\n\tstruct inode *inode;\n\tstruct kernel_lb_addr loc;\n\n\tif (block == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\n\tloc.logicalBlockNum = block;\n\tloc.partitionReferenceNum = partref;\n\tinode = udf_iget(sb, &loc);\n\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic struct dentry *udf_fh_to_dentry(struct super_block *sb,\n\t\t\t\t       struct fid *fid, int fh_len, int fh_type)\n{\n\tif ((fh_len != 3 && fh_len != 5) ||\n\t    (fh_type != FILEID_UDF_WITH_PARENT &&\n\t     fh_type != FILEID_UDF_WITHOUT_PARENT))\n\t\treturn NULL;\n\n\treturn udf_nfs_get_inode(sb, fid->udf.block, fid->udf.partref,\n\t\t\tfid->udf.generation);\n}"
  },
  {
    "function_name": "udf_nfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "1194-1215",
    "snippet": "static struct dentry *udf_nfs_get_inode(struct super_block *sb, u32 block,\n\t\t\t\t\tu16 partref, __u32 generation)\n{\n\tstruct inode *inode;\n\tstruct kernel_lb_addr loc;\n\n\tif (block == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\n\tloc.logicalBlockNum = block;\n\tloc.partitionReferenceNum = partref;\n\tinode = udf_iget(sb, &loc);\n\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn d_obtain_alias(inode);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "inode"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_iget",
          "args": [
            "sb",
            "&loc"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "udf_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "148-152",
          "snippet": "static inline struct inode *udf_iget(struct super_block *sb,\n\t\t\t\t     struct kernel_lb_addr *ino)\n{\n\treturn __udf_iget(sb, ino, false);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline struct inode *udf_iget(struct super_block *sb,\n\t\t\t\t     struct kernel_lb_addr *ino)\n{\n\treturn __udf_iget(sb, ino, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic struct dentry *udf_nfs_get_inode(struct super_block *sb, u32 block,\n\t\t\t\t\tu16 partref, __u32 generation)\n{\n\tstruct inode *inode;\n\tstruct kernel_lb_addr loc;\n\n\tif (block == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\n\tloc.logicalBlockNum = block;\n\tloc.partitionReferenceNum = partref;\n\tinode = udf_iget(sb, &loc);\n\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn d_obtain_alias(inode);\n}"
  },
  {
    "function_name": "udf_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "1170-1191",
    "snippet": "static struct dentry *udf_get_parent(struct dentry *child)\n{\n\tstruct kernel_lb_addr tloc;\n\tstruct inode *inode = NULL;\n\tstruct qstr dotdot = QSTR_INIT(\"..\", 2);\n\tstruct fileIdentDesc cfi;\n\tstruct udf_fileident_bh fibh;\n\n\tif (!udf_find_entry(child->d_inode, &dotdot, &fibh, &cfi))\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\n\ttloc = lelb_to_cpu(cfi.icb.extLocation);\n\tinode = udf_iget(child->d_inode->i_sb, &tloc);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\treturn d_obtain_alias(inode);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "inode"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_iget",
          "args": [
            "child->d_inode->i_sb",
            "&tloc"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "udf_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "148-152",
          "snippet": "static inline struct inode *udf_iget(struct super_block *sb,\n\t\t\t\t     struct kernel_lb_addr *ino)\n{\n\treturn __udf_iget(sb, ino, false);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline struct inode *udf_iget(struct super_block *sb,\n\t\t\t\t     struct kernel_lb_addr *ino)\n{\n\treturn __udf_iget(sb, ino, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lelb_to_cpu",
          "args": [
            "cfi.icb.extLocation"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "lelb_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfend.h",
          "lines": "7-15",
          "snippet": "static inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}",
          "includes": [
            "#include <linux/string.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string.h>\n#include <asm/byteorder.h>\n\nstatic inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "fibh.sbh"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EACCES"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_find_entry",
          "args": [
            "child->d_inode",
            "&dotdot",
            "&fibh",
            "&cfi"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "udf_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "142-252",
          "snippet": "static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\tstruct super_block *sb = dir->i_sb;\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(sb, &eloc, offset);\n\t\tif ((++offset << sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(sb, nameptr, lfi, fname, UDF_NAME_LEN);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\tstruct super_block *sb = dir->i_sb;\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(sb, &eloc, offset);\n\t\tif ((++offset << sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(sb, nameptr, lfi, fname, UDF_NAME_LEN);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QSTR_INIT",
          "args": [
            "\"..\"",
            "2"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic struct dentry *udf_get_parent(struct dentry *child)\n{\n\tstruct kernel_lb_addr tloc;\n\tstruct inode *inode = NULL;\n\tstruct qstr dotdot = QSTR_INIT(\"..\", 2);\n\tstruct fileIdentDesc cfi;\n\tstruct udf_fileident_bh fibh;\n\n\tif (!udf_find_entry(child->d_inode, &dotdot, &fibh, &cfi))\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\n\ttloc = lelb_to_cpu(cfi.icb.extLocation);\n\tinode = udf_iget(child->d_inode->i_sb, &tloc);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\treturn d_obtain_alias(inode);\n}"
  },
  {
    "function_name": "udf_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "1036-1168",
    "snippet": "static int udf_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t      struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct udf_fileident_bh ofibh, nfibh;\n\tstruct fileIdentDesc *ofi = NULL, *nfi = NULL, *dir_fi = NULL;\n\tstruct fileIdentDesc ocfi, ncfi;\n\tstruct buffer_head *dir_bh = NULL;\n\tint retval = -ENOENT;\n\tstruct kernel_lb_addr tloc;\n\tstruct udf_inode_info *old_iinfo = UDF_I(old_inode);\n\n\tofi = udf_find_entry(old_dir, &old_dentry->d_name, &ofibh, &ocfi);\n\tif (ofi) {\n\t\tif (ofibh.sbh != ofibh.ebh)\n\t\t\tbrelse(ofibh.ebh);\n\t\tbrelse(ofibh.sbh);\n\t}\n\ttloc = lelb_to_cpu(ocfi.icb.extLocation);\n\tif (!ofi || udf_get_lb_pblock(old_dir->i_sb, &tloc, 0)\n\t    != old_inode->i_ino)\n\t\tgoto end_rename;\n\n\tnfi = udf_find_entry(new_dir, &new_dentry->d_name, &nfibh, &ncfi);\n\tif (nfi) {\n\t\tif (!new_inode) {\n\t\t\tif (nfibh.sbh != nfibh.ebh)\n\t\t\t\tbrelse(nfibh.ebh);\n\t\t\tbrelse(nfibh.sbh);\n\t\t\tnfi = NULL;\n\t\t}\n\t}\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\tint offset = udf_ext0_offset(old_inode);\n\n\t\tif (new_inode) {\n\t\t\tretval = -ENOTEMPTY;\n\t\t\tif (!empty_dir(new_inode))\n\t\t\t\tgoto end_rename;\n\t\t}\n\t\tretval = -EIO;\n\t\tif (old_iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tdir_fi = udf_get_fileident(\n\t\t\t\t\told_iinfo->i_ext.i_data -\n\t\t\t\t\t  (old_iinfo->i_efe ?\n\t\t\t\t\t   sizeof(struct extendedFileEntry) :\n\t\t\t\t\t   sizeof(struct fileEntry)),\n\t\t\t\t\told_inode->i_sb->s_blocksize, &offset);\n\t\t} else {\n\t\t\tdir_bh = udf_bread(old_inode, 0, 0, &retval);\n\t\t\tif (!dir_bh)\n\t\t\t\tgoto end_rename;\n\t\t\tdir_fi = udf_get_fileident(dir_bh->b_data,\n\t\t\t\t\told_inode->i_sb->s_blocksize, &offset);\n\t\t}\n\t\tif (!dir_fi)\n\t\t\tgoto end_rename;\n\t\ttloc = lelb_to_cpu(dir_fi->icb.extLocation);\n\t\tif (udf_get_lb_pblock(old_inode->i_sb, &tloc, 0) !=\n\t\t\t\told_dir->i_ino)\n\t\t\tgoto end_rename;\n\t}\n\tif (!nfi) {\n\t\tnfi = udf_add_entry(new_dir, new_dentry, &nfibh, &ncfi,\n\t\t\t\t    &retval);\n\t\tif (!nfi)\n\t\t\tgoto end_rename;\n\t}\n\n\t/*\n\t * Like most other Unix systems, set the ctime for inodes on a\n\t * rename.\n\t */\n\told_inode->i_ctime = current_fs_time(old_inode->i_sb);\n\tmark_inode_dirty(old_inode);\n\n\t/*\n\t * ok, that's it\n\t */\n\tncfi.fileVersionNum = ocfi.fileVersionNum;\n\tncfi.fileCharacteristics = ocfi.fileCharacteristics;\n\tmemcpy(&(ncfi.icb), &(ocfi.icb), sizeof(struct long_ad));\n\tudf_write_fi(new_dir, &ncfi, nfi, &nfibh, NULL, NULL);\n\n\t/* The old fid may have moved - find it again */\n\tofi = udf_find_entry(old_dir, &old_dentry->d_name, &ofibh, &ocfi);\n\tudf_delete_entry(old_dir, ofi, &ofibh, &ocfi);\n\n\tif (new_inode) {\n\t\tnew_inode->i_ctime = current_fs_time(new_inode->i_sb);\n\t\tinode_dec_link_count(new_inode);\n\t}\n\told_dir->i_ctime = old_dir->i_mtime = current_fs_time(old_dir->i_sb);\n\tmark_inode_dirty(old_dir);\n\n\tif (dir_fi) {\n\t\tdir_fi->icb.extLocation = cpu_to_lelb(UDF_I(new_dir)->i_location);\n\t\tudf_update_tag((char *)dir_fi,\n\t\t\t\t(sizeof(struct fileIdentDesc) +\n\t\t\t\tle16_to_cpu(dir_fi->lengthOfImpUse) + 3) & ~3);\n\t\tif (old_iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tmark_inode_dirty(old_inode);\n\t\telse\n\t\t\tmark_buffer_dirty_inode(dir_bh, old_inode);\n\n\t\tinode_dec_link_count(old_dir);\n\t\tif (new_inode)\n\t\t\tinode_dec_link_count(new_inode);\n\t\telse {\n\t\t\tinc_nlink(new_dir);\n\t\t\tmark_inode_dirty(new_dir);\n\t\t}\n\t}\n\n\tif (ofi) {\n\t\tif (ofibh.sbh != ofibh.ebh)\n\t\t\tbrelse(ofibh.ebh);\n\t\tbrelse(ofibh.sbh);\n\t}\n\n\tretval = 0;\n\nend_rename:\n\tbrelse(dir_bh);\n\tif (nfi) {\n\t\tif (nfibh.sbh != nfibh.ebh)\n\t\t\tbrelse(nfibh.ebh);\n\t\tbrelse(nfibh.sbh);\n\t}\n\n\treturn retval;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "nfibh.sbh"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "new_dir"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "new_dir"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "new_inode"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "old_dir"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "dir_bh",
            "old_inode"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_update_tag",
          "args": [
            "(char *)dir_fi",
            "(sizeof(struct fileIdentDesc) +\n\t\t\t\tle16_to_cpu(dir_fi->lengthOfImpUse) + 3) & ~3"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "udf_update_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "269-277",
          "snippet": "void udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dir_fi->lengthOfImpUse"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_lelb",
          "args": [
            "UDF_I(new_dir)->i_location"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_lelb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfend.h",
          "lines": "17-25",
          "snippet": "static inline struct lb_addr cpu_to_lelb(struct kernel_lb_addr in)\n{\n\tstruct lb_addr out;\n\n\tout.logicalBlockNum = cpu_to_le32(in.logicalBlockNum);\n\tout.partitionReferenceNum = cpu_to_le16(in.partitionReferenceNum);\n\n\treturn out;\n}",
          "includes": [
            "#include <linux/string.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string.h>\n#include <asm/byteorder.h>\n\nstatic inline struct lb_addr cpu_to_lelb(struct kernel_lb_addr in)\n{\n\tstruct lb_addr out;\n\n\tout.logicalBlockNum = cpu_to_le32(in.logicalBlockNum);\n\tout.partitionReferenceNum = cpu_to_le16(in.partitionReferenceNum);\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "new_dir"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "old_dir->i_sb"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "new_inode"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "new_inode->i_sb"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_delete_entry",
          "args": [
            "old_dir",
            "ofi",
            "&ofibh",
            "&ocfi"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "udf_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "540-550",
          "snippet": "static int udf_delete_entry(struct inode *inode, struct fileIdentDesc *fi,\n\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t    struct fileIdentDesc *cfi)\n{\n\tcfi->fileCharacteristics |= FID_FILE_CHAR_DELETED;\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))\n\t\tmemset(&(cfi->icb), 0x00, sizeof(struct long_ad));\n\n\treturn udf_write_fi(inode, cfi, fi, fibh, NULL, NULL);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic int udf_delete_entry(struct inode *inode, struct fileIdentDesc *fi,\n\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t    struct fileIdentDesc *cfi)\n{\n\tcfi->fileCharacteristics |= FID_FILE_CHAR_DELETED;\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))\n\t\tmemset(&(cfi->icb), 0x00, sizeof(struct long_ad));\n\n\treturn udf_write_fi(inode, cfi, fi, fibh, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_find_entry",
          "args": [
            "old_dir",
            "&old_dentry->d_name",
            "&ofibh",
            "&ocfi"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "udf_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "142-252",
          "snippet": "static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\tstruct super_block *sb = dir->i_sb;\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(sb, &eloc, offset);\n\t\tif ((++offset << sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(sb, nameptr, lfi, fname, UDF_NAME_LEN);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\tstruct super_block *sb = dir->i_sb;\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(sb, &eloc, offset);\n\t\tif ((++offset << sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(sb, nameptr, lfi, fname, UDF_NAME_LEN);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_write_fi",
          "args": [
            "new_dir",
            "&ncfi",
            "nfi",
            "&nfibh",
            "NULL",
            "NULL"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_fi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "44-140",
          "snippet": "int udf_write_fi(struct inode *inode, struct fileIdentDesc *cfi,\n\t\t struct fileIdentDesc *sfi, struct udf_fileident_bh *fibh,\n\t\t uint8_t *impuse, uint8_t *fileident)\n{\n\tuint16_t crclen = fibh->eoffset - fibh->soffset - sizeof(struct tag);\n\tuint16_t crc;\n\tint offset;\n\tuint16_t liu = le16_to_cpu(cfi->lengthOfImpUse);\n\tuint8_t lfi = cfi->lengthFileIdent;\n\tint padlen = fibh->eoffset - fibh->soffset - liu - lfi -\n\t\tsizeof(struct fileIdentDesc);\n\tint adinicb = 0;\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tadinicb = 1;\n\n\toffset = fibh->soffset + sizeof(struct fileIdentDesc);\n\n\tif (impuse) {\n\t\tif (adinicb || (offset + liu < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, liu);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, impuse, liu);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, -offset);\n\t\t\tmemcpy(fibh->ebh->b_data, impuse - offset,\n\t\t\t\tliu + offset);\n\t\t}\n\t}\n\n\toffset += liu;\n\n\tif (fileident) {\n\t\tif (adinicb || (offset + lfi < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident, lfi);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, fileident, lfi);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident,\n\t\t\t\t-offset);\n\t\t\tmemcpy(fibh->ebh->b_data, fileident - offset,\n\t\t\t\tlfi + offset);\n\t\t}\n\t}\n\n\toffset += lfi;\n\n\tif (adinicb || (offset + padlen < 0)) {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, padlen);\n\t} else if (offset >= 0) {\n\t\tmemset(fibh->ebh->b_data + offset, 0x00, padlen);\n\t} else {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, -offset);\n\t\tmemset(fibh->ebh->b_data, 0x00, padlen + offset);\n\t}\n\n\tcrc = crc_itu_t(0, (uint8_t *)cfi + sizeof(struct tag),\n\t\t      sizeof(struct fileIdentDesc) - sizeof(struct tag));\n\n\tif (fibh->sbh == fibh->ebh) {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t      sizeof(struct fileIdentDesc));\n\t} else if (sizeof(struct fileIdentDesc) >= -fibh->soffset) {\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data +\n\t\t\t\t\tsizeof(struct fileIdentDesc) +\n\t\t\t\t\tfibh->soffset,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      -fibh->soffset - sizeof(struct fileIdentDesc));\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data, fibh->eoffset);\n\t}\n\n\tcfi->descTag.descCRC = cpu_to_le16(crc);\n\tcfi->descTag.descCRCLength = cpu_to_le16(crclen);\n\tcfi->descTag.tagChecksum = udf_tag_checksum(&cfi->descTag);\n\n\tif (adinicb || (sizeof(struct fileIdentDesc) <= -fibh->soffset)) {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi,\n\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi, -fibh->soffset);\n\t\tmemcpy(fibh->ebh->b_data, (uint8_t *)cfi - fibh->soffset,\n\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\t}\n\n\tif (adinicb) {\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tmark_buffer_dirty_inode(fibh->ebh, inode);\n\t\tmark_buffer_dirty_inode(fibh->sbh, inode);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nint udf_write_fi(struct inode *inode, struct fileIdentDesc *cfi,\n\t\t struct fileIdentDesc *sfi, struct udf_fileident_bh *fibh,\n\t\t uint8_t *impuse, uint8_t *fileident)\n{\n\tuint16_t crclen = fibh->eoffset - fibh->soffset - sizeof(struct tag);\n\tuint16_t crc;\n\tint offset;\n\tuint16_t liu = le16_to_cpu(cfi->lengthOfImpUse);\n\tuint8_t lfi = cfi->lengthFileIdent;\n\tint padlen = fibh->eoffset - fibh->soffset - liu - lfi -\n\t\tsizeof(struct fileIdentDesc);\n\tint adinicb = 0;\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tadinicb = 1;\n\n\toffset = fibh->soffset + sizeof(struct fileIdentDesc);\n\n\tif (impuse) {\n\t\tif (adinicb || (offset + liu < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, liu);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, impuse, liu);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, -offset);\n\t\t\tmemcpy(fibh->ebh->b_data, impuse - offset,\n\t\t\t\tliu + offset);\n\t\t}\n\t}\n\n\toffset += liu;\n\n\tif (fileident) {\n\t\tif (adinicb || (offset + lfi < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident, lfi);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, fileident, lfi);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident,\n\t\t\t\t-offset);\n\t\t\tmemcpy(fibh->ebh->b_data, fileident - offset,\n\t\t\t\tlfi + offset);\n\t\t}\n\t}\n\n\toffset += lfi;\n\n\tif (adinicb || (offset + padlen < 0)) {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, padlen);\n\t} else if (offset >= 0) {\n\t\tmemset(fibh->ebh->b_data + offset, 0x00, padlen);\n\t} else {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, -offset);\n\t\tmemset(fibh->ebh->b_data, 0x00, padlen + offset);\n\t}\n\n\tcrc = crc_itu_t(0, (uint8_t *)cfi + sizeof(struct tag),\n\t\t      sizeof(struct fileIdentDesc) - sizeof(struct tag));\n\n\tif (fibh->sbh == fibh->ebh) {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t      sizeof(struct fileIdentDesc));\n\t} else if (sizeof(struct fileIdentDesc) >= -fibh->soffset) {\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data +\n\t\t\t\t\tsizeof(struct fileIdentDesc) +\n\t\t\t\t\tfibh->soffset,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      -fibh->soffset - sizeof(struct fileIdentDesc));\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data, fibh->eoffset);\n\t}\n\n\tcfi->descTag.descCRC = cpu_to_le16(crc);\n\tcfi->descTag.descCRCLength = cpu_to_le16(crclen);\n\tcfi->descTag.tagChecksum = udf_tag_checksum(&cfi->descTag);\n\n\tif (adinicb || (sizeof(struct fileIdentDesc) <= -fibh->soffset)) {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi,\n\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi, -fibh->soffset);\n\t\tmemcpy(fibh->ebh->b_data, (uint8_t *)cfi - fibh->soffset,\n\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\t}\n\n\tif (adinicb) {\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tmark_buffer_dirty_inode(fibh->ebh, inode);\n\t\tmark_buffer_dirty_inode(fibh->sbh, inode);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&(ncfi.icb)",
            "&(ocfi.icb)",
            "sizeof(struct long_ad)"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "old_inode->i_sb"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_add_entry",
          "args": [
            "new_dir",
            "new_dentry",
            "&nfibh",
            "&ncfi",
            "&retval"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "udf_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "295-538",
          "snippet": "static struct fileIdentDesc *udf_add_entry(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   struct udf_fileident_bh *fibh,\n\t\t\t\t\t   struct fileIdentDesc *cfi, int *err)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fileIdentDesc *fi = NULL;\n\tunsigned char *name = NULL;\n\tint namelen;\n\tloff_t f_pos;\n\tloff_t size = udf_ext0_offset(dir) + dir->i_size;\n\tint nfidlen;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tint block;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen = 0;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo;\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!name) {\n\t\t*err = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tif (dentry) {\n\t\tif (!dentry->d_name.len) {\n\t\t\t*err = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t\tnamelen = udf_put_filename(sb, dentry->d_name.name, name,\n\t\t\t\t\t\t dentry->d_name.len);\n\t\tif (!namelen) {\n\t\t\t*err = -ENAMETOOLONG;\n\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\tnamelen = 0;\n\t}\n\n\tnfidlen = (sizeof(struct fileIdentDesc) + namelen + 3) & ~3;\n\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\tdinfo = UDF_I(dir);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tblock = udf_get_lb_pblock(dir->i_sb,\n\t\t\t\t\t&dinfo->i_location, 0);\n\t\t\tfibh->soffset = fibh->eoffset = sb->s_blocksize;\n\t\t\tgoto add;\n\t\t}\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tblock = dinfo->i_location.logicalBlockNum;\n\t}\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\n\t\tif (!fi) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (((sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi + 3) & ~3) == nfidlen) {\n\t\t\t\tcfi->descTag.tagSerialNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileVersionNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileCharacteristics = 0;\n\t\t\t\tcfi->lengthFileIdent = namelen;\n\t\t\t\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\t\t\t\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL,\n\t\t\t\t\t\t  name))\n\t\t\t\t\tgoto out_ok;\n\t\t\t\telse {\n\t\t\t\t\t*err = -EIO;\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nadd:\n\tf_pos += nfidlen;\n\n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB &&\n\t    sb->s_blocksize - fibh->eoffset < nfidlen) {\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tfibh->soffset -= udf_ext0_offset(dir);\n\t\tfibh->eoffset -= udf_ext0_offset(dir);\n\t\tf_pos -= udf_ext0_offset(dir);\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tbrelse(fibh->ebh);\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh =\n\t\t\t\tudf_expand_dir_adinicb(dir, &block, err);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\t\t/* Load extent udf_expand_dir_adinicb() has created */\n\t\tudf_current_aext(dir, &epos, &eloc, &elen, 1);\n\t}\n\n\t/* Entry fits into current block? */\n\tif (sb->s_blocksize - fibh->eoffset >= nfidlen) {\n\t\tfibh->soffset = fibh->eoffset;\n\t\tfibh->eoffset += nfidlen;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tblock = dinfo->i_location.logicalBlockNum;\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t\t(dinfo->i_ext.i_data +\n\t\t\t\t\t fibh->soffset -\n\t\t\t\t\t udf_ext0_offset(dir) +\n\t\t\t\t\t dinfo->i_lenEAttr);\n\t\t} else {\n\t\t\tblock = eloc.logicalBlockNum +\n\t\t\t\t\t((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + fibh->soffset);\n\t\t}\n\t} else {\n\t\t/* Round up last extent in the file */\n\t\telen = (elen + sb->s_blocksize - 1) & ~(sb->s_blocksize - 1);\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\tdinfo->i_lenExtents = (dinfo->i_lenExtents + sb->s_blocksize\n\t\t\t\t\t- 1) & ~(sb->s_blocksize - 1);\n\n\t\tfibh->soffset = fibh->eoffset - sb->s_blocksize;\n\t\tfibh->eoffset += nfidlen - sb->s_blocksize;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\tfibh->ebh = udf_bread(dir,\n\t\t\t\tf_pos >> dir->i_sb->s_blocksize_bits, 1, err);\n\t\tif (!fibh->ebh)\n\t\t\tgoto out_err;\n\t\t/* Extents could have been merged, invalidate our position */\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\n\t\tif (!fibh->soffset) {\n\t\t\t/* Find the freshly allocated block */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t\tfi = (struct fileIdentDesc *)(fibh->sbh->b_data);\n\t\t} else {\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + sb->s_blocksize +\n\t\t\t\t\tfibh->soffset);\n\t\t}\n\t}\n\n\tmemset(cfi, 0, sizeof(struct fileIdentDesc));\n\tif (UDF_SB(sb)->s_udfrev >= 0x0200)\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 3, 1, block,\n\t\t\t    sizeof(struct tag));\n\telse\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 2, 1, block,\n\t\t\t    sizeof(struct tag));\n\tcfi->fileVersionNum = cpu_to_le16(1);\n\tcfi->lengthFileIdent = namelen;\n\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL, name)) {\n\t\tdir->i_size += nfidlen;\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tdinfo->i_lenAlloc += nfidlen;\n\t\telse {\n\t\t\t/* Find the last extent and truncate it to proper size */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\telen -= dinfo->i_lenExtents - dir->i_size;\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\t\tdinfo->i_lenExtents = dir->i_size;\n\t\t}\n\n\t\tmark_inode_dirty(dir);\n\t\tgoto out_ok;\n\t} else {\n\t\t*err = -EIO;\n\t\tgoto out_err;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(name);\n\treturn fi;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic struct fileIdentDesc *udf_add_entry(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   struct udf_fileident_bh *fibh,\n\t\t\t\t\t   struct fileIdentDesc *cfi, int *err)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fileIdentDesc *fi = NULL;\n\tunsigned char *name = NULL;\n\tint namelen;\n\tloff_t f_pos;\n\tloff_t size = udf_ext0_offset(dir) + dir->i_size;\n\tint nfidlen;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tint block;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen = 0;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo;\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!name) {\n\t\t*err = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tif (dentry) {\n\t\tif (!dentry->d_name.len) {\n\t\t\t*err = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t\tnamelen = udf_put_filename(sb, dentry->d_name.name, name,\n\t\t\t\t\t\t dentry->d_name.len);\n\t\tif (!namelen) {\n\t\t\t*err = -ENAMETOOLONG;\n\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\tnamelen = 0;\n\t}\n\n\tnfidlen = (sizeof(struct fileIdentDesc) + namelen + 3) & ~3;\n\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\tdinfo = UDF_I(dir);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tblock = udf_get_lb_pblock(dir->i_sb,\n\t\t\t\t\t&dinfo->i_location, 0);\n\t\t\tfibh->soffset = fibh->eoffset = sb->s_blocksize;\n\t\t\tgoto add;\n\t\t}\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tblock = dinfo->i_location.logicalBlockNum;\n\t}\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\n\t\tif (!fi) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (((sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi + 3) & ~3) == nfidlen) {\n\t\t\t\tcfi->descTag.tagSerialNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileVersionNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileCharacteristics = 0;\n\t\t\t\tcfi->lengthFileIdent = namelen;\n\t\t\t\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\t\t\t\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL,\n\t\t\t\t\t\t  name))\n\t\t\t\t\tgoto out_ok;\n\t\t\t\telse {\n\t\t\t\t\t*err = -EIO;\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nadd:\n\tf_pos += nfidlen;\n\n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB &&\n\t    sb->s_blocksize - fibh->eoffset < nfidlen) {\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tfibh->soffset -= udf_ext0_offset(dir);\n\t\tfibh->eoffset -= udf_ext0_offset(dir);\n\t\tf_pos -= udf_ext0_offset(dir);\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tbrelse(fibh->ebh);\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh =\n\t\t\t\tudf_expand_dir_adinicb(dir, &block, err);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\t\t/* Load extent udf_expand_dir_adinicb() has created */\n\t\tudf_current_aext(dir, &epos, &eloc, &elen, 1);\n\t}\n\n\t/* Entry fits into current block? */\n\tif (sb->s_blocksize - fibh->eoffset >= nfidlen) {\n\t\tfibh->soffset = fibh->eoffset;\n\t\tfibh->eoffset += nfidlen;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tblock = dinfo->i_location.logicalBlockNum;\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t\t(dinfo->i_ext.i_data +\n\t\t\t\t\t fibh->soffset -\n\t\t\t\t\t udf_ext0_offset(dir) +\n\t\t\t\t\t dinfo->i_lenEAttr);\n\t\t} else {\n\t\t\tblock = eloc.logicalBlockNum +\n\t\t\t\t\t((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + fibh->soffset);\n\t\t}\n\t} else {\n\t\t/* Round up last extent in the file */\n\t\telen = (elen + sb->s_blocksize - 1) & ~(sb->s_blocksize - 1);\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\tdinfo->i_lenExtents = (dinfo->i_lenExtents + sb->s_blocksize\n\t\t\t\t\t- 1) & ~(sb->s_blocksize - 1);\n\n\t\tfibh->soffset = fibh->eoffset - sb->s_blocksize;\n\t\tfibh->eoffset += nfidlen - sb->s_blocksize;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\tfibh->ebh = udf_bread(dir,\n\t\t\t\tf_pos >> dir->i_sb->s_blocksize_bits, 1, err);\n\t\tif (!fibh->ebh)\n\t\t\tgoto out_err;\n\t\t/* Extents could have been merged, invalidate our position */\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\n\t\tif (!fibh->soffset) {\n\t\t\t/* Find the freshly allocated block */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t\tfi = (struct fileIdentDesc *)(fibh->sbh->b_data);\n\t\t} else {\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + sb->s_blocksize +\n\t\t\t\t\tfibh->soffset);\n\t\t}\n\t}\n\n\tmemset(cfi, 0, sizeof(struct fileIdentDesc));\n\tif (UDF_SB(sb)->s_udfrev >= 0x0200)\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 3, 1, block,\n\t\t\t    sizeof(struct tag));\n\telse\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 2, 1, block,\n\t\t\t    sizeof(struct tag));\n\tcfi->fileVersionNum = cpu_to_le16(1);\n\tcfi->lengthFileIdent = namelen;\n\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL, name)) {\n\t\tdir->i_size += nfidlen;\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tdinfo->i_lenAlloc += nfidlen;\n\t\telse {\n\t\t\t/* Find the last extent and truncate it to proper size */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\telen -= dinfo->i_lenExtents - dir->i_size;\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\t\tdinfo->i_lenExtents = dir->i_size;\n\t\t}\n\n\t\tmark_inode_dirty(dir);\n\t\tgoto out_ok;\n\t} else {\n\t\t*err = -EIO;\n\t\tgoto out_err;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(name);\n\treturn fi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "old_inode->i_sb",
            "&tloc",
            "0"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lelb_to_cpu",
          "args": [
            "dir_fi->icb.extLocation"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "lelb_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfend.h",
          "lines": "7-15",
          "snippet": "static inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}",
          "includes": [
            "#include <linux/string.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string.h>\n#include <asm/byteorder.h>\n\nstatic inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_fileident",
          "args": [
            "dir_bh->b_data",
            "old_inode->i_sb->s_blocksize",
            "&offset"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_fileident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/directory.c",
          "lines": "157-196",
          "snippet": "struct fileIdentDesc *udf_get_fileident(void *buffer, int bufsize, int *offset)\n{\n\tstruct fileIdentDesc *fi;\n\tint lengthThisIdent;\n\tuint8_t *ptr;\n\tint padlen;\n\n\tif ((!buffer) || (!offset)) {\n\t\tudf_debug(\"invalidparms, buffer=%p, offset=%p\\n\",\n\t\t\t  buffer, offset);\n\t\treturn NULL;\n\t}\n\n\tptr = buffer;\n\n\tif ((*offset > 0) && (*offset < bufsize))\n\t\tptr += *offset;\n\tfi = (struct fileIdentDesc *)ptr;\n\tif (fi->descTag.tagIdent != cpu_to_le16(TAG_IDENT_FID)) {\n\t\tudf_debug(\"0x%x != TAG_IDENT_FID\\n\",\n\t\t\t  le16_to_cpu(fi->descTag.tagIdent));\n\t\tudf_debug(\"offset: %u sizeof: %lu bufsize: %u\\n\",\n\t\t\t  *offset, (unsigned long)sizeof(struct fileIdentDesc),\n\t\t\t  bufsize);\n\t\treturn NULL;\n\t}\n\tif ((*offset + sizeof(struct fileIdentDesc)) > bufsize)\n\t\tlengthThisIdent = sizeof(struct fileIdentDesc);\n\telse\n\t\tlengthThisIdent = sizeof(struct fileIdentDesc) +\n\t\t\tfi->lengthFileIdent + le16_to_cpu(fi->lengthOfImpUse);\n\n\t/* we need to figure padding, too! */\n\tpadlen = lengthThisIdent % UDF_NAME_PAD;\n\tif (padlen)\n\t\tlengthThisIdent += (UDF_NAME_PAD - padlen);\n\t*offset = *offset + lengthThisIdent;\n\n\treturn fi;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstruct fileIdentDesc *udf_get_fileident(void *buffer, int bufsize, int *offset)\n{\n\tstruct fileIdentDesc *fi;\n\tint lengthThisIdent;\n\tuint8_t *ptr;\n\tint padlen;\n\n\tif ((!buffer) || (!offset)) {\n\t\tudf_debug(\"invalidparms, buffer=%p, offset=%p\\n\",\n\t\t\t  buffer, offset);\n\t\treturn NULL;\n\t}\n\n\tptr = buffer;\n\n\tif ((*offset > 0) && (*offset < bufsize))\n\t\tptr += *offset;\n\tfi = (struct fileIdentDesc *)ptr;\n\tif (fi->descTag.tagIdent != cpu_to_le16(TAG_IDENT_FID)) {\n\t\tudf_debug(\"0x%x != TAG_IDENT_FID\\n\",\n\t\t\t  le16_to_cpu(fi->descTag.tagIdent));\n\t\tudf_debug(\"offset: %u sizeof: %lu bufsize: %u\\n\",\n\t\t\t  *offset, (unsigned long)sizeof(struct fileIdentDesc),\n\t\t\t  bufsize);\n\t\treturn NULL;\n\t}\n\tif ((*offset + sizeof(struct fileIdentDesc)) > bufsize)\n\t\tlengthThisIdent = sizeof(struct fileIdentDesc);\n\telse\n\t\tlengthThisIdent = sizeof(struct fileIdentDesc) +\n\t\t\tfi->lengthFileIdent + le16_to_cpu(fi->lengthOfImpUse);\n\n\t/* we need to figure padding, too! */\n\tpadlen = lengthThisIdent % UDF_NAME_PAD;\n\tif (padlen)\n\t\tlengthThisIdent += (UDF_NAME_PAD - padlen);\n\t*offset = *offset + lengthThisIdent;\n\n\treturn fi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_bread",
          "args": [
            "old_inode",
            "0",
            "0",
            "&retval"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "udf_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "1184-1205",
          "snippet": "struct buffer_head *udf_bread(struct inode *inode, int block,\n\t\t\t      int create, int *err)\n{\n\tstruct buffer_head *bh = NULL;\n\n\tbh = udf_getblk(inode, block, create, err);\n\tif (!bh)\n\t\treturn NULL;\n\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\n\tll_rw_block(READ, 1, &bh);\n\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\n\tbrelse(bh);\n\t*err = -EIO;\n\treturn NULL;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\nstruct buffer_head *udf_bread(struct inode *inode, int block,\n\t\t\t      int create, int *err)\n{\n\tstruct buffer_head *bh = NULL;\n\n\tbh = udf_getblk(inode, block, create, err);\n\tif (!bh)\n\t\treturn NULL;\n\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\n\tll_rw_block(READ, 1, &bh);\n\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\n\tbrelse(bh);\n\t*err = -EIO;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "empty_dir",
          "args": [
            "new_inode"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "698-765",
          "snippet": "static int empty_dir(struct inode *dir)\n{\n\tstruct fileIdentDesc *fi, cfi;\n\tstruct udf_fileident_bh fibh;\n\tloff_t f_pos;\n\tloff_t size = udf_ext0_offset(dir) + dir->i_size;\n\tint block;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\n\tf_pos = udf_ext0_offset(dir);\n\tfibh.soffset = fibh.eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tfibh.sbh = fibh.ebh = NULL;\n\telse if (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits,\n\t\t\t      &epos, &eloc, &elen, &offset) ==\n\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30)) {\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh.sbh = fibh.ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh.sbh) {\n\t\t\tbrelse(epos.bh);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tbrelse(epos.bh);\n\t\treturn 0;\n\t}\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, &fibh, &cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi) {\n\t\t\tif (fibh.sbh != fibh.ebh)\n\t\t\t\tbrelse(fibh.ebh);\n\t\t\tbrelse(fibh.sbh);\n\t\t\tbrelse(epos.bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (cfi.lengthFileIdent &&\n\t\t    (cfi.fileCharacteristics & FID_FILE_CHAR_DELETED) == 0) {\n\t\t\tif (fibh.sbh != fibh.ebh)\n\t\t\t\tbrelse(fibh.ebh);\n\t\t\tbrelse(fibh.sbh);\n\t\t\tbrelse(epos.bh);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\tbrelse(epos.bh);\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic int empty_dir(struct inode *dir)\n{\n\tstruct fileIdentDesc *fi, cfi;\n\tstruct udf_fileident_bh fibh;\n\tloff_t f_pos;\n\tloff_t size = udf_ext0_offset(dir) + dir->i_size;\n\tint block;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\n\tf_pos = udf_ext0_offset(dir);\n\tfibh.soffset = fibh.eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tfibh.sbh = fibh.ebh = NULL;\n\telse if (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits,\n\t\t\t      &epos, &eloc, &elen, &offset) ==\n\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30)) {\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh.sbh = fibh.ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh.sbh) {\n\t\t\tbrelse(epos.bh);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tbrelse(epos.bh);\n\t\treturn 0;\n\t}\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, &fibh, &cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi) {\n\t\t\tif (fibh.sbh != fibh.ebh)\n\t\t\t\tbrelse(fibh.ebh);\n\t\t\tbrelse(fibh.sbh);\n\t\t\tbrelse(epos.bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (cfi.lengthFileIdent &&\n\t\t    (cfi.fileCharacteristics & FID_FILE_CHAR_DELETED) == 0) {\n\t\t\tif (fibh.sbh != fibh.ebh)\n\t\t\t\tbrelse(fibh.ebh);\n\t\t\tbrelse(fibh.sbh);\n\t\t\tbrelse(epos.bh);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\tbrelse(epos.bh);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_ext0_offset",
          "args": [
            "old_inode"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "udf_ext0_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "66-72",
          "snippet": "static inline size_t udf_ext0_offset(struct inode *inode)\n{\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\treturn udf_file_entry_alloc_offset(inode);\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_ext0_offset(struct inode *inode)\n{\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\treturn udf_file_entry_alloc_offset(inode);\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode->i_mode"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic int udf_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t      struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct udf_fileident_bh ofibh, nfibh;\n\tstruct fileIdentDesc *ofi = NULL, *nfi = NULL, *dir_fi = NULL;\n\tstruct fileIdentDesc ocfi, ncfi;\n\tstruct buffer_head *dir_bh = NULL;\n\tint retval = -ENOENT;\n\tstruct kernel_lb_addr tloc;\n\tstruct udf_inode_info *old_iinfo = UDF_I(old_inode);\n\n\tofi = udf_find_entry(old_dir, &old_dentry->d_name, &ofibh, &ocfi);\n\tif (ofi) {\n\t\tif (ofibh.sbh != ofibh.ebh)\n\t\t\tbrelse(ofibh.ebh);\n\t\tbrelse(ofibh.sbh);\n\t}\n\ttloc = lelb_to_cpu(ocfi.icb.extLocation);\n\tif (!ofi || udf_get_lb_pblock(old_dir->i_sb, &tloc, 0)\n\t    != old_inode->i_ino)\n\t\tgoto end_rename;\n\n\tnfi = udf_find_entry(new_dir, &new_dentry->d_name, &nfibh, &ncfi);\n\tif (nfi) {\n\t\tif (!new_inode) {\n\t\t\tif (nfibh.sbh != nfibh.ebh)\n\t\t\t\tbrelse(nfibh.ebh);\n\t\t\tbrelse(nfibh.sbh);\n\t\t\tnfi = NULL;\n\t\t}\n\t}\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\tint offset = udf_ext0_offset(old_inode);\n\n\t\tif (new_inode) {\n\t\t\tretval = -ENOTEMPTY;\n\t\t\tif (!empty_dir(new_inode))\n\t\t\t\tgoto end_rename;\n\t\t}\n\t\tretval = -EIO;\n\t\tif (old_iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tdir_fi = udf_get_fileident(\n\t\t\t\t\told_iinfo->i_ext.i_data -\n\t\t\t\t\t  (old_iinfo->i_efe ?\n\t\t\t\t\t   sizeof(struct extendedFileEntry) :\n\t\t\t\t\t   sizeof(struct fileEntry)),\n\t\t\t\t\told_inode->i_sb->s_blocksize, &offset);\n\t\t} else {\n\t\t\tdir_bh = udf_bread(old_inode, 0, 0, &retval);\n\t\t\tif (!dir_bh)\n\t\t\t\tgoto end_rename;\n\t\t\tdir_fi = udf_get_fileident(dir_bh->b_data,\n\t\t\t\t\told_inode->i_sb->s_blocksize, &offset);\n\t\t}\n\t\tif (!dir_fi)\n\t\t\tgoto end_rename;\n\t\ttloc = lelb_to_cpu(dir_fi->icb.extLocation);\n\t\tif (udf_get_lb_pblock(old_inode->i_sb, &tloc, 0) !=\n\t\t\t\told_dir->i_ino)\n\t\t\tgoto end_rename;\n\t}\n\tif (!nfi) {\n\t\tnfi = udf_add_entry(new_dir, new_dentry, &nfibh, &ncfi,\n\t\t\t\t    &retval);\n\t\tif (!nfi)\n\t\t\tgoto end_rename;\n\t}\n\n\t/*\n\t * Like most other Unix systems, set the ctime for inodes on a\n\t * rename.\n\t */\n\told_inode->i_ctime = current_fs_time(old_inode->i_sb);\n\tmark_inode_dirty(old_inode);\n\n\t/*\n\t * ok, that's it\n\t */\n\tncfi.fileVersionNum = ocfi.fileVersionNum;\n\tncfi.fileCharacteristics = ocfi.fileCharacteristics;\n\tmemcpy(&(ncfi.icb), &(ocfi.icb), sizeof(struct long_ad));\n\tudf_write_fi(new_dir, &ncfi, nfi, &nfibh, NULL, NULL);\n\n\t/* The old fid may have moved - find it again */\n\tofi = udf_find_entry(old_dir, &old_dentry->d_name, &ofibh, &ocfi);\n\tudf_delete_entry(old_dir, ofi, &ofibh, &ocfi);\n\n\tif (new_inode) {\n\t\tnew_inode->i_ctime = current_fs_time(new_inode->i_sb);\n\t\tinode_dec_link_count(new_inode);\n\t}\n\told_dir->i_ctime = old_dir->i_mtime = current_fs_time(old_dir->i_sb);\n\tmark_inode_dirty(old_dir);\n\n\tif (dir_fi) {\n\t\tdir_fi->icb.extLocation = cpu_to_lelb(UDF_I(new_dir)->i_location);\n\t\tudf_update_tag((char *)dir_fi,\n\t\t\t\t(sizeof(struct fileIdentDesc) +\n\t\t\t\tle16_to_cpu(dir_fi->lengthOfImpUse) + 3) & ~3);\n\t\tif (old_iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tmark_inode_dirty(old_inode);\n\t\telse\n\t\t\tmark_buffer_dirty_inode(dir_bh, old_inode);\n\n\t\tinode_dec_link_count(old_dir);\n\t\tif (new_inode)\n\t\t\tinode_dec_link_count(new_inode);\n\t\telse {\n\t\t\tinc_nlink(new_dir);\n\t\t\tmark_inode_dirty(new_dir);\n\t\t}\n\t}\n\n\tif (ofi) {\n\t\tif (ofibh.sbh != ofibh.ebh)\n\t\t\tbrelse(ofibh.ebh);\n\t\tbrelse(ofibh.sbh);\n\t}\n\n\tretval = 0;\n\nend_rename:\n\tbrelse(dir_bh);\n\tif (nfi) {\n\t\tif (nfibh.sbh != nfibh.ebh)\n\t\t\tbrelse(nfibh.ebh);\n\t\tbrelse(nfibh.sbh);\n\t}\n\n\treturn retval;\n}"
  },
  {
    "function_name": "udf_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "999-1031",
    "snippet": "static int udf_link(struct dentry *old_dentry, struct inode *dir,\n\t\t    struct dentry *dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tstruct udf_fileident_bh fibh;\n\tstruct fileIdentDesc cfi, *fi;\n\tint err;\n\n\tfi = udf_add_entry(dir, dentry, &fibh, &cfi, &err);\n\tif (!fi) {\n\t\treturn err;\n\t}\n\tcfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\tcfi.icb.extLocation = cpu_to_lelb(UDF_I(inode)->i_location);\n\tif (UDF_SB(inode->i_sb)->s_lvid_bh) {\n\t\t*(__le32 *)((struct allocDescImpUse *)cfi.icb.impUse)->impUse =\n\t\t\tcpu_to_le32(lvid_get_unique_id(inode->i_sb));\n\t}\n\tudf_write_fi(dir, &cfi, fi, &fibh, NULL, NULL);\n\tif (UDF_I(dir)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tmark_inode_dirty(dir);\n\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\tinc_nlink(inode);\n\tinode->i_ctime = current_fs_time(inode->i_sb);\n\tmark_inode_dirty(inode);\n\tihold(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "inode->i_sb"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "fibh.sbh"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "dir"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_write_fi",
          "args": [
            "dir",
            "&cfi",
            "fi",
            "&fibh",
            "NULL",
            "NULL"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_fi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "44-140",
          "snippet": "int udf_write_fi(struct inode *inode, struct fileIdentDesc *cfi,\n\t\t struct fileIdentDesc *sfi, struct udf_fileident_bh *fibh,\n\t\t uint8_t *impuse, uint8_t *fileident)\n{\n\tuint16_t crclen = fibh->eoffset - fibh->soffset - sizeof(struct tag);\n\tuint16_t crc;\n\tint offset;\n\tuint16_t liu = le16_to_cpu(cfi->lengthOfImpUse);\n\tuint8_t lfi = cfi->lengthFileIdent;\n\tint padlen = fibh->eoffset - fibh->soffset - liu - lfi -\n\t\tsizeof(struct fileIdentDesc);\n\tint adinicb = 0;\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tadinicb = 1;\n\n\toffset = fibh->soffset + sizeof(struct fileIdentDesc);\n\n\tif (impuse) {\n\t\tif (adinicb || (offset + liu < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, liu);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, impuse, liu);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, -offset);\n\t\t\tmemcpy(fibh->ebh->b_data, impuse - offset,\n\t\t\t\tliu + offset);\n\t\t}\n\t}\n\n\toffset += liu;\n\n\tif (fileident) {\n\t\tif (adinicb || (offset + lfi < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident, lfi);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, fileident, lfi);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident,\n\t\t\t\t-offset);\n\t\t\tmemcpy(fibh->ebh->b_data, fileident - offset,\n\t\t\t\tlfi + offset);\n\t\t}\n\t}\n\n\toffset += lfi;\n\n\tif (adinicb || (offset + padlen < 0)) {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, padlen);\n\t} else if (offset >= 0) {\n\t\tmemset(fibh->ebh->b_data + offset, 0x00, padlen);\n\t} else {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, -offset);\n\t\tmemset(fibh->ebh->b_data, 0x00, padlen + offset);\n\t}\n\n\tcrc = crc_itu_t(0, (uint8_t *)cfi + sizeof(struct tag),\n\t\t      sizeof(struct fileIdentDesc) - sizeof(struct tag));\n\n\tif (fibh->sbh == fibh->ebh) {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t      sizeof(struct fileIdentDesc));\n\t} else if (sizeof(struct fileIdentDesc) >= -fibh->soffset) {\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data +\n\t\t\t\t\tsizeof(struct fileIdentDesc) +\n\t\t\t\t\tfibh->soffset,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      -fibh->soffset - sizeof(struct fileIdentDesc));\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data, fibh->eoffset);\n\t}\n\n\tcfi->descTag.descCRC = cpu_to_le16(crc);\n\tcfi->descTag.descCRCLength = cpu_to_le16(crclen);\n\tcfi->descTag.tagChecksum = udf_tag_checksum(&cfi->descTag);\n\n\tif (adinicb || (sizeof(struct fileIdentDesc) <= -fibh->soffset)) {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi,\n\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi, -fibh->soffset);\n\t\tmemcpy(fibh->ebh->b_data, (uint8_t *)cfi - fibh->soffset,\n\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\t}\n\n\tif (adinicb) {\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tmark_buffer_dirty_inode(fibh->ebh, inode);\n\t\tmark_buffer_dirty_inode(fibh->sbh, inode);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nint udf_write_fi(struct inode *inode, struct fileIdentDesc *cfi,\n\t\t struct fileIdentDesc *sfi, struct udf_fileident_bh *fibh,\n\t\t uint8_t *impuse, uint8_t *fileident)\n{\n\tuint16_t crclen = fibh->eoffset - fibh->soffset - sizeof(struct tag);\n\tuint16_t crc;\n\tint offset;\n\tuint16_t liu = le16_to_cpu(cfi->lengthOfImpUse);\n\tuint8_t lfi = cfi->lengthFileIdent;\n\tint padlen = fibh->eoffset - fibh->soffset - liu - lfi -\n\t\tsizeof(struct fileIdentDesc);\n\tint adinicb = 0;\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tadinicb = 1;\n\n\toffset = fibh->soffset + sizeof(struct fileIdentDesc);\n\n\tif (impuse) {\n\t\tif (adinicb || (offset + liu < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, liu);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, impuse, liu);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, -offset);\n\t\t\tmemcpy(fibh->ebh->b_data, impuse - offset,\n\t\t\t\tliu + offset);\n\t\t}\n\t}\n\n\toffset += liu;\n\n\tif (fileident) {\n\t\tif (adinicb || (offset + lfi < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident, lfi);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, fileident, lfi);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident,\n\t\t\t\t-offset);\n\t\t\tmemcpy(fibh->ebh->b_data, fileident - offset,\n\t\t\t\tlfi + offset);\n\t\t}\n\t}\n\n\toffset += lfi;\n\n\tif (adinicb || (offset + padlen < 0)) {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, padlen);\n\t} else if (offset >= 0) {\n\t\tmemset(fibh->ebh->b_data + offset, 0x00, padlen);\n\t} else {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, -offset);\n\t\tmemset(fibh->ebh->b_data, 0x00, padlen + offset);\n\t}\n\n\tcrc = crc_itu_t(0, (uint8_t *)cfi + sizeof(struct tag),\n\t\t      sizeof(struct fileIdentDesc) - sizeof(struct tag));\n\n\tif (fibh->sbh == fibh->ebh) {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t      sizeof(struct fileIdentDesc));\n\t} else if (sizeof(struct fileIdentDesc) >= -fibh->soffset) {\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data +\n\t\t\t\t\tsizeof(struct fileIdentDesc) +\n\t\t\t\t\tfibh->soffset,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      -fibh->soffset - sizeof(struct fileIdentDesc));\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data, fibh->eoffset);\n\t}\n\n\tcfi->descTag.descCRC = cpu_to_le16(crc);\n\tcfi->descTag.descCRCLength = cpu_to_le16(crclen);\n\tcfi->descTag.tagChecksum = udf_tag_checksum(&cfi->descTag);\n\n\tif (adinicb || (sizeof(struct fileIdentDesc) <= -fibh->soffset)) {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi,\n\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi, -fibh->soffset);\n\t\tmemcpy(fibh->ebh->b_data, (uint8_t *)cfi - fibh->soffset,\n\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\t}\n\n\tif (adinicb) {\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tmark_buffer_dirty_inode(fibh->ebh, inode);\n\t\tmark_buffer_dirty_inode(fibh->sbh, inode);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lvid_get_unique_id(inode->i_sb)"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lvid_get_unique_id",
          "args": [
            "inode->i_sb"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "lvid_get_unique_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2034-2059",
          "snippet": "u64 lvid_get_unique_id(struct super_block *sb)\n{\n\tstruct buffer_head *bh;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolHeaderDesc *lvhd;\n\tu64 uniqueID;\n\tu64 ret;\n\n\tbh = sbi->s_lvid_bh;\n\tif (!bh)\n\t\treturn 0;\n\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvhd = (struct logicalVolHeaderDesc *)lvid->logicalVolContentsUse;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tret = uniqueID = le64_to_cpu(lvhd->uniqueID);\n\tif (!(++uniqueID & 0xFFFFFFFF))\n\t\tuniqueID += 16;\n\tlvhd->uniqueID = cpu_to_le64(uniqueID);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\tmark_buffer_dirty(bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nu64 lvid_get_unique_id(struct super_block *sb)\n{\n\tstruct buffer_head *bh;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolHeaderDesc *lvhd;\n\tu64 uniqueID;\n\tu64 ret;\n\n\tbh = sbi->s_lvid_bh;\n\tif (!bh)\n\t\treturn 0;\n\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvhd = (struct logicalVolHeaderDesc *)lvid->logicalVolContentsUse;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tret = uniqueID = le64_to_cpu(lvhd->uniqueID);\n\tif (!(++uniqueID & 0xFFFFFFFF))\n\t\tuniqueID += 16;\n\tlvhd->uniqueID = cpu_to_le64(uniqueID);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\tmark_buffer_dirty(bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_lelb",
          "args": [
            "UDF_I(inode)->i_location"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_lelb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfend.h",
          "lines": "17-25",
          "snippet": "static inline struct lb_addr cpu_to_lelb(struct kernel_lb_addr in)\n{\n\tstruct lb_addr out;\n\n\tout.logicalBlockNum = cpu_to_le32(in.logicalBlockNum);\n\tout.partitionReferenceNum = cpu_to_le16(in.partitionReferenceNum);\n\n\treturn out;\n}",
          "includes": [
            "#include <linux/string.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string.h>\n#include <asm/byteorder.h>\n\nstatic inline struct lb_addr cpu_to_lelb(struct kernel_lb_addr in)\n{\n\tstruct lb_addr out;\n\n\tout.logicalBlockNum = cpu_to_le32(in.logicalBlockNum);\n\tout.partitionReferenceNum = cpu_to_le16(in.partitionReferenceNum);\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_sb->s_blocksize"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_add_entry",
          "args": [
            "dir",
            "dentry",
            "&fibh",
            "&cfi",
            "&err"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "udf_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "295-538",
          "snippet": "static struct fileIdentDesc *udf_add_entry(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   struct udf_fileident_bh *fibh,\n\t\t\t\t\t   struct fileIdentDesc *cfi, int *err)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fileIdentDesc *fi = NULL;\n\tunsigned char *name = NULL;\n\tint namelen;\n\tloff_t f_pos;\n\tloff_t size = udf_ext0_offset(dir) + dir->i_size;\n\tint nfidlen;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tint block;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen = 0;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo;\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!name) {\n\t\t*err = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tif (dentry) {\n\t\tif (!dentry->d_name.len) {\n\t\t\t*err = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t\tnamelen = udf_put_filename(sb, dentry->d_name.name, name,\n\t\t\t\t\t\t dentry->d_name.len);\n\t\tif (!namelen) {\n\t\t\t*err = -ENAMETOOLONG;\n\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\tnamelen = 0;\n\t}\n\n\tnfidlen = (sizeof(struct fileIdentDesc) + namelen + 3) & ~3;\n\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\tdinfo = UDF_I(dir);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tblock = udf_get_lb_pblock(dir->i_sb,\n\t\t\t\t\t&dinfo->i_location, 0);\n\t\t\tfibh->soffset = fibh->eoffset = sb->s_blocksize;\n\t\t\tgoto add;\n\t\t}\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tblock = dinfo->i_location.logicalBlockNum;\n\t}\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\n\t\tif (!fi) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (((sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi + 3) & ~3) == nfidlen) {\n\t\t\t\tcfi->descTag.tagSerialNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileVersionNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileCharacteristics = 0;\n\t\t\t\tcfi->lengthFileIdent = namelen;\n\t\t\t\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\t\t\t\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL,\n\t\t\t\t\t\t  name))\n\t\t\t\t\tgoto out_ok;\n\t\t\t\telse {\n\t\t\t\t\t*err = -EIO;\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nadd:\n\tf_pos += nfidlen;\n\n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB &&\n\t    sb->s_blocksize - fibh->eoffset < nfidlen) {\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tfibh->soffset -= udf_ext0_offset(dir);\n\t\tfibh->eoffset -= udf_ext0_offset(dir);\n\t\tf_pos -= udf_ext0_offset(dir);\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tbrelse(fibh->ebh);\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh =\n\t\t\t\tudf_expand_dir_adinicb(dir, &block, err);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\t\t/* Load extent udf_expand_dir_adinicb() has created */\n\t\tudf_current_aext(dir, &epos, &eloc, &elen, 1);\n\t}\n\n\t/* Entry fits into current block? */\n\tif (sb->s_blocksize - fibh->eoffset >= nfidlen) {\n\t\tfibh->soffset = fibh->eoffset;\n\t\tfibh->eoffset += nfidlen;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tblock = dinfo->i_location.logicalBlockNum;\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t\t(dinfo->i_ext.i_data +\n\t\t\t\t\t fibh->soffset -\n\t\t\t\t\t udf_ext0_offset(dir) +\n\t\t\t\t\t dinfo->i_lenEAttr);\n\t\t} else {\n\t\t\tblock = eloc.logicalBlockNum +\n\t\t\t\t\t((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + fibh->soffset);\n\t\t}\n\t} else {\n\t\t/* Round up last extent in the file */\n\t\telen = (elen + sb->s_blocksize - 1) & ~(sb->s_blocksize - 1);\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\tdinfo->i_lenExtents = (dinfo->i_lenExtents + sb->s_blocksize\n\t\t\t\t\t- 1) & ~(sb->s_blocksize - 1);\n\n\t\tfibh->soffset = fibh->eoffset - sb->s_blocksize;\n\t\tfibh->eoffset += nfidlen - sb->s_blocksize;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\tfibh->ebh = udf_bread(dir,\n\t\t\t\tf_pos >> dir->i_sb->s_blocksize_bits, 1, err);\n\t\tif (!fibh->ebh)\n\t\t\tgoto out_err;\n\t\t/* Extents could have been merged, invalidate our position */\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\n\t\tif (!fibh->soffset) {\n\t\t\t/* Find the freshly allocated block */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t\tfi = (struct fileIdentDesc *)(fibh->sbh->b_data);\n\t\t} else {\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + sb->s_blocksize +\n\t\t\t\t\tfibh->soffset);\n\t\t}\n\t}\n\n\tmemset(cfi, 0, sizeof(struct fileIdentDesc));\n\tif (UDF_SB(sb)->s_udfrev >= 0x0200)\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 3, 1, block,\n\t\t\t    sizeof(struct tag));\n\telse\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 2, 1, block,\n\t\t\t    sizeof(struct tag));\n\tcfi->fileVersionNum = cpu_to_le16(1);\n\tcfi->lengthFileIdent = namelen;\n\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL, name)) {\n\t\tdir->i_size += nfidlen;\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tdinfo->i_lenAlloc += nfidlen;\n\t\telse {\n\t\t\t/* Find the last extent and truncate it to proper size */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\telen -= dinfo->i_lenExtents - dir->i_size;\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\t\tdinfo->i_lenExtents = dir->i_size;\n\t\t}\n\n\t\tmark_inode_dirty(dir);\n\t\tgoto out_ok;\n\t} else {\n\t\t*err = -EIO;\n\t\tgoto out_err;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(name);\n\treturn fi;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic struct fileIdentDesc *udf_add_entry(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   struct udf_fileident_bh *fibh,\n\t\t\t\t\t   struct fileIdentDesc *cfi, int *err)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fileIdentDesc *fi = NULL;\n\tunsigned char *name = NULL;\n\tint namelen;\n\tloff_t f_pos;\n\tloff_t size = udf_ext0_offset(dir) + dir->i_size;\n\tint nfidlen;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tint block;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen = 0;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo;\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!name) {\n\t\t*err = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tif (dentry) {\n\t\tif (!dentry->d_name.len) {\n\t\t\t*err = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t\tnamelen = udf_put_filename(sb, dentry->d_name.name, name,\n\t\t\t\t\t\t dentry->d_name.len);\n\t\tif (!namelen) {\n\t\t\t*err = -ENAMETOOLONG;\n\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\tnamelen = 0;\n\t}\n\n\tnfidlen = (sizeof(struct fileIdentDesc) + namelen + 3) & ~3;\n\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\tdinfo = UDF_I(dir);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tblock = udf_get_lb_pblock(dir->i_sb,\n\t\t\t\t\t&dinfo->i_location, 0);\n\t\t\tfibh->soffset = fibh->eoffset = sb->s_blocksize;\n\t\t\tgoto add;\n\t\t}\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tblock = dinfo->i_location.logicalBlockNum;\n\t}\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\n\t\tif (!fi) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (((sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi + 3) & ~3) == nfidlen) {\n\t\t\t\tcfi->descTag.tagSerialNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileVersionNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileCharacteristics = 0;\n\t\t\t\tcfi->lengthFileIdent = namelen;\n\t\t\t\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\t\t\t\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL,\n\t\t\t\t\t\t  name))\n\t\t\t\t\tgoto out_ok;\n\t\t\t\telse {\n\t\t\t\t\t*err = -EIO;\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nadd:\n\tf_pos += nfidlen;\n\n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB &&\n\t    sb->s_blocksize - fibh->eoffset < nfidlen) {\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tfibh->soffset -= udf_ext0_offset(dir);\n\t\tfibh->eoffset -= udf_ext0_offset(dir);\n\t\tf_pos -= udf_ext0_offset(dir);\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tbrelse(fibh->ebh);\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh =\n\t\t\t\tudf_expand_dir_adinicb(dir, &block, err);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\t\t/* Load extent udf_expand_dir_adinicb() has created */\n\t\tudf_current_aext(dir, &epos, &eloc, &elen, 1);\n\t}\n\n\t/* Entry fits into current block? */\n\tif (sb->s_blocksize - fibh->eoffset >= nfidlen) {\n\t\tfibh->soffset = fibh->eoffset;\n\t\tfibh->eoffset += nfidlen;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tblock = dinfo->i_location.logicalBlockNum;\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t\t(dinfo->i_ext.i_data +\n\t\t\t\t\t fibh->soffset -\n\t\t\t\t\t udf_ext0_offset(dir) +\n\t\t\t\t\t dinfo->i_lenEAttr);\n\t\t} else {\n\t\t\tblock = eloc.logicalBlockNum +\n\t\t\t\t\t((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + fibh->soffset);\n\t\t}\n\t} else {\n\t\t/* Round up last extent in the file */\n\t\telen = (elen + sb->s_blocksize - 1) & ~(sb->s_blocksize - 1);\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\tdinfo->i_lenExtents = (dinfo->i_lenExtents + sb->s_blocksize\n\t\t\t\t\t- 1) & ~(sb->s_blocksize - 1);\n\n\t\tfibh->soffset = fibh->eoffset - sb->s_blocksize;\n\t\tfibh->eoffset += nfidlen - sb->s_blocksize;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\tfibh->ebh = udf_bread(dir,\n\t\t\t\tf_pos >> dir->i_sb->s_blocksize_bits, 1, err);\n\t\tif (!fibh->ebh)\n\t\t\tgoto out_err;\n\t\t/* Extents could have been merged, invalidate our position */\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\n\t\tif (!fibh->soffset) {\n\t\t\t/* Find the freshly allocated block */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t\tfi = (struct fileIdentDesc *)(fibh->sbh->b_data);\n\t\t} else {\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + sb->s_blocksize +\n\t\t\t\t\tfibh->soffset);\n\t\t}\n\t}\n\n\tmemset(cfi, 0, sizeof(struct fileIdentDesc));\n\tif (UDF_SB(sb)->s_udfrev >= 0x0200)\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 3, 1, block,\n\t\t\t    sizeof(struct tag));\n\telse\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 2, 1, block,\n\t\t\t    sizeof(struct tag));\n\tcfi->fileVersionNum = cpu_to_le16(1);\n\tcfi->lengthFileIdent = namelen;\n\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL, name)) {\n\t\tdir->i_size += nfidlen;\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tdinfo->i_lenAlloc += nfidlen;\n\t\telse {\n\t\t\t/* Find the last extent and truncate it to proper size */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\telen -= dinfo->i_lenExtents - dir->i_size;\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\t\tdinfo->i_lenExtents = dir->i_size;\n\t\t}\n\n\t\tmark_inode_dirty(dir);\n\t\tgoto out_ok;\n\t} else {\n\t\t*err = -EIO;\n\t\tgoto out_err;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(name);\n\treturn fi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic int udf_link(struct dentry *old_dentry, struct inode *dir,\n\t\t    struct dentry *dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tstruct udf_fileident_bh fibh;\n\tstruct fileIdentDesc cfi, *fi;\n\tint err;\n\n\tfi = udf_add_entry(dir, dentry, &fibh, &cfi, &err);\n\tif (!fi) {\n\t\treturn err;\n\t}\n\tcfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\tcfi.icb.extLocation = cpu_to_lelb(UDF_I(inode)->i_location);\n\tif (UDF_SB(inode->i_sb)->s_lvid_bh) {\n\t\t*(__le32 *)((struct allocDescImpUse *)cfi.icb.impUse)->impUse =\n\t\t\tcpu_to_le32(lvid_get_unique_id(inode->i_sb));\n\t}\n\tudf_write_fi(dir, &cfi, fi, &fibh, NULL, NULL);\n\tif (UDF_I(dir)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tmark_inode_dirty(dir);\n\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\tinc_nlink(inode);\n\tinode->i_ctime = current_fs_time(inode->i_sb);\n\tmark_inode_dirty(inode);\n\tihold(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "851-997",
    "snippet": "static int udf_symlink(struct inode *dir, struct dentry *dentry,\n\t\t       const char *symname)\n{\n\tstruct inode *inode = udf_new_inode(dir, S_IFLNK | S_IRWXUGO);\n\tstruct pathComponent *pc;\n\tconst char *compstart;\n\tstruct extent_position epos = {};\n\tint eoffset, elen = 0;\n\tuint8_t *ea;\n\tint err;\n\tint block;\n\tunsigned char *name = NULL;\n\tint namelen;\n\tstruct udf_inode_info *iinfo;\n\tstruct super_block *sb = dir->i_sb;\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tiinfo = UDF_I(inode);\n\tdown_write(&iinfo->i_data_sem);\n\tname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!name) {\n\t\terr = -ENOMEM;\n\t\tgoto out_no_entry;\n\t}\n\n\tinode->i_data.a_ops = &udf_symlink_aops;\n\tinode->i_op = &udf_symlink_inode_operations;\n\n\tif (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tstruct kernel_lb_addr eloc;\n\t\tuint32_t bsize;\n\n\t\tblock = udf_new_block(sb, inode,\n\t\t\t\tiinfo->i_location.partitionReferenceNum,\n\t\t\t\tiinfo->i_location.logicalBlockNum, &err);\n\t\tif (!block)\n\t\t\tgoto out_no_entry;\n\t\tepos.block = iinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(inode);\n\t\tepos.bh = NULL;\n\t\teloc.logicalBlockNum = block;\n\t\teloc.partitionReferenceNum =\n\t\t\t\tiinfo->i_location.partitionReferenceNum;\n\t\tbsize = sb->s_blocksize;\n\t\tiinfo->i_lenExtents = bsize;\n\t\tudf_add_aext(inode, &epos, &eloc, bsize, 0);\n\t\tbrelse(epos.bh);\n\n\t\tblock = udf_get_pblock(sb, block,\n\t\t\t\tiinfo->i_location.partitionReferenceNum,\n\t\t\t\t0);\n\t\tepos.bh = udf_tgetblk(sb, block);\n\t\tlock_buffer(epos.bh);\n\t\tmemset(epos.bh->b_data, 0x00, bsize);\n\t\tset_buffer_uptodate(epos.bh);\n\t\tunlock_buffer(epos.bh);\n\t\tmark_buffer_dirty_inode(epos.bh, inode);\n\t\tea = epos.bh->b_data + udf_ext0_offset(inode);\n\t} else\n\t\tea = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\n\teoffset = sb->s_blocksize - udf_ext0_offset(inode);\n\tpc = (struct pathComponent *)ea;\n\n\tif (*symname == '/') {\n\t\tdo {\n\t\t\tsymname++;\n\t\t} while (*symname == '/');\n\n\t\tpc->componentType = 1;\n\t\tpc->lengthComponentIdent = 0;\n\t\tpc->componentFileVersionNum = 0;\n\t\telen += sizeof(struct pathComponent);\n\t}\n\n\terr = -ENAMETOOLONG;\n\n\twhile (*symname) {\n\t\tif (elen + sizeof(struct pathComponent) > eoffset)\n\t\t\tgoto out_no_entry;\n\n\t\tpc = (struct pathComponent *)(ea + elen);\n\n\t\tcompstart = symname;\n\n\t\tdo {\n\t\t\tsymname++;\n\t\t} while (*symname && *symname != '/');\n\n\t\tpc->componentType = 5;\n\t\tpc->lengthComponentIdent = 0;\n\t\tpc->componentFileVersionNum = 0;\n\t\tif (compstart[0] == '.') {\n\t\t\tif ((symname - compstart) == 1)\n\t\t\t\tpc->componentType = 4;\n\t\t\telse if ((symname - compstart) == 2 &&\n\t\t\t\t\tcompstart[1] == '.')\n\t\t\t\tpc->componentType = 3;\n\t\t}\n\n\t\tif (pc->componentType == 5) {\n\t\t\tnamelen = udf_put_filename(sb, compstart, name,\n\t\t\t\t\t\t   symname - compstart);\n\t\t\tif (!namelen)\n\t\t\t\tgoto out_no_entry;\n\n\t\t\tif (elen + sizeof(struct pathComponent) + namelen >\n\t\t\t\t\teoffset)\n\t\t\t\tgoto out_no_entry;\n\t\t\telse\n\t\t\t\tpc->lengthComponentIdent = namelen;\n\n\t\t\tmemcpy(pc->componentIdent, name, namelen);\n\t\t}\n\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n\n\t\tif (*symname) {\n\t\t\tdo {\n\t\t\t\tsymname++;\n\t\t\t} while (*symname == '/');\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\tinode->i_size = elen;\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tiinfo->i_lenAlloc = inode->i_size;\n\telse\n\t\tudf_truncate_tail_extent(inode);\n\tmark_inode_dirty(inode);\n\tup_write(&iinfo->i_data_sem);\n\n\terr = udf_add_nondir(dentry, inode);\nout:\n\tkfree(name);\n\treturn err;\n\nout_no_entry:\n\tup_write(&iinfo->i_data_sem);\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tgoto out;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations udf_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_add_nondir",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "udf_add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "552-581",
          "snippet": "static int udf_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct udf_fileident_bh fibh;\n\tstruct fileIdentDesc cfi, *fi;\n\tint err;\n\n\tfi = udf_add_entry(dir, dentry, &fibh, &cfi, &err);\n\tif (unlikely(!fi)) {\n\t\tinode_dec_link_count(inode);\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\treturn err;\n\t}\n\tcfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\tcfi.icb.extLocation = cpu_to_lelb(iinfo->i_location);\n\t*(__le32 *)((struct allocDescImpUse *)cfi.icb.impUse)->impUse =\n\t\tcpu_to_le32(iinfo->i_unique & 0x00000000FFFFFFFFUL);\n\tudf_write_fi(dir, &cfi, fi, &fibh, NULL, NULL);\n\tif (UDF_I(dir)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tmark_inode_dirty(dir);\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic int udf_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct udf_fileident_bh fibh;\n\tstruct fileIdentDesc cfi, *fi;\n\tint err;\n\n\tfi = udf_add_entry(dir, dentry, &fibh, &cfi, &err);\n\tif (unlikely(!fi)) {\n\t\tinode_dec_link_count(inode);\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\treturn err;\n\t}\n\tcfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\tcfi.icb.extLocation = cpu_to_lelb(iinfo->i_location);\n\t*(__le32 *)((struct allocDescImpUse *)cfi.icb.impUse)->impUse =\n\t\tcpu_to_le32(iinfo->i_unique & 0x00000000FFFFFFFFUL);\n\tudf_write_fi(dir, &cfi, fi, &fibh, NULL, NULL);\n\tif (UDF_I(dir)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tmark_inode_dirty(dir);\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_truncate_tail_extent",
          "args": [
            "inode"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "udf_truncate_tail_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/truncate.c",
          "lines": "68-120",
          "snippet": "void udf_truncate_tail_extent(struct inode *inode)\n{\n\tstruct extent_position epos = {};\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen, nelen;\n\tuint64_t lbcount = 0;\n\tint8_t etype = -1, netype;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ||\n\t    inode->i_size == iinfo->i_lenExtents)\n\t\treturn;\n\t/* Are we going to delete the file anyway? */\n\tif (inode->i_nlink == 0)\n\t\treturn;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\t/* Find the last extent in the file */\n\twhile ((netype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tetype = netype;\n\t\tlbcount += elen;\n\t\tif (lbcount > inode->i_size) {\n\t\t\tif (lbcount - inode->i_size >= inode->i_sb->s_blocksize)\n\t\t\t\tudf_warn(inode->i_sb,\n\t\t\t\t\t \"Too long extent after EOF in inode %u: i_size: %lld lbcount: %lld extent %u+%u\\n\",\n\t\t\t\t\t (unsigned)inode->i_ino,\n\t\t\t\t\t (long long)inode->i_size,\n\t\t\t\t\t (long long)lbcount,\n\t\t\t\t\t (unsigned)eloc.logicalBlockNum,\n\t\t\t\t\t (unsigned)elen);\n\t\t\tnelen = elen - (lbcount - inode->i_size);\n\t\t\tepos.offset -= adsize;\n\t\t\textent_trunc(inode, &epos, &eloc, etype, elen, nelen);\n\t\t\tepos.offset += adsize;\n\t\t\tif (udf_next_aext(inode, &epos, &eloc, &elen, 1) != -1)\n\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\"Extent after EOF in inode %u\\n\",\n\t\t\t\t\t(unsigned)inode->i_ino);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* This inode entry is in-memory only and thus we don't have to mark\n\t * the inode dirty */\n\tiinfo->i_lenExtents = inode->i_size;\n\tbrelse(epos.bh);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_truncate_tail_extent(struct inode *inode)\n{\n\tstruct extent_position epos = {};\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen, nelen;\n\tuint64_t lbcount = 0;\n\tint8_t etype = -1, netype;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ||\n\t    inode->i_size == iinfo->i_lenExtents)\n\t\treturn;\n\t/* Are we going to delete the file anyway? */\n\tif (inode->i_nlink == 0)\n\t\treturn;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\t/* Find the last extent in the file */\n\twhile ((netype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tetype = netype;\n\t\tlbcount += elen;\n\t\tif (lbcount > inode->i_size) {\n\t\t\tif (lbcount - inode->i_size >= inode->i_sb->s_blocksize)\n\t\t\t\tudf_warn(inode->i_sb,\n\t\t\t\t\t \"Too long extent after EOF in inode %u: i_size: %lld lbcount: %lld extent %u+%u\\n\",\n\t\t\t\t\t (unsigned)inode->i_ino,\n\t\t\t\t\t (long long)inode->i_size,\n\t\t\t\t\t (long long)lbcount,\n\t\t\t\t\t (unsigned)eloc.logicalBlockNum,\n\t\t\t\t\t (unsigned)elen);\n\t\t\tnelen = elen - (lbcount - inode->i_size);\n\t\t\tepos.offset -= adsize;\n\t\t\textent_trunc(inode, &epos, &eloc, etype, elen, nelen);\n\t\t\tepos.offset += adsize;\n\t\t\tif (udf_next_aext(inode, &epos, &eloc, &elen, 1) != -1)\n\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\"Extent after EOF in inode %u\\n\",\n\t\t\t\t\t(unsigned)inode->i_ino);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* This inode entry is in-memory only and thus we don't have to mark\n\t * the inode dirty */\n\tiinfo->i_lenExtents = inode->i_size;\n\tbrelse(epos.bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "epos.bh"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pc->componentIdent",
            "name",
            "namelen"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_put_filename",
          "args": [
            "sb",
            "compstart",
            "name",
            "symname - compstart"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "udf_put_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
          "lines": "380-402",
          "snippet": "int udf_put_filename(struct super_block *sb, const uint8_t *sname,\n\t\t     uint8_t *dname, int flen)\n{\n\tstruct ustr unifilename;\n\tint namelen;\n\n\tif (!udf_char_to_ustr(&unifilename, sname, flen))\n\t\treturn 0;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tnamelen = udf_UTF8toCS0(dname, &unifilename, UDF_NAME_LEN);\n\t\tif (!namelen)\n\t\t\treturn 0;\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tnamelen = udf_NLStoCS0(UDF_SB(sb)->s_nls_map, dname,\n\t\t\t\t\t&unifilename, UDF_NAME_LEN);\n\t\tif (!namelen)\n\t\t\treturn 0;\n\t} else\n\t\treturn 0;\n\n\treturn namelen;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>\t/* for memset */",
            "#include <linux/kernel.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);\n\nint udf_put_filename(struct super_block *sb, const uint8_t *sname,\n\t\t     uint8_t *dname, int flen)\n{\n\tstruct ustr unifilename;\n\tint namelen;\n\n\tif (!udf_char_to_ustr(&unifilename, sname, flen))\n\t\treturn 0;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tnamelen = udf_UTF8toCS0(dname, &unifilename, UDF_NAME_LEN);\n\t\tif (!namelen)\n\t\t\treturn 0;\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tnamelen = udf_NLStoCS0(UDF_SB(sb)->s_nls_map, dname,\n\t\t\t\t\t&unifilename, UDF_NAME_LEN);\n\t\tif (!namelen)\n\t\t\treturn 0;\n\t} else\n\t\treturn 0;\n\n\treturn namelen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_ext0_offset",
          "args": [
            "inode"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "udf_ext0_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "66-72",
          "snippet": "static inline size_t udf_ext0_offset(struct inode *inode)\n{\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\treturn udf_file_entry_alloc_offset(inode);\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_ext0_offset(struct inode *inode)\n{\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\treturn udf_file_entry_alloc_offset(inode);\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "epos.bh",
            "inode"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "epos.bh"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "epos.bh"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "epos.bh->b_data",
            "0x00",
            "bsize"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_tgetblk",
          "args": [
            "sb",
            "block"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tgetblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "32-38",
          "snippet": "struct buffer_head *udf_tgetblk(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_getblk(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_getblk(sb, block);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tgetblk(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_getblk(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_getblk(sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_pblock",
          "args": [
            "sb",
            "block",
            "iinfo->i_location.partitionReferenceNum",
            "0"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_pblock_meta25",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/partition.c",
          "lines": "306-339",
          "snippet": "uint32_t udf_get_pblock_meta25(struct super_block *sb, uint32_t block,\n\t\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_meta_data *mdata;\n\tuint32_t retblk;\n\tstruct inode *inode;\n\n\tudf_debug(\"READING from METADATA\\n\");\n\n\tmap = &sbi->s_partmaps[partition];\n\tmdata = &map->s_type_specific.s_metadata;\n\tinode = mdata->s_metadata_fe ? : mdata->s_mirror_fe;\n\n\t/* We shouldn't mount such media... */\n\tBUG_ON(!inode);\n\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\tif (retblk == 0xFFFFFFFF && mdata->s_metadata_fe) {\n\t\tudf_warn(sb, \"error reading from METADATA, trying to read from MIRROR\\n\");\n\t\tif (!(mdata->s_flags & MF_MIRROR_FE_LOADED)) {\n\t\t\tmdata->s_mirror_fe = udf_find_metadata_inode_efe(sb,\n\t\t\t\tmdata->s_mirror_file_loc, map->s_partition_num);\n\t\t\tmdata->s_flags |= MF_MIRROR_FE_LOADED;\n\t\t}\n\n\t\tinode = mdata->s_mirror_fe;\n\t\tif (!inode)\n\t\t\treturn 0xFFFFFFFF;\n\t\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\t}\n\n\treturn retblk;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include \"udfdecl.h\"\n\nuint32_t udf_get_pblock_meta25(struct super_block *sb, uint32_t block,\n\t\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_meta_data *mdata;\n\tuint32_t retblk;\n\tstruct inode *inode;\n\n\tudf_debug(\"READING from METADATA\\n\");\n\n\tmap = &sbi->s_partmaps[partition];\n\tmdata = &map->s_type_specific.s_metadata;\n\tinode = mdata->s_metadata_fe ? : mdata->s_mirror_fe;\n\n\t/* We shouldn't mount such media... */\n\tBUG_ON(!inode);\n\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\tif (retblk == 0xFFFFFFFF && mdata->s_metadata_fe) {\n\t\tudf_warn(sb, \"error reading from METADATA, trying to read from MIRROR\\n\");\n\t\tif (!(mdata->s_flags & MF_MIRROR_FE_LOADED)) {\n\t\t\tmdata->s_mirror_fe = udf_find_metadata_inode_efe(sb,\n\t\t\t\tmdata->s_mirror_file_loc, map->s_partition_num);\n\t\t\tmdata->s_flags |= MF_MIRROR_FE_LOADED;\n\t\t}\n\n\t\tinode = mdata->s_mirror_fe;\n\t\tif (!inode)\n\t\t\treturn 0xFFFFFFFF;\n\t\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\t}\n\n\treturn retblk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_add_aext",
          "args": [
            "inode",
            "&epos",
            "&eloc",
            "bsize",
            "0"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "udf_add_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "1876-2003",
          "snippet": "int udf_add_aext(struct inode *inode, struct extent_position *epos,\n\t\t struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tstruct short_ad *sad = NULL;\n\tstruct long_ad *lad = NULL;\n\tstruct allocExtDesc *aed;\n\tuint8_t *ptr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\tif (epos->offset + (2 * adsize) > inode->i_sb->s_blocksize) {\n\t\tunsigned char *sptr, *dptr;\n\t\tstruct buffer_head *nbh;\n\t\tint err, loffset;\n\t\tstruct kernel_lb_addr obloc = epos->block;\n\n\t\tepos->block.logicalBlockNum = udf_new_block(inode->i_sb, NULL,\n\t\t\t\t\t\tobloc.partitionReferenceNum,\n\t\t\t\t\t\tobloc.logicalBlockNum, &err);\n\t\tif (!epos->block.logicalBlockNum)\n\t\t\treturn -ENOSPC;\n\t\tnbh = udf_tgetblk(inode->i_sb, udf_get_lb_pblock(inode->i_sb,\n\t\t\t\t\t\t\t\t &epos->block,\n\t\t\t\t\t\t\t\t 0));\n\t\tif (!nbh)\n\t\t\treturn -EIO;\n\t\tlock_buffer(nbh);\n\t\tmemset(nbh->b_data, 0x00, inode->i_sb->s_blocksize);\n\t\tset_buffer_uptodate(nbh);\n\t\tunlock_buffer(nbh);\n\t\tmark_buffer_dirty_inode(nbh, inode);\n\n\t\taed = (struct allocExtDesc *)(nbh->b_data);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))\n\t\t\taed->previousAllocExtLocation =\n\t\t\t\t\tcpu_to_le32(obloc.logicalBlockNum);\n\t\tif (epos->offset + adsize > inode->i_sb->s_blocksize) {\n\t\t\tloffset = epos->offset;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(adsize);\n\t\t\tsptr = ptr - adsize;\n\t\t\tdptr = nbh->b_data + sizeof(struct allocExtDesc);\n\t\t\tmemcpy(dptr, sptr, adsize);\n\t\t\tepos->offset = sizeof(struct allocExtDesc) + adsize;\n\t\t} else {\n\t\t\tloffset = epos->offset + adsize;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(0);\n\t\t\tsptr = ptr;\n\t\t\tepos->offset = sizeof(struct allocExtDesc);\n\n\t\t\tif (epos->bh) {\n\t\t\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\t\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\t\t} else {\n\t\t\t\tiinfo->i_lenAlloc += adsize;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t}\n\t\tif (UDF_SB(inode->i_sb)->s_udfrev >= 0x0200)\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 3, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\telse\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 2, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\tswitch (iinfo->i_alloc_type) {\n\t\tcase ICBTAG_FLAG_AD_SHORT:\n\t\t\tsad = (struct short_ad *)sptr;\n\t\t\tsad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tsad->extPosition =\n\t\t\t\tcpu_to_le32(epos->block.logicalBlockNum);\n\t\t\tbreak;\n\t\tcase ICBTAG_FLAG_AD_LONG:\n\t\t\tlad = (struct long_ad *)sptr;\n\t\t\tlad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tlad->extLocation = cpu_to_lelb(epos->block);\n\t\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\t\tbreak;\n\t\t}\n\t\tif (epos->bh) {\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(epos->bh->b_data, loffset);\n\t\t\telse\n\t\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t\t\tbrelse(epos->bh);\n\t\t} else {\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tepos->bh = nbh;\n\t}\n\n\tudf_write_aext(inode, epos, eloc, elen, inc);\n\n\tif (!epos->bh) {\n\t\tiinfo->i_lenAlloc += adsize;\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t\tUDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tepos->offset + (inc ? 0 : adsize));\n\t\telse\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);",
            "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\nint udf_add_aext(struct inode *inode, struct extent_position *epos,\n\t\t struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tstruct short_ad *sad = NULL;\n\tstruct long_ad *lad = NULL;\n\tstruct allocExtDesc *aed;\n\tuint8_t *ptr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\tif (epos->offset + (2 * adsize) > inode->i_sb->s_blocksize) {\n\t\tunsigned char *sptr, *dptr;\n\t\tstruct buffer_head *nbh;\n\t\tint err, loffset;\n\t\tstruct kernel_lb_addr obloc = epos->block;\n\n\t\tepos->block.logicalBlockNum = udf_new_block(inode->i_sb, NULL,\n\t\t\t\t\t\tobloc.partitionReferenceNum,\n\t\t\t\t\t\tobloc.logicalBlockNum, &err);\n\t\tif (!epos->block.logicalBlockNum)\n\t\t\treturn -ENOSPC;\n\t\tnbh = udf_tgetblk(inode->i_sb, udf_get_lb_pblock(inode->i_sb,\n\t\t\t\t\t\t\t\t &epos->block,\n\t\t\t\t\t\t\t\t 0));\n\t\tif (!nbh)\n\t\t\treturn -EIO;\n\t\tlock_buffer(nbh);\n\t\tmemset(nbh->b_data, 0x00, inode->i_sb->s_blocksize);\n\t\tset_buffer_uptodate(nbh);\n\t\tunlock_buffer(nbh);\n\t\tmark_buffer_dirty_inode(nbh, inode);\n\n\t\taed = (struct allocExtDesc *)(nbh->b_data);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))\n\t\t\taed->previousAllocExtLocation =\n\t\t\t\t\tcpu_to_le32(obloc.logicalBlockNum);\n\t\tif (epos->offset + adsize > inode->i_sb->s_blocksize) {\n\t\t\tloffset = epos->offset;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(adsize);\n\t\t\tsptr = ptr - adsize;\n\t\t\tdptr = nbh->b_data + sizeof(struct allocExtDesc);\n\t\t\tmemcpy(dptr, sptr, adsize);\n\t\t\tepos->offset = sizeof(struct allocExtDesc) + adsize;\n\t\t} else {\n\t\t\tloffset = epos->offset + adsize;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(0);\n\t\t\tsptr = ptr;\n\t\t\tepos->offset = sizeof(struct allocExtDesc);\n\n\t\t\tif (epos->bh) {\n\t\t\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\t\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\t\t} else {\n\t\t\t\tiinfo->i_lenAlloc += adsize;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t}\n\t\tif (UDF_SB(inode->i_sb)->s_udfrev >= 0x0200)\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 3, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\telse\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 2, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\tswitch (iinfo->i_alloc_type) {\n\t\tcase ICBTAG_FLAG_AD_SHORT:\n\t\t\tsad = (struct short_ad *)sptr;\n\t\t\tsad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tsad->extPosition =\n\t\t\t\tcpu_to_le32(epos->block.logicalBlockNum);\n\t\t\tbreak;\n\t\tcase ICBTAG_FLAG_AD_LONG:\n\t\t\tlad = (struct long_ad *)sptr;\n\t\t\tlad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tlad->extLocation = cpu_to_lelb(epos->block);\n\t\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\t\tbreak;\n\t\t}\n\t\tif (epos->bh) {\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(epos->bh->b_data, loffset);\n\t\t\telse\n\t\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t\t\tbrelse(epos->bh);\n\t\t} else {\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tepos->bh = nbh;\n\t}\n\n\tudf_write_aext(inode, epos, eloc, elen, inc);\n\n\tif (!epos->bh) {\n\t\tiinfo->i_lenAlloc += adsize;\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t\tUDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tepos->offset + (inc ? 0 : adsize));\n\t\telse\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_file_entry_alloc_offset",
          "args": [
            "inode"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "udf_file_entry_alloc_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "55-64",
          "snippet": "static inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_new_block",
          "args": [
            "sb",
            "inode",
            "iinfo->i_location.partitionReferenceNum",
            "iinfo->i_location.logicalBlockNum",
            "&err"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "udf_new_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "795-825",
          "snippet": "inline int udf_new_block(struct super_block *sb,\n\t\t\t struct inode *inode,\n\t\t\t uint16_t partition, uint32_t goal, int *err)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\tint block;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_uspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_uspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_fspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_fspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse {\n\t\t*err = -EIO;\n\t\treturn 0;\n\t}\n\tif (inode && block)\n\t\tinode_add_bytes(inode, sb->s_blocksize);\n\treturn block;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\ninline int udf_new_block(struct super_block *sb,\n\t\t\t struct inode *inode,\n\t\t\t uint16_t partition, uint32_t goal, int *err)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\tint block;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_uspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_uspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_fspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_fspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse {\n\t\t*err = -EIO;\n\t\treturn 0;\n\t}\n\tif (inode && block)\n\t\tinode_add_bytes(inode, sb->s_blocksize);\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "UDF_NAME_LEN",
            "GFP_NOFS"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_new_inode",
          "args": [
            "dir",
            "S_IFLNK | S_IRWXUGO"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "udf_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/ialloc.c",
          "lines": "48-133",
          "snippet": "struct inode *udf_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct inode *inode;\n\tint block;\n\tuint32_t start = UDF_I(dir)->i_location.logicalBlockNum;\n\tstruct udf_inode_info *iinfo;\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\tint err;\n\n\tinode = new_inode(sb);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tiinfo = UDF_I(inode);\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_EXTENDED_FE)) {\n\t\tiinfo->i_efe = 1;\n\t\tif (UDF_VERS_USE_EXTENDED_FE > sbi->s_udfrev)\n\t\t\tsbi->s_udfrev = UDF_VERS_USE_EXTENDED_FE;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct extendedFileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t} else {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct fileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t}\n\tif (!iinfo->i_ext.i_data) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terr = -ENOSPC;\n\tblock = udf_new_block(dir->i_sb, NULL,\n\t\t\t      dinfo->i_location.partitionReferenceNum,\n\t\t\t      start, &err);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (lvidiu) {\n\t\tiinfo->i_unique = lvid_get_unique_id(sb);\n\t\tinode->i_generation = iinfo->i_unique;\n\t\tmutex_lock(&sbi->s_alloc_mutex);\n\t\tif (S_ISDIR(mode))\n\t\t\tle32_add_cpu(&lvidiu->numDirs, 1);\n\t\telse\n\t\t\tle32_add_cpu(&lvidiu->numFiles, 1);\n\t\tudf_updated_lvid(sb);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t}\n\n\tinode_init_owner(inode, dir, mode);\n\n\tiinfo->i_location.logicalBlockNum = block;\n\tiinfo->i_location.partitionReferenceNum =\n\t\t\t\tdinfo->i_location.partitionReferenceNum;\n\tinode->i_ino = udf_get_lb_pblock(sb, &iinfo->i_location, 0);\n\tinode->i_blocks = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_use = 0;\n\tiinfo->i_checkpoint = 1;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_AD_IN_ICB))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\telse if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime =\n\t\tiinfo->i_crtime = current_fs_time(inode->i_sb);\n\tif (unlikely(insert_inode_locked(inode) < 0)) {\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tmark_inode_dirty(inode);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct inode *udf_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct inode *inode;\n\tint block;\n\tuint32_t start = UDF_I(dir)->i_location.logicalBlockNum;\n\tstruct udf_inode_info *iinfo;\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\tint err;\n\n\tinode = new_inode(sb);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tiinfo = UDF_I(inode);\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_EXTENDED_FE)) {\n\t\tiinfo->i_efe = 1;\n\t\tif (UDF_VERS_USE_EXTENDED_FE > sbi->s_udfrev)\n\t\t\tsbi->s_udfrev = UDF_VERS_USE_EXTENDED_FE;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct extendedFileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t} else {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct fileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t}\n\tif (!iinfo->i_ext.i_data) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terr = -ENOSPC;\n\tblock = udf_new_block(dir->i_sb, NULL,\n\t\t\t      dinfo->i_location.partitionReferenceNum,\n\t\t\t      start, &err);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (lvidiu) {\n\t\tiinfo->i_unique = lvid_get_unique_id(sb);\n\t\tinode->i_generation = iinfo->i_unique;\n\t\tmutex_lock(&sbi->s_alloc_mutex);\n\t\tif (S_ISDIR(mode))\n\t\t\tle32_add_cpu(&lvidiu->numDirs, 1);\n\t\telse\n\t\t\tle32_add_cpu(&lvidiu->numFiles, 1);\n\t\tudf_updated_lvid(sb);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t}\n\n\tinode_init_owner(inode, dir, mode);\n\n\tiinfo->i_location.logicalBlockNum = block;\n\tiinfo->i_location.partitionReferenceNum =\n\t\t\t\tdinfo->i_location.partitionReferenceNum;\n\tinode->i_ino = udf_get_lb_pblock(sb, &iinfo->i_location, 0);\n\tinode->i_blocks = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_use = 0;\n\tiinfo->i_checkpoint = 1;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_AD_IN_ICB))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\telse if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime =\n\t\tiinfo->i_crtime = current_fs_time(inode->i_sb);\n\tif (unlikely(insert_inode_locked(inode) < 0)) {\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tmark_inode_dirty(inode);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nconst struct inode_operations udf_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n};\n\nstatic int udf_symlink(struct inode *dir, struct dentry *dentry,\n\t\t       const char *symname)\n{\n\tstruct inode *inode = udf_new_inode(dir, S_IFLNK | S_IRWXUGO);\n\tstruct pathComponent *pc;\n\tconst char *compstart;\n\tstruct extent_position epos = {};\n\tint eoffset, elen = 0;\n\tuint8_t *ea;\n\tint err;\n\tint block;\n\tunsigned char *name = NULL;\n\tint namelen;\n\tstruct udf_inode_info *iinfo;\n\tstruct super_block *sb = dir->i_sb;\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tiinfo = UDF_I(inode);\n\tdown_write(&iinfo->i_data_sem);\n\tname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!name) {\n\t\terr = -ENOMEM;\n\t\tgoto out_no_entry;\n\t}\n\n\tinode->i_data.a_ops = &udf_symlink_aops;\n\tinode->i_op = &udf_symlink_inode_operations;\n\n\tif (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tstruct kernel_lb_addr eloc;\n\t\tuint32_t bsize;\n\n\t\tblock = udf_new_block(sb, inode,\n\t\t\t\tiinfo->i_location.partitionReferenceNum,\n\t\t\t\tiinfo->i_location.logicalBlockNum, &err);\n\t\tif (!block)\n\t\t\tgoto out_no_entry;\n\t\tepos.block = iinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(inode);\n\t\tepos.bh = NULL;\n\t\teloc.logicalBlockNum = block;\n\t\teloc.partitionReferenceNum =\n\t\t\t\tiinfo->i_location.partitionReferenceNum;\n\t\tbsize = sb->s_blocksize;\n\t\tiinfo->i_lenExtents = bsize;\n\t\tudf_add_aext(inode, &epos, &eloc, bsize, 0);\n\t\tbrelse(epos.bh);\n\n\t\tblock = udf_get_pblock(sb, block,\n\t\t\t\tiinfo->i_location.partitionReferenceNum,\n\t\t\t\t0);\n\t\tepos.bh = udf_tgetblk(sb, block);\n\t\tlock_buffer(epos.bh);\n\t\tmemset(epos.bh->b_data, 0x00, bsize);\n\t\tset_buffer_uptodate(epos.bh);\n\t\tunlock_buffer(epos.bh);\n\t\tmark_buffer_dirty_inode(epos.bh, inode);\n\t\tea = epos.bh->b_data + udf_ext0_offset(inode);\n\t} else\n\t\tea = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\n\teoffset = sb->s_blocksize - udf_ext0_offset(inode);\n\tpc = (struct pathComponent *)ea;\n\n\tif (*symname == '/') {\n\t\tdo {\n\t\t\tsymname++;\n\t\t} while (*symname == '/');\n\n\t\tpc->componentType = 1;\n\t\tpc->lengthComponentIdent = 0;\n\t\tpc->componentFileVersionNum = 0;\n\t\telen += sizeof(struct pathComponent);\n\t}\n\n\terr = -ENAMETOOLONG;\n\n\twhile (*symname) {\n\t\tif (elen + sizeof(struct pathComponent) > eoffset)\n\t\t\tgoto out_no_entry;\n\n\t\tpc = (struct pathComponent *)(ea + elen);\n\n\t\tcompstart = symname;\n\n\t\tdo {\n\t\t\tsymname++;\n\t\t} while (*symname && *symname != '/');\n\n\t\tpc->componentType = 5;\n\t\tpc->lengthComponentIdent = 0;\n\t\tpc->componentFileVersionNum = 0;\n\t\tif (compstart[0] == '.') {\n\t\t\tif ((symname - compstart) == 1)\n\t\t\t\tpc->componentType = 4;\n\t\t\telse if ((symname - compstart) == 2 &&\n\t\t\t\t\tcompstart[1] == '.')\n\t\t\t\tpc->componentType = 3;\n\t\t}\n\n\t\tif (pc->componentType == 5) {\n\t\t\tnamelen = udf_put_filename(sb, compstart, name,\n\t\t\t\t\t\t   symname - compstart);\n\t\t\tif (!namelen)\n\t\t\t\tgoto out_no_entry;\n\n\t\t\tif (elen + sizeof(struct pathComponent) + namelen >\n\t\t\t\t\teoffset)\n\t\t\t\tgoto out_no_entry;\n\t\t\telse\n\t\t\t\tpc->lengthComponentIdent = namelen;\n\n\t\t\tmemcpy(pc->componentIdent, name, namelen);\n\t\t}\n\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n\n\t\tif (*symname) {\n\t\t\tdo {\n\t\t\t\tsymname++;\n\t\t\t} while (*symname == '/');\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\tinode->i_size = elen;\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tiinfo->i_lenAlloc = inode->i_size;\n\telse\n\t\tudf_truncate_tail_extent(inode);\n\tmark_inode_dirty(inode);\n\tup_write(&iinfo->i_data_sem);\n\n\terr = udf_add_nondir(dentry, inode);\nout:\n\tkfree(name);\n\treturn err;\n\nout_no_entry:\n\tup_write(&iinfo->i_data_sem);\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tgoto out;\n}"
  },
  {
    "function_name": "udf_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "809-849",
    "snippet": "static int udf_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint retval;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct udf_fileident_bh fibh;\n\tstruct fileIdentDesc *fi;\n\tstruct fileIdentDesc cfi;\n\tstruct kernel_lb_addr tloc;\n\n\tretval = -ENOENT;\n\tfi = udf_find_entry(dir, &dentry->d_name, &fibh, &cfi);\n\tif (!fi)\n\t\tgoto out;\n\n\tretval = -EIO;\n\ttloc = lelb_to_cpu(cfi.icb.extLocation);\n\tif (udf_get_lb_pblock(dir->i_sb, &tloc, 0) != inode->i_ino)\n\t\tgoto end_unlink;\n\n\tif (!inode->i_nlink) {\n\t\tudf_debug(\"Deleting nonexistent file (%lu), %d\\n\",\n\t\t\t  inode->i_ino, inode->i_nlink);\n\t\tset_nlink(inode, 1);\n\t}\n\tretval = udf_delete_entry(dir, fi, &fibh, &cfi);\n\tif (retval)\n\t\tgoto end_unlink;\n\tdir->i_ctime = dir->i_mtime = current_fs_time(dir->i_sb);\n\tmark_inode_dirty(dir);\n\tinode_dec_link_count(inode);\n\tinode->i_ctime = dir->i_ctime;\n\tretval = 0;\n\nend_unlink:\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\nout:\n\treturn retval;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "fibh.sbh"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "dir->i_sb"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_delete_entry",
          "args": [
            "dir",
            "fi",
            "&fibh",
            "&cfi"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "udf_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "540-550",
          "snippet": "static int udf_delete_entry(struct inode *inode, struct fileIdentDesc *fi,\n\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t    struct fileIdentDesc *cfi)\n{\n\tcfi->fileCharacteristics |= FID_FILE_CHAR_DELETED;\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))\n\t\tmemset(&(cfi->icb), 0x00, sizeof(struct long_ad));\n\n\treturn udf_write_fi(inode, cfi, fi, fibh, NULL, NULL);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic int udf_delete_entry(struct inode *inode, struct fileIdentDesc *fi,\n\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t    struct fileIdentDesc *cfi)\n{\n\tcfi->fileCharacteristics |= FID_FILE_CHAR_DELETED;\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))\n\t\tmemset(&(cfi->icb), 0x00, sizeof(struct long_ad));\n\n\treturn udf_write_fi(inode, cfi, fi, fibh, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "1"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Deleting nonexistent file (%lu), %d\\n\"",
            "inode->i_ino",
            "inode->i_nlink"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "dir->i_sb",
            "&tloc",
            "0"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lelb_to_cpu",
          "args": [
            "cfi.icb.extLocation"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "lelb_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfend.h",
          "lines": "7-15",
          "snippet": "static inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}",
          "includes": [
            "#include <linux/string.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string.h>\n#include <asm/byteorder.h>\n\nstatic inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_find_entry",
          "args": [
            "dir",
            "&dentry->d_name",
            "&fibh",
            "&cfi"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "udf_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "142-252",
          "snippet": "static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\tstruct super_block *sb = dir->i_sb;\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(sb, &eloc, offset);\n\t\tif ((++offset << sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(sb, nameptr, lfi, fname, UDF_NAME_LEN);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\tstruct super_block *sb = dir->i_sb;\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(sb, &eloc, offset);\n\t\tif ((++offset << sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(sb, nameptr, lfi, fname, UDF_NAME_LEN);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic int udf_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint retval;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct udf_fileident_bh fibh;\n\tstruct fileIdentDesc *fi;\n\tstruct fileIdentDesc cfi;\n\tstruct kernel_lb_addr tloc;\n\n\tretval = -ENOENT;\n\tfi = udf_find_entry(dir, &dentry->d_name, &fibh, &cfi);\n\tif (!fi)\n\t\tgoto out;\n\n\tretval = -EIO;\n\ttloc = lelb_to_cpu(cfi.icb.extLocation);\n\tif (udf_get_lb_pblock(dir->i_sb, &tloc, 0) != inode->i_ino)\n\t\tgoto end_unlink;\n\n\tif (!inode->i_nlink) {\n\t\tudf_debug(\"Deleting nonexistent file (%lu), %d\\n\",\n\t\t\t  inode->i_ino, inode->i_nlink);\n\t\tset_nlink(inode, 1);\n\t}\n\tretval = udf_delete_entry(dir, fi, &fibh, &cfi);\n\tif (retval)\n\t\tgoto end_unlink;\n\tdir->i_ctime = dir->i_mtime = current_fs_time(dir->i_sb);\n\tmark_inode_dirty(dir);\n\tinode_dec_link_count(inode);\n\tinode->i_ctime = dir->i_ctime;\n\tretval = 0;\n\nend_unlink:\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\nout:\n\treturn retval;\n}"
  },
  {
    "function_name": "udf_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "767-807",
    "snippet": "static int udf_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint retval;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct udf_fileident_bh fibh;\n\tstruct fileIdentDesc *fi, cfi;\n\tstruct kernel_lb_addr tloc;\n\n\tretval = -ENOENT;\n\tfi = udf_find_entry(dir, &dentry->d_name, &fibh, &cfi);\n\tif (!fi)\n\t\tgoto out;\n\n\tretval = -EIO;\n\ttloc = lelb_to_cpu(cfi.icb.extLocation);\n\tif (udf_get_lb_pblock(dir->i_sb, &tloc, 0) != inode->i_ino)\n\t\tgoto end_rmdir;\n\tretval = -ENOTEMPTY;\n\tif (!empty_dir(inode))\n\t\tgoto end_rmdir;\n\tretval = udf_delete_entry(dir, fi, &fibh, &cfi);\n\tif (retval)\n\t\tgoto end_rmdir;\n\tif (inode->i_nlink != 2)\n\t\tudf_warn(inode->i_sb, \"empty directory has nlink != 2 (%d)\\n\",\n\t\t\t inode->i_nlink);\n\tclear_nlink(inode);\n\tinode->i_size = 0;\n\tinode_dec_link_count(dir);\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime =\n\t\t\t\t\t\tcurrent_fs_time(dir->i_sb);\n\tmark_inode_dirty(dir);\n\nend_rmdir:\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\nout:\n\treturn retval;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "fibh.sbh"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "dir->i_sb"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "dir"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_warn",
          "args": [
            "inode->i_sb",
            "\"empty directory has nlink != 2 (%d)\\n\"",
            "inode->i_nlink"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "_udf_warn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2272-2286",
          "snippet": "void _udf_warn(struct super_block *sb, const char *function,\n\t       const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_warn(\"warning (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nvoid _udf_warn(struct super_block *sb, const char *function,\n\t       const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_warn(\"warning (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_delete_entry",
          "args": [
            "dir",
            "fi",
            "&fibh",
            "&cfi"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "udf_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "540-550",
          "snippet": "static int udf_delete_entry(struct inode *inode, struct fileIdentDesc *fi,\n\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t    struct fileIdentDesc *cfi)\n{\n\tcfi->fileCharacteristics |= FID_FILE_CHAR_DELETED;\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))\n\t\tmemset(&(cfi->icb), 0x00, sizeof(struct long_ad));\n\n\treturn udf_write_fi(inode, cfi, fi, fibh, NULL, NULL);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic int udf_delete_entry(struct inode *inode, struct fileIdentDesc *fi,\n\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t    struct fileIdentDesc *cfi)\n{\n\tcfi->fileCharacteristics |= FID_FILE_CHAR_DELETED;\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))\n\t\tmemset(&(cfi->icb), 0x00, sizeof(struct long_ad));\n\n\treturn udf_write_fi(inode, cfi, fi, fibh, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "empty_dir",
          "args": [
            "inode"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "698-765",
          "snippet": "static int empty_dir(struct inode *dir)\n{\n\tstruct fileIdentDesc *fi, cfi;\n\tstruct udf_fileident_bh fibh;\n\tloff_t f_pos;\n\tloff_t size = udf_ext0_offset(dir) + dir->i_size;\n\tint block;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\n\tf_pos = udf_ext0_offset(dir);\n\tfibh.soffset = fibh.eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tfibh.sbh = fibh.ebh = NULL;\n\telse if (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits,\n\t\t\t      &epos, &eloc, &elen, &offset) ==\n\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30)) {\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh.sbh = fibh.ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh.sbh) {\n\t\t\tbrelse(epos.bh);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tbrelse(epos.bh);\n\t\treturn 0;\n\t}\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, &fibh, &cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi) {\n\t\t\tif (fibh.sbh != fibh.ebh)\n\t\t\t\tbrelse(fibh.ebh);\n\t\t\tbrelse(fibh.sbh);\n\t\t\tbrelse(epos.bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (cfi.lengthFileIdent &&\n\t\t    (cfi.fileCharacteristics & FID_FILE_CHAR_DELETED) == 0) {\n\t\t\tif (fibh.sbh != fibh.ebh)\n\t\t\t\tbrelse(fibh.ebh);\n\t\t\tbrelse(fibh.sbh);\n\t\t\tbrelse(epos.bh);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\tbrelse(epos.bh);\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic int empty_dir(struct inode *dir)\n{\n\tstruct fileIdentDesc *fi, cfi;\n\tstruct udf_fileident_bh fibh;\n\tloff_t f_pos;\n\tloff_t size = udf_ext0_offset(dir) + dir->i_size;\n\tint block;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\n\tf_pos = udf_ext0_offset(dir);\n\tfibh.soffset = fibh.eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tfibh.sbh = fibh.ebh = NULL;\n\telse if (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits,\n\t\t\t      &epos, &eloc, &elen, &offset) ==\n\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30)) {\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh.sbh = fibh.ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh.sbh) {\n\t\t\tbrelse(epos.bh);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tbrelse(epos.bh);\n\t\treturn 0;\n\t}\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, &fibh, &cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi) {\n\t\t\tif (fibh.sbh != fibh.ebh)\n\t\t\t\tbrelse(fibh.ebh);\n\t\t\tbrelse(fibh.sbh);\n\t\t\tbrelse(epos.bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (cfi.lengthFileIdent &&\n\t\t    (cfi.fileCharacteristics & FID_FILE_CHAR_DELETED) == 0) {\n\t\t\tif (fibh.sbh != fibh.ebh)\n\t\t\t\tbrelse(fibh.ebh);\n\t\t\tbrelse(fibh.sbh);\n\t\t\tbrelse(epos.bh);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\tbrelse(epos.bh);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "dir->i_sb",
            "&tloc",
            "0"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lelb_to_cpu",
          "args": [
            "cfi.icb.extLocation"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "lelb_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfend.h",
          "lines": "7-15",
          "snippet": "static inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}",
          "includes": [
            "#include <linux/string.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string.h>\n#include <asm/byteorder.h>\n\nstatic inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_find_entry",
          "args": [
            "dir",
            "&dentry->d_name",
            "&fibh",
            "&cfi"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "udf_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "142-252",
          "snippet": "static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\tstruct super_block *sb = dir->i_sb;\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(sb, &eloc, offset);\n\t\tif ((++offset << sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(sb, nameptr, lfi, fname, UDF_NAME_LEN);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\tstruct super_block *sb = dir->i_sb;\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(sb, &eloc, offset);\n\t\tif ((++offset << sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(sb, nameptr, lfi, fname, UDF_NAME_LEN);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic int udf_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint retval;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct udf_fileident_bh fibh;\n\tstruct fileIdentDesc *fi, cfi;\n\tstruct kernel_lb_addr tloc;\n\n\tretval = -ENOENT;\n\tfi = udf_find_entry(dir, &dentry->d_name, &fibh, &cfi);\n\tif (!fi)\n\t\tgoto out;\n\n\tretval = -EIO;\n\ttloc = lelb_to_cpu(cfi.icb.extLocation);\n\tif (udf_get_lb_pblock(dir->i_sb, &tloc, 0) != inode->i_ino)\n\t\tgoto end_rmdir;\n\tretval = -ENOTEMPTY;\n\tif (!empty_dir(inode))\n\t\tgoto end_rmdir;\n\tretval = udf_delete_entry(dir, fi, &fibh, &cfi);\n\tif (retval)\n\t\tgoto end_rmdir;\n\tif (inode->i_nlink != 2)\n\t\tudf_warn(inode->i_sb, \"empty directory has nlink != 2 (%d)\\n\",\n\t\t\t inode->i_nlink);\n\tclear_nlink(inode);\n\tinode->i_size = 0;\n\tinode_dec_link_count(dir);\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime =\n\t\t\t\t\t\tcurrent_fs_time(dir->i_sb);\n\tmark_inode_dirty(dir);\n\nend_rmdir:\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\nout:\n\treturn retval;\n}"
  },
  {
    "function_name": "empty_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "698-765",
    "snippet": "static int empty_dir(struct inode *dir)\n{\n\tstruct fileIdentDesc *fi, cfi;\n\tstruct udf_fileident_bh fibh;\n\tloff_t f_pos;\n\tloff_t size = udf_ext0_offset(dir) + dir->i_size;\n\tint block;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\n\tf_pos = udf_ext0_offset(dir);\n\tfibh.soffset = fibh.eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tfibh.sbh = fibh.ebh = NULL;\n\telse if (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits,\n\t\t\t      &epos, &eloc, &elen, &offset) ==\n\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30)) {\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh.sbh = fibh.ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh.sbh) {\n\t\t\tbrelse(epos.bh);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tbrelse(epos.bh);\n\t\treturn 0;\n\t}\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, &fibh, &cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi) {\n\t\t\tif (fibh.sbh != fibh.ebh)\n\t\t\t\tbrelse(fibh.ebh);\n\t\t\tbrelse(fibh.sbh);\n\t\t\tbrelse(epos.bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (cfi.lengthFileIdent &&\n\t\t    (cfi.fileCharacteristics & FID_FILE_CHAR_DELETED) == 0) {\n\t\t\tif (fibh.sbh != fibh.ebh)\n\t\t\t\tbrelse(fibh.ebh);\n\t\t\tbrelse(fibh.sbh);\n\t\t\tbrelse(epos.bh);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\tbrelse(epos.bh);\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "epos.bh"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_fileident_read",
          "args": [
            "dir",
            "&f_pos",
            "&fibh",
            "&cfi",
            "&epos",
            "&eloc",
            "&elen",
            "&offset"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "udf_fileident_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/directory.c",
          "lines": "21-155",
          "snippet": "struct fileIdentDesc *udf_fileident_read(struct inode *dir, loff_t *nf_pos,\n\t\t\t\t\t struct udf_fileident_bh *fibh,\n\t\t\t\t\t struct fileIdentDesc *cfi,\n\t\t\t\t\t struct extent_position *epos,\n\t\t\t\t\t struct kernel_lb_addr *eloc, uint32_t *elen,\n\t\t\t\t\t sector_t *offset)\n{\n\tstruct fileIdentDesc *fi;\n\tint i, num, block;\n\tstruct buffer_head *tmp, *bha[16];\n\tstruct udf_inode_info *iinfo = UDF_I(dir);\n\n\tfibh->soffset = fibh->eoffset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tfi = udf_get_fileident(iinfo->i_ext.i_data -\n\t\t\t\t       (iinfo->i_efe ?\n\t\t\t\t\tsizeof(struct extendedFileEntry) :\n\t\t\t\t\tsizeof(struct fileEntry)),\n\t\t\t\t       dir->i_sb->s_blocksize,\n\t\t\t\t       &(fibh->eoffset));\n\t\tif (!fi)\n\t\t\treturn NULL;\n\n\t\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\n\t\treturn fi;\n\t}\n\n\tif (fibh->eoffset == dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\t\tunsigned char blocksize_bits = dir->i_sb->s_blocksize_bits;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\treturn NULL;\n\t\tfibh->soffset = fibh->eoffset = 0;\n\n\t\tif (!(*offset & ((16 >> (blocksize_bits - 9)) - 1))) {\n\t\t\ti = 16 >> (blocksize_bits - 9);\n\t\t\tif (i + *offset > (*elen >> blocksize_bits))\n\t\t\t\ti = (*elen >> blocksize_bits)-*offset;\n\t\t\tfor (num = 0; i > 0; i--) {\n\t\t\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc,\n\t\t\t\t\t\t\t  *offset + i);\n\t\t\t\ttmp = udf_tgetblk(dir->i_sb, block);\n\t\t\t\tif (tmp && !buffer_uptodate(tmp) &&\n\t\t\t\t\t\t!buffer_locked(tmp))\n\t\t\t\t\tbha[num++] = tmp;\n\t\t\t\telse\n\t\t\t\t\tbrelse(tmp);\n\t\t\t}\n\t\t\tif (num) {\n\t\t\t\tll_rw_block(READA, num, bha);\n\t\t\t\tfor (i = 0; i < num; i++)\n\t\t\t\t\tbrelse(bha[i]);\n\t\t\t}\n\t\t}\n\t} else if (fibh->sbh != fibh->ebh) {\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh;\n\t}\n\n\tfi = udf_get_fileident(fibh->sbh->b_data, dir->i_sb->s_blocksize,\n\t\t\t       &(fibh->eoffset));\n\n\tif (!fi)\n\t\treturn NULL;\n\n\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\tif (fibh->eoffset <= dir->i_sb->s_blocksize) {\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\t} else if (fibh->eoffset > dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << dir->i_sb->s_blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tfibh->soffset -= dir->i_sb->s_blocksize;\n\t\tfibh->eoffset -= dir->i_sb->s_blocksize;\n\n\t\tfibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->ebh)\n\t\t\treturn NULL;\n\n\t\tif (sizeof(struct fileIdentDesc) > -fibh->soffset) {\n\t\t\tint fi_len;\n\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi, -fibh->soffset);\n\t\t\tmemcpy((uint8_t *)cfi - fibh->soffset,\n\t\t\t       fibh->ebh->b_data,\n\t\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\n\t\t\tfi_len = (sizeof(struct fileIdentDesc) +\n\t\t\t\t  cfi->lengthFileIdent +\n\t\t\t\t  le16_to_cpu(cfi->lengthOfImpUse) + 3) & ~3;\n\n\t\t\t*nf_pos += fi_len - (fibh->eoffset - fibh->soffset);\n\t\t\tfibh->eoffset = fibh->soffset + fi_len;\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t\t       sizeof(struct fileIdentDesc));\n\t\t}\n\t}\n\treturn fi;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstruct fileIdentDesc *udf_fileident_read(struct inode *dir, loff_t *nf_pos,\n\t\t\t\t\t struct udf_fileident_bh *fibh,\n\t\t\t\t\t struct fileIdentDesc *cfi,\n\t\t\t\t\t struct extent_position *epos,\n\t\t\t\t\t struct kernel_lb_addr *eloc, uint32_t *elen,\n\t\t\t\t\t sector_t *offset)\n{\n\tstruct fileIdentDesc *fi;\n\tint i, num, block;\n\tstruct buffer_head *tmp, *bha[16];\n\tstruct udf_inode_info *iinfo = UDF_I(dir);\n\n\tfibh->soffset = fibh->eoffset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tfi = udf_get_fileident(iinfo->i_ext.i_data -\n\t\t\t\t       (iinfo->i_efe ?\n\t\t\t\t\tsizeof(struct extendedFileEntry) :\n\t\t\t\t\tsizeof(struct fileEntry)),\n\t\t\t\t       dir->i_sb->s_blocksize,\n\t\t\t\t       &(fibh->eoffset));\n\t\tif (!fi)\n\t\t\treturn NULL;\n\n\t\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\n\t\treturn fi;\n\t}\n\n\tif (fibh->eoffset == dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\t\tunsigned char blocksize_bits = dir->i_sb->s_blocksize_bits;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\treturn NULL;\n\t\tfibh->soffset = fibh->eoffset = 0;\n\n\t\tif (!(*offset & ((16 >> (blocksize_bits - 9)) - 1))) {\n\t\t\ti = 16 >> (blocksize_bits - 9);\n\t\t\tif (i + *offset > (*elen >> blocksize_bits))\n\t\t\t\ti = (*elen >> blocksize_bits)-*offset;\n\t\t\tfor (num = 0; i > 0; i--) {\n\t\t\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc,\n\t\t\t\t\t\t\t  *offset + i);\n\t\t\t\ttmp = udf_tgetblk(dir->i_sb, block);\n\t\t\t\tif (tmp && !buffer_uptodate(tmp) &&\n\t\t\t\t\t\t!buffer_locked(tmp))\n\t\t\t\t\tbha[num++] = tmp;\n\t\t\t\telse\n\t\t\t\t\tbrelse(tmp);\n\t\t\t}\n\t\t\tif (num) {\n\t\t\t\tll_rw_block(READA, num, bha);\n\t\t\t\tfor (i = 0; i < num; i++)\n\t\t\t\t\tbrelse(bha[i]);\n\t\t\t}\n\t\t}\n\t} else if (fibh->sbh != fibh->ebh) {\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh;\n\t}\n\n\tfi = udf_get_fileident(fibh->sbh->b_data, dir->i_sb->s_blocksize,\n\t\t\t       &(fibh->eoffset));\n\n\tif (!fi)\n\t\treturn NULL;\n\n\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\tif (fibh->eoffset <= dir->i_sb->s_blocksize) {\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\t} else if (fibh->eoffset > dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << dir->i_sb->s_blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tfibh->soffset -= dir->i_sb->s_blocksize;\n\t\tfibh->eoffset -= dir->i_sb->s_blocksize;\n\n\t\tfibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->ebh)\n\t\t\treturn NULL;\n\n\t\tif (sizeof(struct fileIdentDesc) > -fibh->soffset) {\n\t\t\tint fi_len;\n\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi, -fibh->soffset);\n\t\t\tmemcpy((uint8_t *)cfi - fibh->soffset,\n\t\t\t       fibh->ebh->b_data,\n\t\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\n\t\t\tfi_len = (sizeof(struct fileIdentDesc) +\n\t\t\t\t  cfi->lengthFileIdent +\n\t\t\t\t  le16_to_cpu(cfi->lengthOfImpUse) + 3) & ~3;\n\n\t\t\t*nf_pos += fi_len - (fibh->eoffset - fibh->soffset);\n\t\t\tfibh->eoffset = fibh->soffset + fi_len;\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t\t       sizeof(struct fileIdentDesc));\n\t\t}\n\t}\n\treturn fi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_tread",
          "args": [
            "dir->i_sb",
            "block"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "40-46",
          "snippet": "struct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "dir->i_sb",
            "&eloc",
            "offset"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_bmap",
          "args": [
            "dir",
            "f_pos >> dir->i_sb->s_blocksize_bits",
            "&epos",
            "&eloc",
            "&elen",
            "&offset"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "inode_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2237-2268",
          "snippet": "int8_t inode_bmap(struct inode *inode, sector_t block,\n\t\t  struct extent_position *pos, struct kernel_lb_addr *eloc,\n\t\t  uint32_t *elen, sector_t *offset)\n{\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tloff_t lbcount = 0, bcount =\n\t    (loff_t) block << blocksize_bits;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tiinfo = UDF_I(inode);\n\tif (!udf_read_extent_cache(inode, bcount, &lbcount, pos)) {\n\t\tpos->offset = 0;\n\t\tpos->block = iinfo->i_location;\n\t\tpos->bh = NULL;\n\t}\n\t*elen = 0;\n\tdo {\n\t\tetype = udf_next_aext(inode, pos, eloc, elen, 1);\n\t\tif (etype == -1) {\n\t\t\t*offset = (bcount - lbcount) >> blocksize_bits;\n\t\t\tiinfo->i_lenExtents = lbcount;\n\t\t\treturn -1;\n\t\t}\n\t\tlbcount += *elen;\n\t} while (lbcount <= bcount);\n\t/* update extent cache */\n\tudf_update_extent_cache(inode, lbcount - *elen, pos, 1);\n\t*offset = (bcount + *elen - lbcount) >> blocksize_bits;\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t inode_bmap(struct inode *inode, sector_t block,\n\t\t  struct extent_position *pos, struct kernel_lb_addr *eloc,\n\t\t  uint32_t *elen, sector_t *offset)\n{\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tloff_t lbcount = 0, bcount =\n\t    (loff_t) block << blocksize_bits;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tiinfo = UDF_I(inode);\n\tif (!udf_read_extent_cache(inode, bcount, &lbcount, pos)) {\n\t\tpos->offset = 0;\n\t\tpos->block = iinfo->i_location;\n\t\tpos->bh = NULL;\n\t}\n\t*elen = 0;\n\tdo {\n\t\tetype = udf_next_aext(inode, pos, eloc, elen, 1);\n\t\tif (etype == -1) {\n\t\t\t*offset = (bcount - lbcount) >> blocksize_bits;\n\t\t\tiinfo->i_lenExtents = lbcount;\n\t\t\treturn -1;\n\t\t}\n\t\tlbcount += *elen;\n\t} while (lbcount <= bcount);\n\t/* update extent cache */\n\tudf_update_extent_cache(inode, lbcount - *elen, pos, 1);\n\t*offset = (bcount + *elen - lbcount) >> blocksize_bits;\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_ext0_offset",
          "args": [
            "dir"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "udf_ext0_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "66-72",
          "snippet": "static inline size_t udf_ext0_offset(struct inode *inode)\n{\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\treturn udf_file_entry_alloc_offset(inode);\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_ext0_offset(struct inode *inode)\n{\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\treturn udf_file_entry_alloc_offset(inode);\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "dir"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic int empty_dir(struct inode *dir)\n{\n\tstruct fileIdentDesc *fi, cfi;\n\tstruct udf_fileident_bh fibh;\n\tloff_t f_pos;\n\tloff_t size = udf_ext0_offset(dir) + dir->i_size;\n\tint block;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\n\tf_pos = udf_ext0_offset(dir);\n\tfibh.soffset = fibh.eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tfibh.sbh = fibh.ebh = NULL;\n\telse if (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits,\n\t\t\t      &epos, &eloc, &elen, &offset) ==\n\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30)) {\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh.sbh = fibh.ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh.sbh) {\n\t\t\tbrelse(epos.bh);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tbrelse(epos.bh);\n\t\treturn 0;\n\t}\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, &fibh, &cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi) {\n\t\t\tif (fibh.sbh != fibh.ebh)\n\t\t\t\tbrelse(fibh.ebh);\n\t\t\tbrelse(fibh.sbh);\n\t\t\tbrelse(epos.bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (cfi.lengthFileIdent &&\n\t\t    (cfi.fileCharacteristics & FID_FILE_CHAR_DELETED) == 0) {\n\t\t\tif (fibh.sbh != fibh.ebh)\n\t\t\t\tbrelse(fibh.ebh);\n\t\t\tbrelse(fibh.sbh);\n\t\t\tbrelse(epos.bh);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\tbrelse(epos.bh);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "udf_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "637-696",
    "snippet": "static int udf_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode;\n\tstruct udf_fileident_bh fibh;\n\tstruct fileIdentDesc cfi, *fi;\n\tint err;\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tstruct udf_inode_info *iinfo;\n\n\tinode = udf_new_inode(dir, S_IFDIR | mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tiinfo = UDF_I(inode);\n\tinode->i_op = &udf_dir_inode_operations;\n\tinode->i_fop = &udf_dir_operations;\n\tfi = udf_add_entry(inode, NULL, &fibh, &cfi, &err);\n\tif (!fi) {\n\t\tinode_dec_link_count(inode);\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\tset_nlink(inode, 2);\n\tcfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\tcfi.icb.extLocation = cpu_to_lelb(dinfo->i_location);\n\t*(__le32 *)((struct allocDescImpUse *)cfi.icb.impUse)->impUse =\n\t\tcpu_to_le32(dinfo->i_unique & 0x00000000FFFFFFFFUL);\n\tcfi.fileCharacteristics =\n\t\t\tFID_FILE_CHAR_DIRECTORY | FID_FILE_CHAR_PARENT;\n\tudf_write_fi(inode, &cfi, fi, &fibh, NULL, NULL);\n\tbrelse(fibh.sbh);\n\tmark_inode_dirty(inode);\n\n\tfi = udf_add_entry(dir, dentry, &fibh, &cfi, &err);\n\tif (!fi) {\n\t\tclear_nlink(inode);\n\t\tmark_inode_dirty(inode);\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\tcfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\tcfi.icb.extLocation = cpu_to_lelb(iinfo->i_location);\n\t*(__le32 *)((struct allocDescImpUse *)cfi.icb.impUse)->impUse =\n\t\tcpu_to_le32(iinfo->i_unique & 0x00000000FFFFFFFFUL);\n\tcfi.fileCharacteristics |= FID_FILE_CHAR_DIRECTORY;\n\tudf_write_fi(dir, &cfi, fi, &fibh, NULL, NULL);\n\tinc_nlink(dir);\n\tmark_inode_dirty(dir);\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\terr = 0;\n\nout:\n\treturn err;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations udf_dir_inode_operations = {\n\t.lookup\t\t\t\t= udf_lookup,\n\t.create\t\t\t\t= udf_create,\n\t.link\t\t\t\t= udf_link,\n\t.unlink\t\t\t\t= udf_unlink,\n\t.symlink\t\t\t= udf_symlink,\n\t.mkdir\t\t\t\t= udf_mkdir,\n\t.rmdir\t\t\t\t= udf_rmdir,\n\t.mknod\t\t\t\t= udf_mknod,\n\t.rename\t\t\t\t= udf_rename,\n\t.tmpfile\t\t\t= udf_tmpfile,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "fibh.sbh"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dir"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_write_fi",
          "args": [
            "dir",
            "&cfi",
            "fi",
            "&fibh",
            "NULL",
            "NULL"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_fi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "44-140",
          "snippet": "int udf_write_fi(struct inode *inode, struct fileIdentDesc *cfi,\n\t\t struct fileIdentDesc *sfi, struct udf_fileident_bh *fibh,\n\t\t uint8_t *impuse, uint8_t *fileident)\n{\n\tuint16_t crclen = fibh->eoffset - fibh->soffset - sizeof(struct tag);\n\tuint16_t crc;\n\tint offset;\n\tuint16_t liu = le16_to_cpu(cfi->lengthOfImpUse);\n\tuint8_t lfi = cfi->lengthFileIdent;\n\tint padlen = fibh->eoffset - fibh->soffset - liu - lfi -\n\t\tsizeof(struct fileIdentDesc);\n\tint adinicb = 0;\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tadinicb = 1;\n\n\toffset = fibh->soffset + sizeof(struct fileIdentDesc);\n\n\tif (impuse) {\n\t\tif (adinicb || (offset + liu < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, liu);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, impuse, liu);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, -offset);\n\t\t\tmemcpy(fibh->ebh->b_data, impuse - offset,\n\t\t\t\tliu + offset);\n\t\t}\n\t}\n\n\toffset += liu;\n\n\tif (fileident) {\n\t\tif (adinicb || (offset + lfi < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident, lfi);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, fileident, lfi);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident,\n\t\t\t\t-offset);\n\t\t\tmemcpy(fibh->ebh->b_data, fileident - offset,\n\t\t\t\tlfi + offset);\n\t\t}\n\t}\n\n\toffset += lfi;\n\n\tif (adinicb || (offset + padlen < 0)) {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, padlen);\n\t} else if (offset >= 0) {\n\t\tmemset(fibh->ebh->b_data + offset, 0x00, padlen);\n\t} else {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, -offset);\n\t\tmemset(fibh->ebh->b_data, 0x00, padlen + offset);\n\t}\n\n\tcrc = crc_itu_t(0, (uint8_t *)cfi + sizeof(struct tag),\n\t\t      sizeof(struct fileIdentDesc) - sizeof(struct tag));\n\n\tif (fibh->sbh == fibh->ebh) {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t      sizeof(struct fileIdentDesc));\n\t} else if (sizeof(struct fileIdentDesc) >= -fibh->soffset) {\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data +\n\t\t\t\t\tsizeof(struct fileIdentDesc) +\n\t\t\t\t\tfibh->soffset,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      -fibh->soffset - sizeof(struct fileIdentDesc));\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data, fibh->eoffset);\n\t}\n\n\tcfi->descTag.descCRC = cpu_to_le16(crc);\n\tcfi->descTag.descCRCLength = cpu_to_le16(crclen);\n\tcfi->descTag.tagChecksum = udf_tag_checksum(&cfi->descTag);\n\n\tif (adinicb || (sizeof(struct fileIdentDesc) <= -fibh->soffset)) {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi,\n\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi, -fibh->soffset);\n\t\tmemcpy(fibh->ebh->b_data, (uint8_t *)cfi - fibh->soffset,\n\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\t}\n\n\tif (adinicb) {\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tmark_buffer_dirty_inode(fibh->ebh, inode);\n\t\tmark_buffer_dirty_inode(fibh->sbh, inode);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nint udf_write_fi(struct inode *inode, struct fileIdentDesc *cfi,\n\t\t struct fileIdentDesc *sfi, struct udf_fileident_bh *fibh,\n\t\t uint8_t *impuse, uint8_t *fileident)\n{\n\tuint16_t crclen = fibh->eoffset - fibh->soffset - sizeof(struct tag);\n\tuint16_t crc;\n\tint offset;\n\tuint16_t liu = le16_to_cpu(cfi->lengthOfImpUse);\n\tuint8_t lfi = cfi->lengthFileIdent;\n\tint padlen = fibh->eoffset - fibh->soffset - liu - lfi -\n\t\tsizeof(struct fileIdentDesc);\n\tint adinicb = 0;\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tadinicb = 1;\n\n\toffset = fibh->soffset + sizeof(struct fileIdentDesc);\n\n\tif (impuse) {\n\t\tif (adinicb || (offset + liu < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, liu);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, impuse, liu);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, -offset);\n\t\t\tmemcpy(fibh->ebh->b_data, impuse - offset,\n\t\t\t\tliu + offset);\n\t\t}\n\t}\n\n\toffset += liu;\n\n\tif (fileident) {\n\t\tif (adinicb || (offset + lfi < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident, lfi);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, fileident, lfi);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident,\n\t\t\t\t-offset);\n\t\t\tmemcpy(fibh->ebh->b_data, fileident - offset,\n\t\t\t\tlfi + offset);\n\t\t}\n\t}\n\n\toffset += lfi;\n\n\tif (adinicb || (offset + padlen < 0)) {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, padlen);\n\t} else if (offset >= 0) {\n\t\tmemset(fibh->ebh->b_data + offset, 0x00, padlen);\n\t} else {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, -offset);\n\t\tmemset(fibh->ebh->b_data, 0x00, padlen + offset);\n\t}\n\n\tcrc = crc_itu_t(0, (uint8_t *)cfi + sizeof(struct tag),\n\t\t      sizeof(struct fileIdentDesc) - sizeof(struct tag));\n\n\tif (fibh->sbh == fibh->ebh) {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t      sizeof(struct fileIdentDesc));\n\t} else if (sizeof(struct fileIdentDesc) >= -fibh->soffset) {\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data +\n\t\t\t\t\tsizeof(struct fileIdentDesc) +\n\t\t\t\t\tfibh->soffset,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      -fibh->soffset - sizeof(struct fileIdentDesc));\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data, fibh->eoffset);\n\t}\n\n\tcfi->descTag.descCRC = cpu_to_le16(crc);\n\tcfi->descTag.descCRCLength = cpu_to_le16(crclen);\n\tcfi->descTag.tagChecksum = udf_tag_checksum(&cfi->descTag);\n\n\tif (adinicb || (sizeof(struct fileIdentDesc) <= -fibh->soffset)) {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi,\n\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi, -fibh->soffset);\n\t\tmemcpy(fibh->ebh->b_data, (uint8_t *)cfi - fibh->soffset,\n\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\t}\n\n\tif (adinicb) {\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tmark_buffer_dirty_inode(fibh->ebh, inode);\n\t\tmark_buffer_dirty_inode(fibh->sbh, inode);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "iinfo->i_unique & 0x00000000FFFFFFFFUL"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_lelb",
          "args": [
            "iinfo->i_location"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_lelb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfend.h",
          "lines": "17-25",
          "snippet": "static inline struct lb_addr cpu_to_lelb(struct kernel_lb_addr in)\n{\n\tstruct lb_addr out;\n\n\tout.logicalBlockNum = cpu_to_le32(in.logicalBlockNum);\n\tout.partitionReferenceNum = cpu_to_le16(in.partitionReferenceNum);\n\n\treturn out;\n}",
          "includes": [
            "#include <linux/string.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string.h>\n#include <asm/byteorder.h>\n\nstatic inline struct lb_addr cpu_to_lelb(struct kernel_lb_addr in)\n{\n\tstruct lb_addr out;\n\n\tout.logicalBlockNum = cpu_to_le32(in.logicalBlockNum);\n\tout.partitionReferenceNum = cpu_to_le16(in.partitionReferenceNum);\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_sb->s_blocksize"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_add_entry",
          "args": [
            "dir",
            "dentry",
            "&fibh",
            "&cfi",
            "&err"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "udf_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "295-538",
          "snippet": "static struct fileIdentDesc *udf_add_entry(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   struct udf_fileident_bh *fibh,\n\t\t\t\t\t   struct fileIdentDesc *cfi, int *err)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fileIdentDesc *fi = NULL;\n\tunsigned char *name = NULL;\n\tint namelen;\n\tloff_t f_pos;\n\tloff_t size = udf_ext0_offset(dir) + dir->i_size;\n\tint nfidlen;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tint block;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen = 0;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo;\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!name) {\n\t\t*err = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tif (dentry) {\n\t\tif (!dentry->d_name.len) {\n\t\t\t*err = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t\tnamelen = udf_put_filename(sb, dentry->d_name.name, name,\n\t\t\t\t\t\t dentry->d_name.len);\n\t\tif (!namelen) {\n\t\t\t*err = -ENAMETOOLONG;\n\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\tnamelen = 0;\n\t}\n\n\tnfidlen = (sizeof(struct fileIdentDesc) + namelen + 3) & ~3;\n\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\tdinfo = UDF_I(dir);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tblock = udf_get_lb_pblock(dir->i_sb,\n\t\t\t\t\t&dinfo->i_location, 0);\n\t\t\tfibh->soffset = fibh->eoffset = sb->s_blocksize;\n\t\t\tgoto add;\n\t\t}\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tblock = dinfo->i_location.logicalBlockNum;\n\t}\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\n\t\tif (!fi) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (((sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi + 3) & ~3) == nfidlen) {\n\t\t\t\tcfi->descTag.tagSerialNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileVersionNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileCharacteristics = 0;\n\t\t\t\tcfi->lengthFileIdent = namelen;\n\t\t\t\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\t\t\t\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL,\n\t\t\t\t\t\t  name))\n\t\t\t\t\tgoto out_ok;\n\t\t\t\telse {\n\t\t\t\t\t*err = -EIO;\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nadd:\n\tf_pos += nfidlen;\n\n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB &&\n\t    sb->s_blocksize - fibh->eoffset < nfidlen) {\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tfibh->soffset -= udf_ext0_offset(dir);\n\t\tfibh->eoffset -= udf_ext0_offset(dir);\n\t\tf_pos -= udf_ext0_offset(dir);\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tbrelse(fibh->ebh);\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh =\n\t\t\t\tudf_expand_dir_adinicb(dir, &block, err);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\t\t/* Load extent udf_expand_dir_adinicb() has created */\n\t\tudf_current_aext(dir, &epos, &eloc, &elen, 1);\n\t}\n\n\t/* Entry fits into current block? */\n\tif (sb->s_blocksize - fibh->eoffset >= nfidlen) {\n\t\tfibh->soffset = fibh->eoffset;\n\t\tfibh->eoffset += nfidlen;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tblock = dinfo->i_location.logicalBlockNum;\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t\t(dinfo->i_ext.i_data +\n\t\t\t\t\t fibh->soffset -\n\t\t\t\t\t udf_ext0_offset(dir) +\n\t\t\t\t\t dinfo->i_lenEAttr);\n\t\t} else {\n\t\t\tblock = eloc.logicalBlockNum +\n\t\t\t\t\t((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + fibh->soffset);\n\t\t}\n\t} else {\n\t\t/* Round up last extent in the file */\n\t\telen = (elen + sb->s_blocksize - 1) & ~(sb->s_blocksize - 1);\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\tdinfo->i_lenExtents = (dinfo->i_lenExtents + sb->s_blocksize\n\t\t\t\t\t- 1) & ~(sb->s_blocksize - 1);\n\n\t\tfibh->soffset = fibh->eoffset - sb->s_blocksize;\n\t\tfibh->eoffset += nfidlen - sb->s_blocksize;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\tfibh->ebh = udf_bread(dir,\n\t\t\t\tf_pos >> dir->i_sb->s_blocksize_bits, 1, err);\n\t\tif (!fibh->ebh)\n\t\t\tgoto out_err;\n\t\t/* Extents could have been merged, invalidate our position */\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\n\t\tif (!fibh->soffset) {\n\t\t\t/* Find the freshly allocated block */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t\tfi = (struct fileIdentDesc *)(fibh->sbh->b_data);\n\t\t} else {\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + sb->s_blocksize +\n\t\t\t\t\tfibh->soffset);\n\t\t}\n\t}\n\n\tmemset(cfi, 0, sizeof(struct fileIdentDesc));\n\tif (UDF_SB(sb)->s_udfrev >= 0x0200)\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 3, 1, block,\n\t\t\t    sizeof(struct tag));\n\telse\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 2, 1, block,\n\t\t\t    sizeof(struct tag));\n\tcfi->fileVersionNum = cpu_to_le16(1);\n\tcfi->lengthFileIdent = namelen;\n\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL, name)) {\n\t\tdir->i_size += nfidlen;\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tdinfo->i_lenAlloc += nfidlen;\n\t\telse {\n\t\t\t/* Find the last extent and truncate it to proper size */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\telen -= dinfo->i_lenExtents - dir->i_size;\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\t\tdinfo->i_lenExtents = dir->i_size;\n\t\t}\n\n\t\tmark_inode_dirty(dir);\n\t\tgoto out_ok;\n\t} else {\n\t\t*err = -EIO;\n\t\tgoto out_err;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(name);\n\treturn fi;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic struct fileIdentDesc *udf_add_entry(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   struct udf_fileident_bh *fibh,\n\t\t\t\t\t   struct fileIdentDesc *cfi, int *err)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fileIdentDesc *fi = NULL;\n\tunsigned char *name = NULL;\n\tint namelen;\n\tloff_t f_pos;\n\tloff_t size = udf_ext0_offset(dir) + dir->i_size;\n\tint nfidlen;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tint block;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen = 0;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo;\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!name) {\n\t\t*err = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tif (dentry) {\n\t\tif (!dentry->d_name.len) {\n\t\t\t*err = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t\tnamelen = udf_put_filename(sb, dentry->d_name.name, name,\n\t\t\t\t\t\t dentry->d_name.len);\n\t\tif (!namelen) {\n\t\t\t*err = -ENAMETOOLONG;\n\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\tnamelen = 0;\n\t}\n\n\tnfidlen = (sizeof(struct fileIdentDesc) + namelen + 3) & ~3;\n\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\tdinfo = UDF_I(dir);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tblock = udf_get_lb_pblock(dir->i_sb,\n\t\t\t\t\t&dinfo->i_location, 0);\n\t\t\tfibh->soffset = fibh->eoffset = sb->s_blocksize;\n\t\t\tgoto add;\n\t\t}\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tblock = dinfo->i_location.logicalBlockNum;\n\t}\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\n\t\tif (!fi) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (((sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi + 3) & ~3) == nfidlen) {\n\t\t\t\tcfi->descTag.tagSerialNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileVersionNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileCharacteristics = 0;\n\t\t\t\tcfi->lengthFileIdent = namelen;\n\t\t\t\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\t\t\t\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL,\n\t\t\t\t\t\t  name))\n\t\t\t\t\tgoto out_ok;\n\t\t\t\telse {\n\t\t\t\t\t*err = -EIO;\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nadd:\n\tf_pos += nfidlen;\n\n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB &&\n\t    sb->s_blocksize - fibh->eoffset < nfidlen) {\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tfibh->soffset -= udf_ext0_offset(dir);\n\t\tfibh->eoffset -= udf_ext0_offset(dir);\n\t\tf_pos -= udf_ext0_offset(dir);\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tbrelse(fibh->ebh);\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh =\n\t\t\t\tudf_expand_dir_adinicb(dir, &block, err);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\t\t/* Load extent udf_expand_dir_adinicb() has created */\n\t\tudf_current_aext(dir, &epos, &eloc, &elen, 1);\n\t}\n\n\t/* Entry fits into current block? */\n\tif (sb->s_blocksize - fibh->eoffset >= nfidlen) {\n\t\tfibh->soffset = fibh->eoffset;\n\t\tfibh->eoffset += nfidlen;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tblock = dinfo->i_location.logicalBlockNum;\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t\t(dinfo->i_ext.i_data +\n\t\t\t\t\t fibh->soffset -\n\t\t\t\t\t udf_ext0_offset(dir) +\n\t\t\t\t\t dinfo->i_lenEAttr);\n\t\t} else {\n\t\t\tblock = eloc.logicalBlockNum +\n\t\t\t\t\t((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + fibh->soffset);\n\t\t}\n\t} else {\n\t\t/* Round up last extent in the file */\n\t\telen = (elen + sb->s_blocksize - 1) & ~(sb->s_blocksize - 1);\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\tdinfo->i_lenExtents = (dinfo->i_lenExtents + sb->s_blocksize\n\t\t\t\t\t- 1) & ~(sb->s_blocksize - 1);\n\n\t\tfibh->soffset = fibh->eoffset - sb->s_blocksize;\n\t\tfibh->eoffset += nfidlen - sb->s_blocksize;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\tfibh->ebh = udf_bread(dir,\n\t\t\t\tf_pos >> dir->i_sb->s_blocksize_bits, 1, err);\n\t\tif (!fibh->ebh)\n\t\t\tgoto out_err;\n\t\t/* Extents could have been merged, invalidate our position */\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\n\t\tif (!fibh->soffset) {\n\t\t\t/* Find the freshly allocated block */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t\tfi = (struct fileIdentDesc *)(fibh->sbh->b_data);\n\t\t} else {\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + sb->s_blocksize +\n\t\t\t\t\tfibh->soffset);\n\t\t}\n\t}\n\n\tmemset(cfi, 0, sizeof(struct fileIdentDesc));\n\tif (UDF_SB(sb)->s_udfrev >= 0x0200)\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 3, 1, block,\n\t\t\t    sizeof(struct tag));\n\telse\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 2, 1, block,\n\t\t\t    sizeof(struct tag));\n\tcfi->fileVersionNum = cpu_to_le16(1);\n\tcfi->lengthFileIdent = namelen;\n\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL, name)) {\n\t\tdir->i_size += nfidlen;\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tdinfo->i_lenAlloc += nfidlen;\n\t\telse {\n\t\t\t/* Find the last extent and truncate it to proper size */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\telen -= dinfo->i_lenExtents - dir->i_size;\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\t\tdinfo->i_lenExtents = dir->i_size;\n\t\t}\n\n\t\tmark_inode_dirty(dir);\n\t\tgoto out_ok;\n\t} else {\n\t\t*err = -EIO;\n\t\tgoto out_err;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(name);\n\treturn fi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "dinfo->i_unique & 0x00000000FFFFFFFFUL"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_sb->s_blocksize"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_new_inode",
          "args": [
            "dir",
            "S_IFDIR | mode"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "udf_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/ialloc.c",
          "lines": "48-133",
          "snippet": "struct inode *udf_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct inode *inode;\n\tint block;\n\tuint32_t start = UDF_I(dir)->i_location.logicalBlockNum;\n\tstruct udf_inode_info *iinfo;\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\tint err;\n\n\tinode = new_inode(sb);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tiinfo = UDF_I(inode);\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_EXTENDED_FE)) {\n\t\tiinfo->i_efe = 1;\n\t\tif (UDF_VERS_USE_EXTENDED_FE > sbi->s_udfrev)\n\t\t\tsbi->s_udfrev = UDF_VERS_USE_EXTENDED_FE;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct extendedFileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t} else {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct fileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t}\n\tif (!iinfo->i_ext.i_data) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terr = -ENOSPC;\n\tblock = udf_new_block(dir->i_sb, NULL,\n\t\t\t      dinfo->i_location.partitionReferenceNum,\n\t\t\t      start, &err);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (lvidiu) {\n\t\tiinfo->i_unique = lvid_get_unique_id(sb);\n\t\tinode->i_generation = iinfo->i_unique;\n\t\tmutex_lock(&sbi->s_alloc_mutex);\n\t\tif (S_ISDIR(mode))\n\t\t\tle32_add_cpu(&lvidiu->numDirs, 1);\n\t\telse\n\t\t\tle32_add_cpu(&lvidiu->numFiles, 1);\n\t\tudf_updated_lvid(sb);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t}\n\n\tinode_init_owner(inode, dir, mode);\n\n\tiinfo->i_location.logicalBlockNum = block;\n\tiinfo->i_location.partitionReferenceNum =\n\t\t\t\tdinfo->i_location.partitionReferenceNum;\n\tinode->i_ino = udf_get_lb_pblock(sb, &iinfo->i_location, 0);\n\tinode->i_blocks = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_use = 0;\n\tiinfo->i_checkpoint = 1;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_AD_IN_ICB))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\telse if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime =\n\t\tiinfo->i_crtime = current_fs_time(inode->i_sb);\n\tif (unlikely(insert_inode_locked(inode) < 0)) {\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tmark_inode_dirty(inode);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct inode *udf_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct inode *inode;\n\tint block;\n\tuint32_t start = UDF_I(dir)->i_location.logicalBlockNum;\n\tstruct udf_inode_info *iinfo;\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\tint err;\n\n\tinode = new_inode(sb);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tiinfo = UDF_I(inode);\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_EXTENDED_FE)) {\n\t\tiinfo->i_efe = 1;\n\t\tif (UDF_VERS_USE_EXTENDED_FE > sbi->s_udfrev)\n\t\t\tsbi->s_udfrev = UDF_VERS_USE_EXTENDED_FE;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct extendedFileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t} else {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct fileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t}\n\tif (!iinfo->i_ext.i_data) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terr = -ENOSPC;\n\tblock = udf_new_block(dir->i_sb, NULL,\n\t\t\t      dinfo->i_location.partitionReferenceNum,\n\t\t\t      start, &err);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (lvidiu) {\n\t\tiinfo->i_unique = lvid_get_unique_id(sb);\n\t\tinode->i_generation = iinfo->i_unique;\n\t\tmutex_lock(&sbi->s_alloc_mutex);\n\t\tif (S_ISDIR(mode))\n\t\t\tle32_add_cpu(&lvidiu->numDirs, 1);\n\t\telse\n\t\t\tle32_add_cpu(&lvidiu->numFiles, 1);\n\t\tudf_updated_lvid(sb);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t}\n\n\tinode_init_owner(inode, dir, mode);\n\n\tiinfo->i_location.logicalBlockNum = block;\n\tiinfo->i_location.partitionReferenceNum =\n\t\t\t\tdinfo->i_location.partitionReferenceNum;\n\tinode->i_ino = udf_get_lb_pblock(sb, &iinfo->i_location, 0);\n\tinode->i_blocks = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_use = 0;\n\tiinfo->i_checkpoint = 1;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_AD_IN_ICB))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\telse if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime =\n\t\tiinfo->i_crtime = current_fs_time(inode->i_sb);\n\tif (unlikely(insert_inode_locked(inode) < 0)) {\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tmark_inode_dirty(inode);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nconst struct inode_operations udf_dir_inode_operations = {\n\t.lookup\t\t\t\t= udf_lookup,\n\t.create\t\t\t\t= udf_create,\n\t.link\t\t\t\t= udf_link,\n\t.unlink\t\t\t\t= udf_unlink,\n\t.symlink\t\t\t= udf_symlink,\n\t.mkdir\t\t\t\t= udf_mkdir,\n\t.rmdir\t\t\t\t= udf_rmdir,\n\t.mknod\t\t\t\t= udf_mknod,\n\t.rename\t\t\t\t= udf_rename,\n\t.tmpfile\t\t\t= udf_tmpfile,\n};\n\nstatic int udf_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode;\n\tstruct udf_fileident_bh fibh;\n\tstruct fileIdentDesc cfi, *fi;\n\tint err;\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tstruct udf_inode_info *iinfo;\n\n\tinode = udf_new_inode(dir, S_IFDIR | mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tiinfo = UDF_I(inode);\n\tinode->i_op = &udf_dir_inode_operations;\n\tinode->i_fop = &udf_dir_operations;\n\tfi = udf_add_entry(inode, NULL, &fibh, &cfi, &err);\n\tif (!fi) {\n\t\tinode_dec_link_count(inode);\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\tset_nlink(inode, 2);\n\tcfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\tcfi.icb.extLocation = cpu_to_lelb(dinfo->i_location);\n\t*(__le32 *)((struct allocDescImpUse *)cfi.icb.impUse)->impUse =\n\t\tcpu_to_le32(dinfo->i_unique & 0x00000000FFFFFFFFUL);\n\tcfi.fileCharacteristics =\n\t\t\tFID_FILE_CHAR_DIRECTORY | FID_FILE_CHAR_PARENT;\n\tudf_write_fi(inode, &cfi, fi, &fibh, NULL, NULL);\n\tbrelse(fibh.sbh);\n\tmark_inode_dirty(inode);\n\n\tfi = udf_add_entry(dir, dentry, &fibh, &cfi, &err);\n\tif (!fi) {\n\t\tclear_nlink(inode);\n\t\tmark_inode_dirty(inode);\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\tgoto out;\n\t}\n\tcfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\tcfi.icb.extLocation = cpu_to_lelb(iinfo->i_location);\n\t*(__le32 *)((struct allocDescImpUse *)cfi.icb.impUse)->impUse =\n\t\tcpu_to_le32(iinfo->i_unique & 0x00000000FFFFFFFFUL);\n\tcfi.fileCharacteristics |= FID_FILE_CHAR_DIRECTORY;\n\tudf_write_fi(dir, &cfi, fi, &fibh, NULL, NULL);\n\tinc_nlink(dir);\n\tmark_inode_dirty(dir);\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\terr = 0;\n\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "udf_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "621-635",
    "snippet": "static int udf_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t     dev_t rdev)\n{\n\tstruct inode *inode;\n\n\tif (!old_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tinode = udf_new_inode(dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinit_special_inode(inode, mode, rdev);\n\treturn udf_add_nondir(dentry, inode);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_add_nondir",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "udf_add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "552-581",
          "snippet": "static int udf_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct udf_fileident_bh fibh;\n\tstruct fileIdentDesc cfi, *fi;\n\tint err;\n\n\tfi = udf_add_entry(dir, dentry, &fibh, &cfi, &err);\n\tif (unlikely(!fi)) {\n\t\tinode_dec_link_count(inode);\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\treturn err;\n\t}\n\tcfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\tcfi.icb.extLocation = cpu_to_lelb(iinfo->i_location);\n\t*(__le32 *)((struct allocDescImpUse *)cfi.icb.impUse)->impUse =\n\t\tcpu_to_le32(iinfo->i_unique & 0x00000000FFFFFFFFUL);\n\tudf_write_fi(dir, &cfi, fi, &fibh, NULL, NULL);\n\tif (UDF_I(dir)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tmark_inode_dirty(dir);\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic int udf_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct udf_fileident_bh fibh;\n\tstruct fileIdentDesc cfi, *fi;\n\tint err;\n\n\tfi = udf_add_entry(dir, dentry, &fibh, &cfi, &err);\n\tif (unlikely(!fi)) {\n\t\tinode_dec_link_count(inode);\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\treturn err;\n\t}\n\tcfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\tcfi.icb.extLocation = cpu_to_lelb(iinfo->i_location);\n\t*(__le32 *)((struct allocDescImpUse *)cfi.icb.impUse)->impUse =\n\t\tcpu_to_le32(iinfo->i_unique & 0x00000000FFFFFFFFUL);\n\tudf_write_fi(dir, &cfi, fi, &fibh, NULL, NULL);\n\tif (UDF_I(dir)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tmark_inode_dirty(dir);\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "mode",
            "rdev"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_new_inode",
          "args": [
            "dir",
            "mode"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "udf_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/ialloc.c",
          "lines": "48-133",
          "snippet": "struct inode *udf_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct inode *inode;\n\tint block;\n\tuint32_t start = UDF_I(dir)->i_location.logicalBlockNum;\n\tstruct udf_inode_info *iinfo;\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\tint err;\n\n\tinode = new_inode(sb);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tiinfo = UDF_I(inode);\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_EXTENDED_FE)) {\n\t\tiinfo->i_efe = 1;\n\t\tif (UDF_VERS_USE_EXTENDED_FE > sbi->s_udfrev)\n\t\t\tsbi->s_udfrev = UDF_VERS_USE_EXTENDED_FE;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct extendedFileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t} else {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct fileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t}\n\tif (!iinfo->i_ext.i_data) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terr = -ENOSPC;\n\tblock = udf_new_block(dir->i_sb, NULL,\n\t\t\t      dinfo->i_location.partitionReferenceNum,\n\t\t\t      start, &err);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (lvidiu) {\n\t\tiinfo->i_unique = lvid_get_unique_id(sb);\n\t\tinode->i_generation = iinfo->i_unique;\n\t\tmutex_lock(&sbi->s_alloc_mutex);\n\t\tif (S_ISDIR(mode))\n\t\t\tle32_add_cpu(&lvidiu->numDirs, 1);\n\t\telse\n\t\t\tle32_add_cpu(&lvidiu->numFiles, 1);\n\t\tudf_updated_lvid(sb);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t}\n\n\tinode_init_owner(inode, dir, mode);\n\n\tiinfo->i_location.logicalBlockNum = block;\n\tiinfo->i_location.partitionReferenceNum =\n\t\t\t\tdinfo->i_location.partitionReferenceNum;\n\tinode->i_ino = udf_get_lb_pblock(sb, &iinfo->i_location, 0);\n\tinode->i_blocks = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_use = 0;\n\tiinfo->i_checkpoint = 1;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_AD_IN_ICB))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\telse if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime =\n\t\tiinfo->i_crtime = current_fs_time(inode->i_sb);\n\tif (unlikely(insert_inode_locked(inode) < 0)) {\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tmark_inode_dirty(inode);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct inode *udf_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct inode *inode;\n\tint block;\n\tuint32_t start = UDF_I(dir)->i_location.logicalBlockNum;\n\tstruct udf_inode_info *iinfo;\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\tint err;\n\n\tinode = new_inode(sb);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tiinfo = UDF_I(inode);\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_EXTENDED_FE)) {\n\t\tiinfo->i_efe = 1;\n\t\tif (UDF_VERS_USE_EXTENDED_FE > sbi->s_udfrev)\n\t\t\tsbi->s_udfrev = UDF_VERS_USE_EXTENDED_FE;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct extendedFileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t} else {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct fileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t}\n\tif (!iinfo->i_ext.i_data) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terr = -ENOSPC;\n\tblock = udf_new_block(dir->i_sb, NULL,\n\t\t\t      dinfo->i_location.partitionReferenceNum,\n\t\t\t      start, &err);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (lvidiu) {\n\t\tiinfo->i_unique = lvid_get_unique_id(sb);\n\t\tinode->i_generation = iinfo->i_unique;\n\t\tmutex_lock(&sbi->s_alloc_mutex);\n\t\tif (S_ISDIR(mode))\n\t\t\tle32_add_cpu(&lvidiu->numDirs, 1);\n\t\telse\n\t\t\tle32_add_cpu(&lvidiu->numFiles, 1);\n\t\tudf_updated_lvid(sb);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t}\n\n\tinode_init_owner(inode, dir, mode);\n\n\tiinfo->i_location.logicalBlockNum = block;\n\tiinfo->i_location.partitionReferenceNum =\n\t\t\t\tdinfo->i_location.partitionReferenceNum;\n\tinode->i_ino = udf_get_lb_pblock(sb, &iinfo->i_location, 0);\n\tinode->i_blocks = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_use = 0;\n\tiinfo->i_checkpoint = 1;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_AD_IN_ICB))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\telse if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime =\n\t\tiinfo->i_crtime = current_fs_time(inode->i_sb);\n\tif (unlikely(insert_inode_locked(inode) < 0)) {\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tmark_inode_dirty(inode);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_valid_dev",
          "args": [
            "rdev"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic int udf_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t     dev_t rdev)\n{\n\tstruct inode *inode;\n\n\tif (!old_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tinode = udf_new_inode(dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinit_special_inode(inode, mode, rdev);\n\treturn udf_add_nondir(dentry, inode);\n}"
  },
  {
    "function_name": "udf_tmpfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "602-619",
    "snippet": "static int udf_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode = udf_new_inode(dir, mode);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\telse\n\t\tinode->i_data.a_ops = &udf_aops;\n\tinode->i_op = &udf_file_inode_operations;\n\tinode->i_fop = &udf_file_operations;\n\tmark_inode_dirty(inode);\n\td_tmpfile(dentry, inode);\n\tunlock_new_inode(inode);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_tmpfile",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "d_tmpfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3325-3338",
          "snippet": "void d_tmpfile(struct dentry *dentry, struct inode *inode)\n{\n\tinode_dec_link_count(inode);\n\tBUG_ON(dentry->d_name.name != dentry->d_iname ||\n\t\t!hlist_unhashed(&dentry->d_u.d_alias) ||\n\t\t!d_unlinked(dentry));\n\tspin_lock(&dentry->d_parent->d_lock);\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tdentry->d_name.len = sprintf(dentry->d_iname, \"#%llu\",\n\t\t\t\t(unsigned long long)inode->i_ino);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&dentry->d_parent->d_lock);\n\td_instantiate(dentry, inode);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_tmpfile(struct dentry *dentry, struct inode *inode)\n{\n\tinode_dec_link_count(inode);\n\tBUG_ON(dentry->d_name.name != dentry->d_iname ||\n\t\t!hlist_unhashed(&dentry->d_u.d_alias) ||\n\t\t!d_unlinked(dentry));\n\tspin_lock(&dentry->d_parent->d_lock);\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tdentry->d_name.len = sprintf(dentry->d_iname, \"#%llu\",\n\t\t\t\t(unsigned long long)inode->i_ino);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&dentry->d_parent->d_lock);\n\td_instantiate(dentry, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_new_inode",
          "args": [
            "dir",
            "mode"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "udf_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/ialloc.c",
          "lines": "48-133",
          "snippet": "struct inode *udf_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct inode *inode;\n\tint block;\n\tuint32_t start = UDF_I(dir)->i_location.logicalBlockNum;\n\tstruct udf_inode_info *iinfo;\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\tint err;\n\n\tinode = new_inode(sb);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tiinfo = UDF_I(inode);\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_EXTENDED_FE)) {\n\t\tiinfo->i_efe = 1;\n\t\tif (UDF_VERS_USE_EXTENDED_FE > sbi->s_udfrev)\n\t\t\tsbi->s_udfrev = UDF_VERS_USE_EXTENDED_FE;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct extendedFileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t} else {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct fileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t}\n\tif (!iinfo->i_ext.i_data) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terr = -ENOSPC;\n\tblock = udf_new_block(dir->i_sb, NULL,\n\t\t\t      dinfo->i_location.partitionReferenceNum,\n\t\t\t      start, &err);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (lvidiu) {\n\t\tiinfo->i_unique = lvid_get_unique_id(sb);\n\t\tinode->i_generation = iinfo->i_unique;\n\t\tmutex_lock(&sbi->s_alloc_mutex);\n\t\tif (S_ISDIR(mode))\n\t\t\tle32_add_cpu(&lvidiu->numDirs, 1);\n\t\telse\n\t\t\tle32_add_cpu(&lvidiu->numFiles, 1);\n\t\tudf_updated_lvid(sb);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t}\n\n\tinode_init_owner(inode, dir, mode);\n\n\tiinfo->i_location.logicalBlockNum = block;\n\tiinfo->i_location.partitionReferenceNum =\n\t\t\t\tdinfo->i_location.partitionReferenceNum;\n\tinode->i_ino = udf_get_lb_pblock(sb, &iinfo->i_location, 0);\n\tinode->i_blocks = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_use = 0;\n\tiinfo->i_checkpoint = 1;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_AD_IN_ICB))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\telse if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime =\n\t\tiinfo->i_crtime = current_fs_time(inode->i_sb);\n\tif (unlikely(insert_inode_locked(inode) < 0)) {\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tmark_inode_dirty(inode);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct inode *udf_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct inode *inode;\n\tint block;\n\tuint32_t start = UDF_I(dir)->i_location.logicalBlockNum;\n\tstruct udf_inode_info *iinfo;\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\tint err;\n\n\tinode = new_inode(sb);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tiinfo = UDF_I(inode);\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_EXTENDED_FE)) {\n\t\tiinfo->i_efe = 1;\n\t\tif (UDF_VERS_USE_EXTENDED_FE > sbi->s_udfrev)\n\t\t\tsbi->s_udfrev = UDF_VERS_USE_EXTENDED_FE;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct extendedFileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t} else {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct fileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t}\n\tif (!iinfo->i_ext.i_data) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terr = -ENOSPC;\n\tblock = udf_new_block(dir->i_sb, NULL,\n\t\t\t      dinfo->i_location.partitionReferenceNum,\n\t\t\t      start, &err);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (lvidiu) {\n\t\tiinfo->i_unique = lvid_get_unique_id(sb);\n\t\tinode->i_generation = iinfo->i_unique;\n\t\tmutex_lock(&sbi->s_alloc_mutex);\n\t\tif (S_ISDIR(mode))\n\t\t\tle32_add_cpu(&lvidiu->numDirs, 1);\n\t\telse\n\t\t\tle32_add_cpu(&lvidiu->numFiles, 1);\n\t\tudf_updated_lvid(sb);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t}\n\n\tinode_init_owner(inode, dir, mode);\n\n\tiinfo->i_location.logicalBlockNum = block;\n\tiinfo->i_location.partitionReferenceNum =\n\t\t\t\tdinfo->i_location.partitionReferenceNum;\n\tinode->i_ino = udf_get_lb_pblock(sb, &iinfo->i_location, 0);\n\tinode->i_blocks = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_use = 0;\n\tiinfo->i_checkpoint = 1;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_AD_IN_ICB))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\telse if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime =\n\t\tiinfo->i_crtime = current_fs_time(inode->i_sb);\n\tif (unlikely(insert_inode_locked(inode) < 0)) {\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tmark_inode_dirty(inode);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic int udf_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode = udf_new_inode(dir, mode);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\telse\n\t\tinode->i_data.a_ops = &udf_aops;\n\tinode->i_op = &udf_file_inode_operations;\n\tinode->i_fop = &udf_file_operations;\n\tmark_inode_dirty(inode);\n\td_tmpfile(dentry, inode);\n\tunlock_new_inode(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "583-600",
    "snippet": "static int udf_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t      bool excl)\n{\n\tstruct inode *inode = udf_new_inode(dir, mode);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\telse\n\t\tinode->i_data.a_ops = &udf_aops;\n\tinode->i_op = &udf_file_inode_operations;\n\tinode->i_fop = &udf_file_operations;\n\tmark_inode_dirty(inode);\n\n\treturn udf_add_nondir(dentry, inode);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_add_nondir",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "udf_add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "552-581",
          "snippet": "static int udf_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct udf_fileident_bh fibh;\n\tstruct fileIdentDesc cfi, *fi;\n\tint err;\n\n\tfi = udf_add_entry(dir, dentry, &fibh, &cfi, &err);\n\tif (unlikely(!fi)) {\n\t\tinode_dec_link_count(inode);\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\treturn err;\n\t}\n\tcfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\tcfi.icb.extLocation = cpu_to_lelb(iinfo->i_location);\n\t*(__le32 *)((struct allocDescImpUse *)cfi.icb.impUse)->impUse =\n\t\tcpu_to_le32(iinfo->i_unique & 0x00000000FFFFFFFFUL);\n\tudf_write_fi(dir, &cfi, fi, &fibh, NULL, NULL);\n\tif (UDF_I(dir)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tmark_inode_dirty(dir);\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic int udf_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct udf_fileident_bh fibh;\n\tstruct fileIdentDesc cfi, *fi;\n\tint err;\n\n\tfi = udf_add_entry(dir, dentry, &fibh, &cfi, &err);\n\tif (unlikely(!fi)) {\n\t\tinode_dec_link_count(inode);\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\treturn err;\n\t}\n\tcfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\tcfi.icb.extLocation = cpu_to_lelb(iinfo->i_location);\n\t*(__le32 *)((struct allocDescImpUse *)cfi.icb.impUse)->impUse =\n\t\tcpu_to_le32(iinfo->i_unique & 0x00000000FFFFFFFFUL);\n\tudf_write_fi(dir, &cfi, fi, &fibh, NULL, NULL);\n\tif (UDF_I(dir)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tmark_inode_dirty(dir);\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_new_inode",
          "args": [
            "dir",
            "mode"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "udf_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/ialloc.c",
          "lines": "48-133",
          "snippet": "struct inode *udf_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct inode *inode;\n\tint block;\n\tuint32_t start = UDF_I(dir)->i_location.logicalBlockNum;\n\tstruct udf_inode_info *iinfo;\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\tint err;\n\n\tinode = new_inode(sb);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tiinfo = UDF_I(inode);\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_EXTENDED_FE)) {\n\t\tiinfo->i_efe = 1;\n\t\tif (UDF_VERS_USE_EXTENDED_FE > sbi->s_udfrev)\n\t\t\tsbi->s_udfrev = UDF_VERS_USE_EXTENDED_FE;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct extendedFileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t} else {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct fileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t}\n\tif (!iinfo->i_ext.i_data) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terr = -ENOSPC;\n\tblock = udf_new_block(dir->i_sb, NULL,\n\t\t\t      dinfo->i_location.partitionReferenceNum,\n\t\t\t      start, &err);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (lvidiu) {\n\t\tiinfo->i_unique = lvid_get_unique_id(sb);\n\t\tinode->i_generation = iinfo->i_unique;\n\t\tmutex_lock(&sbi->s_alloc_mutex);\n\t\tif (S_ISDIR(mode))\n\t\t\tle32_add_cpu(&lvidiu->numDirs, 1);\n\t\telse\n\t\t\tle32_add_cpu(&lvidiu->numFiles, 1);\n\t\tudf_updated_lvid(sb);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t}\n\n\tinode_init_owner(inode, dir, mode);\n\n\tiinfo->i_location.logicalBlockNum = block;\n\tiinfo->i_location.partitionReferenceNum =\n\t\t\t\tdinfo->i_location.partitionReferenceNum;\n\tinode->i_ino = udf_get_lb_pblock(sb, &iinfo->i_location, 0);\n\tinode->i_blocks = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_use = 0;\n\tiinfo->i_checkpoint = 1;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_AD_IN_ICB))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\telse if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime =\n\t\tiinfo->i_crtime = current_fs_time(inode->i_sb);\n\tif (unlikely(insert_inode_locked(inode) < 0)) {\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tmark_inode_dirty(inode);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct inode *udf_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct inode *inode;\n\tint block;\n\tuint32_t start = UDF_I(dir)->i_location.logicalBlockNum;\n\tstruct udf_inode_info *iinfo;\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\tint err;\n\n\tinode = new_inode(sb);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tiinfo = UDF_I(inode);\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_EXTENDED_FE)) {\n\t\tiinfo->i_efe = 1;\n\t\tif (UDF_VERS_USE_EXTENDED_FE > sbi->s_udfrev)\n\t\t\tsbi->s_udfrev = UDF_VERS_USE_EXTENDED_FE;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct extendedFileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t} else {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct fileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t}\n\tif (!iinfo->i_ext.i_data) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terr = -ENOSPC;\n\tblock = udf_new_block(dir->i_sb, NULL,\n\t\t\t      dinfo->i_location.partitionReferenceNum,\n\t\t\t      start, &err);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (lvidiu) {\n\t\tiinfo->i_unique = lvid_get_unique_id(sb);\n\t\tinode->i_generation = iinfo->i_unique;\n\t\tmutex_lock(&sbi->s_alloc_mutex);\n\t\tif (S_ISDIR(mode))\n\t\t\tle32_add_cpu(&lvidiu->numDirs, 1);\n\t\telse\n\t\t\tle32_add_cpu(&lvidiu->numFiles, 1);\n\t\tudf_updated_lvid(sb);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t}\n\n\tinode_init_owner(inode, dir, mode);\n\n\tiinfo->i_location.logicalBlockNum = block;\n\tiinfo->i_location.partitionReferenceNum =\n\t\t\t\tdinfo->i_location.partitionReferenceNum;\n\tinode->i_ino = udf_get_lb_pblock(sb, &iinfo->i_location, 0);\n\tinode->i_blocks = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_use = 0;\n\tiinfo->i_checkpoint = 1;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_AD_IN_ICB))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\telse if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime =\n\t\tiinfo->i_crtime = current_fs_time(inode->i_sb);\n\tif (unlikely(insert_inode_locked(inode) < 0)) {\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tmark_inode_dirty(inode);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic int udf_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t      bool excl)\n{\n\tstruct inode *inode = udf_new_inode(dir, mode);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\telse\n\t\tinode->i_data.a_ops = &udf_aops;\n\tinode->i_op = &udf_file_inode_operations;\n\tinode->i_fop = &udf_file_operations;\n\tmark_inode_dirty(inode);\n\n\treturn udf_add_nondir(dentry, inode);\n}"
  },
  {
    "function_name": "udf_add_nondir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "552-581",
    "snippet": "static int udf_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct udf_fileident_bh fibh;\n\tstruct fileIdentDesc cfi, *fi;\n\tint err;\n\n\tfi = udf_add_entry(dir, dentry, &fibh, &cfi, &err);\n\tif (unlikely(!fi)) {\n\t\tinode_dec_link_count(inode);\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\treturn err;\n\t}\n\tcfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\tcfi.icb.extLocation = cpu_to_lelb(iinfo->i_location);\n\t*(__le32 *)((struct allocDescImpUse *)cfi.icb.impUse)->impUse =\n\t\tcpu_to_le32(iinfo->i_unique & 0x00000000FFFFFFFFUL);\n\tudf_write_fi(dir, &cfi, fi, &fibh, NULL, NULL);\n\tif (UDF_I(dir)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tmark_inode_dirty(dir);\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "fibh.sbh"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "dir"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_write_fi",
          "args": [
            "dir",
            "&cfi",
            "fi",
            "&fibh",
            "NULL",
            "NULL"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_fi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "44-140",
          "snippet": "int udf_write_fi(struct inode *inode, struct fileIdentDesc *cfi,\n\t\t struct fileIdentDesc *sfi, struct udf_fileident_bh *fibh,\n\t\t uint8_t *impuse, uint8_t *fileident)\n{\n\tuint16_t crclen = fibh->eoffset - fibh->soffset - sizeof(struct tag);\n\tuint16_t crc;\n\tint offset;\n\tuint16_t liu = le16_to_cpu(cfi->lengthOfImpUse);\n\tuint8_t lfi = cfi->lengthFileIdent;\n\tint padlen = fibh->eoffset - fibh->soffset - liu - lfi -\n\t\tsizeof(struct fileIdentDesc);\n\tint adinicb = 0;\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tadinicb = 1;\n\n\toffset = fibh->soffset + sizeof(struct fileIdentDesc);\n\n\tif (impuse) {\n\t\tif (adinicb || (offset + liu < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, liu);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, impuse, liu);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, -offset);\n\t\t\tmemcpy(fibh->ebh->b_data, impuse - offset,\n\t\t\t\tliu + offset);\n\t\t}\n\t}\n\n\toffset += liu;\n\n\tif (fileident) {\n\t\tif (adinicb || (offset + lfi < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident, lfi);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, fileident, lfi);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident,\n\t\t\t\t-offset);\n\t\t\tmemcpy(fibh->ebh->b_data, fileident - offset,\n\t\t\t\tlfi + offset);\n\t\t}\n\t}\n\n\toffset += lfi;\n\n\tif (adinicb || (offset + padlen < 0)) {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, padlen);\n\t} else if (offset >= 0) {\n\t\tmemset(fibh->ebh->b_data + offset, 0x00, padlen);\n\t} else {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, -offset);\n\t\tmemset(fibh->ebh->b_data, 0x00, padlen + offset);\n\t}\n\n\tcrc = crc_itu_t(0, (uint8_t *)cfi + sizeof(struct tag),\n\t\t      sizeof(struct fileIdentDesc) - sizeof(struct tag));\n\n\tif (fibh->sbh == fibh->ebh) {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t      sizeof(struct fileIdentDesc));\n\t} else if (sizeof(struct fileIdentDesc) >= -fibh->soffset) {\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data +\n\t\t\t\t\tsizeof(struct fileIdentDesc) +\n\t\t\t\t\tfibh->soffset,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      -fibh->soffset - sizeof(struct fileIdentDesc));\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data, fibh->eoffset);\n\t}\n\n\tcfi->descTag.descCRC = cpu_to_le16(crc);\n\tcfi->descTag.descCRCLength = cpu_to_le16(crclen);\n\tcfi->descTag.tagChecksum = udf_tag_checksum(&cfi->descTag);\n\n\tif (adinicb || (sizeof(struct fileIdentDesc) <= -fibh->soffset)) {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi,\n\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi, -fibh->soffset);\n\t\tmemcpy(fibh->ebh->b_data, (uint8_t *)cfi - fibh->soffset,\n\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\t}\n\n\tif (adinicb) {\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tmark_buffer_dirty_inode(fibh->ebh, inode);\n\t\tmark_buffer_dirty_inode(fibh->sbh, inode);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nint udf_write_fi(struct inode *inode, struct fileIdentDesc *cfi,\n\t\t struct fileIdentDesc *sfi, struct udf_fileident_bh *fibh,\n\t\t uint8_t *impuse, uint8_t *fileident)\n{\n\tuint16_t crclen = fibh->eoffset - fibh->soffset - sizeof(struct tag);\n\tuint16_t crc;\n\tint offset;\n\tuint16_t liu = le16_to_cpu(cfi->lengthOfImpUse);\n\tuint8_t lfi = cfi->lengthFileIdent;\n\tint padlen = fibh->eoffset - fibh->soffset - liu - lfi -\n\t\tsizeof(struct fileIdentDesc);\n\tint adinicb = 0;\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tadinicb = 1;\n\n\toffset = fibh->soffset + sizeof(struct fileIdentDesc);\n\n\tif (impuse) {\n\t\tif (adinicb || (offset + liu < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, liu);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, impuse, liu);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, -offset);\n\t\t\tmemcpy(fibh->ebh->b_data, impuse - offset,\n\t\t\t\tliu + offset);\n\t\t}\n\t}\n\n\toffset += liu;\n\n\tif (fileident) {\n\t\tif (adinicb || (offset + lfi < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident, lfi);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, fileident, lfi);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident,\n\t\t\t\t-offset);\n\t\t\tmemcpy(fibh->ebh->b_data, fileident - offset,\n\t\t\t\tlfi + offset);\n\t\t}\n\t}\n\n\toffset += lfi;\n\n\tif (adinicb || (offset + padlen < 0)) {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, padlen);\n\t} else if (offset >= 0) {\n\t\tmemset(fibh->ebh->b_data + offset, 0x00, padlen);\n\t} else {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, -offset);\n\t\tmemset(fibh->ebh->b_data, 0x00, padlen + offset);\n\t}\n\n\tcrc = crc_itu_t(0, (uint8_t *)cfi + sizeof(struct tag),\n\t\t      sizeof(struct fileIdentDesc) - sizeof(struct tag));\n\n\tif (fibh->sbh == fibh->ebh) {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t      sizeof(struct fileIdentDesc));\n\t} else if (sizeof(struct fileIdentDesc) >= -fibh->soffset) {\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data +\n\t\t\t\t\tsizeof(struct fileIdentDesc) +\n\t\t\t\t\tfibh->soffset,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      -fibh->soffset - sizeof(struct fileIdentDesc));\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data, fibh->eoffset);\n\t}\n\n\tcfi->descTag.descCRC = cpu_to_le16(crc);\n\tcfi->descTag.descCRCLength = cpu_to_le16(crclen);\n\tcfi->descTag.tagChecksum = udf_tag_checksum(&cfi->descTag);\n\n\tif (adinicb || (sizeof(struct fileIdentDesc) <= -fibh->soffset)) {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi,\n\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi, -fibh->soffset);\n\t\tmemcpy(fibh->ebh->b_data, (uint8_t *)cfi - fibh->soffset,\n\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\t}\n\n\tif (adinicb) {\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tmark_buffer_dirty_inode(fibh->ebh, inode);\n\t\tmark_buffer_dirty_inode(fibh->sbh, inode);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "iinfo->i_unique & 0x00000000FFFFFFFFUL"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_lelb",
          "args": [
            "iinfo->i_location"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_lelb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfend.h",
          "lines": "17-25",
          "snippet": "static inline struct lb_addr cpu_to_lelb(struct kernel_lb_addr in)\n{\n\tstruct lb_addr out;\n\n\tout.logicalBlockNum = cpu_to_le32(in.logicalBlockNum);\n\tout.partitionReferenceNum = cpu_to_le16(in.partitionReferenceNum);\n\n\treturn out;\n}",
          "includes": [
            "#include <linux/string.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string.h>\n#include <asm/byteorder.h>\n\nstatic inline struct lb_addr cpu_to_lelb(struct kernel_lb_addr in)\n{\n\tstruct lb_addr out;\n\n\tout.logicalBlockNum = cpu_to_le32(in.logicalBlockNum);\n\tout.partitionReferenceNum = cpu_to_le16(in.partitionReferenceNum);\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_sb->s_blocksize"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!fi"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_add_entry",
          "args": [
            "dir",
            "dentry",
            "&fibh",
            "&cfi",
            "&err"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "udf_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "295-538",
          "snippet": "static struct fileIdentDesc *udf_add_entry(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   struct udf_fileident_bh *fibh,\n\t\t\t\t\t   struct fileIdentDesc *cfi, int *err)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fileIdentDesc *fi = NULL;\n\tunsigned char *name = NULL;\n\tint namelen;\n\tloff_t f_pos;\n\tloff_t size = udf_ext0_offset(dir) + dir->i_size;\n\tint nfidlen;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tint block;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen = 0;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo;\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!name) {\n\t\t*err = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tif (dentry) {\n\t\tif (!dentry->d_name.len) {\n\t\t\t*err = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t\tnamelen = udf_put_filename(sb, dentry->d_name.name, name,\n\t\t\t\t\t\t dentry->d_name.len);\n\t\tif (!namelen) {\n\t\t\t*err = -ENAMETOOLONG;\n\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\tnamelen = 0;\n\t}\n\n\tnfidlen = (sizeof(struct fileIdentDesc) + namelen + 3) & ~3;\n\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\tdinfo = UDF_I(dir);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tblock = udf_get_lb_pblock(dir->i_sb,\n\t\t\t\t\t&dinfo->i_location, 0);\n\t\t\tfibh->soffset = fibh->eoffset = sb->s_blocksize;\n\t\t\tgoto add;\n\t\t}\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tblock = dinfo->i_location.logicalBlockNum;\n\t}\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\n\t\tif (!fi) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (((sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi + 3) & ~3) == nfidlen) {\n\t\t\t\tcfi->descTag.tagSerialNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileVersionNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileCharacteristics = 0;\n\t\t\t\tcfi->lengthFileIdent = namelen;\n\t\t\t\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\t\t\t\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL,\n\t\t\t\t\t\t  name))\n\t\t\t\t\tgoto out_ok;\n\t\t\t\telse {\n\t\t\t\t\t*err = -EIO;\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nadd:\n\tf_pos += nfidlen;\n\n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB &&\n\t    sb->s_blocksize - fibh->eoffset < nfidlen) {\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tfibh->soffset -= udf_ext0_offset(dir);\n\t\tfibh->eoffset -= udf_ext0_offset(dir);\n\t\tf_pos -= udf_ext0_offset(dir);\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tbrelse(fibh->ebh);\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh =\n\t\t\t\tudf_expand_dir_adinicb(dir, &block, err);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\t\t/* Load extent udf_expand_dir_adinicb() has created */\n\t\tudf_current_aext(dir, &epos, &eloc, &elen, 1);\n\t}\n\n\t/* Entry fits into current block? */\n\tif (sb->s_blocksize - fibh->eoffset >= nfidlen) {\n\t\tfibh->soffset = fibh->eoffset;\n\t\tfibh->eoffset += nfidlen;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tblock = dinfo->i_location.logicalBlockNum;\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t\t(dinfo->i_ext.i_data +\n\t\t\t\t\t fibh->soffset -\n\t\t\t\t\t udf_ext0_offset(dir) +\n\t\t\t\t\t dinfo->i_lenEAttr);\n\t\t} else {\n\t\t\tblock = eloc.logicalBlockNum +\n\t\t\t\t\t((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + fibh->soffset);\n\t\t}\n\t} else {\n\t\t/* Round up last extent in the file */\n\t\telen = (elen + sb->s_blocksize - 1) & ~(sb->s_blocksize - 1);\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\tdinfo->i_lenExtents = (dinfo->i_lenExtents + sb->s_blocksize\n\t\t\t\t\t- 1) & ~(sb->s_blocksize - 1);\n\n\t\tfibh->soffset = fibh->eoffset - sb->s_blocksize;\n\t\tfibh->eoffset += nfidlen - sb->s_blocksize;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\tfibh->ebh = udf_bread(dir,\n\t\t\t\tf_pos >> dir->i_sb->s_blocksize_bits, 1, err);\n\t\tif (!fibh->ebh)\n\t\t\tgoto out_err;\n\t\t/* Extents could have been merged, invalidate our position */\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\n\t\tif (!fibh->soffset) {\n\t\t\t/* Find the freshly allocated block */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t\tfi = (struct fileIdentDesc *)(fibh->sbh->b_data);\n\t\t} else {\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + sb->s_blocksize +\n\t\t\t\t\tfibh->soffset);\n\t\t}\n\t}\n\n\tmemset(cfi, 0, sizeof(struct fileIdentDesc));\n\tif (UDF_SB(sb)->s_udfrev >= 0x0200)\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 3, 1, block,\n\t\t\t    sizeof(struct tag));\n\telse\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 2, 1, block,\n\t\t\t    sizeof(struct tag));\n\tcfi->fileVersionNum = cpu_to_le16(1);\n\tcfi->lengthFileIdent = namelen;\n\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL, name)) {\n\t\tdir->i_size += nfidlen;\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tdinfo->i_lenAlloc += nfidlen;\n\t\telse {\n\t\t\t/* Find the last extent and truncate it to proper size */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\telen -= dinfo->i_lenExtents - dir->i_size;\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\t\tdinfo->i_lenExtents = dir->i_size;\n\t\t}\n\n\t\tmark_inode_dirty(dir);\n\t\tgoto out_ok;\n\t} else {\n\t\t*err = -EIO;\n\t\tgoto out_err;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(name);\n\treturn fi;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic struct fileIdentDesc *udf_add_entry(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   struct udf_fileident_bh *fibh,\n\t\t\t\t\t   struct fileIdentDesc *cfi, int *err)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fileIdentDesc *fi = NULL;\n\tunsigned char *name = NULL;\n\tint namelen;\n\tloff_t f_pos;\n\tloff_t size = udf_ext0_offset(dir) + dir->i_size;\n\tint nfidlen;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tint block;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen = 0;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo;\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!name) {\n\t\t*err = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tif (dentry) {\n\t\tif (!dentry->d_name.len) {\n\t\t\t*err = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t\tnamelen = udf_put_filename(sb, dentry->d_name.name, name,\n\t\t\t\t\t\t dentry->d_name.len);\n\t\tif (!namelen) {\n\t\t\t*err = -ENAMETOOLONG;\n\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\tnamelen = 0;\n\t}\n\n\tnfidlen = (sizeof(struct fileIdentDesc) + namelen + 3) & ~3;\n\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\tdinfo = UDF_I(dir);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tblock = udf_get_lb_pblock(dir->i_sb,\n\t\t\t\t\t&dinfo->i_location, 0);\n\t\t\tfibh->soffset = fibh->eoffset = sb->s_blocksize;\n\t\t\tgoto add;\n\t\t}\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tblock = dinfo->i_location.logicalBlockNum;\n\t}\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\n\t\tif (!fi) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (((sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi + 3) & ~3) == nfidlen) {\n\t\t\t\tcfi->descTag.tagSerialNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileVersionNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileCharacteristics = 0;\n\t\t\t\tcfi->lengthFileIdent = namelen;\n\t\t\t\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\t\t\t\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL,\n\t\t\t\t\t\t  name))\n\t\t\t\t\tgoto out_ok;\n\t\t\t\telse {\n\t\t\t\t\t*err = -EIO;\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nadd:\n\tf_pos += nfidlen;\n\n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB &&\n\t    sb->s_blocksize - fibh->eoffset < nfidlen) {\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tfibh->soffset -= udf_ext0_offset(dir);\n\t\tfibh->eoffset -= udf_ext0_offset(dir);\n\t\tf_pos -= udf_ext0_offset(dir);\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tbrelse(fibh->ebh);\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh =\n\t\t\t\tudf_expand_dir_adinicb(dir, &block, err);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\t\t/* Load extent udf_expand_dir_adinicb() has created */\n\t\tudf_current_aext(dir, &epos, &eloc, &elen, 1);\n\t}\n\n\t/* Entry fits into current block? */\n\tif (sb->s_blocksize - fibh->eoffset >= nfidlen) {\n\t\tfibh->soffset = fibh->eoffset;\n\t\tfibh->eoffset += nfidlen;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tblock = dinfo->i_location.logicalBlockNum;\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t\t(dinfo->i_ext.i_data +\n\t\t\t\t\t fibh->soffset -\n\t\t\t\t\t udf_ext0_offset(dir) +\n\t\t\t\t\t dinfo->i_lenEAttr);\n\t\t} else {\n\t\t\tblock = eloc.logicalBlockNum +\n\t\t\t\t\t((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + fibh->soffset);\n\t\t}\n\t} else {\n\t\t/* Round up last extent in the file */\n\t\telen = (elen + sb->s_blocksize - 1) & ~(sb->s_blocksize - 1);\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\tdinfo->i_lenExtents = (dinfo->i_lenExtents + sb->s_blocksize\n\t\t\t\t\t- 1) & ~(sb->s_blocksize - 1);\n\n\t\tfibh->soffset = fibh->eoffset - sb->s_blocksize;\n\t\tfibh->eoffset += nfidlen - sb->s_blocksize;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\tfibh->ebh = udf_bread(dir,\n\t\t\t\tf_pos >> dir->i_sb->s_blocksize_bits, 1, err);\n\t\tif (!fibh->ebh)\n\t\t\tgoto out_err;\n\t\t/* Extents could have been merged, invalidate our position */\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\n\t\tif (!fibh->soffset) {\n\t\t\t/* Find the freshly allocated block */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t\tfi = (struct fileIdentDesc *)(fibh->sbh->b_data);\n\t\t} else {\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + sb->s_blocksize +\n\t\t\t\t\tfibh->soffset);\n\t\t}\n\t}\n\n\tmemset(cfi, 0, sizeof(struct fileIdentDesc));\n\tif (UDF_SB(sb)->s_udfrev >= 0x0200)\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 3, 1, block,\n\t\t\t    sizeof(struct tag));\n\telse\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 2, 1, block,\n\t\t\t    sizeof(struct tag));\n\tcfi->fileVersionNum = cpu_to_le16(1);\n\tcfi->lengthFileIdent = namelen;\n\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL, name)) {\n\t\tdir->i_size += nfidlen;\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tdinfo->i_lenAlloc += nfidlen;\n\t\telse {\n\t\t\t/* Find the last extent and truncate it to proper size */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\telen -= dinfo->i_lenExtents - dir->i_size;\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\t\tdinfo->i_lenExtents = dir->i_size;\n\t\t}\n\n\t\tmark_inode_dirty(dir);\n\t\tgoto out_ok;\n\t} else {\n\t\t*err = -EIO;\n\t\tgoto out_err;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(name);\n\treturn fi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic int udf_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct udf_fileident_bh fibh;\n\tstruct fileIdentDesc cfi, *fi;\n\tint err;\n\n\tfi = udf_add_entry(dir, dentry, &fibh, &cfi, &err);\n\tif (unlikely(!fi)) {\n\t\tinode_dec_link_count(inode);\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\treturn err;\n\t}\n\tcfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\tcfi.icb.extLocation = cpu_to_lelb(iinfo->i_location);\n\t*(__le32 *)((struct allocDescImpUse *)cfi.icb.impUse)->impUse =\n\t\tcpu_to_le32(iinfo->i_unique & 0x00000000FFFFFFFFUL);\n\tudf_write_fi(dir, &cfi, fi, &fibh, NULL, NULL);\n\tif (UDF_I(dir)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tmark_inode_dirty(dir);\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_delete_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "540-550",
    "snippet": "static int udf_delete_entry(struct inode *inode, struct fileIdentDesc *fi,\n\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t    struct fileIdentDesc *cfi)\n{\n\tcfi->fileCharacteristics |= FID_FILE_CHAR_DELETED;\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))\n\t\tmemset(&(cfi->icb), 0x00, sizeof(struct long_ad));\n\n\treturn udf_write_fi(inode, cfi, fi, fibh, NULL, NULL);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_write_fi",
          "args": [
            "inode",
            "cfi",
            "fi",
            "fibh",
            "NULL",
            "NULL"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_fi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "44-140",
          "snippet": "int udf_write_fi(struct inode *inode, struct fileIdentDesc *cfi,\n\t\t struct fileIdentDesc *sfi, struct udf_fileident_bh *fibh,\n\t\t uint8_t *impuse, uint8_t *fileident)\n{\n\tuint16_t crclen = fibh->eoffset - fibh->soffset - sizeof(struct tag);\n\tuint16_t crc;\n\tint offset;\n\tuint16_t liu = le16_to_cpu(cfi->lengthOfImpUse);\n\tuint8_t lfi = cfi->lengthFileIdent;\n\tint padlen = fibh->eoffset - fibh->soffset - liu - lfi -\n\t\tsizeof(struct fileIdentDesc);\n\tint adinicb = 0;\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tadinicb = 1;\n\n\toffset = fibh->soffset + sizeof(struct fileIdentDesc);\n\n\tif (impuse) {\n\t\tif (adinicb || (offset + liu < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, liu);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, impuse, liu);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, -offset);\n\t\t\tmemcpy(fibh->ebh->b_data, impuse - offset,\n\t\t\t\tliu + offset);\n\t\t}\n\t}\n\n\toffset += liu;\n\n\tif (fileident) {\n\t\tif (adinicb || (offset + lfi < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident, lfi);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, fileident, lfi);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident,\n\t\t\t\t-offset);\n\t\t\tmemcpy(fibh->ebh->b_data, fileident - offset,\n\t\t\t\tlfi + offset);\n\t\t}\n\t}\n\n\toffset += lfi;\n\n\tif (adinicb || (offset + padlen < 0)) {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, padlen);\n\t} else if (offset >= 0) {\n\t\tmemset(fibh->ebh->b_data + offset, 0x00, padlen);\n\t} else {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, -offset);\n\t\tmemset(fibh->ebh->b_data, 0x00, padlen + offset);\n\t}\n\n\tcrc = crc_itu_t(0, (uint8_t *)cfi + sizeof(struct tag),\n\t\t      sizeof(struct fileIdentDesc) - sizeof(struct tag));\n\n\tif (fibh->sbh == fibh->ebh) {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t      sizeof(struct fileIdentDesc));\n\t} else if (sizeof(struct fileIdentDesc) >= -fibh->soffset) {\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data +\n\t\t\t\t\tsizeof(struct fileIdentDesc) +\n\t\t\t\t\tfibh->soffset,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      -fibh->soffset - sizeof(struct fileIdentDesc));\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data, fibh->eoffset);\n\t}\n\n\tcfi->descTag.descCRC = cpu_to_le16(crc);\n\tcfi->descTag.descCRCLength = cpu_to_le16(crclen);\n\tcfi->descTag.tagChecksum = udf_tag_checksum(&cfi->descTag);\n\n\tif (adinicb || (sizeof(struct fileIdentDesc) <= -fibh->soffset)) {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi,\n\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi, -fibh->soffset);\n\t\tmemcpy(fibh->ebh->b_data, (uint8_t *)cfi - fibh->soffset,\n\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\t}\n\n\tif (adinicb) {\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tmark_buffer_dirty_inode(fibh->ebh, inode);\n\t\tmark_buffer_dirty_inode(fibh->sbh, inode);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nint udf_write_fi(struct inode *inode, struct fileIdentDesc *cfi,\n\t\t struct fileIdentDesc *sfi, struct udf_fileident_bh *fibh,\n\t\t uint8_t *impuse, uint8_t *fileident)\n{\n\tuint16_t crclen = fibh->eoffset - fibh->soffset - sizeof(struct tag);\n\tuint16_t crc;\n\tint offset;\n\tuint16_t liu = le16_to_cpu(cfi->lengthOfImpUse);\n\tuint8_t lfi = cfi->lengthFileIdent;\n\tint padlen = fibh->eoffset - fibh->soffset - liu - lfi -\n\t\tsizeof(struct fileIdentDesc);\n\tint adinicb = 0;\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tadinicb = 1;\n\n\toffset = fibh->soffset + sizeof(struct fileIdentDesc);\n\n\tif (impuse) {\n\t\tif (adinicb || (offset + liu < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, liu);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, impuse, liu);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, -offset);\n\t\t\tmemcpy(fibh->ebh->b_data, impuse - offset,\n\t\t\t\tliu + offset);\n\t\t}\n\t}\n\n\toffset += liu;\n\n\tif (fileident) {\n\t\tif (adinicb || (offset + lfi < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident, lfi);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, fileident, lfi);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident,\n\t\t\t\t-offset);\n\t\t\tmemcpy(fibh->ebh->b_data, fileident - offset,\n\t\t\t\tlfi + offset);\n\t\t}\n\t}\n\n\toffset += lfi;\n\n\tif (adinicb || (offset + padlen < 0)) {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, padlen);\n\t} else if (offset >= 0) {\n\t\tmemset(fibh->ebh->b_data + offset, 0x00, padlen);\n\t} else {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, -offset);\n\t\tmemset(fibh->ebh->b_data, 0x00, padlen + offset);\n\t}\n\n\tcrc = crc_itu_t(0, (uint8_t *)cfi + sizeof(struct tag),\n\t\t      sizeof(struct fileIdentDesc) - sizeof(struct tag));\n\n\tif (fibh->sbh == fibh->ebh) {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t      sizeof(struct fileIdentDesc));\n\t} else if (sizeof(struct fileIdentDesc) >= -fibh->soffset) {\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data +\n\t\t\t\t\tsizeof(struct fileIdentDesc) +\n\t\t\t\t\tfibh->soffset,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      -fibh->soffset - sizeof(struct fileIdentDesc));\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data, fibh->eoffset);\n\t}\n\n\tcfi->descTag.descCRC = cpu_to_le16(crc);\n\tcfi->descTag.descCRCLength = cpu_to_le16(crclen);\n\tcfi->descTag.tagChecksum = udf_tag_checksum(&cfi->descTag);\n\n\tif (adinicb || (sizeof(struct fileIdentDesc) <= -fibh->soffset)) {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi,\n\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi, -fibh->soffset);\n\t\tmemcpy(fibh->ebh->b_data, (uint8_t *)cfi - fibh->soffset,\n\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\t}\n\n\tif (adinicb) {\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tmark_buffer_dirty_inode(fibh->ebh, inode);\n\t\tmark_buffer_dirty_inode(fibh->sbh, inode);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&(cfi->icb)",
            "0x00",
            "sizeof(struct long_ad)"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "inode->i_sb",
            "UDF_FLAG_STRICT"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic int udf_delete_entry(struct inode *inode, struct fileIdentDesc *fi,\n\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t    struct fileIdentDesc *cfi)\n{\n\tcfi->fileCharacteristics |= FID_FILE_CHAR_DELETED;\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))\n\t\tmemset(&(cfi->icb), 0x00, sizeof(struct long_ad));\n\n\treturn udf_write_fi(inode, cfi, fi, fibh, NULL, NULL);\n}"
  },
  {
    "function_name": "udf_add_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "295-538",
    "snippet": "static struct fileIdentDesc *udf_add_entry(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   struct udf_fileident_bh *fibh,\n\t\t\t\t\t   struct fileIdentDesc *cfi, int *err)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fileIdentDesc *fi = NULL;\n\tunsigned char *name = NULL;\n\tint namelen;\n\tloff_t f_pos;\n\tloff_t size = udf_ext0_offset(dir) + dir->i_size;\n\tint nfidlen;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tint block;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen = 0;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo;\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!name) {\n\t\t*err = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tif (dentry) {\n\t\tif (!dentry->d_name.len) {\n\t\t\t*err = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t\tnamelen = udf_put_filename(sb, dentry->d_name.name, name,\n\t\t\t\t\t\t dentry->d_name.len);\n\t\tif (!namelen) {\n\t\t\t*err = -ENAMETOOLONG;\n\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\tnamelen = 0;\n\t}\n\n\tnfidlen = (sizeof(struct fileIdentDesc) + namelen + 3) & ~3;\n\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\tdinfo = UDF_I(dir);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tblock = udf_get_lb_pblock(dir->i_sb,\n\t\t\t\t\t&dinfo->i_location, 0);\n\t\t\tfibh->soffset = fibh->eoffset = sb->s_blocksize;\n\t\t\tgoto add;\n\t\t}\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tblock = dinfo->i_location.logicalBlockNum;\n\t}\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\n\t\tif (!fi) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (((sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi + 3) & ~3) == nfidlen) {\n\t\t\t\tcfi->descTag.tagSerialNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileVersionNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileCharacteristics = 0;\n\t\t\t\tcfi->lengthFileIdent = namelen;\n\t\t\t\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\t\t\t\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL,\n\t\t\t\t\t\t  name))\n\t\t\t\t\tgoto out_ok;\n\t\t\t\telse {\n\t\t\t\t\t*err = -EIO;\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nadd:\n\tf_pos += nfidlen;\n\n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB &&\n\t    sb->s_blocksize - fibh->eoffset < nfidlen) {\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tfibh->soffset -= udf_ext0_offset(dir);\n\t\tfibh->eoffset -= udf_ext0_offset(dir);\n\t\tf_pos -= udf_ext0_offset(dir);\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tbrelse(fibh->ebh);\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh =\n\t\t\t\tudf_expand_dir_adinicb(dir, &block, err);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\t\t/* Load extent udf_expand_dir_adinicb() has created */\n\t\tudf_current_aext(dir, &epos, &eloc, &elen, 1);\n\t}\n\n\t/* Entry fits into current block? */\n\tif (sb->s_blocksize - fibh->eoffset >= nfidlen) {\n\t\tfibh->soffset = fibh->eoffset;\n\t\tfibh->eoffset += nfidlen;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tblock = dinfo->i_location.logicalBlockNum;\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t\t(dinfo->i_ext.i_data +\n\t\t\t\t\t fibh->soffset -\n\t\t\t\t\t udf_ext0_offset(dir) +\n\t\t\t\t\t dinfo->i_lenEAttr);\n\t\t} else {\n\t\t\tblock = eloc.logicalBlockNum +\n\t\t\t\t\t((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + fibh->soffset);\n\t\t}\n\t} else {\n\t\t/* Round up last extent in the file */\n\t\telen = (elen + sb->s_blocksize - 1) & ~(sb->s_blocksize - 1);\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\tdinfo->i_lenExtents = (dinfo->i_lenExtents + sb->s_blocksize\n\t\t\t\t\t- 1) & ~(sb->s_blocksize - 1);\n\n\t\tfibh->soffset = fibh->eoffset - sb->s_blocksize;\n\t\tfibh->eoffset += nfidlen - sb->s_blocksize;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\tfibh->ebh = udf_bread(dir,\n\t\t\t\tf_pos >> dir->i_sb->s_blocksize_bits, 1, err);\n\t\tif (!fibh->ebh)\n\t\t\tgoto out_err;\n\t\t/* Extents could have been merged, invalidate our position */\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\n\t\tif (!fibh->soffset) {\n\t\t\t/* Find the freshly allocated block */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t\tfi = (struct fileIdentDesc *)(fibh->sbh->b_data);\n\t\t} else {\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + sb->s_blocksize +\n\t\t\t\t\tfibh->soffset);\n\t\t}\n\t}\n\n\tmemset(cfi, 0, sizeof(struct fileIdentDesc));\n\tif (UDF_SB(sb)->s_udfrev >= 0x0200)\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 3, 1, block,\n\t\t\t    sizeof(struct tag));\n\telse\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 2, 1, block,\n\t\t\t    sizeof(struct tag));\n\tcfi->fileVersionNum = cpu_to_le16(1);\n\tcfi->lengthFileIdent = namelen;\n\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL, name)) {\n\t\tdir->i_size += nfidlen;\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tdinfo->i_lenAlloc += nfidlen;\n\t\telse {\n\t\t\t/* Find the last extent and truncate it to proper size */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\telen -= dinfo->i_lenExtents - dir->i_size;\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\t\tdinfo->i_lenExtents = dir->i_size;\n\t\t}\n\n\t\tmark_inode_dirty(dir);\n\t\tgoto out_ok;\n\t} else {\n\t\t*err = -EIO;\n\t\tgoto out_err;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(name);\n\treturn fi;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "epos.bh"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_write_aext",
          "args": [
            "dir",
            "&epos",
            "&eloc",
            "elen",
            "1"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2005-2055",
          "snippet": "void udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nvoid udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_next_aext",
          "args": [
            "dir",
            "&epos",
            "&eloc",
            "&elen",
            "1"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "udf_next_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2057-2077",
          "snippet": "int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_write_fi",
          "args": [
            "dir",
            "cfi",
            "fi",
            "fibh",
            "NULL",
            "name"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_fi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "44-140",
          "snippet": "int udf_write_fi(struct inode *inode, struct fileIdentDesc *cfi,\n\t\t struct fileIdentDesc *sfi, struct udf_fileident_bh *fibh,\n\t\t uint8_t *impuse, uint8_t *fileident)\n{\n\tuint16_t crclen = fibh->eoffset - fibh->soffset - sizeof(struct tag);\n\tuint16_t crc;\n\tint offset;\n\tuint16_t liu = le16_to_cpu(cfi->lengthOfImpUse);\n\tuint8_t lfi = cfi->lengthFileIdent;\n\tint padlen = fibh->eoffset - fibh->soffset - liu - lfi -\n\t\tsizeof(struct fileIdentDesc);\n\tint adinicb = 0;\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tadinicb = 1;\n\n\toffset = fibh->soffset + sizeof(struct fileIdentDesc);\n\n\tif (impuse) {\n\t\tif (adinicb || (offset + liu < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, liu);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, impuse, liu);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, -offset);\n\t\t\tmemcpy(fibh->ebh->b_data, impuse - offset,\n\t\t\t\tliu + offset);\n\t\t}\n\t}\n\n\toffset += liu;\n\n\tif (fileident) {\n\t\tif (adinicb || (offset + lfi < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident, lfi);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, fileident, lfi);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident,\n\t\t\t\t-offset);\n\t\t\tmemcpy(fibh->ebh->b_data, fileident - offset,\n\t\t\t\tlfi + offset);\n\t\t}\n\t}\n\n\toffset += lfi;\n\n\tif (adinicb || (offset + padlen < 0)) {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, padlen);\n\t} else if (offset >= 0) {\n\t\tmemset(fibh->ebh->b_data + offset, 0x00, padlen);\n\t} else {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, -offset);\n\t\tmemset(fibh->ebh->b_data, 0x00, padlen + offset);\n\t}\n\n\tcrc = crc_itu_t(0, (uint8_t *)cfi + sizeof(struct tag),\n\t\t      sizeof(struct fileIdentDesc) - sizeof(struct tag));\n\n\tif (fibh->sbh == fibh->ebh) {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t      sizeof(struct fileIdentDesc));\n\t} else if (sizeof(struct fileIdentDesc) >= -fibh->soffset) {\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data +\n\t\t\t\t\tsizeof(struct fileIdentDesc) +\n\t\t\t\t\tfibh->soffset,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      -fibh->soffset - sizeof(struct fileIdentDesc));\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data, fibh->eoffset);\n\t}\n\n\tcfi->descTag.descCRC = cpu_to_le16(crc);\n\tcfi->descTag.descCRCLength = cpu_to_le16(crclen);\n\tcfi->descTag.tagChecksum = udf_tag_checksum(&cfi->descTag);\n\n\tif (adinicb || (sizeof(struct fileIdentDesc) <= -fibh->soffset)) {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi,\n\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi, -fibh->soffset);\n\t\tmemcpy(fibh->ebh->b_data, (uint8_t *)cfi - fibh->soffset,\n\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\t}\n\n\tif (adinicb) {\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tmark_buffer_dirty_inode(fibh->ebh, inode);\n\t\tmark_buffer_dirty_inode(fibh->sbh, inode);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nint udf_write_fi(struct inode *inode, struct fileIdentDesc *cfi,\n\t\t struct fileIdentDesc *sfi, struct udf_fileident_bh *fibh,\n\t\t uint8_t *impuse, uint8_t *fileident)\n{\n\tuint16_t crclen = fibh->eoffset - fibh->soffset - sizeof(struct tag);\n\tuint16_t crc;\n\tint offset;\n\tuint16_t liu = le16_to_cpu(cfi->lengthOfImpUse);\n\tuint8_t lfi = cfi->lengthFileIdent;\n\tint padlen = fibh->eoffset - fibh->soffset - liu - lfi -\n\t\tsizeof(struct fileIdentDesc);\n\tint adinicb = 0;\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tadinicb = 1;\n\n\toffset = fibh->soffset + sizeof(struct fileIdentDesc);\n\n\tif (impuse) {\n\t\tif (adinicb || (offset + liu < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, liu);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, impuse, liu);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, -offset);\n\t\t\tmemcpy(fibh->ebh->b_data, impuse - offset,\n\t\t\t\tliu + offset);\n\t\t}\n\t}\n\n\toffset += liu;\n\n\tif (fileident) {\n\t\tif (adinicb || (offset + lfi < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident, lfi);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, fileident, lfi);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident,\n\t\t\t\t-offset);\n\t\t\tmemcpy(fibh->ebh->b_data, fileident - offset,\n\t\t\t\tlfi + offset);\n\t\t}\n\t}\n\n\toffset += lfi;\n\n\tif (adinicb || (offset + padlen < 0)) {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, padlen);\n\t} else if (offset >= 0) {\n\t\tmemset(fibh->ebh->b_data + offset, 0x00, padlen);\n\t} else {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, -offset);\n\t\tmemset(fibh->ebh->b_data, 0x00, padlen + offset);\n\t}\n\n\tcrc = crc_itu_t(0, (uint8_t *)cfi + sizeof(struct tag),\n\t\t      sizeof(struct fileIdentDesc) - sizeof(struct tag));\n\n\tif (fibh->sbh == fibh->ebh) {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t      sizeof(struct fileIdentDesc));\n\t} else if (sizeof(struct fileIdentDesc) >= -fibh->soffset) {\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data +\n\t\t\t\t\tsizeof(struct fileIdentDesc) +\n\t\t\t\t\tfibh->soffset,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      -fibh->soffset - sizeof(struct fileIdentDesc));\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data, fibh->eoffset);\n\t}\n\n\tcfi->descTag.descCRC = cpu_to_le16(crc);\n\tcfi->descTag.descCRCLength = cpu_to_le16(crclen);\n\tcfi->descTag.tagChecksum = udf_tag_checksum(&cfi->descTag);\n\n\tif (adinicb || (sizeof(struct fileIdentDesc) <= -fibh->soffset)) {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi,\n\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi, -fibh->soffset);\n\t\tmemcpy(fibh->ebh->b_data, (uint8_t *)cfi - fibh->soffset,\n\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\t}\n\n\tif (adinicb) {\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tmark_buffer_dirty_inode(fibh->ebh, inode);\n\t\tmark_buffer_dirty_inode(fibh->sbh, inode);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_new_tag",
          "args": [
            "(char *)cfi",
            "TAG_IDENT_FID",
            "2",
            "1",
            "block",
            "sizeof(struct tag)"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "udf_new_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "279-288",
          "snippet": "void udf_new_tag(char *data, uint16_t ident, uint16_t version, uint16_t snum,\n\t\t uint32_t loc, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\ttptr->tagIdent = cpu_to_le16(ident);\n\ttptr->descVersion = cpu_to_le16(version);\n\ttptr->tagSerialNum = cpu_to_le16(snum);\n\ttptr->tagLocation = cpu_to_le32(loc);\n\tudf_update_tag(data, length);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_new_tag(char *data, uint16_t ident, uint16_t version, uint16_t snum,\n\t\t uint32_t loc, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\ttptr->tagIdent = cpu_to_le16(ident);\n\ttptr->descVersion = cpu_to_le16(version);\n\ttptr->tagSerialNum = cpu_to_le16(snum);\n\ttptr->tagLocation = cpu_to_le32(loc);\n\tudf_update_tag(data, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cfi",
            "0",
            "sizeof(struct fileIdentDesc)"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_file_entry_alloc_offset",
          "args": [
            "dir"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "udf_file_entry_alloc_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "55-64",
          "snippet": "static inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_bread",
          "args": [
            "dir",
            "f_pos >> dir->i_sb->s_blocksize_bits",
            "1",
            "err"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "udf_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "1184-1205",
          "snippet": "struct buffer_head *udf_bread(struct inode *inode, int block,\n\t\t\t      int create, int *err)\n{\n\tstruct buffer_head *bh = NULL;\n\n\tbh = udf_getblk(inode, block, create, err);\n\tif (!bh)\n\t\treturn NULL;\n\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\n\tll_rw_block(READ, 1, &bh);\n\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\n\tbrelse(bh);\n\t*err = -EIO;\n\treturn NULL;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\nstruct buffer_head *udf_bread(struct inode *inode, int block,\n\t\t\t      int create, int *err)\n{\n\tstruct buffer_head *bh = NULL;\n\n\tbh = udf_getblk(inode, block, create, err);\n\tif (!bh)\n\t\treturn NULL;\n\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\n\tll_rw_block(READ, 1, &bh);\n\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\n\tbrelse(bh);\n\t*err = -EIO;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_ext0_offset",
          "args": [
            "dir"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "udf_ext0_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "66-72",
          "snippet": "static inline size_t udf_ext0_offset(struct inode *inode)\n{\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\treturn udf_file_entry_alloc_offset(inode);\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_ext0_offset(struct inode *inode)\n{\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\treturn udf_file_entry_alloc_offset(inode);\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_current_aext",
          "args": [
            "dir",
            "&epos",
            "&eloc",
            "&elen",
            "1"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "udf_current_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2079-2131",
          "snippet": "int8_t udf_current_aext(struct inode *inode, struct extent_position *epos,\n\t\t\tstruct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint alen;\n\tint8_t etype;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh) {\n\t\tif (!epos->offset)\n\t\t\tepos->offset = udf_file_entry_alloc_offset(inode);\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\t\talen = udf_file_entry_alloc_offset(inode) +\n\t\t\t\t\t\t\tiinfo->i_lenAlloc;\n\t} else {\n\t\tif (!epos->offset)\n\t\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tptr = epos->bh->b_data + epos->offset;\n\t\talen = sizeof(struct allocExtDesc) +\n\t\t\tle32_to_cpu(((struct allocExtDesc *)epos->bh->b_data)->\n\t\t\t\t\t\t\tlengthAllocDescs);\n\t}\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = udf_get_fileshortad(ptr, alen, &epos->offset, inc);\n\t\tif (!sad)\n\t\t\treturn -1;\n\t\tetype = le32_to_cpu(sad->extLength) >> 30;\n\t\teloc->logicalBlockNum = le32_to_cpu(sad->extPosition);\n\t\teloc->partitionReferenceNum =\n\t\t\t\tiinfo->i_location.partitionReferenceNum;\n\t\t*elen = le32_to_cpu(sad->extLength) & UDF_EXTENT_LENGTH_MASK;\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = udf_get_filelongad(ptr, alen, &epos->offset, inc);\n\t\tif (!lad)\n\t\t\treturn -1;\n\t\tetype = le32_to_cpu(lad->extLength) >> 30;\n\t\t*eloc = lelb_to_cpu(lad->extLocation);\n\t\t*elen = le32_to_cpu(lad->extLength) & UDF_EXTENT_LENGTH_MASK;\n\t\tbreak;\n\tdefault:\n\t\tudf_debug(\"alloc_type = %d unsupported\\n\", iinfo->i_alloc_type);\n\t\treturn -1;\n\t}\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_current_aext(struct inode *inode, struct extent_position *epos,\n\t\t\tstruct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint alen;\n\tint8_t etype;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh) {\n\t\tif (!epos->offset)\n\t\t\tepos->offset = udf_file_entry_alloc_offset(inode);\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\t\talen = udf_file_entry_alloc_offset(inode) +\n\t\t\t\t\t\t\tiinfo->i_lenAlloc;\n\t} else {\n\t\tif (!epos->offset)\n\t\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tptr = epos->bh->b_data + epos->offset;\n\t\talen = sizeof(struct allocExtDesc) +\n\t\t\tle32_to_cpu(((struct allocExtDesc *)epos->bh->b_data)->\n\t\t\t\t\t\t\tlengthAllocDescs);\n\t}\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = udf_get_fileshortad(ptr, alen, &epos->offset, inc);\n\t\tif (!sad)\n\t\t\treturn -1;\n\t\tetype = le32_to_cpu(sad->extLength) >> 30;\n\t\teloc->logicalBlockNum = le32_to_cpu(sad->extPosition);\n\t\teloc->partitionReferenceNum =\n\t\t\t\tiinfo->i_location.partitionReferenceNum;\n\t\t*elen = le32_to_cpu(sad->extLength) & UDF_EXTENT_LENGTH_MASK;\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = udf_get_filelongad(ptr, alen, &epos->offset, inc);\n\t\tif (!lad)\n\t\t\treturn -1;\n\t\tetype = le32_to_cpu(lad->extLength) >> 30;\n\t\t*eloc = lelb_to_cpu(lad->extLocation);\n\t\t*elen = le32_to_cpu(lad->extLength) & UDF_EXTENT_LENGTH_MASK;\n\t\tbreak;\n\tdefault:\n\t\tudf_debug(\"alloc_type = %d unsupported\\n\", iinfo->i_alloc_type);\n\t\treturn -1;\n\t}\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_expand_dir_adinicb",
          "args": [
            "dir",
            "&block",
            "err"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "udf_expand_dir_adinicb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "330-420",
          "snippet": "struct buffer_head *udf_expand_dir_adinicb(struct inode *inode, int *block,\n\t\t\t\t\t   int *err)\n{\n\tint newblock;\n\tstruct buffer_head *dbh = NULL;\n\tstruct kernel_lb_addr eloc;\n\tuint8_t alloctype;\n\tstruct extent_position epos;\n\n\tstruct udf_fileident_bh sfibh, dfibh;\n\tloff_t f_pos = udf_ext0_offset(inode);\n\tint size = udf_ext0_offset(inode) + inode->i_size;\n\tstruct fileIdentDesc cfi, *sfi, *dfi;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\talloctype = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\talloctype = ICBTAG_FLAG_AD_LONG;\n\n\tif (!inode->i_size) {\n\t\tiinfo->i_alloc_type = alloctype;\n\t\tmark_inode_dirty(inode);\n\t\treturn NULL;\n\t}\n\n\t/* alloc block, and copy data to it */\n\t*block = udf_new_block(inode->i_sb, inode,\n\t\t\t       iinfo->i_location.partitionReferenceNum,\n\t\t\t       iinfo->i_location.logicalBlockNum, err);\n\tif (!(*block))\n\t\treturn NULL;\n\tnewblock = udf_get_pblock(inode->i_sb, *block,\n\t\t\t\t  iinfo->i_location.partitionReferenceNum,\n\t\t\t\t0);\n\tif (!newblock)\n\t\treturn NULL;\n\tdbh = udf_tgetblk(inode->i_sb, newblock);\n\tif (!dbh)\n\t\treturn NULL;\n\tlock_buffer(dbh);\n\tmemset(dbh->b_data, 0x00, inode->i_sb->s_blocksize);\n\tset_buffer_uptodate(dbh);\n\tunlock_buffer(dbh);\n\tmark_buffer_dirty_inode(dbh, inode);\n\n\tsfibh.soffset = sfibh.eoffset =\n\t\t\tf_pos & (inode->i_sb->s_blocksize - 1);\n\tsfibh.sbh = sfibh.ebh = NULL;\n\tdfibh.soffset = dfibh.eoffset = 0;\n\tdfibh.sbh = dfibh.ebh = dbh;\n\twhile (f_pos < size) {\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\tsfi = udf_fileident_read(inode, &f_pos, &sfibh, &cfi, NULL,\n\t\t\t\t\t NULL, NULL, NULL);\n\t\tif (!sfi) {\n\t\t\tbrelse(dbh);\n\t\t\treturn NULL;\n\t\t}\n\t\tiinfo->i_alloc_type = alloctype;\n\t\tsfi->descTag.tagLocation = cpu_to_le32(*block);\n\t\tdfibh.soffset = dfibh.eoffset;\n\t\tdfibh.eoffset += (sfibh.eoffset - sfibh.soffset);\n\t\tdfi = (struct fileIdentDesc *)(dbh->b_data + dfibh.soffset);\n\t\tif (udf_write_fi(inode, sfi, dfi, &dfibh, sfi->impUse,\n\t\t\t\t sfi->fileIdent +\n\t\t\t\t\tle16_to_cpu(sfi->lengthOfImpUse))) {\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\t\tbrelse(dbh);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tmark_buffer_dirty_inode(dbh, inode);\n\n\tmemset(iinfo->i_ext.i_data + iinfo->i_lenEAttr, 0,\n\t\tiinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\teloc.logicalBlockNum = *block;\n\teloc.partitionReferenceNum =\n\t\t\t\tiinfo->i_location.partitionReferenceNum;\n\tiinfo->i_lenExtents = inode->i_size;\n\tepos.bh = NULL;\n\tepos.block = iinfo->i_location;\n\tepos.offset = udf_file_entry_alloc_offset(inode);\n\tudf_add_aext(inode, &epos, &eloc, inode->i_size, 0);\n\t/* UniqueID stuff */\n\n\tbrelse(epos.bh);\n\tmark_inode_dirty(inode);\n\treturn dbh;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int udf_alloc_i_data(struct inode *inode, size_t size);",
            "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int udf_alloc_i_data(struct inode *inode, size_t size);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\nstruct buffer_head *udf_expand_dir_adinicb(struct inode *inode, int *block,\n\t\t\t\t\t   int *err)\n{\n\tint newblock;\n\tstruct buffer_head *dbh = NULL;\n\tstruct kernel_lb_addr eloc;\n\tuint8_t alloctype;\n\tstruct extent_position epos;\n\n\tstruct udf_fileident_bh sfibh, dfibh;\n\tloff_t f_pos = udf_ext0_offset(inode);\n\tint size = udf_ext0_offset(inode) + inode->i_size;\n\tstruct fileIdentDesc cfi, *sfi, *dfi;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\talloctype = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\talloctype = ICBTAG_FLAG_AD_LONG;\n\n\tif (!inode->i_size) {\n\t\tiinfo->i_alloc_type = alloctype;\n\t\tmark_inode_dirty(inode);\n\t\treturn NULL;\n\t}\n\n\t/* alloc block, and copy data to it */\n\t*block = udf_new_block(inode->i_sb, inode,\n\t\t\t       iinfo->i_location.partitionReferenceNum,\n\t\t\t       iinfo->i_location.logicalBlockNum, err);\n\tif (!(*block))\n\t\treturn NULL;\n\tnewblock = udf_get_pblock(inode->i_sb, *block,\n\t\t\t\t  iinfo->i_location.partitionReferenceNum,\n\t\t\t\t0);\n\tif (!newblock)\n\t\treturn NULL;\n\tdbh = udf_tgetblk(inode->i_sb, newblock);\n\tif (!dbh)\n\t\treturn NULL;\n\tlock_buffer(dbh);\n\tmemset(dbh->b_data, 0x00, inode->i_sb->s_blocksize);\n\tset_buffer_uptodate(dbh);\n\tunlock_buffer(dbh);\n\tmark_buffer_dirty_inode(dbh, inode);\n\n\tsfibh.soffset = sfibh.eoffset =\n\t\t\tf_pos & (inode->i_sb->s_blocksize - 1);\n\tsfibh.sbh = sfibh.ebh = NULL;\n\tdfibh.soffset = dfibh.eoffset = 0;\n\tdfibh.sbh = dfibh.ebh = dbh;\n\twhile (f_pos < size) {\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\tsfi = udf_fileident_read(inode, &f_pos, &sfibh, &cfi, NULL,\n\t\t\t\t\t NULL, NULL, NULL);\n\t\tif (!sfi) {\n\t\t\tbrelse(dbh);\n\t\t\treturn NULL;\n\t\t}\n\t\tiinfo->i_alloc_type = alloctype;\n\t\tsfi->descTag.tagLocation = cpu_to_le32(*block);\n\t\tdfibh.soffset = dfibh.eoffset;\n\t\tdfibh.eoffset += (sfibh.eoffset - sfibh.soffset);\n\t\tdfi = (struct fileIdentDesc *)(dbh->b_data + dfibh.soffset);\n\t\tif (udf_write_fi(inode, sfi, dfi, &dfibh, sfi->impUse,\n\t\t\t\t sfi->fileIdent +\n\t\t\t\t\tle16_to_cpu(sfi->lengthOfImpUse))) {\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\t\tbrelse(dbh);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tmark_buffer_dirty_inode(dbh, inode);\n\n\tmemset(iinfo->i_ext.i_data + iinfo->i_lenEAttr, 0,\n\t\tiinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\teloc.logicalBlockNum = *block;\n\teloc.partitionReferenceNum =\n\t\t\t\tiinfo->i_location.partitionReferenceNum;\n\tiinfo->i_lenExtents = inode->i_size;\n\tepos.bh = NULL;\n\tepos.block = iinfo->i_location;\n\tepos.offset = udf_file_entry_alloc_offset(inode);\n\tudf_add_aext(inode, &epos, &eloc, inode->i_size, 0);\n\t/* UniqueID stuff */\n\n\tbrelse(epos.bh);\n\tmark_inode_dirty(inode);\n\treturn dbh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "cfi->lengthOfImpUse"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_fileident_read",
          "args": [
            "dir",
            "&f_pos",
            "fibh",
            "cfi",
            "&epos",
            "&eloc",
            "&elen",
            "&offset"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "udf_fileident_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/directory.c",
          "lines": "21-155",
          "snippet": "struct fileIdentDesc *udf_fileident_read(struct inode *dir, loff_t *nf_pos,\n\t\t\t\t\t struct udf_fileident_bh *fibh,\n\t\t\t\t\t struct fileIdentDesc *cfi,\n\t\t\t\t\t struct extent_position *epos,\n\t\t\t\t\t struct kernel_lb_addr *eloc, uint32_t *elen,\n\t\t\t\t\t sector_t *offset)\n{\n\tstruct fileIdentDesc *fi;\n\tint i, num, block;\n\tstruct buffer_head *tmp, *bha[16];\n\tstruct udf_inode_info *iinfo = UDF_I(dir);\n\n\tfibh->soffset = fibh->eoffset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tfi = udf_get_fileident(iinfo->i_ext.i_data -\n\t\t\t\t       (iinfo->i_efe ?\n\t\t\t\t\tsizeof(struct extendedFileEntry) :\n\t\t\t\t\tsizeof(struct fileEntry)),\n\t\t\t\t       dir->i_sb->s_blocksize,\n\t\t\t\t       &(fibh->eoffset));\n\t\tif (!fi)\n\t\t\treturn NULL;\n\n\t\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\n\t\treturn fi;\n\t}\n\n\tif (fibh->eoffset == dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\t\tunsigned char blocksize_bits = dir->i_sb->s_blocksize_bits;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\treturn NULL;\n\t\tfibh->soffset = fibh->eoffset = 0;\n\n\t\tif (!(*offset & ((16 >> (blocksize_bits - 9)) - 1))) {\n\t\t\ti = 16 >> (blocksize_bits - 9);\n\t\t\tif (i + *offset > (*elen >> blocksize_bits))\n\t\t\t\ti = (*elen >> blocksize_bits)-*offset;\n\t\t\tfor (num = 0; i > 0; i--) {\n\t\t\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc,\n\t\t\t\t\t\t\t  *offset + i);\n\t\t\t\ttmp = udf_tgetblk(dir->i_sb, block);\n\t\t\t\tif (tmp && !buffer_uptodate(tmp) &&\n\t\t\t\t\t\t!buffer_locked(tmp))\n\t\t\t\t\tbha[num++] = tmp;\n\t\t\t\telse\n\t\t\t\t\tbrelse(tmp);\n\t\t\t}\n\t\t\tif (num) {\n\t\t\t\tll_rw_block(READA, num, bha);\n\t\t\t\tfor (i = 0; i < num; i++)\n\t\t\t\t\tbrelse(bha[i]);\n\t\t\t}\n\t\t}\n\t} else if (fibh->sbh != fibh->ebh) {\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh;\n\t}\n\n\tfi = udf_get_fileident(fibh->sbh->b_data, dir->i_sb->s_blocksize,\n\t\t\t       &(fibh->eoffset));\n\n\tif (!fi)\n\t\treturn NULL;\n\n\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\tif (fibh->eoffset <= dir->i_sb->s_blocksize) {\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\t} else if (fibh->eoffset > dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << dir->i_sb->s_blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tfibh->soffset -= dir->i_sb->s_blocksize;\n\t\tfibh->eoffset -= dir->i_sb->s_blocksize;\n\n\t\tfibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->ebh)\n\t\t\treturn NULL;\n\n\t\tif (sizeof(struct fileIdentDesc) > -fibh->soffset) {\n\t\t\tint fi_len;\n\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi, -fibh->soffset);\n\t\t\tmemcpy((uint8_t *)cfi - fibh->soffset,\n\t\t\t       fibh->ebh->b_data,\n\t\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\n\t\t\tfi_len = (sizeof(struct fileIdentDesc) +\n\t\t\t\t  cfi->lengthFileIdent +\n\t\t\t\t  le16_to_cpu(cfi->lengthOfImpUse) + 3) & ~3;\n\n\t\t\t*nf_pos += fi_len - (fibh->eoffset - fibh->soffset);\n\t\t\tfibh->eoffset = fibh->soffset + fi_len;\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t\t       sizeof(struct fileIdentDesc));\n\t\t}\n\t}\n\treturn fi;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstruct fileIdentDesc *udf_fileident_read(struct inode *dir, loff_t *nf_pos,\n\t\t\t\t\t struct udf_fileident_bh *fibh,\n\t\t\t\t\t struct fileIdentDesc *cfi,\n\t\t\t\t\t struct extent_position *epos,\n\t\t\t\t\t struct kernel_lb_addr *eloc, uint32_t *elen,\n\t\t\t\t\t sector_t *offset)\n{\n\tstruct fileIdentDesc *fi;\n\tint i, num, block;\n\tstruct buffer_head *tmp, *bha[16];\n\tstruct udf_inode_info *iinfo = UDF_I(dir);\n\n\tfibh->soffset = fibh->eoffset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tfi = udf_get_fileident(iinfo->i_ext.i_data -\n\t\t\t\t       (iinfo->i_efe ?\n\t\t\t\t\tsizeof(struct extendedFileEntry) :\n\t\t\t\t\tsizeof(struct fileEntry)),\n\t\t\t\t       dir->i_sb->s_blocksize,\n\t\t\t\t       &(fibh->eoffset));\n\t\tif (!fi)\n\t\t\treturn NULL;\n\n\t\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\n\t\treturn fi;\n\t}\n\n\tif (fibh->eoffset == dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\t\tunsigned char blocksize_bits = dir->i_sb->s_blocksize_bits;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\treturn NULL;\n\t\tfibh->soffset = fibh->eoffset = 0;\n\n\t\tif (!(*offset & ((16 >> (blocksize_bits - 9)) - 1))) {\n\t\t\ti = 16 >> (blocksize_bits - 9);\n\t\t\tif (i + *offset > (*elen >> blocksize_bits))\n\t\t\t\ti = (*elen >> blocksize_bits)-*offset;\n\t\t\tfor (num = 0; i > 0; i--) {\n\t\t\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc,\n\t\t\t\t\t\t\t  *offset + i);\n\t\t\t\ttmp = udf_tgetblk(dir->i_sb, block);\n\t\t\t\tif (tmp && !buffer_uptodate(tmp) &&\n\t\t\t\t\t\t!buffer_locked(tmp))\n\t\t\t\t\tbha[num++] = tmp;\n\t\t\t\telse\n\t\t\t\t\tbrelse(tmp);\n\t\t\t}\n\t\t\tif (num) {\n\t\t\t\tll_rw_block(READA, num, bha);\n\t\t\t\tfor (i = 0; i < num; i++)\n\t\t\t\t\tbrelse(bha[i]);\n\t\t\t}\n\t\t}\n\t} else if (fibh->sbh != fibh->ebh) {\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh;\n\t}\n\n\tfi = udf_get_fileident(fibh->sbh->b_data, dir->i_sb->s_blocksize,\n\t\t\t       &(fibh->eoffset));\n\n\tif (!fi)\n\t\treturn NULL;\n\n\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\tif (fibh->eoffset <= dir->i_sb->s_blocksize) {\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\t} else if (fibh->eoffset > dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << dir->i_sb->s_blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tfibh->soffset -= dir->i_sb->s_blocksize;\n\t\tfibh->eoffset -= dir->i_sb->s_blocksize;\n\n\t\tfibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->ebh)\n\t\t\treturn NULL;\n\n\t\tif (sizeof(struct fileIdentDesc) > -fibh->soffset) {\n\t\t\tint fi_len;\n\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi, -fibh->soffset);\n\t\t\tmemcpy((uint8_t *)cfi - fibh->soffset,\n\t\t\t       fibh->ebh->b_data,\n\t\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\n\t\t\tfi_len = (sizeof(struct fileIdentDesc) +\n\t\t\t\t  cfi->lengthFileIdent +\n\t\t\t\t  le16_to_cpu(cfi->lengthOfImpUse) + 3) & ~3;\n\n\t\t\t*nf_pos += fi_len - (fibh->eoffset - fibh->soffset);\n\t\t\tfibh->eoffset = fibh->soffset + fi_len;\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t\t       sizeof(struct fileIdentDesc));\n\t\t}\n\t}\n\treturn fi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_tread",
          "args": [
            "dir->i_sb",
            "block"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "40-46",
          "snippet": "struct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "dir->i_sb",
            "&eloc",
            "offset"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_bmap",
          "args": [
            "dir",
            "f_pos >> dir->i_sb->s_blocksize_bits",
            "&epos",
            "&eloc",
            "&elen",
            "&offset"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "inode_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2237-2268",
          "snippet": "int8_t inode_bmap(struct inode *inode, sector_t block,\n\t\t  struct extent_position *pos, struct kernel_lb_addr *eloc,\n\t\t  uint32_t *elen, sector_t *offset)\n{\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tloff_t lbcount = 0, bcount =\n\t    (loff_t) block << blocksize_bits;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tiinfo = UDF_I(inode);\n\tif (!udf_read_extent_cache(inode, bcount, &lbcount, pos)) {\n\t\tpos->offset = 0;\n\t\tpos->block = iinfo->i_location;\n\t\tpos->bh = NULL;\n\t}\n\t*elen = 0;\n\tdo {\n\t\tetype = udf_next_aext(inode, pos, eloc, elen, 1);\n\t\tif (etype == -1) {\n\t\t\t*offset = (bcount - lbcount) >> blocksize_bits;\n\t\t\tiinfo->i_lenExtents = lbcount;\n\t\t\treturn -1;\n\t\t}\n\t\tlbcount += *elen;\n\t} while (lbcount <= bcount);\n\t/* update extent cache */\n\tudf_update_extent_cache(inode, lbcount - *elen, pos, 1);\n\t*offset = (bcount + *elen - lbcount) >> blocksize_bits;\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t inode_bmap(struct inode *inode, sector_t block,\n\t\t  struct extent_position *pos, struct kernel_lb_addr *eloc,\n\t\t  uint32_t *elen, sector_t *offset)\n{\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tloff_t lbcount = 0, bcount =\n\t    (loff_t) block << blocksize_bits;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tiinfo = UDF_I(inode);\n\tif (!udf_read_extent_cache(inode, bcount, &lbcount, pos)) {\n\t\tpos->offset = 0;\n\t\tpos->block = iinfo->i_location;\n\t\tpos->bh = NULL;\n\t}\n\t*elen = 0;\n\tdo {\n\t\tetype = udf_next_aext(inode, pos, eloc, elen, 1);\n\t\tif (etype == -1) {\n\t\t\t*offset = (bcount - lbcount) >> blocksize_bits;\n\t\t\tiinfo->i_lenExtents = lbcount;\n\t\t\treturn -1;\n\t\t}\n\t\tlbcount += *elen;\n\t} while (lbcount <= bcount);\n\t/* update extent cache */\n\tudf_update_extent_cache(inode, lbcount - *elen, pos, 1);\n\t*offset = (bcount + *elen - lbcount) >> blocksize_bits;\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "dir"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_put_filename",
          "args": [
            "sb",
            "dentry->d_name.name",
            "name",
            "dentry->d_name.len"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "udf_put_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
          "lines": "380-402",
          "snippet": "int udf_put_filename(struct super_block *sb, const uint8_t *sname,\n\t\t     uint8_t *dname, int flen)\n{\n\tstruct ustr unifilename;\n\tint namelen;\n\n\tif (!udf_char_to_ustr(&unifilename, sname, flen))\n\t\treturn 0;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tnamelen = udf_UTF8toCS0(dname, &unifilename, UDF_NAME_LEN);\n\t\tif (!namelen)\n\t\t\treturn 0;\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tnamelen = udf_NLStoCS0(UDF_SB(sb)->s_nls_map, dname,\n\t\t\t\t\t&unifilename, UDF_NAME_LEN);\n\t\tif (!namelen)\n\t\t\treturn 0;\n\t} else\n\t\treturn 0;\n\n\treturn namelen;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>\t/* for memset */",
            "#include <linux/kernel.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);\n\nint udf_put_filename(struct super_block *sb, const uint8_t *sname,\n\t\t     uint8_t *dname, int flen)\n{\n\tstruct ustr unifilename;\n\tint namelen;\n\n\tif (!udf_char_to_ustr(&unifilename, sname, flen))\n\t\treturn 0;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tnamelen = udf_UTF8toCS0(dname, &unifilename, UDF_NAME_LEN);\n\t\tif (!namelen)\n\t\t\treturn 0;\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tnamelen = udf_NLStoCS0(UDF_SB(sb)->s_nls_map, dname,\n\t\t\t\t\t&unifilename, UDF_NAME_LEN);\n\t\tif (!namelen)\n\t\t\treturn 0;\n\t} else\n\t\treturn 0;\n\n\treturn namelen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "UDF_NAME_LEN",
            "GFP_NOFS"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic struct fileIdentDesc *udf_add_entry(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   struct udf_fileident_bh *fibh,\n\t\t\t\t\t   struct fileIdentDesc *cfi, int *err)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fileIdentDesc *fi = NULL;\n\tunsigned char *name = NULL;\n\tint namelen;\n\tloff_t f_pos;\n\tloff_t size = udf_ext0_offset(dir) + dir->i_size;\n\tint nfidlen;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tint block;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen = 0;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo;\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!name) {\n\t\t*err = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tif (dentry) {\n\t\tif (!dentry->d_name.len) {\n\t\t\t*err = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t\tnamelen = udf_put_filename(sb, dentry->d_name.name, name,\n\t\t\t\t\t\t dentry->d_name.len);\n\t\tif (!namelen) {\n\t\t\t*err = -ENAMETOOLONG;\n\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\tnamelen = 0;\n\t}\n\n\tnfidlen = (sizeof(struct fileIdentDesc) + namelen + 3) & ~3;\n\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\tdinfo = UDF_I(dir);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tblock = udf_get_lb_pblock(dir->i_sb,\n\t\t\t\t\t&dinfo->i_location, 0);\n\t\t\tfibh->soffset = fibh->eoffset = sb->s_blocksize;\n\t\t\tgoto add;\n\t\t}\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tblock = dinfo->i_location.logicalBlockNum;\n\t}\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\n\t\tif (!fi) {\n\t\t\t*err = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (((sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi + 3) & ~3) == nfidlen) {\n\t\t\t\tcfi->descTag.tagSerialNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileVersionNum = cpu_to_le16(1);\n\t\t\t\tcfi->fileCharacteristics = 0;\n\t\t\t\tcfi->lengthFileIdent = namelen;\n\t\t\t\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\t\t\t\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL,\n\t\t\t\t\t\t  name))\n\t\t\t\t\tgoto out_ok;\n\t\t\t\telse {\n\t\t\t\t\t*err = -EIO;\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nadd:\n\tf_pos += nfidlen;\n\n\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB &&\n\t    sb->s_blocksize - fibh->eoffset < nfidlen) {\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tfibh->soffset -= udf_ext0_offset(dir);\n\t\tfibh->eoffset -= udf_ext0_offset(dir);\n\t\tf_pos -= udf_ext0_offset(dir);\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tbrelse(fibh->ebh);\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh =\n\t\t\t\tudf_expand_dir_adinicb(dir, &block, err);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\t\t/* Load extent udf_expand_dir_adinicb() has created */\n\t\tudf_current_aext(dir, &epos, &eloc, &elen, 1);\n\t}\n\n\t/* Entry fits into current block? */\n\tif (sb->s_blocksize - fibh->eoffset >= nfidlen) {\n\t\tfibh->soffset = fibh->eoffset;\n\t\tfibh->eoffset += nfidlen;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tblock = dinfo->i_location.logicalBlockNum;\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t\t(dinfo->i_ext.i_data +\n\t\t\t\t\t fibh->soffset -\n\t\t\t\t\t udf_ext0_offset(dir) +\n\t\t\t\t\t dinfo->i_lenEAttr);\n\t\t} else {\n\t\t\tblock = eloc.logicalBlockNum +\n\t\t\t\t\t((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + fibh->soffset);\n\t\t}\n\t} else {\n\t\t/* Round up last extent in the file */\n\t\telen = (elen + sb->s_blocksize - 1) & ~(sb->s_blocksize - 1);\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\tdinfo->i_lenExtents = (dinfo->i_lenExtents + sb->s_blocksize\n\t\t\t\t\t- 1) & ~(sb->s_blocksize - 1);\n\n\t\tfibh->soffset = fibh->eoffset - sb->s_blocksize;\n\t\tfibh->eoffset += nfidlen - sb->s_blocksize;\n\t\tif (fibh->sbh != fibh->ebh) {\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t}\n\n\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\tfibh->ebh = udf_bread(dir,\n\t\t\t\tf_pos >> dir->i_sb->s_blocksize_bits, 1, err);\n\t\tif (!fibh->ebh)\n\t\t\tgoto out_err;\n\t\t/* Extents could have been merged, invalidate our position */\n\t\tbrelse(epos.bh);\n\t\tepos.bh = NULL;\n\t\tepos.block = dinfo->i_location;\n\t\tepos.offset = udf_file_entry_alloc_offset(dir);\n\n\t\tif (!fibh->soffset) {\n\t\t\t/* Find the freshly allocated block */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\tblock = eloc.logicalBlockNum + ((elen - 1) >>\n\t\t\t\t\tdir->i_sb->s_blocksize_bits);\n\t\t\tbrelse(fibh->sbh);\n\t\t\tfibh->sbh = fibh->ebh;\n\t\t\tfi = (struct fileIdentDesc *)(fibh->sbh->b_data);\n\t\t} else {\n\t\t\tfi = (struct fileIdentDesc *)\n\t\t\t\t(fibh->sbh->b_data + sb->s_blocksize +\n\t\t\t\t\tfibh->soffset);\n\t\t}\n\t}\n\n\tmemset(cfi, 0, sizeof(struct fileIdentDesc));\n\tif (UDF_SB(sb)->s_udfrev >= 0x0200)\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 3, 1, block,\n\t\t\t    sizeof(struct tag));\n\telse\n\t\tudf_new_tag((char *)cfi, TAG_IDENT_FID, 2, 1, block,\n\t\t\t    sizeof(struct tag));\n\tcfi->fileVersionNum = cpu_to_le16(1);\n\tcfi->lengthFileIdent = namelen;\n\tcfi->lengthOfImpUse = cpu_to_le16(0);\n\tif (!udf_write_fi(dir, cfi, fi, fibh, NULL, name)) {\n\t\tdir->i_size += nfidlen;\n\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tdinfo->i_lenAlloc += nfidlen;\n\t\telse {\n\t\t\t/* Find the last extent and truncate it to proper size */\n\t\t\twhile (udf_next_aext(dir, &epos, &eloc, &elen, 1) ==\n\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\t;\n\t\t\telen -= dinfo->i_lenExtents - dir->i_size;\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t\tudf_write_aext(dir, &epos, &eloc, elen, 1);\n\t\t\tdinfo->i_lenExtents = dir->i_size;\n\t\t}\n\n\t\tmark_inode_dirty(dir);\n\t\tgoto out_ok;\n\t} else {\n\t\t*err = -EIO;\n\t\tgoto out_err;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(name);\n\treturn fi;\n}"
  },
  {
    "function_name": "udf_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "254-293",
    "snippet": "static struct dentry *udf_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags)\n{\n\tstruct inode *inode = NULL;\n\tstruct fileIdentDesc cfi;\n\tstruct udf_fileident_bh fibh;\n\n\tif (dentry->d_name.len > UDF_NAME_LEN - 2)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n#ifdef UDF_RECOVERY\n\t/* temporary shorthand for specifying files by inode number */\n\tif (!strncmp(dentry->d_name.name, \".B=\", 3)) {\n\t\tstruct kernel_lb_addr lb = {\n\t\t\t.logicalBlockNum = 0,\n\t\t\t.partitionReferenceNum =\n\t\t\t\tsimple_strtoul(dentry->d_name.name + 3,\n\t\t\t\t\t\tNULL, 0),\n\t\t};\n\t\tinode = udf_iget(dir->i_sb, lb);\n\t\tif (IS_ERR(inode))\n\t\t\treturn inode;\n\t} else\n#endif /* UDF_RECOVERY */\n\n\tif (udf_find_entry(dir, &dentry->d_name, &fibh, &cfi)) {\n\t\tstruct kernel_lb_addr loc;\n\n\t\tif (fibh.sbh != fibh.ebh)\n\t\t\tbrelse(fibh.ebh);\n\t\tbrelse(fibh.sbh);\n\n\t\tloc = lelb_to_cpu(cfi.icb.extLocation);\n\t\tinode = udf_iget(dir->i_sb, &loc);\n\t\tif (IS_ERR(inode))\n\t\t\treturn ERR_CAST(inode);\n\t}\n\n\treturn d_splice_alias(inode, dentry);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_iget",
          "args": [
            "dir->i_sb",
            "&loc"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "udf_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "148-152",
          "snippet": "static inline struct inode *udf_iget(struct super_block *sb,\n\t\t\t\t     struct kernel_lb_addr *ino)\n{\n\treturn __udf_iget(sb, ino, false);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline struct inode *udf_iget(struct super_block *sb,\n\t\t\t\t     struct kernel_lb_addr *ino)\n{\n\treturn __udf_iget(sb, ino, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lelb_to_cpu",
          "args": [
            "cfi.icb.extLocation"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "lelb_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfend.h",
          "lines": "7-15",
          "snippet": "static inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}",
          "includes": [
            "#include <linux/string.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string.h>\n#include <asm/byteorder.h>\n\nstatic inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "fibh.sbh"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_find_entry",
          "args": [
            "dir",
            "&dentry->d_name",
            "&fibh",
            "&cfi"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "udf_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "142-252",
          "snippet": "static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\tstruct super_block *sb = dir->i_sb;\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(sb, &eloc, offset);\n\t\tif ((++offset << sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(sb, nameptr, lfi, fname, UDF_NAME_LEN);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\tstruct super_block *sb = dir->i_sb;\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(sb, &eloc, offset);\n\t\tif ((++offset << sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(sb, nameptr, lfi, fname, UDF_NAME_LEN);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "dentry->d_name.name + 3",
            "NULL",
            "0"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "dentry->d_name.name",
            "\".B=\"",
            "3"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic struct dentry *udf_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags)\n{\n\tstruct inode *inode = NULL;\n\tstruct fileIdentDesc cfi;\n\tstruct udf_fileident_bh fibh;\n\n\tif (dentry->d_name.len > UDF_NAME_LEN - 2)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n#ifdef UDF_RECOVERY\n\t/* temporary shorthand for specifying files by inode number */\n\tif (!strncmp(dentry->d_name.name, \".B=\", 3)) {\n\t\tstruct kernel_lb_addr lb = {\n\t\t\t.logicalBlockNum = 0,\n\t\t\t.partitionReferenceNum =\n\t\t\t\tsimple_strtoul(dentry->d_name.name + 3,\n\t\t\t\t\t\tNULL, 0),\n\t\t};\n\t\tinode = udf_iget(dir->i_sb, lb);\n\t\tif (IS_ERR(inode))\n\t\t\treturn inode;\n\t} else\n#endif /* UDF_RECOVERY */\n\n\tif (udf_find_entry(dir, &dentry->d_name, &fibh, &cfi)) {\n\t\tstruct kernel_lb_addr loc;\n\n\t\tif (fibh.sbh != fibh.ebh)\n\t\t\tbrelse(fibh.ebh);\n\t\tbrelse(fibh.sbh);\n\n\t\tloc = lelb_to_cpu(cfi.icb.extLocation);\n\t\tinode = udf_iget(dir->i_sb, &loc);\n\t\tif (IS_ERR(inode))\n\t\t\treturn ERR_CAST(inode);\n\t}\n\n\treturn d_splice_alias(inode, dentry);\n}"
  },
  {
    "function_name": "udf_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "142-252",
    "snippet": "static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\tstruct super_block *sb = dir->i_sb;\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(sb, &eloc, offset);\n\t\tif ((++offset << sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(sb, nameptr, lfi, fname, UDF_NAME_LEN);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fname"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "epos.bh"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_match",
          "args": [
            "flen",
            "fname",
            "child->len",
            "child->name"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "udf_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "35-42",
          "snippet": "static inline int udf_match(int len1, const unsigned char *name1, int len2,\n\t\t\t    const unsigned char *name2)\n{\n\tif (len1 != len2)\n\t\treturn 0;\n\n\treturn !memcmp(name1, name2, len1);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic inline int udf_match(int len1, const unsigned char *name1, int len2,\n\t\t\t    const unsigned char *name2)\n{\n\tif (len1 != len2)\n\t\treturn 0;\n\n\treturn !memcmp(name1, name2, len1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_filename",
          "args": [
            "sb",
            "nameptr",
            "lfi",
            "fname",
            "UDF_NAME_LEN"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
          "lines": "337-378",
          "snippet": "int udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,\n\t\t     uint8_t *dname, int dlen)\n{\n\tstruct ustr *filename, *unifilename;\n\tint len = 0;\n\n\tfilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!filename)\n\t\treturn 0;\n\n\tunifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!unifilename)\n\t\tgoto out1;\n\n\tif (udf_build_ustr_exact(unifilename, sname, slen))\n\t\tgoto out2;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tif (!udf_CS0toUTF8(filename, unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tif (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,\n\t\t\t\t  unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else\n\t\tgoto out2;\n\n\tlen = udf_translate_to_linux(dname, dlen,\n\t\t\t\t     filename->u_name, filename->u_len,\n\t\t\t\t     unifilename->u_name, unifilename->u_len);\nout2:\n\tkfree(unifilename);\nout1:\n\tkfree(filename);\n\treturn len;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>\t/* for memset */",
            "#include <linux/kernel.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);\n\nint udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,\n\t\t     uint8_t *dname, int dlen)\n{\n\tstruct ustr *filename, *unifilename;\n\tint len = 0;\n\n\tfilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!filename)\n\t\treturn 0;\n\n\tunifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!unifilename)\n\t\tgoto out1;\n\n\tif (udf_build_ustr_exact(unifilename, sname, slen))\n\t\tgoto out2;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tif (!udf_CS0toUTF8(filename, unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tif (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,\n\t\t\t\t  unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else\n\t\tgoto out2;\n\n\tlen = udf_translate_to_linux(dname, dlen,\n\t\t\t\t     filename->u_name, filename->u_len,\n\t\t\t\t     unifilename->u_name, unifilename->u_len);\nout2:\n\tkfree(unifilename);\nout1:\n\tkfree(filename);\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "sb",
            "UDF_FLAG_UNHIDE"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nameptr + lfi - poffset",
            "fibh->ebh->b_data",
            "poffset"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nameptr",
            "fi->fileIdent + liu",
            "lfi - poffset"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "cfi->lengthOfImpUse"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_fileident_read",
          "args": [
            "dir",
            "&f_pos",
            "fibh",
            "cfi",
            "&epos",
            "&eloc",
            "&elen",
            "&offset"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "udf_fileident_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/directory.c",
          "lines": "21-155",
          "snippet": "struct fileIdentDesc *udf_fileident_read(struct inode *dir, loff_t *nf_pos,\n\t\t\t\t\t struct udf_fileident_bh *fibh,\n\t\t\t\t\t struct fileIdentDesc *cfi,\n\t\t\t\t\t struct extent_position *epos,\n\t\t\t\t\t struct kernel_lb_addr *eloc, uint32_t *elen,\n\t\t\t\t\t sector_t *offset)\n{\n\tstruct fileIdentDesc *fi;\n\tint i, num, block;\n\tstruct buffer_head *tmp, *bha[16];\n\tstruct udf_inode_info *iinfo = UDF_I(dir);\n\n\tfibh->soffset = fibh->eoffset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tfi = udf_get_fileident(iinfo->i_ext.i_data -\n\t\t\t\t       (iinfo->i_efe ?\n\t\t\t\t\tsizeof(struct extendedFileEntry) :\n\t\t\t\t\tsizeof(struct fileEntry)),\n\t\t\t\t       dir->i_sb->s_blocksize,\n\t\t\t\t       &(fibh->eoffset));\n\t\tif (!fi)\n\t\t\treturn NULL;\n\n\t\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\n\t\treturn fi;\n\t}\n\n\tif (fibh->eoffset == dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\t\tunsigned char blocksize_bits = dir->i_sb->s_blocksize_bits;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\treturn NULL;\n\t\tfibh->soffset = fibh->eoffset = 0;\n\n\t\tif (!(*offset & ((16 >> (blocksize_bits - 9)) - 1))) {\n\t\t\ti = 16 >> (blocksize_bits - 9);\n\t\t\tif (i + *offset > (*elen >> blocksize_bits))\n\t\t\t\ti = (*elen >> blocksize_bits)-*offset;\n\t\t\tfor (num = 0; i > 0; i--) {\n\t\t\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc,\n\t\t\t\t\t\t\t  *offset + i);\n\t\t\t\ttmp = udf_tgetblk(dir->i_sb, block);\n\t\t\t\tif (tmp && !buffer_uptodate(tmp) &&\n\t\t\t\t\t\t!buffer_locked(tmp))\n\t\t\t\t\tbha[num++] = tmp;\n\t\t\t\telse\n\t\t\t\t\tbrelse(tmp);\n\t\t\t}\n\t\t\tif (num) {\n\t\t\t\tll_rw_block(READA, num, bha);\n\t\t\t\tfor (i = 0; i < num; i++)\n\t\t\t\t\tbrelse(bha[i]);\n\t\t\t}\n\t\t}\n\t} else if (fibh->sbh != fibh->ebh) {\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh;\n\t}\n\n\tfi = udf_get_fileident(fibh->sbh->b_data, dir->i_sb->s_blocksize,\n\t\t\t       &(fibh->eoffset));\n\n\tif (!fi)\n\t\treturn NULL;\n\n\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\tif (fibh->eoffset <= dir->i_sb->s_blocksize) {\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\t} else if (fibh->eoffset > dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << dir->i_sb->s_blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tfibh->soffset -= dir->i_sb->s_blocksize;\n\t\tfibh->eoffset -= dir->i_sb->s_blocksize;\n\n\t\tfibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->ebh)\n\t\t\treturn NULL;\n\n\t\tif (sizeof(struct fileIdentDesc) > -fibh->soffset) {\n\t\t\tint fi_len;\n\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi, -fibh->soffset);\n\t\t\tmemcpy((uint8_t *)cfi - fibh->soffset,\n\t\t\t       fibh->ebh->b_data,\n\t\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\n\t\t\tfi_len = (sizeof(struct fileIdentDesc) +\n\t\t\t\t  cfi->lengthFileIdent +\n\t\t\t\t  le16_to_cpu(cfi->lengthOfImpUse) + 3) & ~3;\n\n\t\t\t*nf_pos += fi_len - (fibh->eoffset - fibh->soffset);\n\t\t\tfibh->eoffset = fibh->soffset + fi_len;\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t\t       sizeof(struct fileIdentDesc));\n\t\t}\n\t}\n\treturn fi;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstruct fileIdentDesc *udf_fileident_read(struct inode *dir, loff_t *nf_pos,\n\t\t\t\t\t struct udf_fileident_bh *fibh,\n\t\t\t\t\t struct fileIdentDesc *cfi,\n\t\t\t\t\t struct extent_position *epos,\n\t\t\t\t\t struct kernel_lb_addr *eloc, uint32_t *elen,\n\t\t\t\t\t sector_t *offset)\n{\n\tstruct fileIdentDesc *fi;\n\tint i, num, block;\n\tstruct buffer_head *tmp, *bha[16];\n\tstruct udf_inode_info *iinfo = UDF_I(dir);\n\n\tfibh->soffset = fibh->eoffset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tfi = udf_get_fileident(iinfo->i_ext.i_data -\n\t\t\t\t       (iinfo->i_efe ?\n\t\t\t\t\tsizeof(struct extendedFileEntry) :\n\t\t\t\t\tsizeof(struct fileEntry)),\n\t\t\t\t       dir->i_sb->s_blocksize,\n\t\t\t\t       &(fibh->eoffset));\n\t\tif (!fi)\n\t\t\treturn NULL;\n\n\t\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\n\t\treturn fi;\n\t}\n\n\tif (fibh->eoffset == dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\t\tunsigned char blocksize_bits = dir->i_sb->s_blocksize_bits;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\treturn NULL;\n\t\tfibh->soffset = fibh->eoffset = 0;\n\n\t\tif (!(*offset & ((16 >> (blocksize_bits - 9)) - 1))) {\n\t\t\ti = 16 >> (blocksize_bits - 9);\n\t\t\tif (i + *offset > (*elen >> blocksize_bits))\n\t\t\t\ti = (*elen >> blocksize_bits)-*offset;\n\t\t\tfor (num = 0; i > 0; i--) {\n\t\t\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc,\n\t\t\t\t\t\t\t  *offset + i);\n\t\t\t\ttmp = udf_tgetblk(dir->i_sb, block);\n\t\t\t\tif (tmp && !buffer_uptodate(tmp) &&\n\t\t\t\t\t\t!buffer_locked(tmp))\n\t\t\t\t\tbha[num++] = tmp;\n\t\t\t\telse\n\t\t\t\t\tbrelse(tmp);\n\t\t\t}\n\t\t\tif (num) {\n\t\t\t\tll_rw_block(READA, num, bha);\n\t\t\t\tfor (i = 0; i < num; i++)\n\t\t\t\t\tbrelse(bha[i]);\n\t\t\t}\n\t\t}\n\t} else if (fibh->sbh != fibh->ebh) {\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh;\n\t}\n\n\tfi = udf_get_fileident(fibh->sbh->b_data, dir->i_sb->s_blocksize,\n\t\t\t       &(fibh->eoffset));\n\n\tif (!fi)\n\t\treturn NULL;\n\n\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\tif (fibh->eoffset <= dir->i_sb->s_blocksize) {\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\t} else if (fibh->eoffset > dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << dir->i_sb->s_blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tfibh->soffset -= dir->i_sb->s_blocksize;\n\t\tfibh->eoffset -= dir->i_sb->s_blocksize;\n\n\t\tfibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->ebh)\n\t\t\treturn NULL;\n\n\t\tif (sizeof(struct fileIdentDesc) > -fibh->soffset) {\n\t\t\tint fi_len;\n\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi, -fibh->soffset);\n\t\t\tmemcpy((uint8_t *)cfi - fibh->soffset,\n\t\t\t       fibh->ebh->b_data,\n\t\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\n\t\t\tfi_len = (sizeof(struct fileIdentDesc) +\n\t\t\t\t  cfi->lengthFileIdent +\n\t\t\t\t  le16_to_cpu(cfi->lengthOfImpUse) + 3) & ~3;\n\n\t\t\t*nf_pos += fi_len - (fibh->eoffset - fibh->soffset);\n\t\t\tfibh->eoffset = fibh->soffset + fi_len;\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t\t       sizeof(struct fileIdentDesc));\n\t\t}\n\t}\n\treturn fi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "UDF_NAME_LEN",
            "GFP_NOFS"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_tread",
          "args": [
            "sb",
            "block"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "40-46",
          "snippet": "struct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "sb",
            "&eloc",
            "offset"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_bmap",
          "args": [
            "dir",
            "f_pos >> sb->s_blocksize_bits",
            "&epos",
            "&eloc",
            "&elen",
            "&offset"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "inode_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2237-2268",
          "snippet": "int8_t inode_bmap(struct inode *inode, sector_t block,\n\t\t  struct extent_position *pos, struct kernel_lb_addr *eloc,\n\t\t  uint32_t *elen, sector_t *offset)\n{\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tloff_t lbcount = 0, bcount =\n\t    (loff_t) block << blocksize_bits;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tiinfo = UDF_I(inode);\n\tif (!udf_read_extent_cache(inode, bcount, &lbcount, pos)) {\n\t\tpos->offset = 0;\n\t\tpos->block = iinfo->i_location;\n\t\tpos->bh = NULL;\n\t}\n\t*elen = 0;\n\tdo {\n\t\tetype = udf_next_aext(inode, pos, eloc, elen, 1);\n\t\tif (etype == -1) {\n\t\t\t*offset = (bcount - lbcount) >> blocksize_bits;\n\t\t\tiinfo->i_lenExtents = lbcount;\n\t\t\treturn -1;\n\t\t}\n\t\tlbcount += *elen;\n\t} while (lbcount <= bcount);\n\t/* update extent cache */\n\tudf_update_extent_cache(inode, lbcount - *elen, pos, 1);\n\t*offset = (bcount + *elen - lbcount) >> blocksize_bits;\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t inode_bmap(struct inode *inode, sector_t block,\n\t\t  struct extent_position *pos, struct kernel_lb_addr *eloc,\n\t\t  uint32_t *elen, sector_t *offset)\n{\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tloff_t lbcount = 0, bcount =\n\t    (loff_t) block << blocksize_bits;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tiinfo = UDF_I(inode);\n\tif (!udf_read_extent_cache(inode, bcount, &lbcount, pos)) {\n\t\tpos->offset = 0;\n\t\tpos->block = iinfo->i_location;\n\t\tpos->bh = NULL;\n\t}\n\t*elen = 0;\n\tdo {\n\t\tetype = udf_next_aext(inode, pos, eloc, elen, 1);\n\t\tif (etype == -1) {\n\t\t\t*offset = (bcount - lbcount) >> blocksize_bits;\n\t\t\tiinfo->i_lenExtents = lbcount;\n\t\t\treturn -1;\n\t\t}\n\t\tlbcount += *elen;\n\t} while (lbcount <= bcount);\n\t/* update extent cache */\n\tudf_update_extent_cache(inode, lbcount - *elen, pos, 1);\n\t*offset = (bcount + *elen - lbcount) >> blocksize_bits;\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_ext0_offset",
          "args": [
            "dir"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "udf_ext0_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "66-72",
          "snippet": "static inline size_t udf_ext0_offset(struct inode *inode)\n{\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\treturn udf_file_entry_alloc_offset(inode);\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_ext0_offset(struct inode *inode)\n{\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\treturn udf_file_entry_alloc_offset(inode);\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "dir"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\tstruct super_block *sb = dir->i_sb;\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(sb, &eloc, offset);\n\t\tif ((++offset << sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(sb, nameptr, lfi, fname, UDF_NAME_LEN);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}"
  },
  {
    "function_name": "udf_write_fi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "44-140",
    "snippet": "int udf_write_fi(struct inode *inode, struct fileIdentDesc *cfi,\n\t\t struct fileIdentDesc *sfi, struct udf_fileident_bh *fibh,\n\t\t uint8_t *impuse, uint8_t *fileident)\n{\n\tuint16_t crclen = fibh->eoffset - fibh->soffset - sizeof(struct tag);\n\tuint16_t crc;\n\tint offset;\n\tuint16_t liu = le16_to_cpu(cfi->lengthOfImpUse);\n\tuint8_t lfi = cfi->lengthFileIdent;\n\tint padlen = fibh->eoffset - fibh->soffset - liu - lfi -\n\t\tsizeof(struct fileIdentDesc);\n\tint adinicb = 0;\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tadinicb = 1;\n\n\toffset = fibh->soffset + sizeof(struct fileIdentDesc);\n\n\tif (impuse) {\n\t\tif (adinicb || (offset + liu < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, liu);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, impuse, liu);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, -offset);\n\t\t\tmemcpy(fibh->ebh->b_data, impuse - offset,\n\t\t\t\tliu + offset);\n\t\t}\n\t}\n\n\toffset += liu;\n\n\tif (fileident) {\n\t\tif (adinicb || (offset + lfi < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident, lfi);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, fileident, lfi);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident,\n\t\t\t\t-offset);\n\t\t\tmemcpy(fibh->ebh->b_data, fileident - offset,\n\t\t\t\tlfi + offset);\n\t\t}\n\t}\n\n\toffset += lfi;\n\n\tif (adinicb || (offset + padlen < 0)) {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, padlen);\n\t} else if (offset >= 0) {\n\t\tmemset(fibh->ebh->b_data + offset, 0x00, padlen);\n\t} else {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, -offset);\n\t\tmemset(fibh->ebh->b_data, 0x00, padlen + offset);\n\t}\n\n\tcrc = crc_itu_t(0, (uint8_t *)cfi + sizeof(struct tag),\n\t\t      sizeof(struct fileIdentDesc) - sizeof(struct tag));\n\n\tif (fibh->sbh == fibh->ebh) {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t      sizeof(struct fileIdentDesc));\n\t} else if (sizeof(struct fileIdentDesc) >= -fibh->soffset) {\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data +\n\t\t\t\t\tsizeof(struct fileIdentDesc) +\n\t\t\t\t\tfibh->soffset,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      -fibh->soffset - sizeof(struct fileIdentDesc));\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data, fibh->eoffset);\n\t}\n\n\tcfi->descTag.descCRC = cpu_to_le16(crc);\n\tcfi->descTag.descCRCLength = cpu_to_le16(crclen);\n\tcfi->descTag.tagChecksum = udf_tag_checksum(&cfi->descTag);\n\n\tif (adinicb || (sizeof(struct fileIdentDesc) <= -fibh->soffset)) {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi,\n\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi, -fibh->soffset);\n\t\tmemcpy(fibh->ebh->b_data, (uint8_t *)cfi - fibh->soffset,\n\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\t}\n\n\tif (adinicb) {\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tmark_buffer_dirty_inode(fibh->ebh, inode);\n\t\tmark_buffer_dirty_inode(fibh->sbh, inode);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "fibh->sbh",
            "inode"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fibh->ebh->b_data",
            "(uint8_t *)cfi - fibh->soffset",
            "sizeof(struct fileIdentDesc) + fibh->soffset"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(uint8_t *)sfi",
            "(uint8_t *)cfi",
            "-fibh->soffset"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(uint8_t *)sfi",
            "(uint8_t *)cfi",
            "sizeof(struct fileIdentDesc)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_tag_checksum",
          "args": [
            "&cfi->descTag"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tag_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "290-299",
          "snippet": "u8 udf_tag_checksum(const struct tag *t)\n{\n\tu8 *data = (u8 *)t;\n\tu8 checksum = 0;\n\tint i;\n\tfor (i = 0; i < sizeof(struct tag); ++i)\n\t\tif (i != 4) /* position of checksum */\n\t\t\tchecksum += data[i];\n\treturn checksum;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nu8 udf_tag_checksum(const struct tag *t)\n{\n\tu8 *data = (u8 *)t;\n\tu8 checksum = 0;\n\tint i;\n\tfor (i = 0; i < sizeof(struct tag); ++i)\n\t\tif (i != 4) /* position of checksum */\n\t\t\tchecksum += data[i];\n\treturn checksum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "crclen"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "crc"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc_itu_t",
          "args": [
            "crc",
            "fibh->ebh->b_data",
            "fibh->eoffset"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc_itu_t",
          "args": [
            "crc",
            "(uint8_t *)sfi->impUse",
            "-fibh->soffset - sizeof(struct fileIdentDesc)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc_itu_t",
          "args": [
            "crc",
            "fibh->ebh->b_data +\n\t\t\t\t\tsizeof(struct fileIdentDesc) +\n\t\t\t\t\tfibh->soffset",
            "crclen + sizeof(struct tag) -\n\t\t\t\t\tsizeof(struct fileIdentDesc)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc_itu_t",
          "args": [
            "crc",
            "(uint8_t *)sfi->impUse",
            "crclen + sizeof(struct tag) -\n\t\t\t      sizeof(struct fileIdentDesc)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc_itu_t",
          "args": [
            "0",
            "(uint8_t *)cfi + sizeof(struct tag)",
            "sizeof(struct fileIdentDesc) - sizeof(struct tag)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fibh->ebh->b_data",
            "0x00",
            "padlen + offset"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(uint8_t *)sfi->padding + liu + lfi",
            "0x00",
            "-offset"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fibh->ebh->b_data + offset",
            "0x00",
            "padlen"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(uint8_t *)sfi->padding + liu + lfi",
            "0x00",
            "padlen"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fibh->ebh->b_data",
            "fileident - offset",
            "lfi + offset"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(uint8_t *)sfi->fileIdent + liu",
            "fileident",
            "-offset"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fibh->ebh->b_data + offset",
            "fileident",
            "lfi"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(uint8_t *)sfi->fileIdent + liu",
            "fileident",
            "lfi"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fibh->ebh->b_data",
            "impuse - offset",
            "liu + offset"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(uint8_t *)sfi->impUse",
            "impuse",
            "-offset"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fibh->ebh->b_data + offset",
            "impuse",
            "liu"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(uint8_t *)sfi->impUse",
            "impuse",
            "liu"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "cfi->lengthOfImpUse"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nint udf_write_fi(struct inode *inode, struct fileIdentDesc *cfi,\n\t\t struct fileIdentDesc *sfi, struct udf_fileident_bh *fibh,\n\t\t uint8_t *impuse, uint8_t *fileident)\n{\n\tuint16_t crclen = fibh->eoffset - fibh->soffset - sizeof(struct tag);\n\tuint16_t crc;\n\tint offset;\n\tuint16_t liu = le16_to_cpu(cfi->lengthOfImpUse);\n\tuint8_t lfi = cfi->lengthFileIdent;\n\tint padlen = fibh->eoffset - fibh->soffset - liu - lfi -\n\t\tsizeof(struct fileIdentDesc);\n\tint adinicb = 0;\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tadinicb = 1;\n\n\toffset = fibh->soffset + sizeof(struct fileIdentDesc);\n\n\tif (impuse) {\n\t\tif (adinicb || (offset + liu < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, liu);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, impuse, liu);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, -offset);\n\t\t\tmemcpy(fibh->ebh->b_data, impuse - offset,\n\t\t\t\tliu + offset);\n\t\t}\n\t}\n\n\toffset += liu;\n\n\tif (fileident) {\n\t\tif (adinicb || (offset + lfi < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident, lfi);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, fileident, lfi);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident,\n\t\t\t\t-offset);\n\t\t\tmemcpy(fibh->ebh->b_data, fileident - offset,\n\t\t\t\tlfi + offset);\n\t\t}\n\t}\n\n\toffset += lfi;\n\n\tif (adinicb || (offset + padlen < 0)) {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, padlen);\n\t} else if (offset >= 0) {\n\t\tmemset(fibh->ebh->b_data + offset, 0x00, padlen);\n\t} else {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, -offset);\n\t\tmemset(fibh->ebh->b_data, 0x00, padlen + offset);\n\t}\n\n\tcrc = crc_itu_t(0, (uint8_t *)cfi + sizeof(struct tag),\n\t\t      sizeof(struct fileIdentDesc) - sizeof(struct tag));\n\n\tif (fibh->sbh == fibh->ebh) {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t      sizeof(struct fileIdentDesc));\n\t} else if (sizeof(struct fileIdentDesc) >= -fibh->soffset) {\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data +\n\t\t\t\t\tsizeof(struct fileIdentDesc) +\n\t\t\t\t\tfibh->soffset,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      -fibh->soffset - sizeof(struct fileIdentDesc));\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data, fibh->eoffset);\n\t}\n\n\tcfi->descTag.descCRC = cpu_to_le16(crc);\n\tcfi->descTag.descCRCLength = cpu_to_le16(crclen);\n\tcfi->descTag.tagChecksum = udf_tag_checksum(&cfi->descTag);\n\n\tif (adinicb || (sizeof(struct fileIdentDesc) <= -fibh->soffset)) {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi,\n\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi, -fibh->soffset);\n\t\tmemcpy(fibh->ebh->b_data, (uint8_t *)cfi - fibh->soffset,\n\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\t}\n\n\tif (adinicb) {\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tmark_buffer_dirty_inode(fibh->ebh, inode);\n\t\tmark_buffer_dirty_inode(fibh->sbh, inode);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
    "lines": "35-42",
    "snippet": "static inline int udf_match(int len1, const unsigned char *name1, int len2,\n\t\t\t    const unsigned char *name2)\n{\n\tif (len1 != len2)\n\t\treturn 0;\n\n\treturn !memcmp(name1, name2, len1);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name1",
            "name2",
            "len1"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstatic inline int udf_match(int len1, const unsigned char *name1, int len2,\n\t\t\t    const unsigned char *name2)\n{\n\tif (len1 != len2)\n\t\treturn 0;\n\n\treturn !memcmp(name1, name2, len1);\n}"
  }
]