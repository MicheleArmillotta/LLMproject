[
  {
    "function_name": "ocfs2_destroy_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "958-961",
    "snippet": "static void ocfs2_destroy_dquot(struct dquot *dquot)\n{\n\tkmem_cache_free(ocfs2_dquot_cachep, dquot);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ocfs2_dquot_cachep",
            "dquot"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic void ocfs2_destroy_dquot(struct dquot *dquot)\n{\n\tkmem_cache_free(ocfs2_dquot_cachep, dquot);\n}"
  },
  {
    "function_name": "ocfs2_alloc_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "948-956",
    "snippet": "static struct dquot *ocfs2_alloc_dquot(struct super_block *sb, int type)\n{\n\tstruct ocfs2_dquot *dquot =\n\t\t\t\tkmem_cache_zalloc(ocfs2_dquot_cachep, GFP_NOFS);\n\n\tif (!dquot)\n\t\treturn NULL;\n\treturn &dquot->dq_dquot;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "ocfs2_dquot_cachep",
            "GFP_NOFS"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic struct dquot *ocfs2_alloc_dquot(struct super_block *sb, int type)\n{\n\tstruct ocfs2_dquot *dquot =\n\t\t\t\tkmem_cache_zalloc(ocfs2_dquot_cachep, GFP_NOFS);\n\n\tif (!dquot)\n\t\treturn NULL;\n\treturn &dquot->dq_dquot;\n}"
  },
  {
    "function_name": "ocfs2_write_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "923-946",
    "snippet": "static int ocfs2_write_info(struct super_block *sb, int type)\n{\n\thandle_t *handle;\n\tint status = 0;\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\n\tstatus = ocfs2_lock_global_qf(oinfo, 1);\n\tif (status < 0)\n\t\tgoto out;\n\thandle = ocfs2_start_trans(OCFS2_SB(sb), OCFS2_QINFO_WRITE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_ilock;\n\t}\n\tstatus = dquot_commit_info(sb, type);\n\tocfs2_commit_trans(OCFS2_SB(sb), handle);\nout_ilock:\n\tocfs2_unlock_global_qf(oinfo, 1);\nout:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_unlock_global_qf",
          "args": [
            "oinfo",
            "1"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_global_qf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "319-333",
          "snippet": "void ocfs2_unlock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tif (ex) {\n\t\tup_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t\tmutex_unlock(&oinfo->dqi_gqinode->i_mutex);\n\t} else {\n\t\tup_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\tocfs2_inode_unlock(oinfo->dqi_gqinode, ex);\n\tbrelse(oinfo->dqi_gqi_bh);\n\tspin_lock(&dq_data_lock);\n\tif (!--oinfo->dqi_gqi_count)\n\t\toinfo->dqi_gqi_bh = NULL;\n\tspin_unlock(&dq_data_lock);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nvoid ocfs2_unlock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tif (ex) {\n\t\tup_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t\tmutex_unlock(&oinfo->dqi_gqinode->i_mutex);\n\t} else {\n\t\tup_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\tocfs2_inode_unlock(oinfo->dqi_gqinode, ex);\n\tbrelse(oinfo->dqi_gqi_bh);\n\tspin_lock(&dq_data_lock);\n\tif (!--oinfo->dqi_gqi_count)\n\t\toinfo->dqi_gqi_bh = NULL;\n\tspin_unlock(&dq_data_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "OCFS2_SB(sb)",
            "handle"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_commit_info",
          "args": [
            "sb",
            "type"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_commit_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1956-1965",
          "snippet": "int dquot_commit_info(struct super_block *sb, int type)\n{\n\tint ret;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\n\tmutex_lock(&dqopt->dqio_mutex);\n\tret = dqopt->ops[type]->write_file_info(sb, type);\n\tmutex_unlock(&dqopt->dqio_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_commit_info(struct super_block *sb, int type)\n{\n\tint ret;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\n\tmutex_lock(&dqopt->dqio_mutex);\n\tret = dqopt->ops[type]->write_file_info(sb, type);\n\tmutex_unlock(&dqopt->dqio_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "OCFS2_SB(sb)",
            "OCFS2_QINFO_WRITE_CREDITS"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_global_qf",
          "args": [
            "oinfo",
            "1"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_global_qf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "296-317",
          "snippet": "int ocfs2_lock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\n\tstatus = ocfs2_inode_lock(oinfo->dqi_gqinode, &bh, ex);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&dq_data_lock);\n\tif (!oinfo->dqi_gqi_count++)\n\t\toinfo->dqi_gqi_bh = bh;\n\telse\n\t\tWARN_ON(bh != oinfo->dqi_gqi_bh);\n\tspin_unlock(&dq_data_lock);\n\tif (ex) {\n\t\tmutex_lock(&oinfo->dqi_gqinode->i_mutex);\n\t\tdown_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t} else {\n\t\tdown_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nint ocfs2_lock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\n\tstatus = ocfs2_inode_lock(oinfo->dqi_gqinode, &bh, ex);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&dq_data_lock);\n\tif (!oinfo->dqi_gqi_count++)\n\t\toinfo->dqi_gqi_bh = bh;\n\telse\n\t\tWARN_ON(bh != oinfo->dqi_gqi_bh);\n\tspin_unlock(&dq_data_lock);\n\tif (ex) {\n\t\tmutex_lock(&oinfo->dqi_gqinode->i_mutex);\n\t\tdown_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t} else {\n\t\tdown_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic int ocfs2_write_info(struct super_block *sb, int type)\n{\n\thandle_t *handle;\n\tint status = 0;\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\n\tstatus = ocfs2_lock_global_qf(oinfo, 1);\n\tif (status < 0)\n\t\tgoto out;\n\thandle = ocfs2_start_trans(OCFS2_SB(sb), OCFS2_QINFO_WRITE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_ilock;\n\t}\n\tstatus = dquot_commit_info(sb, type);\n\tocfs2_commit_trans(OCFS2_SB(sb), handle);\nout_ilock:\n\tocfs2_unlock_global_qf(oinfo, 1);\nout:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_mark_dquot_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "863-920",
    "snippet": "static int ocfs2_mark_dquot_dirty(struct dquot *dquot)\n{\n\tunsigned long mask = (1 << (DQ_LASTSET_B + QIF_ILIMITS_B)) |\n\t\t\t     (1 << (DQ_LASTSET_B + QIF_BLIMITS_B)) |\n\t\t\t     (1 << (DQ_LASTSET_B + QIF_INODES_B)) |\n\t\t\t     (1 << (DQ_LASTSET_B + QIF_SPACE_B)) |\n\t\t\t     (1 << (DQ_LASTSET_B + QIF_BTIME_B)) |\n\t\t\t     (1 << (DQ_LASTSET_B + QIF_ITIME_B));\n\tint sync = 0;\n\tint status;\n\tstruct super_block *sb = dquot->dq_sb;\n\tint type = dquot->dq_id.type;\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\ttrace_ocfs2_mark_dquot_dirty(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t\t     type);\n\n\t/* In case user set some limits, sync dquot immediately to global\n\t * quota file so that information propagates quicker */\n\tspin_lock(&dq_data_lock);\n\tif (dquot->dq_flags & mask)\n\t\tsync = 1;\n\tspin_unlock(&dq_data_lock);\n\t/* This is a slight hack but we can't afford getting global quota\n\t * lock if we already have a transaction started. */\n\tif (!sync || journal_current_handle()) {\n\t\tstatus = ocfs2_write_dquot(dquot);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_lock_global_qf(oinfo, 1);\n\tif (status < 0)\n\t\tgoto out;\n\thandle = ocfs2_start_trans(osb, OCFS2_QSYNC_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_ilock;\n\t}\n\tmutex_lock(&sb_dqopt(sb)->dqio_mutex);\n\tstatus = ocfs2_sync_dquot(dquot);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_dlock;\n\t}\n\t/* Now write updated local dquot structure */\n\tstatus = ocfs2_local_write_dquot(dquot);\nout_dlock:\n\tmutex_unlock(&sb_dqopt(sb)->dqio_mutex);\n\tocfs2_commit_trans(osb, handle);\nout_ilock:\n\tocfs2_unlock_global_qf(oinfo, 1);\nout:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_unlock_global_qf",
          "args": [
            "oinfo",
            "1"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_global_qf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "319-333",
          "snippet": "void ocfs2_unlock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tif (ex) {\n\t\tup_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t\tmutex_unlock(&oinfo->dqi_gqinode->i_mutex);\n\t} else {\n\t\tup_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\tocfs2_inode_unlock(oinfo->dqi_gqinode, ex);\n\tbrelse(oinfo->dqi_gqi_bh);\n\tspin_lock(&dq_data_lock);\n\tif (!--oinfo->dqi_gqi_count)\n\t\toinfo->dqi_gqi_bh = NULL;\n\tspin_unlock(&dq_data_lock);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nvoid ocfs2_unlock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tif (ex) {\n\t\tup_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t\tmutex_unlock(&oinfo->dqi_gqinode->i_mutex);\n\t} else {\n\t\tup_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\tocfs2_inode_unlock(oinfo->dqi_gqinode, ex);\n\tbrelse(oinfo->dqi_gqi_bh);\n\tspin_lock(&dq_data_lock);\n\tif (!--oinfo->dqi_gqi_count)\n\t\toinfo->dqi_gqi_bh = NULL;\n\tspin_unlock(&dq_data_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sb_dqopt(sb)->dqio_mutex"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_local_write_dquot",
          "args": [
            "dquot"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_write_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "896-918",
          "snippet": "int ocfs2_local_write_dquot(struct dquot *dquot)\n{\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tstruct buffer_head *bh;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[dquot->dq_id.type];\n\tint status;\n\n\tstatus = ocfs2_read_quota_phys_block(lqinode, od->dq_local_phys_blk,\n\t\t\t\t\t     &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_modify_bh(lqinode, bh, olq_set_dquot, od);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\nout:\n\tbrelse(bh);\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ocfs2_local_write_dquot(struct dquot *dquot)\n{\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tstruct buffer_head *bh;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[dquot->dq_id.type];\n\tint status;\n\n\tstatus = ocfs2_read_quota_phys_block(lqinode, od->dq_local_phys_blk,\n\t\t\t\t\t     &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_modify_bh(lqinode, bh, olq_set_dquot, od);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\nout:\n\tbrelse(bh);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_sync_dquot",
          "args": [
            "dquot"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sync_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota.h",
          "lines": "101-104",
          "snippet": "static inline int ocfs2_sync_dquot(struct dquot *dquot)\n{\n\treturn __ocfs2_sync_dquot(dquot, 0);\n}",
          "includes": [
            "#include \"ocfs2.h\"",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/list.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2.h\"\n#include <linux/dqblk_qtree.h>\n#include <linux/list.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline int ocfs2_sync_dquot(struct dquot *dquot)\n{\n\treturn __ocfs2_sync_dquot(dquot, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sb_dqopt(sb)->dqio_mutex"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_QSYNC_CREDITS"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_global_qf",
          "args": [
            "oinfo",
            "1"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_global_qf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "296-317",
          "snippet": "int ocfs2_lock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\n\tstatus = ocfs2_inode_lock(oinfo->dqi_gqinode, &bh, ex);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&dq_data_lock);\n\tif (!oinfo->dqi_gqi_count++)\n\t\toinfo->dqi_gqi_bh = bh;\n\telse\n\t\tWARN_ON(bh != oinfo->dqi_gqi_bh);\n\tspin_unlock(&dq_data_lock);\n\tif (ex) {\n\t\tmutex_lock(&oinfo->dqi_gqinode->i_mutex);\n\t\tdown_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t} else {\n\t\tdown_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nint ocfs2_lock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\n\tstatus = ocfs2_inode_lock(oinfo->dqi_gqinode, &bh, ex);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&dq_data_lock);\n\tif (!oinfo->dqi_gqi_count++)\n\t\toinfo->dqi_gqi_bh = bh;\n\telse\n\t\tWARN_ON(bh != oinfo->dqi_gqi_bh);\n\tspin_unlock(&dq_data_lock);\n\tif (ex) {\n\t\tmutex_lock(&oinfo->dqi_gqinode->i_mutex);\n\t\tdown_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t} else {\n\t\tdown_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_write_dquot",
          "args": [
            "dquot"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_write_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "646-667",
          "snippet": "static int ocfs2_write_dquot(struct dquot *dquot)\n{\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(dquot->dq_sb);\n\tint status = 0;\n\n\ttrace_ocfs2_write_dquot(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t\tdquot->dq_id.type);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_QWRITE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tmutex_lock(&sb_dqopt(dquot->dq_sb)->dqio_mutex);\n\tstatus = ocfs2_local_write_dquot(dquot);\n\tmutex_unlock(&sb_dqopt(dquot->dq_sb)->dqio_mutex);\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic int ocfs2_write_dquot(struct dquot *dquot)\n{\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(dquot->dq_sb);\n\tint status = 0;\n\n\ttrace_ocfs2_write_dquot(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t\tdquot->dq_id.type);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_QWRITE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tmutex_lock(&sb_dqopt(dquot->dq_sb)->dqio_mutex);\n\tstatus = ocfs2_local_write_dquot(dquot);\n\tmutex_unlock(&sb_dqopt(dquot->dq_sb)->dqio_mutex);\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_current_handle",
          "args": [],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_mark_dquot_dirty",
          "args": [
            "from_kqid(&init_user_ns, dquot->dq_id)",
            "type"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kqid",
          "args": [
            "&init_user_ns",
            "dquot->dq_id"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "from_kqid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "100-112",
          "snippet": "qid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nqid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic int ocfs2_mark_dquot_dirty(struct dquot *dquot)\n{\n\tunsigned long mask = (1 << (DQ_LASTSET_B + QIF_ILIMITS_B)) |\n\t\t\t     (1 << (DQ_LASTSET_B + QIF_BLIMITS_B)) |\n\t\t\t     (1 << (DQ_LASTSET_B + QIF_INODES_B)) |\n\t\t\t     (1 << (DQ_LASTSET_B + QIF_SPACE_B)) |\n\t\t\t     (1 << (DQ_LASTSET_B + QIF_BTIME_B)) |\n\t\t\t     (1 << (DQ_LASTSET_B + QIF_ITIME_B));\n\tint sync = 0;\n\tint status;\n\tstruct super_block *sb = dquot->dq_sb;\n\tint type = dquot->dq_id.type;\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\ttrace_ocfs2_mark_dquot_dirty(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t\t     type);\n\n\t/* In case user set some limits, sync dquot immediately to global\n\t * quota file so that information propagates quicker */\n\tspin_lock(&dq_data_lock);\n\tif (dquot->dq_flags & mask)\n\t\tsync = 1;\n\tspin_unlock(&dq_data_lock);\n\t/* This is a slight hack but we can't afford getting global quota\n\t * lock if we already have a transaction started. */\n\tif (!sync || journal_current_handle()) {\n\t\tstatus = ocfs2_write_dquot(dquot);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_lock_global_qf(oinfo, 1);\n\tif (status < 0)\n\t\tgoto out;\n\thandle = ocfs2_start_trans(osb, OCFS2_QSYNC_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_ilock;\n\t}\n\tmutex_lock(&sb_dqopt(sb)->dqio_mutex);\n\tstatus = ocfs2_sync_dquot(dquot);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_dlock;\n\t}\n\t/* Now write updated local dquot structure */\n\tstatus = ocfs2_local_write_dquot(dquot);\nout_dlock:\n\tmutex_unlock(&sb_dqopt(sb)->dqio_mutex);\n\tocfs2_commit_trans(osb, handle);\nout_ilock:\n\tocfs2_unlock_global_qf(oinfo, 1);\nout:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_acquire_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "778-861",
    "snippet": "static int ocfs2_acquire_dquot(struct dquot *dquot)\n{\n\tint status = 0, err;\n\tint ex = 0;\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tint type = dquot->dq_id.type;\n\tstruct ocfs2_mem_dqinfo *info = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct inode *gqinode = info->dqi_gqinode;\n\tint need_alloc = ocfs2_global_qinit_alloc(sb, type);\n\thandle_t *handle;\n\n\ttrace_ocfs2_acquire_dquot(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t\t  type);\n\tmutex_lock(&dquot->dq_lock);\n\t/*\n\t * We need an exclusive lock, because we're going to update use count\n\t * and instantiate possibly new dquot structure\n\t */\n\tstatus = ocfs2_lock_global_qf(info, 1);\n\tif (status < 0)\n\t\tgoto out;\n\tstatus = ocfs2_qinfo_lock(info, 0);\n\tif (status < 0)\n\t\tgoto out_dq;\n\t/*\n\t * We always want to read dquot structure from disk because we don't\n\t * know what happened with it while it was on freelist.\n\t */\n\tstatus = qtree_read_dquot(&info->dqi_gi, dquot);\n\tocfs2_qinfo_unlock(info, 0);\n\tif (status < 0)\n\t\tgoto out_dq;\n\n\tOCFS2_DQUOT(dquot)->dq_use_count++;\n\tOCFS2_DQUOT(dquot)->dq_origspace = dquot->dq_dqb.dqb_curspace;\n\tOCFS2_DQUOT(dquot)->dq_originodes = dquot->dq_dqb.dqb_curinodes;\n\tif (!dquot->dq_off) {\t/* No real quota entry? */\n\t\tex = 1;\n\t\t/*\n\t\t * Add blocks to quota file before we start a transaction since\n\t\t * locking allocators ranks above a transaction start\n\t\t */\n\t\tWARN_ON(journal_current_handle());\n\t\tstatus = ocfs2_extend_no_holes(gqinode, NULL,\n\t\t\ti_size_read(gqinode) + (need_alloc << sb->s_blocksize_bits),\n\t\t\ti_size_read(gqinode));\n\t\tif (status < 0)\n\t\t\tgoto out_dq;\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\t\t   ocfs2_calc_global_qinit_credits(sb, type));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tgoto out_dq;\n\t}\n\tstatus = ocfs2_qinfo_lock(info, ex);\n\tif (status < 0)\n\t\tgoto out_trans;\n\tstatus = qtree_write_dquot(&info->dqi_gi, dquot);\n\tif (ex && info_dirty(sb_dqinfo(sb, type))) {\n\t\terr = __ocfs2_global_write_info(sb, type);\n\t\tif (!status)\n\t\t\tstatus = err;\n\t}\n\tocfs2_qinfo_unlock(info, ex);\nout_trans:\n\tocfs2_commit_trans(osb, handle);\nout_dq:\n\tocfs2_unlock_global_qf(info, 1);\n\tif (status < 0)\n\t\tgoto out;\n\n\tstatus = ocfs2_create_local_dquot(dquot);\n\tif (status < 0)\n\t\tgoto out;\n\tset_bit(DQ_ACTIVE_B, &dquot->dq_flags);\nout:\n\tmutex_unlock(&dquot->dq_lock);\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dquot->dq_lock"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "DQ_ACTIVE_B",
            "&dquot->dq_flags"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_create_local_dquot",
          "args": [
            "dquot"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_create_local_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "1219-1267",
          "snippet": "int ocfs2_create_local_dquot(struct dquot *dquot)\n{\n\tstruct super_block *sb = dquot->dq_sb;\n\tint type = dquot->dq_id.type;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[type];\n\tstruct ocfs2_quota_chunk *chunk;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tint offset;\n\tint status;\n\tu64 pcount;\n\n\tdown_write(&OCFS2_I(lqinode)->ip_alloc_sem);\n\tchunk = ocfs2_find_free_entry(sb, type, &offset);\n\tif (!chunk) {\n\t\tchunk = ocfs2_extend_local_quota_file(sb, type, &offset);\n\t\tif (IS_ERR(chunk)) {\n\t\t\tstatus = PTR_ERR(chunk);\n\t\t\tgoto out;\n\t\t}\n\t} else if (IS_ERR(chunk)) {\n\t\tstatus = PTR_ERR(chunk);\n\t\tgoto out;\n\t}\n\tod->dq_local_off = ol_dqblk_off(sb, chunk->qc_num, offset);\n\tod->dq_chunk = chunk;\n\tstatus = ocfs2_extent_map_get_blocks(lqinode,\n\t\t\t\t     ol_dqblk_block(sb, chunk->qc_num, offset),\n\t\t\t\t     &od->dq_local_phys_blk,\n\t\t\t\t     &pcount,\n\t\t\t\t     NULL);\n\n\t/* Initialize dquot structure on disk */\n\tstatus = ocfs2_local_write_dquot(dquot);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t/* Mark structure as allocated */\n\tstatus = ocfs2_modify_bh(lqinode, chunk->qc_headerbh, olq_alloc_dquot,\n\t\t\t\t &offset);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\nout:\n\tup_write(&OCFS2_I(lqinode)->ip_alloc_sem);\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ocfs2_create_local_dquot(struct dquot *dquot)\n{\n\tstruct super_block *sb = dquot->dq_sb;\n\tint type = dquot->dq_id.type;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[type];\n\tstruct ocfs2_quota_chunk *chunk;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tint offset;\n\tint status;\n\tu64 pcount;\n\n\tdown_write(&OCFS2_I(lqinode)->ip_alloc_sem);\n\tchunk = ocfs2_find_free_entry(sb, type, &offset);\n\tif (!chunk) {\n\t\tchunk = ocfs2_extend_local_quota_file(sb, type, &offset);\n\t\tif (IS_ERR(chunk)) {\n\t\t\tstatus = PTR_ERR(chunk);\n\t\t\tgoto out;\n\t\t}\n\t} else if (IS_ERR(chunk)) {\n\t\tstatus = PTR_ERR(chunk);\n\t\tgoto out;\n\t}\n\tod->dq_local_off = ol_dqblk_off(sb, chunk->qc_num, offset);\n\tod->dq_chunk = chunk;\n\tstatus = ocfs2_extent_map_get_blocks(lqinode,\n\t\t\t\t     ol_dqblk_block(sb, chunk->qc_num, offset),\n\t\t\t\t     &od->dq_local_phys_blk,\n\t\t\t\t     &pcount,\n\t\t\t\t     NULL);\n\n\t/* Initialize dquot structure on disk */\n\tstatus = ocfs2_local_write_dquot(dquot);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t/* Mark structure as allocated */\n\tstatus = ocfs2_modify_bh(lqinode, chunk->qc_headerbh, olq_alloc_dquot,\n\t\t\t\t &offset);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\nout:\n\tup_write(&OCFS2_I(lqinode)->ip_alloc_sem);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlock_global_qf",
          "args": [
            "info",
            "1"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_global_qf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "319-333",
          "snippet": "void ocfs2_unlock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tif (ex) {\n\t\tup_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t\tmutex_unlock(&oinfo->dqi_gqinode->i_mutex);\n\t} else {\n\t\tup_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\tocfs2_inode_unlock(oinfo->dqi_gqinode, ex);\n\tbrelse(oinfo->dqi_gqi_bh);\n\tspin_lock(&dq_data_lock);\n\tif (!--oinfo->dqi_gqi_count)\n\t\toinfo->dqi_gqi_bh = NULL;\n\tspin_unlock(&dq_data_lock);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nvoid ocfs2_unlock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tif (ex) {\n\t\tup_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t\tmutex_unlock(&oinfo->dqi_gqinode->i_mutex);\n\t} else {\n\t\tup_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\tocfs2_inode_unlock(oinfo->dqi_gqinode, ex);\n\tbrelse(oinfo->dqi_gqi_bh);\n\tspin_lock(&dq_data_lock);\n\tif (!--oinfo->dqi_gqi_count)\n\t\toinfo->dqi_gqi_bh = NULL;\n\tspin_unlock(&dq_data_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_qinfo_unlock",
          "args": [
            "info",
            "ex"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_qinfo_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3820-3828",
          "snippet": "void ocfs2_qinfo_unlock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_qinfo_unlock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_global_write_info",
          "args": [
            "sb",
            "type"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_global_write_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "415-441",
          "snippet": "static int __ocfs2_global_write_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_global_disk_dqinfo dinfo;\n\tssize_t size;\n\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_flags &= ~DQF_INFO_DIRTY;\n\tdinfo.dqi_bgrace = cpu_to_le32(info->dqi_bgrace);\n\tdinfo.dqi_igrace = cpu_to_le32(info->dqi_igrace);\n\tspin_unlock(&dq_data_lock);\n\tdinfo.dqi_syncms = cpu_to_le32(oinfo->dqi_syncms);\n\tdinfo.dqi_blocks = cpu_to_le32(oinfo->dqi_gi.dqi_blocks);\n\tdinfo.dqi_free_blk = cpu_to_le32(oinfo->dqi_gi.dqi_free_blk);\n\tdinfo.dqi_free_entry = cpu_to_le32(oinfo->dqi_gi.dqi_free_entry);\n\tsize = sb->s_op->quota_write(sb, type, (char *)&dinfo,\n\t\t\t\t     sizeof(struct ocfs2_global_disk_dqinfo),\n\t\t\t\t     OCFS2_GLOBAL_INFO_OFF);\n\tif (size != sizeof(struct ocfs2_global_disk_dqinfo)) {\n\t\tmlog(ML_ERROR, \"Cannot write global quota info structure\\n\");\n\t\tif (size >= 0)\n\t\t\tsize = -EIO;\n\t\treturn size;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic int __ocfs2_global_write_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_global_disk_dqinfo dinfo;\n\tssize_t size;\n\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_flags &= ~DQF_INFO_DIRTY;\n\tdinfo.dqi_bgrace = cpu_to_le32(info->dqi_bgrace);\n\tdinfo.dqi_igrace = cpu_to_le32(info->dqi_igrace);\n\tspin_unlock(&dq_data_lock);\n\tdinfo.dqi_syncms = cpu_to_le32(oinfo->dqi_syncms);\n\tdinfo.dqi_blocks = cpu_to_le32(oinfo->dqi_gi.dqi_blocks);\n\tdinfo.dqi_free_blk = cpu_to_le32(oinfo->dqi_gi.dqi_free_blk);\n\tdinfo.dqi_free_entry = cpu_to_le32(oinfo->dqi_gi.dqi_free_entry);\n\tsize = sb->s_op->quota_write(sb, type, (char *)&dinfo,\n\t\t\t\t     sizeof(struct ocfs2_global_disk_dqinfo),\n\t\t\t\t     OCFS2_GLOBAL_INFO_OFF);\n\tif (size != sizeof(struct ocfs2_global_disk_dqinfo)) {\n\t\tmlog(ML_ERROR, \"Cannot write global quota info structure\\n\");\n\t\tif (size >= 0)\n\t\t\tsize = -EIO;\n\t\treturn size;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "info_dirty",
          "args": [
            "sb_dqinfo(sb, type)"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "mark_fsinfo_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "311-319",
          "snippet": "static void mark_fsinfo_dirty(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tif (sb->s_flags & MS_RDONLY || sbi->fat_bits != 32)\n\t\treturn;\n\n\t__mark_inode_dirty(sbi->fsinfo_inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void mark_fsinfo_dirty(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tif (sb->s_flags & MS_RDONLY || sbi->fat_bits != 32)\n\t\treturn;\n\n\t__mark_inode_dirty(sbi->fsinfo_inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qtree_write_dquot",
          "args": [
            "&info->dqi_gi",
            "dquot"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "qtree_write_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "359-395",
          "snippet": "int qtree_write_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tint type = dquot->dq_id.type;\n\tstruct super_block *sb = dquot->dq_sb;\n\tssize_t ret;\n\tchar *ddquot = getdqbuf(info->dqi_entry_size);\n\n\tif (!ddquot)\n\t\treturn -ENOMEM;\n\n\t/* dq_off is guarded by dqio_mutex */\n\tif (!dquot->dq_off) {\n\t\tret = dq_insert_tree(info, dquot);\n\t\tif (ret < 0) {\n\t\t\tquota_error(sb, \"Error %zd occurred while creating \"\n\t\t\t\t    \"quota\", ret);\n\t\t\tkfree(ddquot);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_ops->mem2disk_dqblk(ddquot, dquot);\n\tspin_unlock(&dq_data_lock);\n\tret = sb->s_op->quota_write(sb, type, ddquot, info->dqi_entry_size,\n\t\t\t\t    dquot->dq_off);\n\tif (ret != info->dqi_entry_size) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOSPC;\n\t} else {\n\t\tret = 0;\n\t}\n\tdqstats_inc(DQST_WRITES);\n\tkfree(ddquot);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint qtree_write_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tint type = dquot->dq_id.type;\n\tstruct super_block *sb = dquot->dq_sb;\n\tssize_t ret;\n\tchar *ddquot = getdqbuf(info->dqi_entry_size);\n\n\tif (!ddquot)\n\t\treturn -ENOMEM;\n\n\t/* dq_off is guarded by dqio_mutex */\n\tif (!dquot->dq_off) {\n\t\tret = dq_insert_tree(info, dquot);\n\t\tif (ret < 0) {\n\t\t\tquota_error(sb, \"Error %zd occurred while creating \"\n\t\t\t\t    \"quota\", ret);\n\t\t\tkfree(ddquot);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_ops->mem2disk_dqblk(ddquot, dquot);\n\tspin_unlock(&dq_data_lock);\n\tret = sb->s_op->quota_write(sb, type, ddquot, info->dqi_entry_size,\n\t\t\t\t    dquot->dq_off);\n\tif (ret != info->dqi_entry_size) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOSPC;\n\t} else {\n\t\tret = 0;\n\t}\n\tdqstats_inc(DQST_WRITES);\n\tkfree(ddquot);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_qinfo_lock",
          "args": [
            "info",
            "ex"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_qinfo_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3875-3905",
          "snippet": "int ocfs2_qinfo_lock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tint status = 0;\n\n\t/* On RO devices, locking really isn't needed... */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (ex)\n\t\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (!ocfs2_should_refresh_lock_res(lockres))\n\t\tgoto bail;\n\t/* OK, we have the lock but we need to refresh the quota info */\n\tstatus = ocfs2_refresh_qinfo(oinfo);\n\tif (status)\n\t\tocfs2_qinfo_unlock(oinfo, ex);\n\tocfs2_complete_lock_res_refresh(lockres, status);\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_qinfo_lock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tint status = 0;\n\n\t/* On RO devices, locking really isn't needed... */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (ex)\n\t\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (!ocfs2_should_refresh_lock_res(lockres))\n\t\tgoto bail;\n\t/* OK, we have the lock but we need to refresh the quota info */\n\tstatus = ocfs2_refresh_qinfo(oinfo);\n\tif (status)\n\t\tocfs2_qinfo_unlock(oinfo, ex);\n\tocfs2_complete_lock_res_refresh(lockres, status);\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "ocfs2_calc_global_qinit_credits(sb, type)"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_global_qinit_credits",
          "args": [
            "sb",
            "type"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_global_qinit_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "467-473",
          "snippet": "static int ocfs2_calc_global_qinit_credits(struct super_block *sb, int type)\n{\n\t/* We modify all the allocated blocks, tree root, info block and\n\t * the inode */\n\treturn (ocfs2_global_qinit_alloc(sb, type) + 2) *\n\t\t\tOCFS2_QUOTA_BLOCK_UPDATE_CREDITS + 1;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic int ocfs2_calc_global_qinit_credits(struct super_block *sb, int type)\n{\n\t/* We modify all the allocated blocks, tree root, info block and\n\t * the inode */\n\treturn (ocfs2_global_qinit_alloc(sb, type) + 2) *\n\t\t\tOCFS2_QUOTA_BLOCK_UPDATE_CREDITS + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_no_holes",
          "args": [
            "gqinode",
            "NULL",
            "i_size_read(gqinode) + (need_alloc << sb->s_blocksize_bits)",
            "i_size_read(gqinode)"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_no_holes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1018-1058",
          "snippet": "int ocfs2_extend_no_holes(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t  u64 new_i_size, u64 zero_to)\n{\n\tint ret;\n\tu32 clusters_to_add;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t/*\n\t * Only quota files call this without a bh, and they can't be\n\t * refcounted.\n\t */\n\tBUG_ON(!di_bh && (oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\tBUG_ON(!di_bh && !(oi->ip_flags & OCFS2_INODE_SYSTEM_FILE));\n\n\tclusters_to_add = ocfs2_clusters_for_bytes(inode->i_sb, new_i_size);\n\tif (clusters_to_add < oi->ip_clusters)\n\t\tclusters_to_add = 0;\n\telse\n\t\tclusters_to_add -= oi->ip_clusters;\n\n\tif (clusters_to_add) {\n\t\tret = __ocfs2_extend_allocation(inode, oi->ip_clusters,\n\t\t\t\t\t\tclusters_to_add, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Call this even if we don't add any clusters to the tree. We\n\t * still need to zero the area between the old i_size and the\n\t * new i_size.\n\t */\n\tret = ocfs2_zero_extend(inode, di_bh, zero_to);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_extend_no_holes(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t  u64 new_i_size, u64 zero_to)\n{\n\tint ret;\n\tu32 clusters_to_add;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t/*\n\t * Only quota files call this without a bh, and they can't be\n\t * refcounted.\n\t */\n\tBUG_ON(!di_bh && (oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\tBUG_ON(!di_bh && !(oi->ip_flags & OCFS2_INODE_SYSTEM_FILE));\n\n\tclusters_to_add = ocfs2_clusters_for_bytes(inode->i_sb, new_i_size);\n\tif (clusters_to_add < oi->ip_clusters)\n\t\tclusters_to_add = 0;\n\telse\n\t\tclusters_to_add -= oi->ip_clusters;\n\n\tif (clusters_to_add) {\n\t\tret = __ocfs2_extend_allocation(inode, oi->ip_clusters,\n\t\t\t\t\t\tclusters_to_add, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Call this even if we don't add any clusters to the tree. We\n\t * still need to zero the area between the old i_size and the\n\t * new i_size.\n\t */\n\tret = ocfs2_zero_extend(inode, di_bh, zero_to);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "gqinode"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "gqinode"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "journal_current_handle()"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_current_handle",
          "args": [],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_DQUOT",
          "args": [
            "dquot"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_DQUOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota.h",
          "lines": "71-74",
          "snippet": "static inline struct ocfs2_dquot *OCFS2_DQUOT(struct dquot *dquot)\n{\n\treturn container_of(dquot, struct ocfs2_dquot, dq_dquot);\n}",
          "includes": [
            "#include \"ocfs2.h\"",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/list.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2.h\"\n#include <linux/dqblk_qtree.h>\n#include <linux/list.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline struct ocfs2_dquot *OCFS2_DQUOT(struct dquot *dquot)\n{\n\treturn container_of(dquot, struct ocfs2_dquot, dq_dquot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qtree_read_dquot",
          "args": [
            "&info->dqi_gi",
            "dquot"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "qtree_read_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "592-651",
          "snippet": "int qtree_read_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tint type = dquot->dq_id.type;\n\tstruct super_block *sb = dquot->dq_sb;\n\tloff_t offset;\n\tchar *ddquot;\n\tint ret = 0;\n\n#ifdef __QUOTA_QT_PARANOIA\n\t/* Invalidated quota? */\n\tif (!sb_dqopt(dquot->dq_sb)->files[type]) {\n\t\tquota_error(sb, \"Quota invalidated while reading!\");\n\t\treturn -EIO;\n\t}\n#endif\n\t/* Do we know offset of the dquot entry in the quota file? */\n\tif (!dquot->dq_off) {\n\t\toffset = find_dqentry(info, dquot);\n\t\tif (offset <= 0) {\t/* Entry not present? */\n\t\t\tif (offset < 0)\n\t\t\t\tquota_error(sb,\"Can't read quota structure \"\n\t\t\t\t\t    \"for id %u\",\n\t\t\t\t\t    from_kqid(&init_user_ns,\n\t\t\t\t\t\t      dquot->dq_id));\n\t\t\tdquot->dq_off = 0;\n\t\t\tset_bit(DQ_FAKE_B, &dquot->dq_flags);\n\t\t\tmemset(&dquot->dq_dqb, 0, sizeof(struct mem_dqblk));\n\t\t\tret = offset;\n\t\t\tgoto out;\n\t\t}\n\t\tdquot->dq_off = offset;\n\t}\n\tddquot = getdqbuf(info->dqi_entry_size);\n\tif (!ddquot)\n\t\treturn -ENOMEM;\n\tret = sb->s_op->quota_read(sb, type, ddquot, info->dqi_entry_size,\n\t\t\t\t   dquot->dq_off);\n\tif (ret != info->dqi_entry_size) {\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tquota_error(sb, \"Error while reading quota structure for id %u\",\n\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));\n\t\tset_bit(DQ_FAKE_B, &dquot->dq_flags);\n\t\tmemset(&dquot->dq_dqb, 0, sizeof(struct mem_dqblk));\n\t\tkfree(ddquot);\n\t\tgoto out;\n\t}\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_ops->disk2mem_dqblk(dquot, ddquot);\n\tif (!dquot->dq_dqb.dqb_bhardlimit &&\n\t    !dquot->dq_dqb.dqb_bsoftlimit &&\n\t    !dquot->dq_dqb.dqb_ihardlimit &&\n\t    !dquot->dq_dqb.dqb_isoftlimit)\n\t\tset_bit(DQ_FAKE_B, &dquot->dq_flags);\n\tspin_unlock(&dq_data_lock);\n\tkfree(ddquot);\nout:\n\tdqstats_inc(DQST_READS);\n\treturn ret;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define __QUOTA_QT_PARANOIA"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\n#define __QUOTA_QT_PARANOIA\n\nint qtree_read_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tint type = dquot->dq_id.type;\n\tstruct super_block *sb = dquot->dq_sb;\n\tloff_t offset;\n\tchar *ddquot;\n\tint ret = 0;\n\n#ifdef __QUOTA_QT_PARANOIA\n\t/* Invalidated quota? */\n\tif (!sb_dqopt(dquot->dq_sb)->files[type]) {\n\t\tquota_error(sb, \"Quota invalidated while reading!\");\n\t\treturn -EIO;\n\t}\n#endif\n\t/* Do we know offset of the dquot entry in the quota file? */\n\tif (!dquot->dq_off) {\n\t\toffset = find_dqentry(info, dquot);\n\t\tif (offset <= 0) {\t/* Entry not present? */\n\t\t\tif (offset < 0)\n\t\t\t\tquota_error(sb,\"Can't read quota structure \"\n\t\t\t\t\t    \"for id %u\",\n\t\t\t\t\t    from_kqid(&init_user_ns,\n\t\t\t\t\t\t      dquot->dq_id));\n\t\t\tdquot->dq_off = 0;\n\t\t\tset_bit(DQ_FAKE_B, &dquot->dq_flags);\n\t\t\tmemset(&dquot->dq_dqb, 0, sizeof(struct mem_dqblk));\n\t\t\tret = offset;\n\t\t\tgoto out;\n\t\t}\n\t\tdquot->dq_off = offset;\n\t}\n\tddquot = getdqbuf(info->dqi_entry_size);\n\tif (!ddquot)\n\t\treturn -ENOMEM;\n\tret = sb->s_op->quota_read(sb, type, ddquot, info->dqi_entry_size,\n\t\t\t\t   dquot->dq_off);\n\tif (ret != info->dqi_entry_size) {\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tquota_error(sb, \"Error while reading quota structure for id %u\",\n\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));\n\t\tset_bit(DQ_FAKE_B, &dquot->dq_flags);\n\t\tmemset(&dquot->dq_dqb, 0, sizeof(struct mem_dqblk));\n\t\tkfree(ddquot);\n\t\tgoto out;\n\t}\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_ops->disk2mem_dqblk(dquot, ddquot);\n\tif (!dquot->dq_dqb.dqb_bhardlimit &&\n\t    !dquot->dq_dqb.dqb_bsoftlimit &&\n\t    !dquot->dq_dqb.dqb_ihardlimit &&\n\t    !dquot->dq_dqb.dqb_isoftlimit)\n\t\tset_bit(DQ_FAKE_B, &dquot->dq_flags);\n\tspin_unlock(&dq_data_lock);\n\tkfree(ddquot);\nout:\n\tdqstats_inc(DQST_READS);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_global_qf",
          "args": [
            "info",
            "1"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_global_qf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "296-317",
          "snippet": "int ocfs2_lock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\n\tstatus = ocfs2_inode_lock(oinfo->dqi_gqinode, &bh, ex);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&dq_data_lock);\n\tif (!oinfo->dqi_gqi_count++)\n\t\toinfo->dqi_gqi_bh = bh;\n\telse\n\t\tWARN_ON(bh != oinfo->dqi_gqi_bh);\n\tspin_unlock(&dq_data_lock);\n\tif (ex) {\n\t\tmutex_lock(&oinfo->dqi_gqinode->i_mutex);\n\t\tdown_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t} else {\n\t\tdown_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nint ocfs2_lock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\n\tstatus = ocfs2_inode_lock(oinfo->dqi_gqinode, &bh, ex);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&dq_data_lock);\n\tif (!oinfo->dqi_gqi_count++)\n\t\toinfo->dqi_gqi_bh = bh;\n\telse\n\t\tWARN_ON(bh != oinfo->dqi_gqi_bh);\n\tspin_unlock(&dq_data_lock);\n\tif (ex) {\n\t\tmutex_lock(&oinfo->dqi_gqinode->i_mutex);\n\t\tdown_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t} else {\n\t\tdown_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dquot->dq_lock"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_acquire_dquot",
          "args": [
            "from_kqid(&init_user_ns, dquot->dq_id)",
            "type"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kqid",
          "args": [
            "&init_user_ns",
            "dquot->dq_id"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "from_kqid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "100-112",
          "snippet": "qid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nqid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_global_qinit_alloc",
          "args": [
            "sb",
            "type"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_global_qinit_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "456-465",
          "snippet": "static int ocfs2_global_qinit_alloc(struct super_block *sb, int type)\n{\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\n\t/*\n\t * We may need to allocate tree blocks and a leaf block but not the\n\t * root block\n\t */\n\treturn oinfo->dqi_gi.dqi_qtree_depth;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic int ocfs2_global_qinit_alloc(struct super_block *sb, int type)\n{\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\n\t/*\n\t * We may need to allocate tree blocks and a leaf block but not the\n\t * root block\n\t */\n\treturn oinfo->dqi_gi.dqi_qtree_depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic int ocfs2_acquire_dquot(struct dquot *dquot)\n{\n\tint status = 0, err;\n\tint ex = 0;\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tint type = dquot->dq_id.type;\n\tstruct ocfs2_mem_dqinfo *info = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct inode *gqinode = info->dqi_gqinode;\n\tint need_alloc = ocfs2_global_qinit_alloc(sb, type);\n\thandle_t *handle;\n\n\ttrace_ocfs2_acquire_dquot(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t\t  type);\n\tmutex_lock(&dquot->dq_lock);\n\t/*\n\t * We need an exclusive lock, because we're going to update use count\n\t * and instantiate possibly new dquot structure\n\t */\n\tstatus = ocfs2_lock_global_qf(info, 1);\n\tif (status < 0)\n\t\tgoto out;\n\tstatus = ocfs2_qinfo_lock(info, 0);\n\tif (status < 0)\n\t\tgoto out_dq;\n\t/*\n\t * We always want to read dquot structure from disk because we don't\n\t * know what happened with it while it was on freelist.\n\t */\n\tstatus = qtree_read_dquot(&info->dqi_gi, dquot);\n\tocfs2_qinfo_unlock(info, 0);\n\tif (status < 0)\n\t\tgoto out_dq;\n\n\tOCFS2_DQUOT(dquot)->dq_use_count++;\n\tOCFS2_DQUOT(dquot)->dq_origspace = dquot->dq_dqb.dqb_curspace;\n\tOCFS2_DQUOT(dquot)->dq_originodes = dquot->dq_dqb.dqb_curinodes;\n\tif (!dquot->dq_off) {\t/* No real quota entry? */\n\t\tex = 1;\n\t\t/*\n\t\t * Add blocks to quota file before we start a transaction since\n\t\t * locking allocators ranks above a transaction start\n\t\t */\n\t\tWARN_ON(journal_current_handle());\n\t\tstatus = ocfs2_extend_no_holes(gqinode, NULL,\n\t\t\ti_size_read(gqinode) + (need_alloc << sb->s_blocksize_bits),\n\t\t\ti_size_read(gqinode));\n\t\tif (status < 0)\n\t\t\tgoto out_dq;\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\t\t   ocfs2_calc_global_qinit_credits(sb, type));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tgoto out_dq;\n\t}\n\tstatus = ocfs2_qinfo_lock(info, ex);\n\tif (status < 0)\n\t\tgoto out_trans;\n\tstatus = qtree_write_dquot(&info->dqi_gi, dquot);\n\tif (ex && info_dirty(sb_dqinfo(sb, type))) {\n\t\terr = __ocfs2_global_write_info(sb, type);\n\t\tif (!status)\n\t\t\tstatus = err;\n\t}\n\tocfs2_qinfo_unlock(info, ex);\nout_trans:\n\tocfs2_commit_trans(osb, handle);\nout_dq:\n\tocfs2_unlock_global_qf(info, 1);\n\tif (status < 0)\n\t\tgoto out;\n\n\tstatus = ocfs2_create_local_dquot(dquot);\n\tif (status < 0)\n\t\tgoto out;\n\tset_bit(DQ_ACTIVE_B, &dquot->dq_flags);\nout:\n\tmutex_unlock(&dquot->dq_lock);\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_release_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "704-771",
    "snippet": "static int ocfs2_release_dquot(struct dquot *dquot)\n{\n\thandle_t *handle;\n\tstruct ocfs2_mem_dqinfo *oinfo =\n\t\t\tsb_dqinfo(dquot->dq_sb, dquot->dq_id.type)->dqi_priv;\n\tstruct ocfs2_super *osb = OCFS2_SB(dquot->dq_sb);\n\tint status = 0;\n\n\ttrace_ocfs2_release_dquot(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t\t  dquot->dq_id.type);\n\n\tmutex_lock(&dquot->dq_lock);\n\t/* Check whether we are not racing with some other dqget() */\n\tif (atomic_read(&dquot->dq_count) > 1)\n\t\tgoto out;\n\t/* Running from downconvert thread? Postpone quota processing to wq */\n\tif (current == osb->dc_task) {\n\t\t/*\n\t\t * Grab our own reference to dquot and queue it for delayed\n\t\t * dropping.  Quota code rechecks after calling\n\t\t * ->release_dquot() and won't free dquot structure.\n\t\t */\n\t\tdqgrab(dquot);\n\t\t/* First entry on list -> queue work */\n\t\tif (llist_add(&OCFS2_DQUOT(dquot)->list, &osb->dquot_drop_list))\n\t\t\tqueue_work(ocfs2_wq, &osb->dquot_drop_work);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_lock_global_qf(oinfo, 1);\n\tif (status < 0)\n\t\tgoto out;\n\thandle = ocfs2_start_trans(osb,\n\t\tocfs2_calc_qdel_credits(dquot->dq_sb, dquot->dq_id.type));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_ilock;\n\t}\n\n\tstatus = ocfs2_global_release_dquot(dquot);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tstatus = ocfs2_local_release_dquot(handle, dquot);\n\t/*\n\t * If we fail here, we cannot do much as global structure is\n\t * already released. So just complain...\n\t */\n\tif (status < 0)\n\t\tmlog_errno(status);\n\t/*\n\t * Clear dq_off so that we search for the structure in quota file next\n\t * time we acquire it. The structure might be deleted and reallocated\n\t * elsewhere by another node while our dquot structure is on freelist.\n\t */\n\tdquot->dq_off = 0;\n\tclear_bit(DQ_ACTIVE_B, &dquot->dq_flags);\nout_trans:\n\tocfs2_commit_trans(osb, handle);\nout_ilock:\n\tocfs2_unlock_global_qf(oinfo, 1);\nout:\n\tmutex_unlock(&dquot->dq_lock);\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qsync_work_fn(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dquot->dq_lock"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_unlock_global_qf",
          "args": [
            "oinfo",
            "1"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_global_qf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "319-333",
          "snippet": "void ocfs2_unlock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tif (ex) {\n\t\tup_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t\tmutex_unlock(&oinfo->dqi_gqinode->i_mutex);\n\t} else {\n\t\tup_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\tocfs2_inode_unlock(oinfo->dqi_gqinode, ex);\n\tbrelse(oinfo->dqi_gqi_bh);\n\tspin_lock(&dq_data_lock);\n\tif (!--oinfo->dqi_gqi_count)\n\t\toinfo->dqi_gqi_bh = NULL;\n\tspin_unlock(&dq_data_lock);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nvoid ocfs2_unlock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tif (ex) {\n\t\tup_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t\tmutex_unlock(&oinfo->dqi_gqinode->i_mutex);\n\t} else {\n\t\tup_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\tocfs2_inode_unlock(oinfo->dqi_gqinode, ex);\n\tbrelse(oinfo->dqi_gqi_bh);\n\tspin_lock(&dq_data_lock);\n\tif (!--oinfo->dqi_gqi_count)\n\t\toinfo->dqi_gqi_bh = NULL;\n\tspin_unlock(&dq_data_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "DQ_ACTIVE_B",
            "&dquot->dq_flags"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_local_release_dquot",
          "args": [
            "handle",
            "dquot"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_release_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "1273-1302",
          "snippet": "int ocfs2_local_release_dquot(handle_t *handle, struct dquot *dquot)\n{\n\tint status;\n\tint type = dquot->dq_id.type;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint offset;\n\n\tstatus = ocfs2_journal_access_dq(handle,\n\t\t\tINODE_CACHE(sb_dqopt(sb)->files[type]),\n\t\t\tod->dq_chunk->qc_headerbh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\toffset = ol_dqblk_chunk_off(sb, od->dq_chunk->qc_num,\n\t\t\t\t\t     od->dq_local_off);\n\tdchunk = (struct ocfs2_local_disk_chunk *)\n\t\t\t(od->dq_chunk->qc_headerbh->b_data);\n\t/* Mark structure as freed */\n\tlock_buffer(od->dq_chunk->qc_headerbh);\n\tocfs2_clear_bit_unaligned(offset, dchunk->dqc_bitmap);\n\tle32_add_cpu(&dchunk->dqc_free, 1);\n\tunlock_buffer(od->dq_chunk->qc_headerbh);\n\tocfs2_journal_dirty(handle, od->dq_chunk->qc_headerbh);\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ocfs2_local_release_dquot(handle_t *handle, struct dquot *dquot)\n{\n\tint status;\n\tint type = dquot->dq_id.type;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint offset;\n\n\tstatus = ocfs2_journal_access_dq(handle,\n\t\t\tINODE_CACHE(sb_dqopt(sb)->files[type]),\n\t\t\tod->dq_chunk->qc_headerbh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\toffset = ol_dqblk_chunk_off(sb, od->dq_chunk->qc_num,\n\t\t\t\t\t     od->dq_local_off);\n\tdchunk = (struct ocfs2_local_disk_chunk *)\n\t\t\t(od->dq_chunk->qc_headerbh->b_data);\n\t/* Mark structure as freed */\n\tlock_buffer(od->dq_chunk->qc_headerbh);\n\tocfs2_clear_bit_unaligned(offset, dchunk->dqc_bitmap);\n\tle32_add_cpu(&dchunk->dqc_free, 1);\n\tunlock_buffer(od->dq_chunk->qc_headerbh);\n\tocfs2_journal_dirty(handle, od->dq_chunk->qc_headerbh);\n\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_global_release_dquot",
          "args": [
            "dquot"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_global_release_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota.h",
          "lines": "105-108",
          "snippet": "static inline int ocfs2_global_release_dquot(struct dquot *dquot)\n{\n\treturn __ocfs2_sync_dquot(dquot, 1);\n}",
          "includes": [
            "#include \"ocfs2.h\"",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/list.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2.h\"\n#include <linux/dqblk_qtree.h>\n#include <linux/list.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline int ocfs2_global_release_dquot(struct dquot *dquot)\n{\n\treturn __ocfs2_sync_dquot(dquot, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "ocfs2_calc_qdel_credits(dquot->dq_sb, dquot->dq_id.type)"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_qdel_credits",
          "args": [
            "dquot->dq_sb",
            "dquot->dq_id.type"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_qdel_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "669-681",
          "snippet": "static int ocfs2_calc_qdel_credits(struct super_block *sb, int type)\n{\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\t/*\n\t * We modify tree, leaf block, global info, local chunk header,\n\t * global and local inode; OCFS2_QINFO_WRITE_CREDITS already\n\t * accounts for inode update\n\t */\n\treturn (oinfo->dqi_gi.dqi_qtree_depth + 2) *\n\t       OCFS2_QUOTA_BLOCK_UPDATE_CREDITS +\n\t       OCFS2_QINFO_WRITE_CREDITS +\n\t       OCFS2_INODE_UPDATE_CREDITS;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic int ocfs2_calc_qdel_credits(struct super_block *sb, int type)\n{\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\t/*\n\t * We modify tree, leaf block, global info, local chunk header,\n\t * global and local inode; OCFS2_QINFO_WRITE_CREDITS already\n\t * accounts for inode update\n\t */\n\treturn (oinfo->dqi_gi.dqi_qtree_depth + 2) *\n\t       OCFS2_QUOTA_BLOCK_UPDATE_CREDITS +\n\t       OCFS2_QINFO_WRITE_CREDITS +\n\t       OCFS2_INODE_UPDATE_CREDITS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_global_qf",
          "args": [
            "oinfo",
            "1"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_global_qf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "296-317",
          "snippet": "int ocfs2_lock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\n\tstatus = ocfs2_inode_lock(oinfo->dqi_gqinode, &bh, ex);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&dq_data_lock);\n\tif (!oinfo->dqi_gqi_count++)\n\t\toinfo->dqi_gqi_bh = bh;\n\telse\n\t\tWARN_ON(bh != oinfo->dqi_gqi_bh);\n\tspin_unlock(&dq_data_lock);\n\tif (ex) {\n\t\tmutex_lock(&oinfo->dqi_gqinode->i_mutex);\n\t\tdown_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t} else {\n\t\tdown_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nint ocfs2_lock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\n\tstatus = ocfs2_inode_lock(oinfo->dqi_gqinode, &bh, ex);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&dq_data_lock);\n\tif (!oinfo->dqi_gqi_count++)\n\t\toinfo->dqi_gqi_bh = bh;\n\telse\n\t\tWARN_ON(bh != oinfo->dqi_gqi_bh);\n\tspin_unlock(&dq_data_lock);\n\tif (ex) {\n\t\tmutex_lock(&oinfo->dqi_gqinode->i_mutex);\n\t\tdown_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t} else {\n\t\tdown_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "ocfs2_wq",
            "&osb->dquot_drop_work"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_add",
          "args": [
            "&OCFS2_DQUOT(dquot)->list",
            "&osb->dquot_drop_list"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_DQUOT",
          "args": [
            "dquot"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_DQUOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota.h",
          "lines": "71-74",
          "snippet": "static inline struct ocfs2_dquot *OCFS2_DQUOT(struct dquot *dquot)\n{\n\treturn container_of(dquot, struct ocfs2_dquot, dq_dquot);\n}",
          "includes": [
            "#include \"ocfs2.h\"",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/list.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2.h\"\n#include <linux/dqblk_qtree.h>\n#include <linux/list.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline struct ocfs2_dquot *OCFS2_DQUOT(struct dquot *dquot)\n{\n\treturn container_of(dquot, struct ocfs2_dquot, dq_dquot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dqgrab",
          "args": [
            "dquot"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&dquot->dq_count"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dquot->dq_lock"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_release_dquot",
          "args": [
            "from_kqid(&init_user_ns, dquot->dq_id)",
            "dquot->dq_id.type"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kqid",
          "args": [
            "&init_user_ns",
            "dquot->dq_id"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "from_kqid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "100-112",
          "snippet": "qid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nqid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "dquot->dq_sb",
            "dquot->dq_id.type"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic void qsync_work_fn(struct work_struct *work);\n\nstatic int ocfs2_release_dquot(struct dquot *dquot)\n{\n\thandle_t *handle;\n\tstruct ocfs2_mem_dqinfo *oinfo =\n\t\t\tsb_dqinfo(dquot->dq_sb, dquot->dq_id.type)->dqi_priv;\n\tstruct ocfs2_super *osb = OCFS2_SB(dquot->dq_sb);\n\tint status = 0;\n\n\ttrace_ocfs2_release_dquot(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t\t  dquot->dq_id.type);\n\n\tmutex_lock(&dquot->dq_lock);\n\t/* Check whether we are not racing with some other dqget() */\n\tif (atomic_read(&dquot->dq_count) > 1)\n\t\tgoto out;\n\t/* Running from downconvert thread? Postpone quota processing to wq */\n\tif (current == osb->dc_task) {\n\t\t/*\n\t\t * Grab our own reference to dquot and queue it for delayed\n\t\t * dropping.  Quota code rechecks after calling\n\t\t * ->release_dquot() and won't free dquot structure.\n\t\t */\n\t\tdqgrab(dquot);\n\t\t/* First entry on list -> queue work */\n\t\tif (llist_add(&OCFS2_DQUOT(dquot)->list, &osb->dquot_drop_list))\n\t\t\tqueue_work(ocfs2_wq, &osb->dquot_drop_work);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_lock_global_qf(oinfo, 1);\n\tif (status < 0)\n\t\tgoto out;\n\thandle = ocfs2_start_trans(osb,\n\t\tocfs2_calc_qdel_credits(dquot->dq_sb, dquot->dq_id.type));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_ilock;\n\t}\n\n\tstatus = ocfs2_global_release_dquot(dquot);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tstatus = ocfs2_local_release_dquot(handle, dquot);\n\t/*\n\t * If we fail here, we cannot do much as global structure is\n\t * already released. So just complain...\n\t */\n\tif (status < 0)\n\t\tmlog_errno(status);\n\t/*\n\t * Clear dq_off so that we search for the structure in quota file next\n\t * time we acquire it. The structure might be deleted and reallocated\n\t * elsewhere by another node while our dquot structure is on freelist.\n\t */\n\tdquot->dq_off = 0;\n\tclear_bit(DQ_ACTIVE_B, &dquot->dq_flags);\nout_trans:\n\tocfs2_commit_trans(osb, handle);\nout_ilock:\n\tocfs2_unlock_global_qf(oinfo, 1);\nout:\n\tmutex_unlock(&dquot->dq_lock);\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_drop_dquot_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "683-695",
    "snippet": "void ocfs2_drop_dquot_refs(struct work_struct *work)\n{\n\tstruct ocfs2_super *osb = container_of(work, struct ocfs2_super,\n\t\t\t\t\t       dquot_drop_work);\n\tstruct llist_node *list;\n\tstruct ocfs2_dquot *odquot, *next_odquot;\n\n\tlist = llist_del_all(&osb->dquot_drop_list);\n\tllist_for_each_entry_safe(odquot, next_odquot, list, list) {\n\t\t/* Drop the reference we acquired in ocfs2_dquot_release() */\n\t\tdqput(&odquot->dq_dquot);\n\t}\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qsync_work_fn(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dqput",
          "args": [
            "&odquot->dq_dquot"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "dqput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "734-794",
          "snippet": "void dqput(struct dquot *dquot)\n{\n\tint ret;\n\n\tif (!dquot)\n\t\treturn;\n#ifdef CONFIG_QUOTA_DEBUG\n\tif (!atomic_read(&dquot->dq_count)) {\n\t\tquota_error(dquot->dq_sb, \"trying to free free dquot of %s %d\",\n\t\t\t    quotatypes[dquot->dq_id.type],\n\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));\n\t\tBUG();\n\t}\n#endif\n\tdqstats_inc(DQST_DROPS);\nwe_slept:\n\tspin_lock(&dq_list_lock);\n\tif (atomic_read(&dquot->dq_count) > 1) {\n\t\t/* We have more than one user... nothing to do */\n\t\tatomic_dec(&dquot->dq_count);\n\t\t/* Releasing dquot during quotaoff phase? */\n\t\tif (!sb_has_quota_active(dquot->dq_sb, dquot->dq_id.type) &&\n\t\t    atomic_read(&dquot->dq_count) == 1)\n\t\t\twake_up(&dquot->dq_wait_unused);\n\t\tspin_unlock(&dq_list_lock);\n\t\treturn;\n\t}\n\t/* Need to release dquot? */\n\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags) && dquot_dirty(dquot)) {\n\t\tspin_unlock(&dq_list_lock);\n\t\t/* Commit dquot before releasing */\n\t\tret = dquot->dq_sb->dq_op->write_dquot(dquot);\n\t\tif (ret < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't write quota structure\"\n\t\t\t\t    \" (error %d). Quota may get out of sync!\",\n\t\t\t\t    ret);\n\t\t\t/*\n\t\t\t * We clear dirty bit anyway, so that we avoid\n\t\t\t * infinite loop here\n\t\t\t */\n\t\t\tspin_lock(&dq_list_lock);\n\t\t\tclear_dquot_dirty(dquot);\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t}\n\t\tgoto we_slept;\n\t}\n\t/* Clear flag in case dquot was inactive (something bad happened) */\n\tclear_dquot_dirty(dquot);\n\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\n\t\tspin_unlock(&dq_list_lock);\n\t\tdquot->dq_sb->dq_op->release_dquot(dquot);\n\t\tgoto we_slept;\n\t}\n\tatomic_dec(&dquot->dq_count);\n#ifdef CONFIG_QUOTA_DEBUG\n\t/* sanity check */\n\tBUG_ON(!list_empty(&dquot->dq_free));\n#endif\n\tput_dquot_last(dquot);\n\tspin_unlock(&dq_list_lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nvoid dqput(struct dquot *dquot)\n{\n\tint ret;\n\n\tif (!dquot)\n\t\treturn;\n#ifdef CONFIG_QUOTA_DEBUG\n\tif (!atomic_read(&dquot->dq_count)) {\n\t\tquota_error(dquot->dq_sb, \"trying to free free dquot of %s %d\",\n\t\t\t    quotatypes[dquot->dq_id.type],\n\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));\n\t\tBUG();\n\t}\n#endif\n\tdqstats_inc(DQST_DROPS);\nwe_slept:\n\tspin_lock(&dq_list_lock);\n\tif (atomic_read(&dquot->dq_count) > 1) {\n\t\t/* We have more than one user... nothing to do */\n\t\tatomic_dec(&dquot->dq_count);\n\t\t/* Releasing dquot during quotaoff phase? */\n\t\tif (!sb_has_quota_active(dquot->dq_sb, dquot->dq_id.type) &&\n\t\t    atomic_read(&dquot->dq_count) == 1)\n\t\t\twake_up(&dquot->dq_wait_unused);\n\t\tspin_unlock(&dq_list_lock);\n\t\treturn;\n\t}\n\t/* Need to release dquot? */\n\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags) && dquot_dirty(dquot)) {\n\t\tspin_unlock(&dq_list_lock);\n\t\t/* Commit dquot before releasing */\n\t\tret = dquot->dq_sb->dq_op->write_dquot(dquot);\n\t\tif (ret < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't write quota structure\"\n\t\t\t\t    \" (error %d). Quota may get out of sync!\",\n\t\t\t\t    ret);\n\t\t\t/*\n\t\t\t * We clear dirty bit anyway, so that we avoid\n\t\t\t * infinite loop here\n\t\t\t */\n\t\t\tspin_lock(&dq_list_lock);\n\t\t\tclear_dquot_dirty(dquot);\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t}\n\t\tgoto we_slept;\n\t}\n\t/* Clear flag in case dquot was inactive (something bad happened) */\n\tclear_dquot_dirty(dquot);\n\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\n\t\tspin_unlock(&dq_list_lock);\n\t\tdquot->dq_sb->dq_op->release_dquot(dquot);\n\t\tgoto we_slept;\n\t}\n\tatomic_dec(&dquot->dq_count);\n#ifdef CONFIG_QUOTA_DEBUG\n\t/* sanity check */\n\tBUG_ON(!list_empty(&dquot->dq_free));\n#endif\n\tput_dquot_last(dquot);\n\tspin_unlock(&dq_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_for_each_entry_safe",
          "args": [
            "odquot",
            "next_odquot",
            "list",
            "list"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_del_all",
          "args": [
            "&osb->dquot_drop_list"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structocfs2_super",
            "dquot_drop_work"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic void qsync_work_fn(struct work_struct *work);\n\nvoid ocfs2_drop_dquot_refs(struct work_struct *work)\n{\n\tstruct ocfs2_super *osb = container_of(work, struct ocfs2_super,\n\t\t\t\t\t       dquot_drop_work);\n\tstruct llist_node *list;\n\tstruct ocfs2_dquot *odquot, *next_odquot;\n\n\tlist = llist_del_all(&osb->dquot_drop_list);\n\tllist_for_each_entry_safe(odquot, next_odquot, list, list) {\n\t\t/* Drop the reference we acquired in ocfs2_dquot_release() */\n\t\tdqput(&odquot->dq_dquot);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_calc_qdel_credits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "669-681",
    "snippet": "static int ocfs2_calc_qdel_credits(struct super_block *sb, int type)\n{\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\t/*\n\t * We modify tree, leaf block, global info, local chunk header,\n\t * global and local inode; OCFS2_QINFO_WRITE_CREDITS already\n\t * accounts for inode update\n\t */\n\treturn (oinfo->dqi_gi.dqi_qtree_depth + 2) *\n\t       OCFS2_QUOTA_BLOCK_UPDATE_CREDITS +\n\t       OCFS2_QINFO_WRITE_CREDITS +\n\t       OCFS2_INODE_UPDATE_CREDITS;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic int ocfs2_calc_qdel_credits(struct super_block *sb, int type)\n{\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\t/*\n\t * We modify tree, leaf block, global info, local chunk header,\n\t * global and local inode; OCFS2_QINFO_WRITE_CREDITS already\n\t * accounts for inode update\n\t */\n\treturn (oinfo->dqi_gi.dqi_qtree_depth + 2) *\n\t       OCFS2_QUOTA_BLOCK_UPDATE_CREDITS +\n\t       OCFS2_QINFO_WRITE_CREDITS +\n\t       OCFS2_INODE_UPDATE_CREDITS;\n}"
  },
  {
    "function_name": "ocfs2_write_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "646-667",
    "snippet": "static int ocfs2_write_dquot(struct dquot *dquot)\n{\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(dquot->dq_sb);\n\tint status = 0;\n\n\ttrace_ocfs2_write_dquot(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t\tdquot->dq_id.type);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_QWRITE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tmutex_lock(&sb_dqopt(dquot->dq_sb)->dqio_mutex);\n\tstatus = ocfs2_local_write_dquot(dquot);\n\tmutex_unlock(&sb_dqopt(dquot->dq_sb)->dqio_mutex);\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sb_dqopt(dquot->dq_sb)->dqio_mutex"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_local_write_dquot",
          "args": [
            "dquot"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_write_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "896-918",
          "snippet": "int ocfs2_local_write_dquot(struct dquot *dquot)\n{\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tstruct buffer_head *bh;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[dquot->dq_id.type];\n\tint status;\n\n\tstatus = ocfs2_read_quota_phys_block(lqinode, od->dq_local_phys_blk,\n\t\t\t\t\t     &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_modify_bh(lqinode, bh, olq_set_dquot, od);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\nout:\n\tbrelse(bh);\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ocfs2_local_write_dquot(struct dquot *dquot)\n{\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tstruct buffer_head *bh;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[dquot->dq_id.type];\n\tint status;\n\n\tstatus = ocfs2_read_quota_phys_block(lqinode, od->dq_local_phys_blk,\n\t\t\t\t\t     &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_modify_bh(lqinode, bh, olq_set_dquot, od);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\nout:\n\tbrelse(bh);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sb_dqopt(dquot->dq_sb)->dqio_mutex"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_QWRITE_CREDITS"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_write_dquot",
          "args": [
            "from_kqid(&init_user_ns, dquot->dq_id)",
            "dquot->dq_id.type"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kqid",
          "args": [
            "&init_user_ns",
            "dquot->dq_id"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "from_kqid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "100-112",
          "snippet": "qid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nqid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dquot->dq_sb"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic int ocfs2_write_dquot(struct dquot *dquot)\n{\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(dquot->dq_sb);\n\tint status = 0;\n\n\ttrace_ocfs2_write_dquot(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t\tdquot->dq_id.type);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_QWRITE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tmutex_lock(&sb_dqopt(dquot->dq_sb)->dqio_mutex);\n\tstatus = ocfs2_local_write_dquot(dquot);\n\tmutex_unlock(&sb_dqopt(dquot->dq_sb)->dqio_mutex);\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "qsync_work_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "630-640",
    "snippet": "static void qsync_work_fn(struct work_struct *work)\n{\n\tstruct ocfs2_mem_dqinfo *oinfo = container_of(work,\n\t\t\t\t\t\t      struct ocfs2_mem_dqinfo,\n\t\t\t\t\t\t      dqi_sync_work.work);\n\tstruct super_block *sb = oinfo->dqi_gqinode->i_sb;\n\n\tdquot_scan_active(sb, ocfs2_sync_dquot_helper, oinfo->dqi_type);\n\tschedule_delayed_work(&oinfo->dqi_sync_work,\n\t\t\t      msecs_to_jiffies(oinfo->dqi_syncms));\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qsync_work_fn(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&oinfo->dqi_sync_work",
            "msecs_to_jiffies(oinfo->dqi_syncms)"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "oinfo->dqi_syncms"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_scan_active",
          "args": [
            "sb",
            "ocfs2_sync_dquot_helper",
            "oinfo->dqi_type"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_scan_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "561-601",
          "snippet": "int dquot_scan_active(struct super_block *sb,\n\t\t      int (*fn)(struct dquot *dquot, unsigned long priv),\n\t\t      unsigned long priv)\n{\n\tstruct dquot *dquot, *old_dquot = NULL;\n\tint ret = 0;\n\n\tmutex_lock(&sb_dqopt(sb)->dqonoff_mutex);\n\tspin_lock(&dq_list_lock);\n\tlist_for_each_entry(dquot, &inuse_list, dq_inuse) {\n\t\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags))\n\t\t\tcontinue;\n\t\tif (dquot->dq_sb != sb)\n\t\t\tcontinue;\n\t\t/* Now we have active dquot so we can just increase use count */\n\t\tatomic_inc(&dquot->dq_count);\n\t\tspin_unlock(&dq_list_lock);\n\t\tdqstats_inc(DQST_LOOKUPS);\n\t\tdqput(old_dquot);\n\t\told_dquot = dquot;\n\t\t/*\n\t\t * ->release_dquot() can be racing with us. Our reference\n\t\t * protects us from new calls to it so just wait for any\n\t\t * outstanding call and recheck the DQ_ACTIVE_B after that.\n\t\t */\n\t\twait_on_dquot(dquot);\n\t\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\n\t\t\tret = fn(dquot, priv);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tspin_lock(&dq_list_lock);\n\t\t/* We are safe to continue now because our dquot could not\n\t\t * be moved out of the inuse list while we hold the reference */\n\t}\n\tspin_unlock(&dq_list_lock);\nout:\n\tdqput(old_dquot);\n\tmutex_unlock(&sb_dqopt(sb)->dqonoff_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);",
            "static LIST_HEAD(inuse_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic LIST_HEAD(inuse_list);\n\nint dquot_scan_active(struct super_block *sb,\n\t\t      int (*fn)(struct dquot *dquot, unsigned long priv),\n\t\t      unsigned long priv)\n{\n\tstruct dquot *dquot, *old_dquot = NULL;\n\tint ret = 0;\n\n\tmutex_lock(&sb_dqopt(sb)->dqonoff_mutex);\n\tspin_lock(&dq_list_lock);\n\tlist_for_each_entry(dquot, &inuse_list, dq_inuse) {\n\t\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags))\n\t\t\tcontinue;\n\t\tif (dquot->dq_sb != sb)\n\t\t\tcontinue;\n\t\t/* Now we have active dquot so we can just increase use count */\n\t\tatomic_inc(&dquot->dq_count);\n\t\tspin_unlock(&dq_list_lock);\n\t\tdqstats_inc(DQST_LOOKUPS);\n\t\tdqput(old_dquot);\n\t\told_dquot = dquot;\n\t\t/*\n\t\t * ->release_dquot() can be racing with us. Our reference\n\t\t * protects us from new calls to it so just wait for any\n\t\t * outstanding call and recheck the DQ_ACTIVE_B after that.\n\t\t */\n\t\twait_on_dquot(dquot);\n\t\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\n\t\t\tret = fn(dquot, priv);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tspin_lock(&dq_list_lock);\n\t\t/* We are safe to continue now because our dquot could not\n\t\t * be moved out of the inuse list while we hold the reference */\n\t}\n\tspin_unlock(&dq_list_lock);\nout:\n\tdqput(old_dquot);\n\tmutex_unlock(&sb_dqopt(sb)->dqonoff_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structocfs2_mem_dqinfo",
            "dqi_sync_work.work"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic void qsync_work_fn(struct work_struct *work);\n\nstatic void qsync_work_fn(struct work_struct *work)\n{\n\tstruct ocfs2_mem_dqinfo *oinfo = container_of(work,\n\t\t\t\t\t\t      struct ocfs2_mem_dqinfo,\n\t\t\t\t\t\t      dqi_sync_work.work);\n\tstruct super_block *sb = oinfo->dqi_gqinode->i_sb;\n\n\tdquot_scan_active(sb, ocfs2_sync_dquot_helper, oinfo->dqi_type);\n\tschedule_delayed_work(&oinfo->dqi_sync_work,\n\t\t\t      msecs_to_jiffies(oinfo->dqi_syncms));\n}"
  },
  {
    "function_name": "ocfs2_sync_dquot_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "591-628",
    "snippet": "static int ocfs2_sync_dquot_helper(struct dquot *dquot, unsigned long type)\n{\n\thandle_t *handle;\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tint status = 0;\n\n\ttrace_ocfs2_sync_dquot_helper(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t\t      dquot->dq_id.type,\n\t\t\t\t      type, sb->s_id);\n\tif (type != dquot->dq_id.type)\n\t\tgoto out;\n\tstatus = ocfs2_lock_global_qf(oinfo, 1);\n\tif (status < 0)\n\t\tgoto out;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_QSYNC_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_ilock;\n\t}\n\tmutex_lock(&sb_dqopt(sb)->dqio_mutex);\n\tstatus = ocfs2_sync_dquot(dquot);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\t/* We have to write local structure as well... */\n\tstatus = ocfs2_local_write_dquot(dquot);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\tmutex_unlock(&sb_dqopt(sb)->dqio_mutex);\n\tocfs2_commit_trans(osb, handle);\nout_ilock:\n\tocfs2_unlock_global_qf(oinfo, 1);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_unlock_global_qf",
          "args": [
            "oinfo",
            "1"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_global_qf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "319-333",
          "snippet": "void ocfs2_unlock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tif (ex) {\n\t\tup_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t\tmutex_unlock(&oinfo->dqi_gqinode->i_mutex);\n\t} else {\n\t\tup_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\tocfs2_inode_unlock(oinfo->dqi_gqinode, ex);\n\tbrelse(oinfo->dqi_gqi_bh);\n\tspin_lock(&dq_data_lock);\n\tif (!--oinfo->dqi_gqi_count)\n\t\toinfo->dqi_gqi_bh = NULL;\n\tspin_unlock(&dq_data_lock);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nvoid ocfs2_unlock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tif (ex) {\n\t\tup_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t\tmutex_unlock(&oinfo->dqi_gqinode->i_mutex);\n\t} else {\n\t\tup_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\tocfs2_inode_unlock(oinfo->dqi_gqinode, ex);\n\tbrelse(oinfo->dqi_gqi_bh);\n\tspin_lock(&dq_data_lock);\n\tif (!--oinfo->dqi_gqi_count)\n\t\toinfo->dqi_gqi_bh = NULL;\n\tspin_unlock(&dq_data_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sb_dqopt(sb)->dqio_mutex"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_local_write_dquot",
          "args": [
            "dquot"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_write_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "896-918",
          "snippet": "int ocfs2_local_write_dquot(struct dquot *dquot)\n{\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tstruct buffer_head *bh;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[dquot->dq_id.type];\n\tint status;\n\n\tstatus = ocfs2_read_quota_phys_block(lqinode, od->dq_local_phys_blk,\n\t\t\t\t\t     &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_modify_bh(lqinode, bh, olq_set_dquot, od);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\nout:\n\tbrelse(bh);\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ocfs2_local_write_dquot(struct dquot *dquot)\n{\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tstruct buffer_head *bh;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[dquot->dq_id.type];\n\tint status;\n\n\tstatus = ocfs2_read_quota_phys_block(lqinode, od->dq_local_phys_blk,\n\t\t\t\t\t     &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_modify_bh(lqinode, bh, olq_set_dquot, od);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\nout:\n\tbrelse(bh);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_sync_dquot",
          "args": [
            "dquot"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sync_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota.h",
          "lines": "101-104",
          "snippet": "static inline int ocfs2_sync_dquot(struct dquot *dquot)\n{\n\treturn __ocfs2_sync_dquot(dquot, 0);\n}",
          "includes": [
            "#include \"ocfs2.h\"",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/list.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2.h\"\n#include <linux/dqblk_qtree.h>\n#include <linux/list.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline int ocfs2_sync_dquot(struct dquot *dquot)\n{\n\treturn __ocfs2_sync_dquot(dquot, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sb_dqopt(sb)->dqio_mutex"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_QSYNC_CREDITS"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_global_qf",
          "args": [
            "oinfo",
            "1"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_global_qf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "296-317",
          "snippet": "int ocfs2_lock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\n\tstatus = ocfs2_inode_lock(oinfo->dqi_gqinode, &bh, ex);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&dq_data_lock);\n\tif (!oinfo->dqi_gqi_count++)\n\t\toinfo->dqi_gqi_bh = bh;\n\telse\n\t\tWARN_ON(bh != oinfo->dqi_gqi_bh);\n\tspin_unlock(&dq_data_lock);\n\tif (ex) {\n\t\tmutex_lock(&oinfo->dqi_gqinode->i_mutex);\n\t\tdown_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t} else {\n\t\tdown_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nint ocfs2_lock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\n\tstatus = ocfs2_inode_lock(oinfo->dqi_gqinode, &bh, ex);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&dq_data_lock);\n\tif (!oinfo->dqi_gqi_count++)\n\t\toinfo->dqi_gqi_bh = bh;\n\telse\n\t\tWARN_ON(bh != oinfo->dqi_gqi_bh);\n\tspin_unlock(&dq_data_lock);\n\tif (ex) {\n\t\tmutex_lock(&oinfo->dqi_gqinode->i_mutex);\n\t\tdown_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t} else {\n\t\tdown_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_sync_dquot_helper",
          "args": [
            "from_kqid(&init_user_ns, dquot->dq_id)",
            "dquot->dq_id.type",
            "type",
            "sb->s_id"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kqid",
          "args": [
            "&init_user_ns",
            "dquot->dq_id"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "from_kqid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "100-112",
          "snippet": "qid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nqid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic int ocfs2_sync_dquot_helper(struct dquot *dquot, unsigned long type)\n{\n\thandle_t *handle;\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tint status = 0;\n\n\ttrace_ocfs2_sync_dquot_helper(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t\t      dquot->dq_id.type,\n\t\t\t\t      type, sb->s_id);\n\tif (type != dquot->dq_id.type)\n\t\tgoto out;\n\tstatus = ocfs2_lock_global_qf(oinfo, 1);\n\tif (status < 0)\n\t\tgoto out;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_QSYNC_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_ilock;\n\t}\n\tmutex_lock(&sb_dqopt(sb)->dqio_mutex);\n\tstatus = ocfs2_sync_dquot(dquot);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\t/* We have to write local structure as well... */\n\tstatus = ocfs2_local_write_dquot(dquot);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\tmutex_unlock(&sb_dqopt(sb)->dqio_mutex);\n\tocfs2_commit_trans(osb, handle);\nout_ilock:\n\tocfs2_unlock_global_qf(oinfo, 1);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "__ocfs2_sync_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "478-586",
    "snippet": "int __ocfs2_sync_dquot(struct dquot *dquot, int freeing)\n{\n\tint err, err2;\n\tstruct super_block *sb = dquot->dq_sb;\n\tint type = dquot->dq_id.type;\n\tstruct ocfs2_mem_dqinfo *info = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct ocfs2_global_disk_dqblk dqblk;\n\ts64 spacechange, inodechange;\n\ttime_t olditime, oldbtime;\n\n\terr = sb->s_op->quota_read(sb, type, (char *)&dqblk,\n\t\t\t\t   sizeof(struct ocfs2_global_disk_dqblk),\n\t\t\t\t   dquot->dq_off);\n\tif (err != sizeof(struct ocfs2_global_disk_dqblk)) {\n\t\tif (err >= 0) {\n\t\t\tmlog(ML_ERROR, \"Short read from global quota file \"\n\t\t\t\t       \"(%u read)\\n\", err);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Update space and inode usage. Get also other information from\n\t * global quota file so that we don't overwrite any changes there.\n\t * We are */\n\tspin_lock(&dq_data_lock);\n\tspacechange = dquot->dq_dqb.dqb_curspace -\n\t\t\t\t\tOCFS2_DQUOT(dquot)->dq_origspace;\n\tinodechange = dquot->dq_dqb.dqb_curinodes -\n\t\t\t\t\tOCFS2_DQUOT(dquot)->dq_originodes;\n\tolditime = dquot->dq_dqb.dqb_itime;\n\toldbtime = dquot->dq_dqb.dqb_btime;\n\tocfs2_global_disk2memdqb(dquot, &dqblk);\n\ttrace_ocfs2_sync_dquot(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t       dquot->dq_dqb.dqb_curspace,\n\t\t\t       (long long)spacechange,\n\t\t\t       dquot->dq_dqb.dqb_curinodes,\n\t\t\t       (long long)inodechange);\n\tif (!test_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags))\n\t\tdquot->dq_dqb.dqb_curspace += spacechange;\n\tif (!test_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags))\n\t\tdquot->dq_dqb.dqb_curinodes += inodechange;\n\t/* Set properly space grace time... */\n\tif (dquot->dq_dqb.dqb_bsoftlimit &&\n\t    dquot->dq_dqb.dqb_curspace > dquot->dq_dqb.dqb_bsoftlimit) {\n\t\tif (!test_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags) &&\n\t\t    oldbtime > 0) {\n\t\t\tif (dquot->dq_dqb.dqb_btime > 0)\n\t\t\t\tdquot->dq_dqb.dqb_btime =\n\t\t\t\t\tmin(dquot->dq_dqb.dqb_btime, oldbtime);\n\t\t\telse\n\t\t\t\tdquot->dq_dqb.dqb_btime = oldbtime;\n\t\t}\n\t} else {\n\t\tdquot->dq_dqb.dqb_btime = 0;\n\t\tclear_bit(DQ_BLKS_B, &dquot->dq_flags);\n\t}\n\t/* Set properly inode grace time... */\n\tif (dquot->dq_dqb.dqb_isoftlimit &&\n\t    dquot->dq_dqb.dqb_curinodes > dquot->dq_dqb.dqb_isoftlimit) {\n\t\tif (!test_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags) &&\n\t\t    olditime > 0) {\n\t\t\tif (dquot->dq_dqb.dqb_itime > 0)\n\t\t\t\tdquot->dq_dqb.dqb_itime =\n\t\t\t\t\tmin(dquot->dq_dqb.dqb_itime, olditime);\n\t\t\telse\n\t\t\t\tdquot->dq_dqb.dqb_itime = olditime;\n\t\t}\n\t} else {\n\t\tdquot->dq_dqb.dqb_itime = 0;\n\t\tclear_bit(DQ_INODES_B, &dquot->dq_flags);\n\t}\n\t/* All information is properly updated, clear the flags */\n\t__clear_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_BLIMITS_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_ILIMITS_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags);\n\tOCFS2_DQUOT(dquot)->dq_origspace = dquot->dq_dqb.dqb_curspace;\n\tOCFS2_DQUOT(dquot)->dq_originodes = dquot->dq_dqb.dqb_curinodes;\n\tspin_unlock(&dq_data_lock);\n\terr = ocfs2_qinfo_lock(info, freeing);\n\tif (err < 0) {\n\t\tmlog(ML_ERROR, \"Failed to lock quota info, losing quota write\"\n\t\t\t       \" (type=%d, id=%u)\\n\", dquot->dq_id.type,\n\t\t\t       (unsigned)from_kqid(&init_user_ns, dquot->dq_id));\n\t\tgoto out;\n\t}\n\tif (freeing)\n\t\tOCFS2_DQUOT(dquot)->dq_use_count--;\n\terr = qtree_write_dquot(&info->dqi_gi, dquot);\n\tif (err < 0)\n\t\tgoto out_qlock;\n\tif (freeing && !OCFS2_DQUOT(dquot)->dq_use_count) {\n\t\terr = qtree_release_dquot(&info->dqi_gi, dquot);\n\t\tif (info_dirty(sb_dqinfo(sb, type))) {\n\t\t\terr2 = __ocfs2_global_write_info(sb, type);\n\t\t\tif (!err)\n\t\t\t\terr = err2;\n\t\t}\n\t}\nout_qlock:\n\tocfs2_qinfo_unlock(info, freeing);\nout:\n\tif (err < 0)\n\t\tmlog_errno(err);\n\treturn err;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "err"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_qinfo_unlock",
          "args": [
            "info",
            "freeing"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_qinfo_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3820-3828",
          "snippet": "void ocfs2_qinfo_unlock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_qinfo_unlock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_global_write_info",
          "args": [
            "sb",
            "type"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_global_write_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "415-441",
          "snippet": "static int __ocfs2_global_write_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_global_disk_dqinfo dinfo;\n\tssize_t size;\n\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_flags &= ~DQF_INFO_DIRTY;\n\tdinfo.dqi_bgrace = cpu_to_le32(info->dqi_bgrace);\n\tdinfo.dqi_igrace = cpu_to_le32(info->dqi_igrace);\n\tspin_unlock(&dq_data_lock);\n\tdinfo.dqi_syncms = cpu_to_le32(oinfo->dqi_syncms);\n\tdinfo.dqi_blocks = cpu_to_le32(oinfo->dqi_gi.dqi_blocks);\n\tdinfo.dqi_free_blk = cpu_to_le32(oinfo->dqi_gi.dqi_free_blk);\n\tdinfo.dqi_free_entry = cpu_to_le32(oinfo->dqi_gi.dqi_free_entry);\n\tsize = sb->s_op->quota_write(sb, type, (char *)&dinfo,\n\t\t\t\t     sizeof(struct ocfs2_global_disk_dqinfo),\n\t\t\t\t     OCFS2_GLOBAL_INFO_OFF);\n\tif (size != sizeof(struct ocfs2_global_disk_dqinfo)) {\n\t\tmlog(ML_ERROR, \"Cannot write global quota info structure\\n\");\n\t\tif (size >= 0)\n\t\t\tsize = -EIO;\n\t\treturn size;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic int __ocfs2_global_write_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_global_disk_dqinfo dinfo;\n\tssize_t size;\n\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_flags &= ~DQF_INFO_DIRTY;\n\tdinfo.dqi_bgrace = cpu_to_le32(info->dqi_bgrace);\n\tdinfo.dqi_igrace = cpu_to_le32(info->dqi_igrace);\n\tspin_unlock(&dq_data_lock);\n\tdinfo.dqi_syncms = cpu_to_le32(oinfo->dqi_syncms);\n\tdinfo.dqi_blocks = cpu_to_le32(oinfo->dqi_gi.dqi_blocks);\n\tdinfo.dqi_free_blk = cpu_to_le32(oinfo->dqi_gi.dqi_free_blk);\n\tdinfo.dqi_free_entry = cpu_to_le32(oinfo->dqi_gi.dqi_free_entry);\n\tsize = sb->s_op->quota_write(sb, type, (char *)&dinfo,\n\t\t\t\t     sizeof(struct ocfs2_global_disk_dqinfo),\n\t\t\t\t     OCFS2_GLOBAL_INFO_OFF);\n\tif (size != sizeof(struct ocfs2_global_disk_dqinfo)) {\n\t\tmlog(ML_ERROR, \"Cannot write global quota info structure\\n\");\n\t\tif (size >= 0)\n\t\t\tsize = -EIO;\n\t\treturn size;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "info_dirty",
          "args": [
            "sb_dqinfo(sb, type)"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "mark_fsinfo_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "311-319",
          "snippet": "static void mark_fsinfo_dirty(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tif (sb->s_flags & MS_RDONLY || sbi->fat_bits != 32)\n\t\treturn;\n\n\t__mark_inode_dirty(sbi->fsinfo_inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void mark_fsinfo_dirty(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tif (sb->s_flags & MS_RDONLY || sbi->fat_bits != 32)\n\t\treturn;\n\n\t__mark_inode_dirty(sbi->fsinfo_inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qtree_release_dquot",
          "args": [
            "&info->dqi_gi",
            "dquot"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "qtree_release_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "656-662",
          "snippet": "int qtree_release_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tif (test_bit(DQ_FAKE_B, &dquot->dq_flags) &&\n\t    !(dquot->dq_dqb.dqb_curinodes | dquot->dq_dqb.dqb_curspace))\n\t\treturn qtree_delete_dquot(info, dquot);\n\treturn 0;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint qtree_release_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tif (test_bit(DQ_FAKE_B, &dquot->dq_flags) &&\n\t    !(dquot->dq_dqb.dqb_curinodes | dquot->dq_dqb.dqb_curspace))\n\t\treturn qtree_delete_dquot(info, dquot);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_DQUOT",
          "args": [
            "dquot"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_DQUOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota.h",
          "lines": "71-74",
          "snippet": "static inline struct ocfs2_dquot *OCFS2_DQUOT(struct dquot *dquot)\n{\n\treturn container_of(dquot, struct ocfs2_dquot, dq_dquot);\n}",
          "includes": [
            "#include \"ocfs2.h\"",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/list.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2.h\"\n#include <linux/dqblk_qtree.h>\n#include <linux/list.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline struct ocfs2_dquot *OCFS2_DQUOT(struct dquot *dquot)\n{\n\treturn container_of(dquot, struct ocfs2_dquot, dq_dquot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qtree_write_dquot",
          "args": [
            "&info->dqi_gi",
            "dquot"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "qtree_write_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "359-395",
          "snippet": "int qtree_write_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tint type = dquot->dq_id.type;\n\tstruct super_block *sb = dquot->dq_sb;\n\tssize_t ret;\n\tchar *ddquot = getdqbuf(info->dqi_entry_size);\n\n\tif (!ddquot)\n\t\treturn -ENOMEM;\n\n\t/* dq_off is guarded by dqio_mutex */\n\tif (!dquot->dq_off) {\n\t\tret = dq_insert_tree(info, dquot);\n\t\tif (ret < 0) {\n\t\t\tquota_error(sb, \"Error %zd occurred while creating \"\n\t\t\t\t    \"quota\", ret);\n\t\t\tkfree(ddquot);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_ops->mem2disk_dqblk(ddquot, dquot);\n\tspin_unlock(&dq_data_lock);\n\tret = sb->s_op->quota_write(sb, type, ddquot, info->dqi_entry_size,\n\t\t\t\t    dquot->dq_off);\n\tif (ret != info->dqi_entry_size) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOSPC;\n\t} else {\n\t\tret = 0;\n\t}\n\tdqstats_inc(DQST_WRITES);\n\tkfree(ddquot);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint qtree_write_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)\n{\n\tint type = dquot->dq_id.type;\n\tstruct super_block *sb = dquot->dq_sb;\n\tssize_t ret;\n\tchar *ddquot = getdqbuf(info->dqi_entry_size);\n\n\tif (!ddquot)\n\t\treturn -ENOMEM;\n\n\t/* dq_off is guarded by dqio_mutex */\n\tif (!dquot->dq_off) {\n\t\tret = dq_insert_tree(info, dquot);\n\t\tif (ret < 0) {\n\t\t\tquota_error(sb, \"Error %zd occurred while creating \"\n\t\t\t\t    \"quota\", ret);\n\t\t\tkfree(ddquot);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_ops->mem2disk_dqblk(ddquot, dquot);\n\tspin_unlock(&dq_data_lock);\n\tret = sb->s_op->quota_write(sb, type, ddquot, info->dqi_entry_size,\n\t\t\t\t    dquot->dq_off);\n\tif (ret != info->dqi_entry_size) {\n\t\tquota_error(sb, \"dquota write failed\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOSPC;\n\t} else {\n\t\tret = 0;\n\t}\n\tdqstats_inc(DQST_WRITES);\n\tkfree(ddquot);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Failed to lock quota info, losing quota write\"\n\t\t\t       \" (type=%d, id=%u)\\n\"",
            "dquot->dq_id.type",
            "(unsigned)from_kqid(&init_user_ns, dquot->dq_id)"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kqid",
          "args": [
            "&init_user_ns",
            "dquot->dq_id"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "from_kqid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "100-112",
          "snippet": "qid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nqid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_qinfo_lock",
          "args": [
            "info",
            "freeing"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_qinfo_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3875-3905",
          "snippet": "int ocfs2_qinfo_lock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tint status = 0;\n\n\t/* On RO devices, locking really isn't needed... */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (ex)\n\t\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (!ocfs2_should_refresh_lock_res(lockres))\n\t\tgoto bail;\n\t/* OK, we have the lock but we need to refresh the quota info */\n\tstatus = ocfs2_refresh_qinfo(oinfo);\n\tif (status)\n\t\tocfs2_qinfo_unlock(oinfo, ex);\n\tocfs2_complete_lock_res_refresh(lockres, status);\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_qinfo_lock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tint status = 0;\n\n\t/* On RO devices, locking really isn't needed... */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (ex)\n\t\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (!ocfs2_should_refresh_lock_res(lockres))\n\t\tgoto bail;\n\t/* OK, we have the lock but we need to refresh the quota info */\n\tstatus = ocfs2_refresh_qinfo(oinfo);\n\tif (status)\n\t\tocfs2_qinfo_unlock(oinfo, ex);\n\tocfs2_complete_lock_res_refresh(lockres, status);\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "DQ_LASTSET_B + QIF_ITIME_B",
            "&dquot->dq_flags"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "DQ_LASTSET_B + QIF_BTIME_B",
            "&dquot->dq_flags"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "DQ_LASTSET_B + QIF_ILIMITS_B",
            "&dquot->dq_flags"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "DQ_LASTSET_B + QIF_BLIMITS_B",
            "&dquot->dq_flags"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "DQ_LASTSET_B + QIF_INODES_B",
            "&dquot->dq_flags"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "DQ_LASTSET_B + QIF_SPACE_B",
            "&dquot->dq_flags"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "DQ_INODES_B",
            "&dquot->dq_flags"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "dquot->dq_dqb.dqb_itime",
            "olditime"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_hamming_encode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "154-157",
          "snippet": "u32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\n{\n\treturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nu32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\n{\n\treturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "DQ_LASTSET_B + QIF_ITIME_B",
            "&dquot->dq_flags"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_sync_dquot",
          "args": [
            "from_kqid(&init_user_ns, dquot->dq_id)",
            "dquot->dq_dqb.dqb_curspace",
            "(long long)spacechange",
            "dquot->dq_dqb.dqb_curinodes",
            "(long long)inodechange"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_global_disk2memdqb",
          "args": [
            "dquot",
            "&dqblk"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_global_disk2memdqb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "69-92",
          "snippet": "static void ocfs2_global_disk2memdqb(struct dquot *dquot, void *dp)\n{\n\tstruct ocfs2_global_disk_dqblk *d = dp;\n\tstruct mem_dqblk *m = &dquot->dq_dqb;\n\n\t/* Update from disk only entries not set by the admin */\n\tif (!test_bit(DQ_LASTSET_B + QIF_ILIMITS_B, &dquot->dq_flags)) {\n\t\tm->dqb_ihardlimit = le64_to_cpu(d->dqb_ihardlimit);\n\t\tm->dqb_isoftlimit = le64_to_cpu(d->dqb_isoftlimit);\n\t}\n\tif (!test_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags))\n\t\tm->dqb_curinodes = le64_to_cpu(d->dqb_curinodes);\n\tif (!test_bit(DQ_LASTSET_B + QIF_BLIMITS_B, &dquot->dq_flags)) {\n\t\tm->dqb_bhardlimit = le64_to_cpu(d->dqb_bhardlimit);\n\t\tm->dqb_bsoftlimit = le64_to_cpu(d->dqb_bsoftlimit);\n\t}\n\tif (!test_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags))\n\t\tm->dqb_curspace = le64_to_cpu(d->dqb_curspace);\n\tif (!test_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags))\n\t\tm->dqb_btime = le64_to_cpu(d->dqb_btime);\n\tif (!test_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags))\n\t\tm->dqb_itime = le64_to_cpu(d->dqb_itime);\n\tOCFS2_DQUOT(dquot)->dq_use_count = le32_to_cpu(d->dqb_use_count);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic void ocfs2_global_disk2memdqb(struct dquot *dquot, void *dp)\n{\n\tstruct ocfs2_global_disk_dqblk *d = dp;\n\tstruct mem_dqblk *m = &dquot->dq_dqb;\n\n\t/* Update from disk only entries not set by the admin */\n\tif (!test_bit(DQ_LASTSET_B + QIF_ILIMITS_B, &dquot->dq_flags)) {\n\t\tm->dqb_ihardlimit = le64_to_cpu(d->dqb_ihardlimit);\n\t\tm->dqb_isoftlimit = le64_to_cpu(d->dqb_isoftlimit);\n\t}\n\tif (!test_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags))\n\t\tm->dqb_curinodes = le64_to_cpu(d->dqb_curinodes);\n\tif (!test_bit(DQ_LASTSET_B + QIF_BLIMITS_B, &dquot->dq_flags)) {\n\t\tm->dqb_bhardlimit = le64_to_cpu(d->dqb_bhardlimit);\n\t\tm->dqb_bsoftlimit = le64_to_cpu(d->dqb_bsoftlimit);\n\t}\n\tif (!test_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags))\n\t\tm->dqb_curspace = le64_to_cpu(d->dqb_curspace);\n\tif (!test_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags))\n\t\tm->dqb_btime = le64_to_cpu(d->dqb_btime);\n\tif (!test_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags))\n\t\tm->dqb_itime = le64_to_cpu(d->dqb_itime);\n\tOCFS2_DQUOT(dquot)->dq_use_count = le32_to_cpu(d->dqb_use_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Short read from global quota file \"\n\t\t\t\t       \"(%u read)\\n\"",
            "err"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->quota_read",
          "args": [
            "sb",
            "type",
            "(char *)&dqblk",
            "sizeof(struct ocfs2_global_disk_dqblk)",
            "dquot->dq_off"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nint __ocfs2_sync_dquot(struct dquot *dquot, int freeing)\n{\n\tint err, err2;\n\tstruct super_block *sb = dquot->dq_sb;\n\tint type = dquot->dq_id.type;\n\tstruct ocfs2_mem_dqinfo *info = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct ocfs2_global_disk_dqblk dqblk;\n\ts64 spacechange, inodechange;\n\ttime_t olditime, oldbtime;\n\n\terr = sb->s_op->quota_read(sb, type, (char *)&dqblk,\n\t\t\t\t   sizeof(struct ocfs2_global_disk_dqblk),\n\t\t\t\t   dquot->dq_off);\n\tif (err != sizeof(struct ocfs2_global_disk_dqblk)) {\n\t\tif (err >= 0) {\n\t\t\tmlog(ML_ERROR, \"Short read from global quota file \"\n\t\t\t\t       \"(%u read)\\n\", err);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Update space and inode usage. Get also other information from\n\t * global quota file so that we don't overwrite any changes there.\n\t * We are */\n\tspin_lock(&dq_data_lock);\n\tspacechange = dquot->dq_dqb.dqb_curspace -\n\t\t\t\t\tOCFS2_DQUOT(dquot)->dq_origspace;\n\tinodechange = dquot->dq_dqb.dqb_curinodes -\n\t\t\t\t\tOCFS2_DQUOT(dquot)->dq_originodes;\n\tolditime = dquot->dq_dqb.dqb_itime;\n\toldbtime = dquot->dq_dqb.dqb_btime;\n\tocfs2_global_disk2memdqb(dquot, &dqblk);\n\ttrace_ocfs2_sync_dquot(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t       dquot->dq_dqb.dqb_curspace,\n\t\t\t       (long long)spacechange,\n\t\t\t       dquot->dq_dqb.dqb_curinodes,\n\t\t\t       (long long)inodechange);\n\tif (!test_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags))\n\t\tdquot->dq_dqb.dqb_curspace += spacechange;\n\tif (!test_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags))\n\t\tdquot->dq_dqb.dqb_curinodes += inodechange;\n\t/* Set properly space grace time... */\n\tif (dquot->dq_dqb.dqb_bsoftlimit &&\n\t    dquot->dq_dqb.dqb_curspace > dquot->dq_dqb.dqb_bsoftlimit) {\n\t\tif (!test_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags) &&\n\t\t    oldbtime > 0) {\n\t\t\tif (dquot->dq_dqb.dqb_btime > 0)\n\t\t\t\tdquot->dq_dqb.dqb_btime =\n\t\t\t\t\tmin(dquot->dq_dqb.dqb_btime, oldbtime);\n\t\t\telse\n\t\t\t\tdquot->dq_dqb.dqb_btime = oldbtime;\n\t\t}\n\t} else {\n\t\tdquot->dq_dqb.dqb_btime = 0;\n\t\tclear_bit(DQ_BLKS_B, &dquot->dq_flags);\n\t}\n\t/* Set properly inode grace time... */\n\tif (dquot->dq_dqb.dqb_isoftlimit &&\n\t    dquot->dq_dqb.dqb_curinodes > dquot->dq_dqb.dqb_isoftlimit) {\n\t\tif (!test_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags) &&\n\t\t    olditime > 0) {\n\t\t\tif (dquot->dq_dqb.dqb_itime > 0)\n\t\t\t\tdquot->dq_dqb.dqb_itime =\n\t\t\t\t\tmin(dquot->dq_dqb.dqb_itime, olditime);\n\t\t\telse\n\t\t\t\tdquot->dq_dqb.dqb_itime = olditime;\n\t\t}\n\t} else {\n\t\tdquot->dq_dqb.dqb_itime = 0;\n\t\tclear_bit(DQ_INODES_B, &dquot->dq_flags);\n\t}\n\t/* All information is properly updated, clear the flags */\n\t__clear_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_BLIMITS_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_ILIMITS_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags);\n\tOCFS2_DQUOT(dquot)->dq_origspace = dquot->dq_dqb.dqb_curspace;\n\tOCFS2_DQUOT(dquot)->dq_originodes = dquot->dq_dqb.dqb_curinodes;\n\tspin_unlock(&dq_data_lock);\n\terr = ocfs2_qinfo_lock(info, freeing);\n\tif (err < 0) {\n\t\tmlog(ML_ERROR, \"Failed to lock quota info, losing quota write\"\n\t\t\t       \" (type=%d, id=%u)\\n\", dquot->dq_id.type,\n\t\t\t       (unsigned)from_kqid(&init_user_ns, dquot->dq_id));\n\t\tgoto out;\n\t}\n\tif (freeing)\n\t\tOCFS2_DQUOT(dquot)->dq_use_count--;\n\terr = qtree_write_dquot(&info->dqi_gi, dquot);\n\tif (err < 0)\n\t\tgoto out_qlock;\n\tif (freeing && !OCFS2_DQUOT(dquot)->dq_use_count) {\n\t\terr = qtree_release_dquot(&info->dqi_gi, dquot);\n\t\tif (info_dirty(sb_dqinfo(sb, type))) {\n\t\t\terr2 = __ocfs2_global_write_info(sb, type);\n\t\t\tif (!err)\n\t\t\t\terr = err2;\n\t\t}\n\t}\nout_qlock:\n\tocfs2_qinfo_unlock(info, freeing);\nout:\n\tif (err < 0)\n\t\tmlog_errno(err);\n\treturn err;\n}"
  },
  {
    "function_name": "ocfs2_calc_global_qinit_credits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "467-473",
    "snippet": "static int ocfs2_calc_global_qinit_credits(struct super_block *sb, int type)\n{\n\t/* We modify all the allocated blocks, tree root, info block and\n\t * the inode */\n\treturn (ocfs2_global_qinit_alloc(sb, type) + 2) *\n\t\t\tOCFS2_QUOTA_BLOCK_UPDATE_CREDITS + 1;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_global_qinit_alloc",
          "args": [
            "sb",
            "type"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_global_qinit_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "456-465",
          "snippet": "static int ocfs2_global_qinit_alloc(struct super_block *sb, int type)\n{\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\n\t/*\n\t * We may need to allocate tree blocks and a leaf block but not the\n\t * root block\n\t */\n\treturn oinfo->dqi_gi.dqi_qtree_depth;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic int ocfs2_global_qinit_alloc(struct super_block *sb, int type)\n{\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\n\t/*\n\t * We may need to allocate tree blocks and a leaf block but not the\n\t * root block\n\t */\n\treturn oinfo->dqi_gi.dqi_qtree_depth;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic int ocfs2_calc_global_qinit_credits(struct super_block *sb, int type)\n{\n\t/* We modify all the allocated blocks, tree root, info block and\n\t * the inode */\n\treturn (ocfs2_global_qinit_alloc(sb, type) + 2) *\n\t\t\tOCFS2_QUOTA_BLOCK_UPDATE_CREDITS + 1;\n}"
  },
  {
    "function_name": "ocfs2_global_qinit_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "456-465",
    "snippet": "static int ocfs2_global_qinit_alloc(struct super_block *sb, int type)\n{\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\n\t/*\n\t * We may need to allocate tree blocks and a leaf block but not the\n\t * root block\n\t */\n\treturn oinfo->dqi_gi.dqi_qtree_depth;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic int ocfs2_global_qinit_alloc(struct super_block *sb, int type)\n{\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\n\t/*\n\t * We may need to allocate tree blocks and a leaf block but not the\n\t * root block\n\t */\n\treturn oinfo->dqi_gi.dqi_qtree_depth;\n}"
  },
  {
    "function_name": "ocfs2_global_write_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "443-454",
    "snippet": "int ocfs2_global_write_info(struct super_block *sb, int type)\n{\n\tint err;\n\tstruct ocfs2_mem_dqinfo *info = sb_dqinfo(sb, type)->dqi_priv;\n\n\terr = ocfs2_qinfo_lock(info, 1);\n\tif (err < 0)\n\t\treturn err;\n\terr = __ocfs2_global_write_info(sb, type);\n\tocfs2_qinfo_unlock(info, 1);\n\treturn err;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_qinfo_unlock",
          "args": [
            "info",
            "1"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_qinfo_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3820-3828",
          "snippet": "void ocfs2_qinfo_unlock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_qinfo_unlock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_global_write_info",
          "args": [
            "sb",
            "type"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_global_write_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "415-441",
          "snippet": "static int __ocfs2_global_write_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_global_disk_dqinfo dinfo;\n\tssize_t size;\n\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_flags &= ~DQF_INFO_DIRTY;\n\tdinfo.dqi_bgrace = cpu_to_le32(info->dqi_bgrace);\n\tdinfo.dqi_igrace = cpu_to_le32(info->dqi_igrace);\n\tspin_unlock(&dq_data_lock);\n\tdinfo.dqi_syncms = cpu_to_le32(oinfo->dqi_syncms);\n\tdinfo.dqi_blocks = cpu_to_le32(oinfo->dqi_gi.dqi_blocks);\n\tdinfo.dqi_free_blk = cpu_to_le32(oinfo->dqi_gi.dqi_free_blk);\n\tdinfo.dqi_free_entry = cpu_to_le32(oinfo->dqi_gi.dqi_free_entry);\n\tsize = sb->s_op->quota_write(sb, type, (char *)&dinfo,\n\t\t\t\t     sizeof(struct ocfs2_global_disk_dqinfo),\n\t\t\t\t     OCFS2_GLOBAL_INFO_OFF);\n\tif (size != sizeof(struct ocfs2_global_disk_dqinfo)) {\n\t\tmlog(ML_ERROR, \"Cannot write global quota info structure\\n\");\n\t\tif (size >= 0)\n\t\t\tsize = -EIO;\n\t\treturn size;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic int __ocfs2_global_write_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_global_disk_dqinfo dinfo;\n\tssize_t size;\n\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_flags &= ~DQF_INFO_DIRTY;\n\tdinfo.dqi_bgrace = cpu_to_le32(info->dqi_bgrace);\n\tdinfo.dqi_igrace = cpu_to_le32(info->dqi_igrace);\n\tspin_unlock(&dq_data_lock);\n\tdinfo.dqi_syncms = cpu_to_le32(oinfo->dqi_syncms);\n\tdinfo.dqi_blocks = cpu_to_le32(oinfo->dqi_gi.dqi_blocks);\n\tdinfo.dqi_free_blk = cpu_to_le32(oinfo->dqi_gi.dqi_free_blk);\n\tdinfo.dqi_free_entry = cpu_to_le32(oinfo->dqi_gi.dqi_free_entry);\n\tsize = sb->s_op->quota_write(sb, type, (char *)&dinfo,\n\t\t\t\t     sizeof(struct ocfs2_global_disk_dqinfo),\n\t\t\t\t     OCFS2_GLOBAL_INFO_OFF);\n\tif (size != sizeof(struct ocfs2_global_disk_dqinfo)) {\n\t\tmlog(ML_ERROR, \"Cannot write global quota info structure\\n\");\n\t\tif (size >= 0)\n\t\t\tsize = -EIO;\n\t\treturn size;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_qinfo_lock",
          "args": [
            "info",
            "1"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_qinfo_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3875-3905",
          "snippet": "int ocfs2_qinfo_lock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tint status = 0;\n\n\t/* On RO devices, locking really isn't needed... */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (ex)\n\t\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (!ocfs2_should_refresh_lock_res(lockres))\n\t\tgoto bail;\n\t/* OK, we have the lock but we need to refresh the quota info */\n\tstatus = ocfs2_refresh_qinfo(oinfo);\n\tif (status)\n\t\tocfs2_qinfo_unlock(oinfo, ex);\n\tocfs2_complete_lock_res_refresh(lockres, status);\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_qinfo_lock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tint status = 0;\n\n\t/* On RO devices, locking really isn't needed... */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (ex)\n\t\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (!ocfs2_should_refresh_lock_res(lockres))\n\t\tgoto bail;\n\t/* OK, we have the lock but we need to refresh the quota info */\n\tstatus = ocfs2_refresh_qinfo(oinfo);\n\tif (status)\n\t\tocfs2_qinfo_unlock(oinfo, ex);\n\tocfs2_complete_lock_res_refresh(lockres, status);\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nint ocfs2_global_write_info(struct super_block *sb, int type)\n{\n\tint err;\n\tstruct ocfs2_mem_dqinfo *info = sb_dqinfo(sb, type)->dqi_priv;\n\n\terr = ocfs2_qinfo_lock(info, 1);\n\tif (err < 0)\n\t\treturn err;\n\terr = __ocfs2_global_write_info(sb, type);\n\tocfs2_qinfo_unlock(info, 1);\n\treturn err;\n}"
  },
  {
    "function_name": "__ocfs2_global_write_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "415-441",
    "snippet": "static int __ocfs2_global_write_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_global_disk_dqinfo dinfo;\n\tssize_t size;\n\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_flags &= ~DQF_INFO_DIRTY;\n\tdinfo.dqi_bgrace = cpu_to_le32(info->dqi_bgrace);\n\tdinfo.dqi_igrace = cpu_to_le32(info->dqi_igrace);\n\tspin_unlock(&dq_data_lock);\n\tdinfo.dqi_syncms = cpu_to_le32(oinfo->dqi_syncms);\n\tdinfo.dqi_blocks = cpu_to_le32(oinfo->dqi_gi.dqi_blocks);\n\tdinfo.dqi_free_blk = cpu_to_le32(oinfo->dqi_gi.dqi_free_blk);\n\tdinfo.dqi_free_entry = cpu_to_le32(oinfo->dqi_gi.dqi_free_entry);\n\tsize = sb->s_op->quota_write(sb, type, (char *)&dinfo,\n\t\t\t\t     sizeof(struct ocfs2_global_disk_dqinfo),\n\t\t\t\t     OCFS2_GLOBAL_INFO_OFF);\n\tif (size != sizeof(struct ocfs2_global_disk_dqinfo)) {\n\t\tmlog(ML_ERROR, \"Cannot write global quota info structure\\n\");\n\t\tif (size >= 0)\n\t\t\tsize = -EIO;\n\t\treturn size;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Cannot write global quota info structure\\n\""
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->quota_write",
          "args": [
            "sb",
            "type",
            "(char *)&dinfo",
            "sizeof(struct ocfs2_global_disk_dqinfo)",
            "OCFS2_GLOBAL_INFO_OFF"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "oinfo->dqi_gi.dqi_free_entry"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "oinfo->dqi_gi.dqi_free_blk"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "oinfo->dqi_gi.dqi_blocks"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "oinfo->dqi_syncms"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "info->dqi_igrace"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "info->dqi_bgrace"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic int __ocfs2_global_write_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_global_disk_dqinfo dinfo;\n\tssize_t size;\n\n\tspin_lock(&dq_data_lock);\n\tinfo->dqi_flags &= ~DQF_INFO_DIRTY;\n\tdinfo.dqi_bgrace = cpu_to_le32(info->dqi_bgrace);\n\tdinfo.dqi_igrace = cpu_to_le32(info->dqi_igrace);\n\tspin_unlock(&dq_data_lock);\n\tdinfo.dqi_syncms = cpu_to_le32(oinfo->dqi_syncms);\n\tdinfo.dqi_blocks = cpu_to_le32(oinfo->dqi_gi.dqi_blocks);\n\tdinfo.dqi_free_blk = cpu_to_le32(oinfo->dqi_gi.dqi_free_blk);\n\tdinfo.dqi_free_entry = cpu_to_le32(oinfo->dqi_gi.dqi_free_entry);\n\tsize = sb->s_op->quota_write(sb, type, (char *)&dinfo,\n\t\t\t\t     sizeof(struct ocfs2_global_disk_dqinfo),\n\t\t\t\t     OCFS2_GLOBAL_INFO_OFF);\n\tif (size != sizeof(struct ocfs2_global_disk_dqinfo)) {\n\t\tmlog(ML_ERROR, \"Cannot write global quota info structure\\n\");\n\t\tif (size >= 0)\n\t\t\tsize = -EIO;\n\t\treturn size;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_global_read_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "336-411",
    "snippet": "int ocfs2_global_read_info(struct super_block *sb, int type)\n{\n\tstruct inode *gqinode = NULL;\n\tunsigned int ino[OCFS2_MAXQUOTAS] = { USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\t      GROUP_QUOTA_SYSTEM_INODE };\n\tstruct ocfs2_global_disk_dqinfo dinfo;\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tu64 pcount;\n\tint status;\n\n\t/* Read global header */\n\tgqinode = ocfs2_get_system_file_inode(OCFS2_SB(sb), ino[type],\n\t\t\tOCFS2_INVALID_SLOT);\n\tif (!gqinode) {\n\t\tmlog(ML_ERROR, \"failed to get global quota inode (type=%d)\\n\",\n\t\t\ttype);\n\t\tstatus = -EINVAL;\n\t\tgoto out_err;\n\t}\n\toinfo->dqi_gi.dqi_sb = sb;\n\toinfo->dqi_gi.dqi_type = type;\n\tocfs2_qinfo_lock_res_init(&oinfo->dqi_gqlock, oinfo);\n\toinfo->dqi_gi.dqi_entry_size = sizeof(struct ocfs2_global_disk_dqblk);\n\toinfo->dqi_gi.dqi_ops = &ocfs2_global_ops;\n\toinfo->dqi_gqi_bh = NULL;\n\toinfo->dqi_gqi_count = 0;\n\toinfo->dqi_gqinode = gqinode;\n\tstatus = ocfs2_lock_global_qf(oinfo, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\tstatus = ocfs2_extent_map_get_blocks(gqinode, 0, &oinfo->dqi_giblk,\n\t\t\t\t\t     &pcount, NULL);\n\tif (status < 0)\n\t\tgoto out_unlock;\n\n\tstatus = ocfs2_qinfo_lock(oinfo, 0);\n\tif (status < 0)\n\t\tgoto out_unlock;\n\tstatus = sb->s_op->quota_read(sb, type, (char *)&dinfo,\n\t\t\t\t      sizeof(struct ocfs2_global_disk_dqinfo),\n\t\t\t\t      OCFS2_GLOBAL_INFO_OFF);\n\tocfs2_qinfo_unlock(oinfo, 0);\n\tocfs2_unlock_global_qf(oinfo, 0);\n\tif (status != sizeof(struct ocfs2_global_disk_dqinfo)) {\n\t\tmlog(ML_ERROR, \"Cannot read global quota info (%d).\\n\",\n\t\t     status);\n\t\tif (status >= 0)\n\t\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\tinfo->dqi_bgrace = le32_to_cpu(dinfo.dqi_bgrace);\n\tinfo->dqi_igrace = le32_to_cpu(dinfo.dqi_igrace);\n\toinfo->dqi_syncms = le32_to_cpu(dinfo.dqi_syncms);\n\toinfo->dqi_gi.dqi_blocks = le32_to_cpu(dinfo.dqi_blocks);\n\toinfo->dqi_gi.dqi_free_blk = le32_to_cpu(dinfo.dqi_free_blk);\n\toinfo->dqi_gi.dqi_free_entry = le32_to_cpu(dinfo.dqi_free_entry);\n\toinfo->dqi_gi.dqi_blocksize_bits = sb->s_blocksize_bits;\n\toinfo->dqi_gi.dqi_usable_bs = sb->s_blocksize -\n\t\t\t\t\t\tOCFS2_QBLK_RESERVED_SPACE;\n\toinfo->dqi_gi.dqi_qtree_depth = qtree_depth(&oinfo->dqi_gi);\n\tINIT_DELAYED_WORK(&oinfo->dqi_sync_work, qsync_work_fn);\n\tschedule_delayed_work(&oinfo->dqi_sync_work,\n\t\t\t      msecs_to_jiffies(oinfo->dqi_syncms));\n\nout_err:\n\treturn status;\nout_unlock:\n\tocfs2_unlock_global_qf(oinfo, 0);\n\tmlog_errno(status);\n\tgoto out_err;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct qtree_fmt_operations ocfs2_global_ops = {\n\t.mem2disk_dqblk = ocfs2_global_mem2diskdqb,\n\t.disk2mem_dqblk = ocfs2_global_disk2memdqb,\n\t.is_id = ocfs2_global_is_id,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_unlock_global_qf",
          "args": [
            "oinfo",
            "0"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_global_qf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "319-333",
          "snippet": "void ocfs2_unlock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tif (ex) {\n\t\tup_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t\tmutex_unlock(&oinfo->dqi_gqinode->i_mutex);\n\t} else {\n\t\tup_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\tocfs2_inode_unlock(oinfo->dqi_gqinode, ex);\n\tbrelse(oinfo->dqi_gqi_bh);\n\tspin_lock(&dq_data_lock);\n\tif (!--oinfo->dqi_gqi_count)\n\t\toinfo->dqi_gqi_bh = NULL;\n\tspin_unlock(&dq_data_lock);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nvoid ocfs2_unlock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tif (ex) {\n\t\tup_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t\tmutex_unlock(&oinfo->dqi_gqinode->i_mutex);\n\t} else {\n\t\tup_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\tocfs2_inode_unlock(oinfo->dqi_gqinode, ex);\n\tbrelse(oinfo->dqi_gqi_bh);\n\tspin_lock(&dq_data_lock);\n\tif (!--oinfo->dqi_gqi_count)\n\t\toinfo->dqi_gqi_bh = NULL;\n\tspin_unlock(&dq_data_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&oinfo->dqi_sync_work",
            "msecs_to_jiffies(oinfo->dqi_syncms)"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "oinfo->dqi_syncms"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&oinfo->dqi_sync_work",
            "qsync_work_fn"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qtree_depth",
          "args": [
            "&oinfo->dqi_gi"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dinfo.dqi_free_entry"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Cannot read global quota info (%d).\\n\"",
            "status"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_qinfo_unlock",
          "args": [
            "oinfo",
            "0"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_qinfo_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3820-3828",
          "snippet": "void ocfs2_qinfo_unlock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_qinfo_unlock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->quota_read",
          "args": [
            "sb",
            "type",
            "(char *)&dinfo",
            "sizeof(struct ocfs2_global_disk_dqinfo)",
            "OCFS2_GLOBAL_INFO_OFF"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_qinfo_lock",
          "args": [
            "oinfo",
            "0"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_qinfo_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3875-3905",
          "snippet": "int ocfs2_qinfo_lock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tint status = 0;\n\n\t/* On RO devices, locking really isn't needed... */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (ex)\n\t\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (!ocfs2_should_refresh_lock_res(lockres))\n\t\tgoto bail;\n\t/* OK, we have the lock but we need to refresh the quota info */\n\tstatus = ocfs2_refresh_qinfo(oinfo);\n\tif (status)\n\t\tocfs2_qinfo_unlock(oinfo, ex);\n\tocfs2_complete_lock_res_refresh(lockres, status);\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_qinfo_lock(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\n\tstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tint status = 0;\n\n\t/* On RO devices, locking really isn't needed... */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tif (ex)\n\t\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tif (!ocfs2_should_refresh_lock_res(lockres))\n\t\tgoto bail;\n\t/* OK, we have the lock but we need to refresh the quota info */\n\tstatus = ocfs2_refresh_qinfo(oinfo);\n\tif (status)\n\t\tocfs2_qinfo_unlock(oinfo, ex);\n\tocfs2_complete_lock_res_refresh(lockres, status);\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_get_blocks",
          "args": [
            "gqinode",
            "0",
            "&oinfo->dqi_giblk",
            "&pcount",
            "NULL"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_get_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "671-705",
          "snippet": "int ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_global_qf",
          "args": [
            "oinfo",
            "0"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_global_qf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "296-317",
          "snippet": "int ocfs2_lock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\n\tstatus = ocfs2_inode_lock(oinfo->dqi_gqinode, &bh, ex);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&dq_data_lock);\n\tif (!oinfo->dqi_gqi_count++)\n\t\toinfo->dqi_gqi_bh = bh;\n\telse\n\t\tWARN_ON(bh != oinfo->dqi_gqi_bh);\n\tspin_unlock(&dq_data_lock);\n\tif (ex) {\n\t\tmutex_lock(&oinfo->dqi_gqinode->i_mutex);\n\t\tdown_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t} else {\n\t\tdown_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nint ocfs2_lock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\n\tstatus = ocfs2_inode_lock(oinfo->dqi_gqinode, &bh, ex);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&dq_data_lock);\n\tif (!oinfo->dqi_gqi_count++)\n\t\toinfo->dqi_gqi_bh = bh;\n\telse\n\t\tWARN_ON(bh != oinfo->dqi_gqi_bh);\n\tspin_unlock(&dq_data_lock);\n\tif (ex) {\n\t\tmutex_lock(&oinfo->dqi_gqinode->i_mutex);\n\t\tdown_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t} else {\n\t\tdown_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_qinfo_lock_res_init",
          "args": [
            "&oinfo->dqi_gqlock",
            "oinfo"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_qinfo_lock_res_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "700-709",
          "snippet": "void ocfs2_qinfo_lock_res_init(struct ocfs2_lock_res *lockres,\n\t\t\t       struct ocfs2_mem_dqinfo *info)\n{\n\tocfs2_lock_res_init_once(lockres);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_QINFO, info->dqi_gi.dqi_type,\n\t\t\t      0, lockres->l_name);\n\tocfs2_lock_res_init_common(OCFS2_SB(info->dqi_gi.dqi_sb), lockres,\n\t\t\t\t   OCFS2_LOCK_TYPE_QINFO, &ocfs2_qinfo_lops,\n\t\t\t\t   info);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_lock_res_ops ocfs2_qinfo_lops = {\n\t.set_lvb\t= ocfs2_set_qinfo_lvb,\n\t.get_osb\t= ocfs2_get_qinfo_osb,\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH | LOCK_TYPE_USES_LVB,\n};",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_lock_res_ops ocfs2_qinfo_lops = {\n\t.set_lvb\t= ocfs2_set_qinfo_lvb,\n\t.get_osb\t= ocfs2_get_qinfo_osb,\n\t.flags\t\t= LOCK_TYPE_REQUIRES_REFRESH | LOCK_TYPE_USES_LVB,\n};\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_qinfo_lock_res_init(struct ocfs2_lock_res *lockres,\n\t\t\t       struct ocfs2_mem_dqinfo *info)\n{\n\tocfs2_lock_res_init_once(lockres);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_QINFO, info->dqi_gi.dqi_type,\n\t\t\t      0, lockres->l_name);\n\tocfs2_lock_res_init_common(OCFS2_SB(info->dqi_gi.dqi_sb), lockres,\n\t\t\t\t   OCFS2_LOCK_TYPE_QINFO, &ocfs2_qinfo_lops,\n\t\t\t\t   info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "OCFS2_SB(sb)",
            "ino[type]",
            "OCFS2_INVALID_SLOT"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstruct qtree_fmt_operations ocfs2_global_ops = {\n\t.mem2disk_dqblk = ocfs2_global_mem2diskdqb,\n\t.disk2mem_dqblk = ocfs2_global_disk2memdqb,\n\t.is_id = ocfs2_global_is_id,\n};\n\nint ocfs2_global_read_info(struct super_block *sb, int type)\n{\n\tstruct inode *gqinode = NULL;\n\tunsigned int ino[OCFS2_MAXQUOTAS] = { USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\t      GROUP_QUOTA_SYSTEM_INODE };\n\tstruct ocfs2_global_disk_dqinfo dinfo;\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tu64 pcount;\n\tint status;\n\n\t/* Read global header */\n\tgqinode = ocfs2_get_system_file_inode(OCFS2_SB(sb), ino[type],\n\t\t\tOCFS2_INVALID_SLOT);\n\tif (!gqinode) {\n\t\tmlog(ML_ERROR, \"failed to get global quota inode (type=%d)\\n\",\n\t\t\ttype);\n\t\tstatus = -EINVAL;\n\t\tgoto out_err;\n\t}\n\toinfo->dqi_gi.dqi_sb = sb;\n\toinfo->dqi_gi.dqi_type = type;\n\tocfs2_qinfo_lock_res_init(&oinfo->dqi_gqlock, oinfo);\n\toinfo->dqi_gi.dqi_entry_size = sizeof(struct ocfs2_global_disk_dqblk);\n\toinfo->dqi_gi.dqi_ops = &ocfs2_global_ops;\n\toinfo->dqi_gqi_bh = NULL;\n\toinfo->dqi_gqi_count = 0;\n\toinfo->dqi_gqinode = gqinode;\n\tstatus = ocfs2_lock_global_qf(oinfo, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\tstatus = ocfs2_extent_map_get_blocks(gqinode, 0, &oinfo->dqi_giblk,\n\t\t\t\t\t     &pcount, NULL);\n\tif (status < 0)\n\t\tgoto out_unlock;\n\n\tstatus = ocfs2_qinfo_lock(oinfo, 0);\n\tif (status < 0)\n\t\tgoto out_unlock;\n\tstatus = sb->s_op->quota_read(sb, type, (char *)&dinfo,\n\t\t\t\t      sizeof(struct ocfs2_global_disk_dqinfo),\n\t\t\t\t      OCFS2_GLOBAL_INFO_OFF);\n\tocfs2_qinfo_unlock(oinfo, 0);\n\tocfs2_unlock_global_qf(oinfo, 0);\n\tif (status != sizeof(struct ocfs2_global_disk_dqinfo)) {\n\t\tmlog(ML_ERROR, \"Cannot read global quota info (%d).\\n\",\n\t\t     status);\n\t\tif (status >= 0)\n\t\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\tinfo->dqi_bgrace = le32_to_cpu(dinfo.dqi_bgrace);\n\tinfo->dqi_igrace = le32_to_cpu(dinfo.dqi_igrace);\n\toinfo->dqi_syncms = le32_to_cpu(dinfo.dqi_syncms);\n\toinfo->dqi_gi.dqi_blocks = le32_to_cpu(dinfo.dqi_blocks);\n\toinfo->dqi_gi.dqi_free_blk = le32_to_cpu(dinfo.dqi_free_blk);\n\toinfo->dqi_gi.dqi_free_entry = le32_to_cpu(dinfo.dqi_free_entry);\n\toinfo->dqi_gi.dqi_blocksize_bits = sb->s_blocksize_bits;\n\toinfo->dqi_gi.dqi_usable_bs = sb->s_blocksize -\n\t\t\t\t\t\tOCFS2_QBLK_RESERVED_SPACE;\n\toinfo->dqi_gi.dqi_qtree_depth = qtree_depth(&oinfo->dqi_gi);\n\tINIT_DELAYED_WORK(&oinfo->dqi_sync_work, qsync_work_fn);\n\tschedule_delayed_work(&oinfo->dqi_sync_work,\n\t\t\t      msecs_to_jiffies(oinfo->dqi_syncms));\n\nout_err:\n\treturn status;\nout_unlock:\n\tocfs2_unlock_global_qf(oinfo, 0);\n\tmlog_errno(status);\n\tgoto out_err;\n}"
  },
  {
    "function_name": "ocfs2_unlock_global_qf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "319-333",
    "snippet": "void ocfs2_unlock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tif (ex) {\n\t\tup_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t\tmutex_unlock(&oinfo->dqi_gqinode->i_mutex);\n\t} else {\n\t\tup_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\tocfs2_inode_unlock(oinfo->dqi_gqinode, ex);\n\tbrelse(oinfo->dqi_gqi_bh);\n\tspin_lock(&dq_data_lock);\n\tif (!--oinfo->dqi_gqi_count)\n\t\toinfo->dqi_gqi_bh = NULL;\n\tspin_unlock(&dq_data_lock);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "oinfo->dqi_gqi_bh"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "oinfo->dqi_gqinode",
            "ex"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "oinfo->dqi_gqinode"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&oinfo->dqi_gqinode->i_mutex"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nvoid ocfs2_unlock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tif (ex) {\n\t\tup_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t\tmutex_unlock(&oinfo->dqi_gqinode->i_mutex);\n\t} else {\n\t\tup_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\tocfs2_inode_unlock(oinfo->dqi_gqinode, ex);\n\tbrelse(oinfo->dqi_gqi_bh);\n\tspin_lock(&dq_data_lock);\n\tif (!--oinfo->dqi_gqi_count)\n\t\toinfo->dqi_gqi_bh = NULL;\n\tspin_unlock(&dq_data_lock);\n}"
  },
  {
    "function_name": "ocfs2_lock_global_qf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "296-317",
    "snippet": "int ocfs2_lock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\n\tstatus = ocfs2_inode_lock(oinfo->dqi_gqinode, &bh, ex);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&dq_data_lock);\n\tif (!oinfo->dqi_gqi_count++)\n\t\toinfo->dqi_gqi_bh = bh;\n\telse\n\t\tWARN_ON(bh != oinfo->dqi_gqi_bh);\n\tspin_unlock(&dq_data_lock);\n\tif (ex) {\n\t\tmutex_lock(&oinfo->dqi_gqinode->i_mutex);\n\t\tdown_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t} else {\n\t\tdown_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "oinfo->dqi_gqinode"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&oinfo->dqi_gqinode->i_mutex"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "bh != oinfo->dqi_gqi_bh"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "oinfo->dqi_gqinode",
            "&bh",
            "ex"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nint ocfs2_lock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\n\tstatus = ocfs2_inode_lock(oinfo->dqi_gqinode, &bh, ex);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&dq_data_lock);\n\tif (!oinfo->dqi_gqi_count++)\n\t\toinfo->dqi_gqi_bh = bh;\n\telse\n\t\tWARN_ON(bh != oinfo->dqi_gqi_bh);\n\tspin_unlock(&dq_data_lock);\n\tif (ex) {\n\t\tmutex_lock(&oinfo->dqi_gqinode->i_mutex);\n\t\tdown_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t} else {\n\t\tdown_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_quota_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "214-294",
    "snippet": "ssize_t ocfs2_quota_write(struct super_block *sb, int type,\n\t\t\t  const char *data, size_t len, loff_t off)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct inode *gqinode = oinfo->dqi_gqinode;\n\tint offset = off & (sb->s_blocksize - 1);\n\tsector_t blk = off >> sb->s_blocksize_bits;\n\tint err = 0, new = 0, ja_type;\n\tstruct buffer_head *bh = NULL;\n\thandle_t *handle = journal_current_handle();\n\tu64 pblock, pcount;\n\n\tif (!handle) {\n\t\tmlog(ML_ERROR, \"Quota write (off=%llu, len=%llu) cancelled \"\n\t\t     \"because transaction was not started.\\n\",\n\t\t     (unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\tif (len > sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE - offset) {\n\t\tWARN_ON(1);\n\t\tlen = sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE - offset;\n\t}\n\n\tif (i_size_read(gqinode) < off + len) {\n\t\tloff_t rounded_end =\n\t\t\t\tocfs2_align_bytes_to_blocks(sb, off + len);\n\n\t\t/* Space is already allocated in ocfs2_acquire_dquot() */\n\t\terr = ocfs2_simple_size_update(gqinode,\n\t\t\t\t\t       oinfo->dqi_gqi_bh,\n\t\t\t\t\t       rounded_end);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tnew = 1;\n\t}\n\terr = ocfs2_extent_map_get_blocks(gqinode, blk, &pblock, &pcount, NULL);\n\tif (err) {\n\t\tmlog_errno(err);\n\t\tgoto out;\n\t}\n\t/* Not rewriting whole block? */\n\tif ((offset || len < sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) &&\n\t    !new) {\n\t\terr = ocfs2_read_quota_phys_block(gqinode, pblock, &bh);\n\t\tja_type = OCFS2_JOURNAL_ACCESS_WRITE;\n\t} else {\n\t\tbh = sb_getblk(sb, pblock);\n\t\tif (!bh)\n\t\t\terr = -ENOMEM;\n\t\tja_type = OCFS2_JOURNAL_ACCESS_CREATE;\n\t}\n\tif (err) {\n\t\tmlog_errno(err);\n\t\tgoto out;\n\t}\n\tlock_buffer(bh);\n\tif (new)\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\tmemcpy(bh->b_data + offset, data, len);\n\tflush_dcache_page(bh->b_page);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tocfs2_set_buffer_uptodate(INODE_CACHE(gqinode), bh);\n\terr = ocfs2_journal_access_dq(handle, INODE_CACHE(gqinode), bh,\n\t\t\t\t      ja_type);\n\tif (err < 0) {\n\t\tbrelse(bh);\n\t\tgoto out;\n\t}\n\tocfs2_journal_dirty(handle, bh);\n\tbrelse(bh);\nout:\n\tif (err) {\n\t\tmlog_errno(err);\n\t\treturn err;\n\t}\n\tgqinode->i_version++;\n\tocfs2_mark_inode_dirty(handle, gqinode, oinfo->dqi_gqi_bh);\n\treturn len;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_mark_inode_dirty",
          "args": [
            "handle",
            "gqinode",
            "oinfo->dqi_gqi_bh"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1250-1289",
          "snippet": "int ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "err"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bh"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_dq",
          "args": [
            "handle",
            "INODE_CACHE(gqinode)",
            "bh",
            "ja_type"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_dq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "747-751",
          "snippet": "int ocfs2_journal_access_dq(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dq_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers dq_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_dq_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dq_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_dq_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};\n\nint ocfs2_journal_access_dq(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dq_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "gqinode"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_buffer_uptodate",
          "args": [
            "INODE_CACHE(gqinode)",
            "bh"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "483-516",
          "snippet": "void ocfs2_set_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t       struct buffer_head *bh)\n{\n\tint expand;\n\n\t/* The block may very well exist in our cache already, so avoid\n\t * doing any more work in that case. */\n\tif (ocfs2_buffer_cached(ci, bh))\n\t\treturn;\n\n\ttrace_ocfs2_set_buffer_uptodate_begin(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr);\n\n\t/* No need to recheck under spinlock - insertion is guarded by\n\t * co_io_lock() */\n\tocfs2_metadata_cache_lock(ci);\n\tif (ocfs2_insert_can_use_array(ci)) {\n\t\t/* Fast case - it's an array and there's a free\n\t\t * spot. */\n\t\tocfs2_append_cache_array(ci, bh->b_blocknr);\n\t\tocfs2_metadata_cache_unlock(ci);\n\t\treturn;\n\t}\n\n\texpand = 0;\n\tif (ci->ci_flags & OCFS2_CACHE_FL_INLINE) {\n\t\t/* We need to bump things up to a tree. */\n\t\texpand = 1;\n\t}\n\tocfs2_metadata_cache_unlock(ci);\n\n\t__ocfs2_set_buffer_uptodate(ci, bh->b_blocknr, expand);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t       struct buffer_head *bh)\n{\n\tint expand;\n\n\t/* The block may very well exist in our cache already, so avoid\n\t * doing any more work in that case. */\n\tif (ocfs2_buffer_cached(ci, bh))\n\t\treturn;\n\n\ttrace_ocfs2_set_buffer_uptodate_begin(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr);\n\n\t/* No need to recheck under spinlock - insertion is guarded by\n\t * co_io_lock() */\n\tocfs2_metadata_cache_lock(ci);\n\tif (ocfs2_insert_can_use_array(ci)) {\n\t\t/* Fast case - it's an array and there's a free\n\t\t * spot. */\n\t\tocfs2_append_cache_array(ci, bh->b_blocknr);\n\t\tocfs2_metadata_cache_unlock(ci);\n\t\treturn;\n\t}\n\n\texpand = 0;\n\tif (ci->ci_flags & OCFS2_CACHE_FL_INLINE) {\n\t\t/* We need to bump things up to a tree. */\n\t\texpand = 1;\n\t}\n\tocfs2_metadata_cache_unlock(ci);\n\n\t__ocfs2_set_buffer_uptodate(ci, bh->b_blocknr, expand);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "bh->b_page"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh->b_data + offset",
            "data",
            "len"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "sb->s_blocksize"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "err"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "pblock"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_quota_phys_block",
          "args": [
            "gqinode",
            "pblock",
            "&bh"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_quota_phys_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "149-160",
          "snippet": "int ocfs2_read_quota_phys_block(struct inode *inode, u64 p_block,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tint rc;\n\n\t*bhp = NULL;\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), p_block, 1, bhp, 0,\n\t\t\t       ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nint ocfs2_read_quota_phys_block(struct inode *inode, u64 p_block,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tint rc;\n\n\t*bhp = NULL;\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), p_block, 1, bhp, 0,\n\t\t\t       ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "err"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_get_blocks",
          "args": [
            "gqinode",
            "blk",
            "&pblock",
            "&pcount",
            "NULL"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_get_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "671-705",
          "snippet": "int ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_simple_size_update",
          "args": [
            "gqinode",
            "oinfo->dqi_gqi_bh",
            "rounded_end"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_simple_size_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "319-343",
          "snippet": "int ocfs2_simple_size_update(struct inode *inode,\n\t\t\t     struct buffer_head *di_bh,\n\t\t\t     u64 new_i_size)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_set_inode_size(handle, inode, di_bh,\n\t\t\t\t   new_i_size);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_simple_size_update(struct inode *inode,\n\t\t\t     struct buffer_head *di_bh,\n\t\t\t     u64 new_i_size)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_set_inode_size(handle, inode, di_bh,\n\t\t\t\t   new_i_size);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_align_bytes_to_blocks",
          "args": [
            "sb",
            "off + len"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_align_bytes_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "785-792",
          "snippet": "static inline u64 ocfs2_align_bytes_to_blocks(struct super_block *sb,\n\t\t\t\t\t      u64 bytes)\n{\n\tu64 blocks;\n\n        blocks = ocfs2_blocks_for_bytes(sb, bytes);\n\treturn blocks << sb->s_blocksize_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_align_bytes_to_blocks(struct super_block *sb,\n\t\t\t\t\t      u64 bytes)\n{\n\tu64 blocks;\n\n        blocks = ocfs2_blocks_for_bytes(sb, bytes);\n\treturn blocks << sb->s_blocksize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "gqinode"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Quota write (off=%llu, len=%llu) cancelled \"\n\t\t     \"because transaction was not started.\\n\"",
            "(unsigned long long)off",
            "(unsigned long long)len"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_current_handle",
          "args": [],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nssize_t ocfs2_quota_write(struct super_block *sb, int type,\n\t\t\t  const char *data, size_t len, loff_t off)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct inode *gqinode = oinfo->dqi_gqinode;\n\tint offset = off & (sb->s_blocksize - 1);\n\tsector_t blk = off >> sb->s_blocksize_bits;\n\tint err = 0, new = 0, ja_type;\n\tstruct buffer_head *bh = NULL;\n\thandle_t *handle = journal_current_handle();\n\tu64 pblock, pcount;\n\n\tif (!handle) {\n\t\tmlog(ML_ERROR, \"Quota write (off=%llu, len=%llu) cancelled \"\n\t\t     \"because transaction was not started.\\n\",\n\t\t     (unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\tif (len > sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE - offset) {\n\t\tWARN_ON(1);\n\t\tlen = sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE - offset;\n\t}\n\n\tif (i_size_read(gqinode) < off + len) {\n\t\tloff_t rounded_end =\n\t\t\t\tocfs2_align_bytes_to_blocks(sb, off + len);\n\n\t\t/* Space is already allocated in ocfs2_acquire_dquot() */\n\t\terr = ocfs2_simple_size_update(gqinode,\n\t\t\t\t\t       oinfo->dqi_gqi_bh,\n\t\t\t\t\t       rounded_end);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tnew = 1;\n\t}\n\terr = ocfs2_extent_map_get_blocks(gqinode, blk, &pblock, &pcount, NULL);\n\tif (err) {\n\t\tmlog_errno(err);\n\t\tgoto out;\n\t}\n\t/* Not rewriting whole block? */\n\tif ((offset || len < sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) &&\n\t    !new) {\n\t\terr = ocfs2_read_quota_phys_block(gqinode, pblock, &bh);\n\t\tja_type = OCFS2_JOURNAL_ACCESS_WRITE;\n\t} else {\n\t\tbh = sb_getblk(sb, pblock);\n\t\tif (!bh)\n\t\t\terr = -ENOMEM;\n\t\tja_type = OCFS2_JOURNAL_ACCESS_CREATE;\n\t}\n\tif (err) {\n\t\tmlog_errno(err);\n\t\tgoto out;\n\t}\n\tlock_buffer(bh);\n\tif (new)\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\tmemcpy(bh->b_data + offset, data, len);\n\tflush_dcache_page(bh->b_page);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tocfs2_set_buffer_uptodate(INODE_CACHE(gqinode), bh);\n\terr = ocfs2_journal_access_dq(handle, INODE_CACHE(gqinode), bh,\n\t\t\t\t      ja_type);\n\tif (err < 0) {\n\t\tbrelse(bh);\n\t\tgoto out;\n\t}\n\tocfs2_journal_dirty(handle, bh);\n\tbrelse(bh);\nout:\n\tif (err) {\n\t\tmlog_errno(err);\n\t\treturn err;\n\t}\n\tgqinode->i_version++;\n\tocfs2_mark_inode_dirty(handle, gqinode, oinfo->dqi_gqi_bh);\n\treturn len;\n}"
  },
  {
    "function_name": "ocfs2_quota_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "165-210",
    "snippet": "ssize_t ocfs2_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t size_t len, loff_t off)\n{\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct inode *gqinode = oinfo->dqi_gqinode;\n\tloff_t i_size = i_size_read(gqinode);\n\tint offset = off & (sb->s_blocksize - 1);\n\tsector_t blk = off >> sb->s_blocksize_bits;\n\tint err = 0;\n\tstruct buffer_head *bh;\n\tsize_t toread, tocopy;\n\tu64 pblock = 0, pcount = 0;\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off + len > i_size)\n\t\tlen = i_size - off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = min_t(size_t, (sb->s_blocksize - offset), toread);\n\t\tif (!pcount) {\n\t\t\terr = ocfs2_extent_map_get_blocks(gqinode, blk, &pblock,\n\t\t\t\t\t\t\t  &pcount, NULL);\n\t\t\tif (err) {\n\t\t\t\tmlog_errno(err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t} else {\n\t\t\tpcount--;\n\t\t\tpblock++;\n\t\t}\n\t\tbh = NULL;\n\t\terr = ocfs2_read_quota_phys_block(gqinode, pblock, &bh);\n\t\tif (err) {\n\t\t\tmlog_errno(err);\n\t\t\treturn err;\n\t\t}\n\t\tmemcpy(data, bh->b_data + offset, tocopy);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "bh->b_data + offset",
            "tocopy"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "err"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_quota_phys_block",
          "args": [
            "gqinode",
            "pblock",
            "&bh"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_quota_phys_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "149-160",
          "snippet": "int ocfs2_read_quota_phys_block(struct inode *inode, u64 p_block,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tint rc;\n\n\t*bhp = NULL;\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), p_block, 1, bhp, 0,\n\t\t\t       ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nint ocfs2_read_quota_phys_block(struct inode *inode, u64 p_block,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tint rc;\n\n\t*bhp = NULL;\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), p_block, 1, bhp, 0,\n\t\t\t       ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "err"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_get_blocks",
          "args": [
            "gqinode",
            "blk",
            "&pblock",
            "&pcount",
            "NULL"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_get_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "671-705",
          "snippet": "int ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "(sb->s_blocksize - offset)",
            "toread"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "gqinode"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nssize_t ocfs2_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t size_t len, loff_t off)\n{\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct inode *gqinode = oinfo->dqi_gqinode;\n\tloff_t i_size = i_size_read(gqinode);\n\tint offset = off & (sb->s_blocksize - 1);\n\tsector_t blk = off >> sb->s_blocksize_bits;\n\tint err = 0;\n\tstruct buffer_head *bh;\n\tsize_t toread, tocopy;\n\tu64 pblock = 0, pcount = 0;\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off + len > i_size)\n\t\tlen = i_size - off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = min_t(size_t, (sb->s_blocksize - offset), toread);\n\t\tif (!pcount) {\n\t\t\terr = ocfs2_extent_map_get_blocks(gqinode, blk, &pblock,\n\t\t\t\t\t\t\t  &pcount, NULL);\n\t\t\tif (err) {\n\t\t\t\tmlog_errno(err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t} else {\n\t\t\tpcount--;\n\t\t\tpblock++;\n\t\t}\n\t\tbh = NULL;\n\t\terr = ocfs2_read_quota_phys_block(gqinode, pblock, &bh);\n\t\tif (err) {\n\t\t\tmlog_errno(err);\n\t\t\treturn err;\n\t\t}\n\t\tmemcpy(data, bh->b_data + offset, tocopy);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}"
  },
  {
    "function_name": "ocfs2_read_quota_phys_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "149-160",
    "snippet": "int ocfs2_read_quota_phys_block(struct inode *inode, u64 p_block,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tint rc;\n\n\t*bhp = NULL;\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), p_block, 1, bhp, 0,\n\t\t\t       ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_blocks",
          "args": [
            "INODE_CACHE(inode)",
            "p_block",
            "1",
            "bhp",
            "0",
            "ocfs2_validate_quota_block"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "176-366",
          "snippet": "int ocfs2_read_blocks(struct ocfs2_caching_info *ci, u64 block, int nr,\n\t\t      struct buffer_head *bhs[], int flags,\n\t\t      int (*validate)(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh))\n{\n\tint status = 0;\n\tint i, ignore_cache = 0;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\n\ttrace_ocfs2_read_blocks_begin(ci, (unsigned long long)block, nr, flags);\n\n\tBUG_ON(!ci);\n\tBUG_ON((flags & OCFS2_BH_READAHEAD) &&\n\t       (flags & OCFS2_BH_IGNORE_CACHE));\n\n\tif (bhs == NULL) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr < 0) {\n\t\tmlog(ML_ERROR, \"asked to read %d blocks!\\n\", nr);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tocfs2_metadata_cache_io_unlock(ci);\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\t\tignore_cache = (flags & OCFS2_BH_IGNORE_CACHE);\n\n\t\t/* There are three read-ahead cases here which we need to\n\t\t * be concerned with. All three assume a buffer has\n\t\t * previously been submitted with OCFS2_BH_READAHEAD\n\t\t * and it hasn't yet completed I/O.\n\t\t *\n\t\t * 1) The current request is sync to disk. This rarely\n\t\t *    happens these days, and never when performance\n\t\t *    matters - the code can just wait on the buffer\n\t\t *    lock and re-submit.\n\t\t *\n\t\t * 2) The current request is cached, but not\n\t\t *    readahead. ocfs2_buffer_uptodate() will return\n\t\t *    false anyway, so we'll wind up waiting on the\n\t\t *    buffer lock to do I/O. We re-check the request\n\t\t *    with after getting the lock to avoid a re-submit.\n\t\t *\n\t\t * 3) The current request is readahead (and so must\n\t\t *    also be a caching one). We short circuit if the\n\t\t *    buffer is locked (under I/O) and if it's in the\n\t\t *    uptodate cache. The re-check from #2 catches the\n\t\t *    case that the previous read-ahead completes just\n\t\t *    before our is-it-in-flight check.\n\t\t */\n\n\t\tif (!ignore_cache && !ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\ttrace_ocfs2_read_blocks_from_disk(\n\t\t\t     (unsigned long long)bh->b_blocknr,\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci));\n\t\t\t/* We're using ignore_cache here to say\n\t\t\t * \"go to disk\" */\n\t\t\tignore_cache = 1;\n\t\t}\n\n\t\ttrace_ocfs2_read_blocks_bh((unsigned long long)bh->b_blocknr,\n\t\t\tignore_cache, buffer_jbd(bh), buffer_dirty(bh));\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ignore_cache) {\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\t/* This should probably be a BUG, or\n\t\t\t\t * at least return an error. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A read-ahead request was made - if the\n\t\t\t * buffer is already under read-ahead from a\n\t\t\t * previously submitted request than we are\n\t\t\t * done here. */\n\t\t\tif ((flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_read_ahead(ci, bh))\n\t\t\t\tcontinue;\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\t\tmlog(ML_ERROR, \"block %llu had the JBD bit set \"\n\t\t\t\t\t       \"while I was in lock_buffer!\",\n\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\t\tBUG();\n#else\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n#endif\n\t\t\t}\n\n\t\t\t/* Re-check ocfs2_buffer_uptodate() as a\n\t\t\t * previously read-ahead buffer may have\n\t\t\t * completed I/O while we were waiting for the\n\t\t\t * buffer lock. */\n\t\t\tif (!(flags & OCFS2_BH_IGNORE_CACHE)\n\t\t\t    && !(flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\t\tif (validate)\n\t\t\t\tset_buffer_needs_validate(bh);\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READ, bh);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tstatus = 0;\n\n\tfor (i = (nr - 1); i >= 0; i--) {\n\t\tbh = bhs[i];\n\n\t\tif (!(flags & OCFS2_BH_READAHEAD)) {\n\t\t\t/* We know this can't have changed as we hold the\n\t\t\t * owner sem. Avoid doing any work on the bh if the\n\t\t\t * journal has it. */\n\t\t\tif (!buffer_jbd(bh))\n\t\t\t\twait_on_buffer(bh);\n\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t/* Status won't be cleared from here on out,\n\t\t\t\t * so we can safely record this and loop back\n\t\t\t\t * to cleanup the other buffers. Don't need to\n\t\t\t\t * remove the clustered uptodate information\n\t\t\t\t * for this bh as it's not marked locally\n\t\t\t\t * uptodate. */\n\t\t\t\tstatus = -EIO;\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (buffer_needs_validate(bh)) {\n\t\t\t\t/* We never set NeedsValidate if the\n\t\t\t\t * buffer was held by the journal, so\n\t\t\t\t * that better not have changed */\n\t\t\t\tBUG_ON(buffer_jbd(bh));\n\t\t\t\tclear_buffer_needs_validate(bh);\n\t\t\t\tstatus = validate(sb, bh);\n\t\t\t\tif (status) {\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Always set the buffer in the cache, even if it was\n\t\t * a forced read, or read-ahead which hasn't yet\n\t\t * completed. */\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t}\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\ttrace_ocfs2_read_blocks_end((unsigned long long)block, nr,\n\t\t\t\t    flags, ignore_cache);\n\nbail:\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks(struct ocfs2_caching_info *ci, u64 block, int nr,\n\t\t      struct buffer_head *bhs[], int flags,\n\t\t      int (*validate)(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh))\n{\n\tint status = 0;\n\tint i, ignore_cache = 0;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\n\ttrace_ocfs2_read_blocks_begin(ci, (unsigned long long)block, nr, flags);\n\n\tBUG_ON(!ci);\n\tBUG_ON((flags & OCFS2_BH_READAHEAD) &&\n\t       (flags & OCFS2_BH_IGNORE_CACHE));\n\n\tif (bhs == NULL) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr < 0) {\n\t\tmlog(ML_ERROR, \"asked to read %d blocks!\\n\", nr);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tocfs2_metadata_cache_io_unlock(ci);\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\t\tignore_cache = (flags & OCFS2_BH_IGNORE_CACHE);\n\n\t\t/* There are three read-ahead cases here which we need to\n\t\t * be concerned with. All three assume a buffer has\n\t\t * previously been submitted with OCFS2_BH_READAHEAD\n\t\t * and it hasn't yet completed I/O.\n\t\t *\n\t\t * 1) The current request is sync to disk. This rarely\n\t\t *    happens these days, and never when performance\n\t\t *    matters - the code can just wait on the buffer\n\t\t *    lock and re-submit.\n\t\t *\n\t\t * 2) The current request is cached, but not\n\t\t *    readahead. ocfs2_buffer_uptodate() will return\n\t\t *    false anyway, so we'll wind up waiting on the\n\t\t *    buffer lock to do I/O. We re-check the request\n\t\t *    with after getting the lock to avoid a re-submit.\n\t\t *\n\t\t * 3) The current request is readahead (and so must\n\t\t *    also be a caching one). We short circuit if the\n\t\t *    buffer is locked (under I/O) and if it's in the\n\t\t *    uptodate cache. The re-check from #2 catches the\n\t\t *    case that the previous read-ahead completes just\n\t\t *    before our is-it-in-flight check.\n\t\t */\n\n\t\tif (!ignore_cache && !ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\ttrace_ocfs2_read_blocks_from_disk(\n\t\t\t     (unsigned long long)bh->b_blocknr,\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci));\n\t\t\t/* We're using ignore_cache here to say\n\t\t\t * \"go to disk\" */\n\t\t\tignore_cache = 1;\n\t\t}\n\n\t\ttrace_ocfs2_read_blocks_bh((unsigned long long)bh->b_blocknr,\n\t\t\tignore_cache, buffer_jbd(bh), buffer_dirty(bh));\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ignore_cache) {\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\t/* This should probably be a BUG, or\n\t\t\t\t * at least return an error. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A read-ahead request was made - if the\n\t\t\t * buffer is already under read-ahead from a\n\t\t\t * previously submitted request than we are\n\t\t\t * done here. */\n\t\t\tif ((flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_read_ahead(ci, bh))\n\t\t\t\tcontinue;\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\t\tmlog(ML_ERROR, \"block %llu had the JBD bit set \"\n\t\t\t\t\t       \"while I was in lock_buffer!\",\n\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\t\tBUG();\n#else\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n#endif\n\t\t\t}\n\n\t\t\t/* Re-check ocfs2_buffer_uptodate() as a\n\t\t\t * previously read-ahead buffer may have\n\t\t\t * completed I/O while we were waiting for the\n\t\t\t * buffer lock. */\n\t\t\tif (!(flags & OCFS2_BH_IGNORE_CACHE)\n\t\t\t    && !(flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\t\tif (validate)\n\t\t\t\tset_buffer_needs_validate(bh);\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READ, bh);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tstatus = 0;\n\n\tfor (i = (nr - 1); i >= 0; i--) {\n\t\tbh = bhs[i];\n\n\t\tif (!(flags & OCFS2_BH_READAHEAD)) {\n\t\t\t/* We know this can't have changed as we hold the\n\t\t\t * owner sem. Avoid doing any work on the bh if the\n\t\t\t * journal has it. */\n\t\t\tif (!buffer_jbd(bh))\n\t\t\t\twait_on_buffer(bh);\n\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t/* Status won't be cleared from here on out,\n\t\t\t\t * so we can safely record this and loop back\n\t\t\t\t * to cleanup the other buffers. Don't need to\n\t\t\t\t * remove the clustered uptodate information\n\t\t\t\t * for this bh as it's not marked locally\n\t\t\t\t * uptodate. */\n\t\t\t\tstatus = -EIO;\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (buffer_needs_validate(bh)) {\n\t\t\t\t/* We never set NeedsValidate if the\n\t\t\t\t * buffer was held by the journal, so\n\t\t\t\t * that better not have changed */\n\t\t\t\tBUG_ON(buffer_jbd(bh));\n\t\t\t\tclear_buffer_needs_validate(bh);\n\t\t\t\tstatus = validate(sb, bh);\n\t\t\t\tif (status) {\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Always set the buffer in the cache, even if it was\n\t\t * a forced read, or read-ahead which hasn't yet\n\t\t * completed. */\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t}\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\ttrace_ocfs2_read_blocks_end((unsigned long long)block, nr,\n\t\t\t\t    flags, ignore_cache);\n\nbail:\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nint ocfs2_read_quota_phys_block(struct inode *inode, u64 p_block,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tint rc;\n\n\t*bhp = NULL;\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), p_block, 1, bhp, 0,\n\t\t\t       ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_validate_quota_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "132-147",
    "snippet": "int ocfs2_validate_quota_block(struct super_block *sb, struct buffer_head *bh)\n{\n\tstruct ocfs2_disk_dqtrailer *dqt =\n\t\tocfs2_block_dqtrailer(sb->s_blocksize, bh->b_data);\n\n\ttrace_ocfs2_validate_quota_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\treturn ocfs2_validate_meta_ecc(sb, bh->b_data, &dqt->dq_check);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_validate_meta_ecc",
          "args": [
            "sb",
            "bh->b_data",
            "&dqt->dq_check"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "613-624",
          "snippet": "int ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_validate_quota_block",
          "args": [
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_block_dqtrailer",
          "args": [
            "sb->s_blocksize",
            "bh->b_data"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_dqtrailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1271-1278",
          "snippet": "static inline struct ocfs2_disk_dqtrailer *ocfs2_block_dqtrailer(int blocksize,\n\t\t\t\t\t\t\t\t void *buf)\n{\n\tchar *ptr = buf;\n\tptr += blocksize - OCFS2_QBLK_RESERVED_SPACE;\n\n\treturn (struct ocfs2_disk_dqtrailer *)ptr;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_QBLK_RESERVED_SPACE 8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_QBLK_RESERVED_SPACE 8\n\nstatic inline struct ocfs2_disk_dqtrailer *ocfs2_block_dqtrailer(int blocksize,\n\t\t\t\t\t\t\t\t void *buf)\n{\n\tchar *ptr = buf;\n\tptr += blocksize - OCFS2_QBLK_RESERVED_SPACE;\n\n\treturn (struct ocfs2_disk_dqtrailer *)ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nint ocfs2_validate_quota_block(struct super_block *sb, struct buffer_head *bh)\n{\n\tstruct ocfs2_disk_dqtrailer *dqt =\n\t\tocfs2_block_dqtrailer(sb->s_blocksize, bh->b_data);\n\n\ttrace_ocfs2_validate_quota_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\treturn ocfs2_validate_meta_ecc(sb, bh->b_data, &dqt->dq_check);\n}"
  },
  {
    "function_name": "ocfs2_global_is_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "112-124",
    "snippet": "static int ocfs2_global_is_id(void *dp, struct dquot *dquot)\n{\n\tstruct ocfs2_global_disk_dqblk *d = dp;\n\tstruct ocfs2_mem_dqinfo *oinfo =\n\t\t\tsb_dqinfo(dquot->dq_sb, dquot->dq_id.type)->dqi_priv;\n\n\tif (qtree_entry_unused(&oinfo->dqi_gi, dp))\n\t\treturn 0;\n\n\treturn qid_eq(make_kqid(&init_user_ns, dquot->dq_id.type,\n\t\t\t\tle32_to_cpu(d->dqb_id)),\n\t\t      dquot->dq_id);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qid_eq",
          "args": [
            "make_kqid(&init_user_ns, dquot->dq_id.type,\n\t\t\t\tle32_to_cpu(d->dqb_id))",
            "dquot->dq_id"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "qid_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "12-26",
          "snippet": "bool qid_eq(struct kqid left, struct kqid right)\n{\n\tif (left.type != right.type)\n\t\treturn false;\n\tswitch(left.type) {\n\tcase USRQUOTA:\n\t\treturn uid_eq(left.uid, right.uid);\n\tcase GRPQUOTA:\n\t\treturn gid_eq(left.gid, right.gid);\n\tcase PRJQUOTA:\n\t\treturn projid_eq(left.projid, right.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nbool qid_eq(struct kqid left, struct kqid right)\n{\n\tif (left.type != right.type)\n\t\treturn false;\n\tswitch(left.type) {\n\tcase USRQUOTA:\n\t\treturn uid_eq(left.uid, right.uid);\n\tcase GRPQUOTA:\n\t\treturn gid_eq(left.gid, right.gid);\n\tcase PRJQUOTA:\n\t\treturn projid_eq(left.projid, right.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kqid",
          "args": [
            "&init_user_ns",
            "dquot->dq_id.type",
            "le32_to_cpu(d->dqb_id)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "d->dqb_id"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qtree_entry_unused",
          "args": [
            "&oinfo->dqi_gi",
            "dp"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "qtree_entry_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/quota_tree.c",
          "lines": "206-214",
          "snippet": "int qtree_entry_unused(struct qtree_mem_dqinfo *info, char *disk)\n{\n\tint i;\n\n\tfor (i = 0; i < info->dqi_entry_size; i++)\n\t\tif (disk[i])\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"quota_tree.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/dqblk_v2.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"quota_tree.h\"\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/dqblk_v2.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint qtree_entry_unused(struct qtree_mem_dqinfo *info, char *disk)\n{\n\tint i;\n\n\tfor (i = 0; i < info->dqi_entry_size; i++)\n\t\tif (disk[i])\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "dquot->dq_sb",
            "dquot->dq_id.type"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic int ocfs2_global_is_id(void *dp, struct dquot *dquot)\n{\n\tstruct ocfs2_global_disk_dqblk *d = dp;\n\tstruct ocfs2_mem_dqinfo *oinfo =\n\t\t\tsb_dqinfo(dquot->dq_sb, dquot->dq_id.type)->dqi_priv;\n\n\tif (qtree_entry_unused(&oinfo->dqi_gi, dp))\n\t\treturn 0;\n\n\treturn qid_eq(make_kqid(&init_user_ns, dquot->dq_id.type,\n\t\t\t\tle32_to_cpu(d->dqb_id)),\n\t\t      dquot->dq_id);\n}"
  },
  {
    "function_name": "ocfs2_global_mem2diskdqb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "94-110",
    "snippet": "static void ocfs2_global_mem2diskdqb(void *dp, struct dquot *dquot)\n{\n\tstruct ocfs2_global_disk_dqblk *d = dp;\n\tstruct mem_dqblk *m = &dquot->dq_dqb;\n\n\td->dqb_id = cpu_to_le32(from_kqid(&init_user_ns, dquot->dq_id));\n\td->dqb_use_count = cpu_to_le32(OCFS2_DQUOT(dquot)->dq_use_count);\n\td->dqb_ihardlimit = cpu_to_le64(m->dqb_ihardlimit);\n\td->dqb_isoftlimit = cpu_to_le64(m->dqb_isoftlimit);\n\td->dqb_curinodes = cpu_to_le64(m->dqb_curinodes);\n\td->dqb_bhardlimit = cpu_to_le64(m->dqb_bhardlimit);\n\td->dqb_bsoftlimit = cpu_to_le64(m->dqb_bsoftlimit);\n\td->dqb_curspace = cpu_to_le64(m->dqb_curspace);\n\td->dqb_btime = cpu_to_le64(m->dqb_btime);\n\td->dqb_itime = cpu_to_le64(m->dqb_itime);\n\td->dqb_pad1 = d->dqb_pad2 = 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "m->dqb_itime"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "m->dqb_btime"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "m->dqb_curspace"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "m->dqb_bsoftlimit"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "m->dqb_bhardlimit"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "m->dqb_curinodes"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "m->dqb_isoftlimit"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "m->dqb_ihardlimit"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_DQUOT(dquot)->dq_use_count"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_DQUOT",
          "args": [
            "dquot"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_DQUOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota.h",
          "lines": "71-74",
          "snippet": "static inline struct ocfs2_dquot *OCFS2_DQUOT(struct dquot *dquot)\n{\n\treturn container_of(dquot, struct ocfs2_dquot, dq_dquot);\n}",
          "includes": [
            "#include \"ocfs2.h\"",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/list.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2.h\"\n#include <linux/dqblk_qtree.h>\n#include <linux/list.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline struct ocfs2_dquot *OCFS2_DQUOT(struct dquot *dquot)\n{\n\treturn container_of(dquot, struct ocfs2_dquot, dq_dquot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kqid(&init_user_ns, dquot->dq_id)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kqid",
          "args": [
            "&init_user_ns",
            "dquot->dq_id"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "from_kqid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "100-112",
          "snippet": "qid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nqid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic void ocfs2_global_mem2diskdqb(void *dp, struct dquot *dquot)\n{\n\tstruct ocfs2_global_disk_dqblk *d = dp;\n\tstruct mem_dqblk *m = &dquot->dq_dqb;\n\n\td->dqb_id = cpu_to_le32(from_kqid(&init_user_ns, dquot->dq_id));\n\td->dqb_use_count = cpu_to_le32(OCFS2_DQUOT(dquot)->dq_use_count);\n\td->dqb_ihardlimit = cpu_to_le64(m->dqb_ihardlimit);\n\td->dqb_isoftlimit = cpu_to_le64(m->dqb_isoftlimit);\n\td->dqb_curinodes = cpu_to_le64(m->dqb_curinodes);\n\td->dqb_bhardlimit = cpu_to_le64(m->dqb_bhardlimit);\n\td->dqb_bsoftlimit = cpu_to_le64(m->dqb_bsoftlimit);\n\td->dqb_curspace = cpu_to_le64(m->dqb_curspace);\n\td->dqb_btime = cpu_to_le64(m->dqb_btime);\n\td->dqb_itime = cpu_to_le64(m->dqb_itime);\n\td->dqb_pad1 = d->dqb_pad2 = 0;\n}"
  },
  {
    "function_name": "ocfs2_global_disk2memdqb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
    "lines": "69-92",
    "snippet": "static void ocfs2_global_disk2memdqb(struct dquot *dquot, void *dp)\n{\n\tstruct ocfs2_global_disk_dqblk *d = dp;\n\tstruct mem_dqblk *m = &dquot->dq_dqb;\n\n\t/* Update from disk only entries not set by the admin */\n\tif (!test_bit(DQ_LASTSET_B + QIF_ILIMITS_B, &dquot->dq_flags)) {\n\t\tm->dqb_ihardlimit = le64_to_cpu(d->dqb_ihardlimit);\n\t\tm->dqb_isoftlimit = le64_to_cpu(d->dqb_isoftlimit);\n\t}\n\tif (!test_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags))\n\t\tm->dqb_curinodes = le64_to_cpu(d->dqb_curinodes);\n\tif (!test_bit(DQ_LASTSET_B + QIF_BLIMITS_B, &dquot->dq_flags)) {\n\t\tm->dqb_bhardlimit = le64_to_cpu(d->dqb_bhardlimit);\n\t\tm->dqb_bsoftlimit = le64_to_cpu(d->dqb_bsoftlimit);\n\t}\n\tif (!test_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags))\n\t\tm->dqb_curspace = le64_to_cpu(d->dqb_curspace);\n\tif (!test_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags))\n\t\tm->dqb_btime = le64_to_cpu(d->dqb_btime);\n\tif (!test_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags))\n\t\tm->dqb_itime = le64_to_cpu(d->dqb_itime);\n\tOCFS2_DQUOT(dquot)->dq_use_count = le32_to_cpu(d->dqb_use_count);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"quota.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/llist.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/writeback.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "d->dqb_use_count"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_DQUOT",
          "args": [
            "dquot"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_DQUOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota.h",
          "lines": "71-74",
          "snippet": "static inline struct ocfs2_dquot *OCFS2_DQUOT(struct dquot *dquot)\n{\n\treturn container_of(dquot, struct ocfs2_dquot, dq_dquot);\n}",
          "includes": [
            "#include \"ocfs2.h\"",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/list.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2.h\"\n#include <linux/dqblk_qtree.h>\n#include <linux/list.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline struct ocfs2_dquot *OCFS2_DQUOT(struct dquot *dquot)\n{\n\treturn container_of(dquot, struct ocfs2_dquot, dq_dquot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "d->dqb_itime"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "DQ_LASTSET_B + QIF_ITIME_B",
            "&dquot->dq_flags"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstatic void ocfs2_global_disk2memdqb(struct dquot *dquot, void *dp)\n{\n\tstruct ocfs2_global_disk_dqblk *d = dp;\n\tstruct mem_dqblk *m = &dquot->dq_dqb;\n\n\t/* Update from disk only entries not set by the admin */\n\tif (!test_bit(DQ_LASTSET_B + QIF_ILIMITS_B, &dquot->dq_flags)) {\n\t\tm->dqb_ihardlimit = le64_to_cpu(d->dqb_ihardlimit);\n\t\tm->dqb_isoftlimit = le64_to_cpu(d->dqb_isoftlimit);\n\t}\n\tif (!test_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags))\n\t\tm->dqb_curinodes = le64_to_cpu(d->dqb_curinodes);\n\tif (!test_bit(DQ_LASTSET_B + QIF_BLIMITS_B, &dquot->dq_flags)) {\n\t\tm->dqb_bhardlimit = le64_to_cpu(d->dqb_bhardlimit);\n\t\tm->dqb_bsoftlimit = le64_to_cpu(d->dqb_bsoftlimit);\n\t}\n\tif (!test_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags))\n\t\tm->dqb_curspace = le64_to_cpu(d->dqb_curspace);\n\tif (!test_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags))\n\t\tm->dqb_btime = le64_to_cpu(d->dqb_btime);\n\tif (!test_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags))\n\t\tm->dqb_itime = le64_to_cpu(d->dqb_itime);\n\tOCFS2_DQUOT(dquot)->dq_use_count = le32_to_cpu(d->dqb_use_count);\n}"
  }
]