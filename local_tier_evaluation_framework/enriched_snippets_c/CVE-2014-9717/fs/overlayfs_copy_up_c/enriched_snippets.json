[
  {
    "function_name": "ovl_copy_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
    "lines": "375-413",
    "snippet": "int ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/splice.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "next"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_copy_up_one",
          "args": [
            "parent",
            "next",
            "&lowerpath",
            "&stat",
            "NULL"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_copy_up_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
          "lines": "288-373",
          "snippet": "int ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,\n\t\t    struct path *lowerpath, struct kstat *stat,\n\t\t    struct iattr *attr)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tint err;\n\tstruct kstat pstat;\n\tstruct path parentpath;\n\tstruct dentry *upperdir;\n\tstruct dentry *upperdentry;\n\tconst struct cred *old_cred;\n\tstruct cred *override_cred;\n\tchar *link = NULL;\n\n\tovl_path_upper(parent, &parentpath);\n\tupperdir = parentpath.dentry;\n\n\terr = vfs_getattr(&parentpath, &pstat);\n\tif (err)\n\t\treturn err;\n\n\tif (S_ISLNK(stat->mode)) {\n\t\tlink = ovl_read_symlink(lowerpath->dentry);\n\t\tif (IS_ERR(link))\n\t\t\treturn PTR_ERR(link);\n\t}\n\n\terr = -ENOMEM;\n\toverride_cred = prepare_creds();\n\tif (!override_cred)\n\t\tgoto out_free_link;\n\n\toverride_cred->fsuid = stat->uid;\n\toverride_cred->fsgid = stat->gid;\n\t/*\n\t * CAP_SYS_ADMIN for copying up extended attributes\n\t * CAP_DAC_OVERRIDE for create\n\t * CAP_FOWNER for chmod, timestamp update\n\t * CAP_FSETID for chmod\n\t * CAP_CHOWN for chown\n\t * CAP_MKNOD for mknod\n\t */\n\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\tcap_raise(override_cred->cap_effective, CAP_MKNOD);\n\told_cred = override_creds(override_cred);\n\n\terr = -EIO;\n\tif (lock_rename(workdir, upperdir) != NULL) {\n\t\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\t\tgoto out_unlock;\n\t}\n\tupperdentry = ovl_dentry_upper(dentry);\n\tif (upperdentry) {\n\t\tunlock_rename(workdir, upperdir);\n\t\terr = 0;\n\t\t/* Raced with another copy-up?  Do the setattr here */\n\t\tif (attr) {\n\t\t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n\t\t\terr = notify_change(upperdentry, attr, NULL);\n\t\t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t\t}\n\t\tgoto out_put_cred;\n\t}\n\n\terr = ovl_copy_up_locked(workdir, upperdir, dentry, lowerpath,\n\t\t\t\t stat, attr, link);\n\tif (!err) {\n\t\t/* Restore timestamps on parent (best effort) */\n\t\tovl_set_timestamps(upperdir, &pstat);\n\t}\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout_put_cred:\n\trevert_creds(old_cred);\n\tput_cred(override_cred);\n\nout_free_link:\n\tif (link)\n\t\tfree_page((unsigned long) link);\n\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,\n\t\t    struct path *lowerpath, struct kstat *stat,\n\t\t    struct iattr *attr)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tint err;\n\tstruct kstat pstat;\n\tstruct path parentpath;\n\tstruct dentry *upperdir;\n\tstruct dentry *upperdentry;\n\tconst struct cred *old_cred;\n\tstruct cred *override_cred;\n\tchar *link = NULL;\n\n\tovl_path_upper(parent, &parentpath);\n\tupperdir = parentpath.dentry;\n\n\terr = vfs_getattr(&parentpath, &pstat);\n\tif (err)\n\t\treturn err;\n\n\tif (S_ISLNK(stat->mode)) {\n\t\tlink = ovl_read_symlink(lowerpath->dentry);\n\t\tif (IS_ERR(link))\n\t\t\treturn PTR_ERR(link);\n\t}\n\n\terr = -ENOMEM;\n\toverride_cred = prepare_creds();\n\tif (!override_cred)\n\t\tgoto out_free_link;\n\n\toverride_cred->fsuid = stat->uid;\n\toverride_cred->fsgid = stat->gid;\n\t/*\n\t * CAP_SYS_ADMIN for copying up extended attributes\n\t * CAP_DAC_OVERRIDE for create\n\t * CAP_FOWNER for chmod, timestamp update\n\t * CAP_FSETID for chmod\n\t * CAP_CHOWN for chown\n\t * CAP_MKNOD for mknod\n\t */\n\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\tcap_raise(override_cred->cap_effective, CAP_MKNOD);\n\told_cred = override_creds(override_cred);\n\n\terr = -EIO;\n\tif (lock_rename(workdir, upperdir) != NULL) {\n\t\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\t\tgoto out_unlock;\n\t}\n\tupperdentry = ovl_dentry_upper(dentry);\n\tif (upperdentry) {\n\t\tunlock_rename(workdir, upperdir);\n\t\terr = 0;\n\t\t/* Raced with another copy-up?  Do the setattr here */\n\t\tif (attr) {\n\t\t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n\t\t\terr = notify_change(upperdentry, attr, NULL);\n\t\t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t\t}\n\t\tgoto out_put_cred;\n\t}\n\n\terr = ovl_copy_up_locked(workdir, upperdir, dentry, lowerpath,\n\t\t\t\t stat, attr, link);\n\tif (!err) {\n\t\t/* Restore timestamps on parent (best effort) */\n\t\tovl_set_timestamps(upperdir, &pstat);\n\t}\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout_put_cred:\n\trevert_creds(old_cred);\n\tput_cred(override_cred);\n\nout_free_link:\n\tif (link)\n\t\tfree_page((unsigned long) link);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_getattr",
          "args": [
            "&lowerpath",
            "&stat"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "65-73",
          "snippet": "int vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint retval;\n\n\tretval = security_inode_getattr(path->mnt, path->dentry);\n\tif (retval)\n\t\treturn retval;\n\treturn vfs_getattr_nosec(path, stat);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nint vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint retval;\n\n\tretval = security_inode_getattr(path->mnt, path->dentry);\n\tif (retval)\n\t\treturn retval;\n\treturn vfs_getattr_nosec(path, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_path_lower",
          "args": [
            "next",
            "&lowerpath"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "171-176",
          "snippet": "void ovl_path_lower(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\t*path = oe->numlower ? oe->lowerstack[0] : (struct path) { NULL, NULL };\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_path_lower(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\t*path = oe->numlower ? oe->lowerstack[0] : (struct path) { NULL, NULL };\n}"
        }
      },
      {
        "call_info": {
          "callee": "OVL_TYPE_UPPER",
          "args": [
            "type"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_path_type",
          "args": [
            "parent"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "70-89",
          "snippet": "enum ovl_path_type ovl_path_type(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tenum ovl_path_type type = 0;\n\n\tif (oe->__upperdentry) {\n\t\ttype = __OVL_PATH_UPPER;\n\n\t\tif (oe->numlower) {\n\t\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\t\ttype |= __OVL_PATH_MERGE;\n\t\t} else if (!oe->opaque) {\n\t\t\ttype |= __OVL_PATH_PURE;\n\t\t}\n\t} else {\n\t\tif (oe->numlower > 1)\n\t\t\ttype |= __OVL_PATH_MERGE;\n\t}\n\treturn type;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tenum ovl_path_type type = 0;\n\n\tif (oe->__upperdentry) {\n\t\ttype = __OVL_PATH_UPPER;\n\n\t\tif (oe->numlower) {\n\t\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\t\ttype |= __OVL_PATH_MERGE;\n\t\t} else if (!oe->opaque) {\n\t\t\ttype |= __OVL_PATH_PURE;\n\t\t}\n\t} else {\n\t\tif (oe->numlower > 1)\n\t\t\ttype |= __OVL_PATH_MERGE;\n\t}\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "next"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OVL_TYPE_UPPER",
          "args": [
            "type"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_copy_up(struct dentry *dentry)\n{\n\tint err;\n\n\terr = 0;\n\twhile (!err) {\n\t\tstruct dentry *next;\n\t\tstruct dentry *parent;\n\t\tstruct path lowerpath;\n\t\tstruct kstat stat;\n\t\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\t\tif (OVL_TYPE_UPPER(type))\n\t\t\tbreak;\n\n\t\tnext = dget(dentry);\n\t\t/* find the topmost dentry not yet copied up */\n\t\tfor (;;) {\n\t\t\tparent = dget_parent(next);\n\n\t\t\ttype = ovl_path_type(parent);\n\t\t\tif (OVL_TYPE_UPPER(type))\n\t\t\t\tbreak;\n\n\t\t\tdput(next);\n\t\t\tnext = parent;\n\t\t}\n\n\t\tovl_path_lower(next, &lowerpath);\n\t\terr = vfs_getattr(&lowerpath, &stat);\n\t\tif (!err)\n\t\t\terr = ovl_copy_up_one(parent, next, &lowerpath, &stat, NULL);\n\n\t\tdput(parent);\n\t\tdput(next);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_copy_up_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
    "lines": "288-373",
    "snippet": "int ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,\n\t\t    struct path *lowerpath, struct kstat *stat,\n\t\t    struct iattr *attr)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tint err;\n\tstruct kstat pstat;\n\tstruct path parentpath;\n\tstruct dentry *upperdir;\n\tstruct dentry *upperdentry;\n\tconst struct cred *old_cred;\n\tstruct cred *override_cred;\n\tchar *link = NULL;\n\n\tovl_path_upper(parent, &parentpath);\n\tupperdir = parentpath.dentry;\n\n\terr = vfs_getattr(&parentpath, &pstat);\n\tif (err)\n\t\treturn err;\n\n\tif (S_ISLNK(stat->mode)) {\n\t\tlink = ovl_read_symlink(lowerpath->dentry);\n\t\tif (IS_ERR(link))\n\t\t\treturn PTR_ERR(link);\n\t}\n\n\terr = -ENOMEM;\n\toverride_cred = prepare_creds();\n\tif (!override_cred)\n\t\tgoto out_free_link;\n\n\toverride_cred->fsuid = stat->uid;\n\toverride_cred->fsgid = stat->gid;\n\t/*\n\t * CAP_SYS_ADMIN for copying up extended attributes\n\t * CAP_DAC_OVERRIDE for create\n\t * CAP_FOWNER for chmod, timestamp update\n\t * CAP_FSETID for chmod\n\t * CAP_CHOWN for chown\n\t * CAP_MKNOD for mknod\n\t */\n\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\tcap_raise(override_cred->cap_effective, CAP_MKNOD);\n\told_cred = override_creds(override_cred);\n\n\terr = -EIO;\n\tif (lock_rename(workdir, upperdir) != NULL) {\n\t\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\t\tgoto out_unlock;\n\t}\n\tupperdentry = ovl_dentry_upper(dentry);\n\tif (upperdentry) {\n\t\tunlock_rename(workdir, upperdir);\n\t\terr = 0;\n\t\t/* Raced with another copy-up?  Do the setattr here */\n\t\tif (attr) {\n\t\t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n\t\t\terr = notify_change(upperdentry, attr, NULL);\n\t\t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t\t}\n\t\tgoto out_put_cred;\n\t}\n\n\terr = ovl_copy_up_locked(workdir, upperdir, dentry, lowerpath,\n\t\t\t\t stat, attr, link);\n\tif (!err) {\n\t\t/* Restore timestamps on parent (best effort) */\n\t\tovl_set_timestamps(upperdir, &pstat);\n\t}\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout_put_cred:\n\trevert_creds(old_cred);\n\tput_cred(override_cred);\n\nout_free_link:\n\tif (link)\n\t\tfree_page((unsigned long) link);\n\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/splice.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long) link"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "override_cred"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "revert_creds",
          "args": [
            "old_cred"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_rename",
          "args": [
            "workdir",
            "upperdir"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2537-2544",
          "snippet": "void unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_set_timestamps",
          "args": [
            "upperdir",
            "&pstat"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_set_timestamps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
          "lines": "159-169",
          "snippet": "static int ovl_set_timestamps(struct dentry *upperdentry, struct kstat *stat)\n{\n\tstruct iattr attr = {\n\t\t.ia_valid =\n\t\t     ATTR_ATIME | ATTR_MTIME | ATTR_ATIME_SET | ATTR_MTIME_SET,\n\t\t.ia_atime = stat->atime,\n\t\t.ia_mtime = stat->mtime,\n\t};\n\n\treturn notify_change(upperdentry, &attr, NULL);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_set_timestamps(struct dentry *upperdentry, struct kstat *stat)\n{\n\tstruct iattr attr = {\n\t\t.ia_valid =\n\t\t     ATTR_ATIME | ATTR_MTIME | ATTR_ATIME_SET | ATTR_MTIME_SET,\n\t\t.ia_atime = stat->atime,\n\t\t.ia_mtime = stat->mtime,\n\t};\n\n\treturn notify_change(upperdentry, &attr, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_copy_up_locked",
          "args": [
            "workdir",
            "upperdir",
            "dentry",
            "lowerpath",
            "stat",
            "attr",
            "link"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_copy_up_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
          "lines": "196-271",
          "snippet": "static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,\n\t\t\t      struct dentry *dentry, struct path *lowerpath,\n\t\t\t      struct kstat *stat, struct iattr *attr,\n\t\t\t      const char *link)\n{\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry = NULL;\n\tstruct dentry *upper = NULL;\n\tumode_t mode = stat->mode;\n\tint err;\n\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out;\n\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out1;\n\n\t/* Can't properly set mode on creation because of the umask */\n\tstat->mode &= S_IFMT;\n\terr = ovl_create_real(wdir, newdentry, stat, link, NULL, true);\n\tstat->mode = mode;\n\tif (err)\n\t\tgoto out2;\n\n\tif (S_ISREG(stat->mode)) {\n\t\tstruct path upperpath;\n\t\tovl_path_upper(dentry, &upperpath);\n\t\tBUG_ON(upperpath.dentry != NULL);\n\t\tupperpath.dentry = newdentry;\n\n\t\terr = ovl_copy_up_data(lowerpath, &upperpath, stat->size);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\n\terr = ovl_copy_xattr(lowerpath->dentry, newdentry);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tmutex_lock(&newdentry->d_inode->i_mutex);\n\terr = ovl_set_attr(newdentry, stat);\n\tif (!err && attr)\n\t\terr = notify_change(newdentry, attr, NULL);\n\tmutex_unlock(&newdentry->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tovl_dentry_update(dentry, newdentry);\n\tnewdentry = NULL;\n\n\t/*\n\t * Non-directores become opaque when copied up.\n\t */\n\tif (!S_ISDIR(stat->mode))\n\t\tovl_dentry_set_opaque(dentry, true);\nout2:\n\tdput(upper);\nout1:\n\tdput(newdentry);\nout:\n\treturn err;\n\nout_cleanup:\n\tovl_cleanup(wdir, newdentry);\n\tgoto out;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,\n\t\t\t      struct dentry *dentry, struct path *lowerpath,\n\t\t\t      struct kstat *stat, struct iattr *attr,\n\t\t\t      const char *link)\n{\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry = NULL;\n\tstruct dentry *upper = NULL;\n\tumode_t mode = stat->mode;\n\tint err;\n\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out;\n\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out1;\n\n\t/* Can't properly set mode on creation because of the umask */\n\tstat->mode &= S_IFMT;\n\terr = ovl_create_real(wdir, newdentry, stat, link, NULL, true);\n\tstat->mode = mode;\n\tif (err)\n\t\tgoto out2;\n\n\tif (S_ISREG(stat->mode)) {\n\t\tstruct path upperpath;\n\t\tovl_path_upper(dentry, &upperpath);\n\t\tBUG_ON(upperpath.dentry != NULL);\n\t\tupperpath.dentry = newdentry;\n\n\t\terr = ovl_copy_up_data(lowerpath, &upperpath, stat->size);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\n\terr = ovl_copy_xattr(lowerpath->dentry, newdentry);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tmutex_lock(&newdentry->d_inode->i_mutex);\n\terr = ovl_set_attr(newdentry, stat);\n\tif (!err && attr)\n\t\terr = notify_change(newdentry, attr, NULL);\n\tmutex_unlock(&newdentry->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tovl_dentry_update(dentry, newdentry);\n\tnewdentry = NULL;\n\n\t/*\n\t * Non-directores become opaque when copied up.\n\t */\n\tif (!S_ISDIR(stat->mode))\n\t\tovl_dentry_set_opaque(dentry, true);\nout2:\n\tdput(upper);\nout1:\n\tdput(newdentry);\nout:\n\treturn err;\n\nout_cleanup:\n\tovl_cleanup(wdir, newdentry);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&upperdentry->d_inode->i_mutex"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_change",
          "args": [
            "upperdentry",
            "attr",
            "NULL"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "190-277",
          "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&upperdentry->d_inode->i_mutex"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_dentry_upper",
          "args": [
            "dentry"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "117-122",
          "snippet": "struct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: failed to lock workdir+upperdir\\n\""
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_rename",
          "args": [
            "workdir",
            "upperdir"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_lock_rename_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "192-210",
          "snippet": "static int ovl_lock_rename_workdir(struct dentry *workdir,\n\t\t\t\t   struct dentry *upperdir)\n{\n\t/* Workdir should not be the same as upperdir */\n\tif (workdir == upperdir)\n\t\tgoto err;\n\n\t/* Workdir should not be subdir of upperdir and vice versa */\n\tif (lock_rename(workdir, upperdir) != NULL)\n\t\tgoto err_unlock;\n\n\treturn 0;\n\nerr_unlock:\n\tunlock_rename(workdir, upperdir);\nerr:\n\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\treturn -EIO;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_lock_rename_workdir(struct dentry *workdir,\n\t\t\t\t   struct dentry *upperdir)\n{\n\t/* Workdir should not be the same as upperdir */\n\tif (workdir == upperdir)\n\t\tgoto err;\n\n\t/* Workdir should not be subdir of upperdir and vice versa */\n\tif (lock_rename(workdir, upperdir) != NULL)\n\t\tgoto err_unlock;\n\n\treturn 0;\n\nerr_unlock:\n\tunlock_rename(workdir, upperdir);\nerr:\n\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "override_creds",
          "args": [
            "override_cred"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_MKNOD"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_CHOWN"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_FSETID"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_FOWNER"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_DAC_OVERRIDE"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "override_cred->cap_effective",
            "CAP_SYS_ADMIN"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "link"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "link"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_read_symlink",
          "args": [
            "lowerpath->dentry"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_read_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
          "lines": "125-157",
          "snippet": "static char *ovl_read_symlink(struct dentry *realdentry)\n{\n\tint res;\n\tchar *buf;\n\tstruct inode *inode = realdentry->d_inode;\n\tmm_segment_t old_fs;\n\n\tres = -EINVAL;\n\tif (!inode->i_op->readlink)\n\t\tgoto err;\n\n\tres = -ENOMEM;\n\tbuf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = inode->i_op->readlink(realdentry,\n\t\t\t\t    (char __user *)buf, PAGE_SIZE - 1);\n\tset_fs(old_fs);\n\tif (res < 0) {\n\t\tfree_page((unsigned long) buf);\n\t\tgoto err;\n\t}\n\tbuf[res] = '\\0';\n\n\treturn buf;\n\nerr:\n\treturn ERR_PTR(res);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic char *ovl_read_symlink(struct dentry *realdentry)\n{\n\tint res;\n\tchar *buf;\n\tstruct inode *inode = realdentry->d_inode;\n\tmm_segment_t old_fs;\n\n\tres = -EINVAL;\n\tif (!inode->i_op->readlink)\n\t\tgoto err;\n\n\tres = -ENOMEM;\n\tbuf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = inode->i_op->readlink(realdentry,\n\t\t\t\t    (char __user *)buf, PAGE_SIZE - 1);\n\tset_fs(old_fs);\n\tif (res < 0) {\n\t\tfree_page((unsigned long) buf);\n\t\tgoto err;\n\t}\n\tbuf[res] = '\\0';\n\n\treturn buf;\n\nerr:\n\treturn ERR_PTR(res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "stat->mode"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_getattr",
          "args": [
            "&parentpath",
            "&pstat"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "65-73",
          "snippet": "int vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint retval;\n\n\tretval = security_inode_getattr(path->mnt, path->dentry);\n\tif (retval)\n\t\treturn retval;\n\treturn vfs_getattr_nosec(path, stat);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nint vfs_getattr(struct path *path, struct kstat *stat)\n{\n\tint retval;\n\n\tretval = security_inode_getattr(path->mnt, path->dentry);\n\tif (retval)\n\t\treturn retval;\n\treturn vfs_getattr_nosec(path, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_path_upper",
          "args": [
            "parent",
            "&parentpath"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "96-103",
          "snippet": "void ovl_path_upper(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tpath->mnt = ofs->upper_mnt;\n\tpath->dentry = ovl_upperdentry_dereference(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_path_upper(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tpath->mnt = ofs->upper_mnt;\n\tpath->dentry = ovl_upperdentry_dereference(oe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_workdir",
          "args": [
            "dentry"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "190-194",
          "snippet": "struct dentry *ovl_workdir(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn ofs->workdir;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_workdir(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn ofs->workdir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,\n\t\t    struct path *lowerpath, struct kstat *stat,\n\t\t    struct iattr *attr)\n{\n\tstruct dentry *workdir = ovl_workdir(dentry);\n\tint err;\n\tstruct kstat pstat;\n\tstruct path parentpath;\n\tstruct dentry *upperdir;\n\tstruct dentry *upperdentry;\n\tconst struct cred *old_cred;\n\tstruct cred *override_cred;\n\tchar *link = NULL;\n\n\tovl_path_upper(parent, &parentpath);\n\tupperdir = parentpath.dentry;\n\n\terr = vfs_getattr(&parentpath, &pstat);\n\tif (err)\n\t\treturn err;\n\n\tif (S_ISLNK(stat->mode)) {\n\t\tlink = ovl_read_symlink(lowerpath->dentry);\n\t\tif (IS_ERR(link))\n\t\t\treturn PTR_ERR(link);\n\t}\n\n\terr = -ENOMEM;\n\toverride_cred = prepare_creds();\n\tif (!override_cred)\n\t\tgoto out_free_link;\n\n\toverride_cred->fsuid = stat->uid;\n\toverride_cred->fsgid = stat->gid;\n\t/*\n\t * CAP_SYS_ADMIN for copying up extended attributes\n\t * CAP_DAC_OVERRIDE for create\n\t * CAP_FOWNER for chmod, timestamp update\n\t * CAP_FSETID for chmod\n\t * CAP_CHOWN for chown\n\t * CAP_MKNOD for mknod\n\t */\n\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\tcap_raise(override_cred->cap_effective, CAP_MKNOD);\n\told_cred = override_creds(override_cred);\n\n\terr = -EIO;\n\tif (lock_rename(workdir, upperdir) != NULL) {\n\t\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\t\tgoto out_unlock;\n\t}\n\tupperdentry = ovl_dentry_upper(dentry);\n\tif (upperdentry) {\n\t\tunlock_rename(workdir, upperdir);\n\t\terr = 0;\n\t\t/* Raced with another copy-up?  Do the setattr here */\n\t\tif (attr) {\n\t\t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n\t\t\terr = notify_change(upperdentry, attr, NULL);\n\t\t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t\t}\n\t\tgoto out_put_cred;\n\t}\n\n\terr = ovl_copy_up_locked(workdir, upperdir, dentry, lowerpath,\n\t\t\t\t stat, attr, link);\n\tif (!err) {\n\t\t/* Restore timestamps on parent (best effort) */\n\t\tovl_set_timestamps(upperdir, &pstat);\n\t}\nout_unlock:\n\tunlock_rename(workdir, upperdir);\nout_put_cred:\n\trevert_creds(old_cred);\n\tput_cred(override_cred);\n\nout_free_link:\n\tif (link)\n\t\tfree_page((unsigned long) link);\n\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_copy_up_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
    "lines": "196-271",
    "snippet": "static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,\n\t\t\t      struct dentry *dentry, struct path *lowerpath,\n\t\t\t      struct kstat *stat, struct iattr *attr,\n\t\t\t      const char *link)\n{\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry = NULL;\n\tstruct dentry *upper = NULL;\n\tumode_t mode = stat->mode;\n\tint err;\n\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out;\n\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out1;\n\n\t/* Can't properly set mode on creation because of the umask */\n\tstat->mode &= S_IFMT;\n\terr = ovl_create_real(wdir, newdentry, stat, link, NULL, true);\n\tstat->mode = mode;\n\tif (err)\n\t\tgoto out2;\n\n\tif (S_ISREG(stat->mode)) {\n\t\tstruct path upperpath;\n\t\tovl_path_upper(dentry, &upperpath);\n\t\tBUG_ON(upperpath.dentry != NULL);\n\t\tupperpath.dentry = newdentry;\n\n\t\terr = ovl_copy_up_data(lowerpath, &upperpath, stat->size);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\n\terr = ovl_copy_xattr(lowerpath->dentry, newdentry);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tmutex_lock(&newdentry->d_inode->i_mutex);\n\terr = ovl_set_attr(newdentry, stat);\n\tif (!err && attr)\n\t\terr = notify_change(newdentry, attr, NULL);\n\tmutex_unlock(&newdentry->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tovl_dentry_update(dentry, newdentry);\n\tnewdentry = NULL;\n\n\t/*\n\t * Non-directores become opaque when copied up.\n\t */\n\tif (!S_ISDIR(stat->mode))\n\t\tovl_dentry_set_opaque(dentry, true);\nout2:\n\tdput(upper);\nout1:\n\tdput(newdentry);\nout:\n\treturn err;\n\nout_cleanup:\n\tovl_cleanup(wdir, newdentry);\n\tgoto out;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/splice.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_cleanup",
          "args": [
            "wdir",
            "newdentry"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cleanup_whiteouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "535-557",
          "snippet": "void ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list)\n{\n\tstruct ovl_cache_entry *p;\n\n\tmutex_lock_nested(&upper->d_inode->i_mutex, I_MUTEX_CHILD);\n\tlist_for_each_entry(p, list, l_node) {\n\t\tstruct dentry *dentry;\n\n\t\tif (!p->is_whiteout)\n\t\t\tcontinue;\n\n\t\tdentry = lookup_one_len(p->name, upper, p->len);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tpr_err(\"overlayfs: lookup '%s/%.*s' failed (%i)\\n\",\n\t\t\t       upper->d_name.name, p->len, p->name,\n\t\t\t       (int) PTR_ERR(dentry));\n\t\t\tcontinue;\n\t\t}\n\t\tovl_cleanup(upper->d_inode, dentry);\n\t\tdput(dentry);\n\t}\n\tmutex_unlock(&upper->d_inode->i_mutex);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list)\n{\n\tstruct ovl_cache_entry *p;\n\n\tmutex_lock_nested(&upper->d_inode->i_mutex, I_MUTEX_CHILD);\n\tlist_for_each_entry(p, list, l_node) {\n\t\tstruct dentry *dentry;\n\n\t\tif (!p->is_whiteout)\n\t\t\tcontinue;\n\n\t\tdentry = lookup_one_len(p->name, upper, p->len);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tpr_err(\"overlayfs: lookup '%s/%.*s' failed (%i)\\n\",\n\t\t\t       upper->d_name.name, p->len, p->name,\n\t\t\t       (int) PTR_ERR(dentry));\n\t\t\tcontinue;\n\t\t}\n\t\tovl_cleanup(upper->d_inode, dentry);\n\t\tdput(dentry);\n\t}\n\tmutex_unlock(&upper->d_inode->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "newdentry"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_dentry_set_opaque",
          "args": [
            "dentry",
            "true"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_set_opaque",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "202-206",
          "snippet": "void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\toe->opaque = opaque;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_dentry_set_opaque(struct dentry *dentry, bool opaque)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\toe->opaque = opaque;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "stat->mode"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_dentry_update",
          "args": [
            "dentry",
            "newdentry"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "208-221",
          "snippet": "void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&upperdentry->d_parent->d_inode->i_mutex));\n\tWARN_ON(oe->__upperdentry);\n\tBUG_ON(!upperdentry->d_inode);\n\t/*\n\t * Make sure upperdentry is consistent before making it visible to\n\t * ovl_upperdentry_dereference().\n\t */\n\tsmp_wmb();\n\toe->__upperdentry = upperdentry;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&upperdentry->d_parent->d_inode->i_mutex));\n\tWARN_ON(oe->__upperdentry);\n\tBUG_ON(!upperdentry->d_inode);\n\t/*\n\t * Make sure upperdentry is consistent before making it visible to\n\t * ovl_upperdentry_dereference().\n\t */\n\tsmp_wmb();\n\toe->__upperdentry = upperdentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_do_rename",
          "args": [
            "wdir",
            "newdentry",
            "udir",
            "upper",
            "0"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_do_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
          "lines": "109-125",
          "snippet": "static inline int ovl_do_rename(struct inode *olddir, struct dentry *olddentry,\n\t\t\t\tstruct inode *newdir, struct dentry *newdentry,\n\t\t\t\tunsigned int flags)\n{\n\tint err;\n\n\tpr_debug(\"rename2(%pd2, %pd2, 0x%x)\\n\",\n\t\t olddentry, newdentry, flags);\n\n\terr = vfs_rename(olddir, olddentry, newdir, newdentry, NULL, flags);\n\n\tif (err) {\n\t\tpr_debug(\"...rename2(%pd2, %pd2, ...) = %i\\n\",\n\t\t\t olddentry, newdentry, err);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum ovl_path_type ovl_path_type(struct dentry *dentry);",
            "u64 ovl_dentry_version_get(struct dentry *dentry);",
            "void ovl_dentry_version_inc(struct dentry *dentry);",
            "struct dentry *ovl_dentry_upper(struct dentry *dentry);",
            "struct dentry *ovl_dentry_lower(struct dentry *dentry);",
            "struct dentry *ovl_dentry_real(struct dentry *dentry);",
            "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);",
            "struct dentry *ovl_workdir(struct dentry *dentry);",
            "int ovl_want_write(struct dentry *dentry);",
            "void ovl_drop_write(struct dentry *dentry);",
            "bool ovl_dentry_is_opaque(struct dentry *dentry);",
            "bool ovl_is_whiteout(struct dentry *dentry);",
            "struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags);",
            "struct file *ovl_path_open(struct path *path, int flags);",
            "int ovl_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags);",
            "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);",
            "void ovl_cleanup(struct inode *dir, struct dentry *dentry);",
            "int ovl_copy_up(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry);\nu64 ovl_dentry_version_get(struct dentry *dentry);\nvoid ovl_dentry_version_inc(struct dentry *dentry);\nstruct dentry *ovl_dentry_upper(struct dentry *dentry);\nstruct dentry *ovl_dentry_lower(struct dentry *dentry);\nstruct dentry *ovl_dentry_real(struct dentry *dentry);\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\nstruct dentry *ovl_workdir(struct dentry *dentry);\nint ovl_want_write(struct dentry *dentry);\nvoid ovl_drop_write(struct dentry *dentry);\nbool ovl_dentry_is_opaque(struct dentry *dentry);\nbool ovl_is_whiteout(struct dentry *dentry);\nstruct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags);\nstruct file *ovl_path_open(struct path *path, int flags);\nint ovl_setxattr(struct dentry *dentry, const char *name,\n\t\t const void *value, size_t size, int flags);\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry);\nvoid ovl_cleanup(struct inode *dir, struct dentry *dentry);\nint ovl_copy_up(struct dentry *dentry);\n\nstatic inline int ovl_do_rename(struct inode *olddir, struct dentry *olddentry,\n\t\t\t\tstruct inode *newdir, struct dentry *newdentry,\n\t\t\t\tunsigned int flags)\n{\n\tint err;\n\n\tpr_debug(\"rename2(%pd2, %pd2, 0x%x)\\n\",\n\t\t olddentry, newdentry, flags);\n\n\terr = vfs_rename(olddir, olddentry, newdir, newdentry, NULL, flags);\n\n\tif (err) {\n\t\tpr_debug(\"...rename2(%pd2, %pd2, ...) = %i\\n\",\n\t\t\t olddentry, newdentry, err);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&newdentry->d_inode->i_mutex"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_change",
          "args": [
            "newdentry",
            "attr",
            "NULL"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "190-277",
          "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_set_attr",
          "args": [
            "newdentry",
            "stat"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_set_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
          "lines": "171-194",
          "snippet": "int ovl_set_attr(struct dentry *upperdentry, struct kstat *stat)\n{\n\tint err = 0;\n\n\tif (!S_ISLNK(stat->mode)) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_MODE,\n\t\t\t.ia_mode = stat->mode,\n\t\t};\n\t\terr = notify_change(upperdentry, &attr, NULL);\n\t}\n\tif (!err) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_UID | ATTR_GID,\n\t\t\t.ia_uid = stat->uid,\n\t\t\t.ia_gid = stat->gid,\n\t\t};\n\t\terr = notify_change(upperdentry, &attr, NULL);\n\t}\n\tif (!err)\n\t\tovl_set_timestamps(upperdentry, stat);\n\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_set_attr(struct dentry *upperdentry, struct kstat *stat)\n{\n\tint err = 0;\n\n\tif (!S_ISLNK(stat->mode)) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_MODE,\n\t\t\t.ia_mode = stat->mode,\n\t\t};\n\t\terr = notify_change(upperdentry, &attr, NULL);\n\t}\n\tif (!err) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_UID | ATTR_GID,\n\t\t\t.ia_uid = stat->uid,\n\t\t\t.ia_gid = stat->gid,\n\t\t};\n\t\terr = notify_change(upperdentry, &attr, NULL);\n\t}\n\tif (!err)\n\t\tovl_set_timestamps(upperdentry, stat);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&newdentry->d_inode->i_mutex"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_copy_xattr",
          "args": [
            "lowerpath->dentry",
            "newdentry"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_copy_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
          "lines": "23-71",
          "snippet": "int ovl_copy_xattr(struct dentry *old, struct dentry *new)\n{\n\tssize_t list_size, size;\n\tchar *buf, *name, *value;\n\tint error;\n\n\tif (!old->d_inode->i_op->getxattr ||\n\t    !new->d_inode->i_op->getxattr)\n\t\treturn 0;\n\n\tlist_size = vfs_listxattr(old, NULL, 0);\n\tif (list_size <= 0) {\n\t\tif (list_size == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn list_size;\n\t}\n\n\tbuf = kzalloc(list_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\terror = -ENOMEM;\n\tvalue = kmalloc(XATTR_SIZE_MAX, GFP_KERNEL);\n\tif (!value)\n\t\tgoto out;\n\n\tlist_size = vfs_listxattr(old, buf, list_size);\n\tif (list_size <= 0) {\n\t\terror = list_size;\n\t\tgoto out_free_value;\n\t}\n\n\tfor (name = buf; name < (buf + list_size); name += strlen(name) + 1) {\n\t\tsize = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);\n\t\tif (size <= 0) {\n\t\t\terror = size;\n\t\t\tgoto out_free_value;\n\t\t}\n\t\terror = vfs_setxattr(new, name, value, size, 0);\n\t\tif (error)\n\t\t\tgoto out_free_value;\n\t}\n\nout_free_value:\n\tkfree(value);\nout:\n\tkfree(buf);\n\treturn error;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_copy_xattr(struct dentry *old, struct dentry *new)\n{\n\tssize_t list_size, size;\n\tchar *buf, *name, *value;\n\tint error;\n\n\tif (!old->d_inode->i_op->getxattr ||\n\t    !new->d_inode->i_op->getxattr)\n\t\treturn 0;\n\n\tlist_size = vfs_listxattr(old, NULL, 0);\n\tif (list_size <= 0) {\n\t\tif (list_size == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn list_size;\n\t}\n\n\tbuf = kzalloc(list_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\terror = -ENOMEM;\n\tvalue = kmalloc(XATTR_SIZE_MAX, GFP_KERNEL);\n\tif (!value)\n\t\tgoto out;\n\n\tlist_size = vfs_listxattr(old, buf, list_size);\n\tif (list_size <= 0) {\n\t\terror = list_size;\n\t\tgoto out_free_value;\n\t}\n\n\tfor (name = buf; name < (buf + list_size); name += strlen(name) + 1) {\n\t\tsize = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);\n\t\tif (size <= 0) {\n\t\t\terror = size;\n\t\t\tgoto out_free_value;\n\t\t}\n\t\terror = vfs_setxattr(new, name, value, size, 0);\n\t\tif (error)\n\t\t\tgoto out_free_value;\n\t}\n\nout_free_value:\n\tkfree(value);\nout:\n\tkfree(buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_copy_up_data",
          "args": [
            "lowerpath",
            "&upperpath",
            "stat->size"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_copy_up_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
          "lines": "73-123",
          "snippet": "static int ovl_copy_up_data(struct path *old, struct path *new, loff_t len)\n{\n\tstruct file *old_file;\n\tstruct file *new_file;\n\tloff_t old_pos = 0;\n\tloff_t new_pos = 0;\n\tint error = 0;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\told_file = ovl_path_open(old, O_RDONLY);\n\tif (IS_ERR(old_file))\n\t\treturn PTR_ERR(old_file);\n\n\tnew_file = ovl_path_open(new, O_WRONLY);\n\tif (IS_ERR(new_file)) {\n\t\terror = PTR_ERR(new_file);\n\t\tgoto out_fput;\n\t}\n\n\t/* FIXME: copy up sparse files efficiently */\n\twhile (len) {\n\t\tsize_t this_len = OVL_COPY_UP_CHUNK_SIZE;\n\t\tlong bytes;\n\n\t\tif (len < this_len)\n\t\t\tthis_len = len;\n\n\t\tif (signal_pending_state(TASK_KILLABLE, current)) {\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tbytes = do_splice_direct(old_file, &old_pos,\n\t\t\t\t\t new_file, &new_pos,\n\t\t\t\t\t this_len, SPLICE_F_MOVE);\n\t\tif (bytes <= 0) {\n\t\t\terror = bytes;\n\t\t\tbreak;\n\t\t}\n\t\tWARN_ON(old_pos != new_pos);\n\n\t\tlen -= bytes;\n\t}\n\n\tfput(new_file);\nout_fput:\n\tfput(old_file);\n\treturn error;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OVL_COPY_UP_CHUNK_SIZE (1 << 20)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\n#define OVL_COPY_UP_CHUNK_SIZE (1 << 20)\n\nstatic int ovl_copy_up_data(struct path *old, struct path *new, loff_t len)\n{\n\tstruct file *old_file;\n\tstruct file *new_file;\n\tloff_t old_pos = 0;\n\tloff_t new_pos = 0;\n\tint error = 0;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\told_file = ovl_path_open(old, O_RDONLY);\n\tif (IS_ERR(old_file))\n\t\treturn PTR_ERR(old_file);\n\n\tnew_file = ovl_path_open(new, O_WRONLY);\n\tif (IS_ERR(new_file)) {\n\t\terror = PTR_ERR(new_file);\n\t\tgoto out_fput;\n\t}\n\n\t/* FIXME: copy up sparse files efficiently */\n\twhile (len) {\n\t\tsize_t this_len = OVL_COPY_UP_CHUNK_SIZE;\n\t\tlong bytes;\n\n\t\tif (len < this_len)\n\t\t\tthis_len = len;\n\n\t\tif (signal_pending_state(TASK_KILLABLE, current)) {\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tbytes = do_splice_direct(old_file, &old_pos,\n\t\t\t\t\t new_file, &new_pos,\n\t\t\t\t\t this_len, SPLICE_F_MOVE);\n\t\tif (bytes <= 0) {\n\t\t\terror = bytes;\n\t\t\tbreak;\n\t\t}\n\t\tWARN_ON(old_pos != new_pos);\n\n\t\tlen -= bytes;\n\t}\n\n\tfput(new_file);\nout_fput:\n\tfput(old_file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "upperpath.dentry != NULL"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_path_upper",
          "args": [
            "dentry",
            "&upperpath"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "96-103",
          "snippet": "void ovl_path_upper(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tpath->mnt = ofs->upper_mnt;\n\tpath->dentry = ovl_upperdentry_dereference(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_path_upper(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tpath->mnt = ofs->upper_mnt;\n\tpath->dentry = ovl_upperdentry_dereference(oe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "stat->mode"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_create_real",
          "args": [
            "wdir",
            "newdentry",
            "stat",
            "link",
            "NULL",
            "true"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_create_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "72-117",
          "snippet": "int ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug)\n{\n\tint err;\n\n\tif (newdentry->d_inode)\n\t\treturn -ESTALE;\n\n\tif (hardlink) {\n\t\terr = ovl_do_link(hardlink, dir, newdentry, debug);\n\t} else {\n\t\tswitch (stat->mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\terr = ovl_do_create(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFDIR:\n\t\t\terr = ovl_do_mkdir(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\tcase S_IFSOCK:\n\t\t\terr = ovl_do_mknod(dir, newdentry,\n\t\t\t\t\t   stat->mode, stat->rdev, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFLNK:\n\t\t\terr = ovl_do_symlink(dir, newdentry, link, debug);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = -EPERM;\n\t\t}\n\t}\n\tif (!err && WARN_ON(!newdentry->d_inode)) {\n\t\t/*\n\t\t * Not quite sure if non-instantiated dentry is legal or not.\n\t\t * VFS doesn't seem to care so check and warn here.\n\t\t */\n\t\terr = -ENOENT;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nint ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug)\n{\n\tint err;\n\n\tif (newdentry->d_inode)\n\t\treturn -ESTALE;\n\n\tif (hardlink) {\n\t\terr = ovl_do_link(hardlink, dir, newdentry, debug);\n\t} else {\n\t\tswitch (stat->mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\terr = ovl_do_create(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFDIR:\n\t\t\terr = ovl_do_mkdir(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\tcase S_IFSOCK:\n\t\t\terr = ovl_do_mknod(dir, newdentry,\n\t\t\t\t\t   stat->mode, stat->rdev, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFLNK:\n\t\t\terr = ovl_do_symlink(dir, newdentry, link, debug);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = -EPERM;\n\t\t}\n\t}\n\tif (!err && WARN_ON(!newdentry->d_inode)) {\n\t\t/*\n\t\t * Not quite sure if non-instantiated dentry is legal or not.\n\t\t * VFS doesn't seem to care so check and warn here.\n\t\t */\n\t\terr = -ENOENT;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "upper"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "upper"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "dentry->d_name.name",
            "upperdir",
            "dentry->d_name.len"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "newdentry"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "newdentry"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_lookup_temp",
          "args": [
            "workdir",
            "dentry"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_lookup_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "34-49",
          "snippet": "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry)\n{\n\tstruct dentry *temp;\n\tchar name[20];\n\n\tsnprintf(name, sizeof(name), \"#%lx\", (unsigned long) dentry);\n\n\ttemp = lookup_one_len(name, workdir, strlen(name));\n\tif (!IS_ERR(temp) && temp->d_inode) {\n\t\tpr_err(\"overlayfs: workdir/%s already exists\\n\", name);\n\t\tdput(temp);\n\t\ttemp = ERR_PTR(-EIO);\n\t}\n\n\treturn temp;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry)\n{\n\tstruct dentry *temp;\n\tchar name[20];\n\n\tsnprintf(name, sizeof(name), \"#%lx\", (unsigned long) dentry);\n\n\ttemp = lookup_one_len(name, workdir, strlen(name));\n\tif (!IS_ERR(temp) && temp->d_inode) {\n\t\tpr_err(\"overlayfs: workdir/%s already exists\\n\", name);\n\t\tdput(temp);\n\t\ttemp = ERR_PTR(-EIO);\n\t}\n\n\treturn temp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,\n\t\t\t      struct dentry *dentry, struct path *lowerpath,\n\t\t\t      struct kstat *stat, struct iattr *attr,\n\t\t\t      const char *link)\n{\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry = NULL;\n\tstruct dentry *upper = NULL;\n\tumode_t mode = stat->mode;\n\tint err;\n\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out;\n\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out1;\n\n\t/* Can't properly set mode on creation because of the umask */\n\tstat->mode &= S_IFMT;\n\terr = ovl_create_real(wdir, newdentry, stat, link, NULL, true);\n\tstat->mode = mode;\n\tif (err)\n\t\tgoto out2;\n\n\tif (S_ISREG(stat->mode)) {\n\t\tstruct path upperpath;\n\t\tovl_path_upper(dentry, &upperpath);\n\t\tBUG_ON(upperpath.dentry != NULL);\n\t\tupperpath.dentry = newdentry;\n\n\t\terr = ovl_copy_up_data(lowerpath, &upperpath, stat->size);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\n\terr = ovl_copy_xattr(lowerpath->dentry, newdentry);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tmutex_lock(&newdentry->d_inode->i_mutex);\n\terr = ovl_set_attr(newdentry, stat);\n\tif (!err && attr)\n\t\terr = notify_change(newdentry, attr, NULL);\n\tmutex_unlock(&newdentry->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tovl_dentry_update(dentry, newdentry);\n\tnewdentry = NULL;\n\n\t/*\n\t * Non-directores become opaque when copied up.\n\t */\n\tif (!S_ISDIR(stat->mode))\n\t\tovl_dentry_set_opaque(dentry, true);\nout2:\n\tdput(upper);\nout1:\n\tdput(newdentry);\nout:\n\treturn err;\n\nout_cleanup:\n\tovl_cleanup(wdir, newdentry);\n\tgoto out;\n}"
  },
  {
    "function_name": "ovl_set_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
    "lines": "171-194",
    "snippet": "int ovl_set_attr(struct dentry *upperdentry, struct kstat *stat)\n{\n\tint err = 0;\n\n\tif (!S_ISLNK(stat->mode)) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_MODE,\n\t\t\t.ia_mode = stat->mode,\n\t\t};\n\t\terr = notify_change(upperdentry, &attr, NULL);\n\t}\n\tif (!err) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_UID | ATTR_GID,\n\t\t\t.ia_uid = stat->uid,\n\t\t\t.ia_gid = stat->gid,\n\t\t};\n\t\terr = notify_change(upperdentry, &attr, NULL);\n\t}\n\tif (!err)\n\t\tovl_set_timestamps(upperdentry, stat);\n\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/splice.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_set_timestamps",
          "args": [
            "upperdentry",
            "stat"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_set_timestamps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
          "lines": "159-169",
          "snippet": "static int ovl_set_timestamps(struct dentry *upperdentry, struct kstat *stat)\n{\n\tstruct iattr attr = {\n\t\t.ia_valid =\n\t\t     ATTR_ATIME | ATTR_MTIME | ATTR_ATIME_SET | ATTR_MTIME_SET,\n\t\t.ia_atime = stat->atime,\n\t\t.ia_mtime = stat->mtime,\n\t};\n\n\treturn notify_change(upperdentry, &attr, NULL);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_set_timestamps(struct dentry *upperdentry, struct kstat *stat)\n{\n\tstruct iattr attr = {\n\t\t.ia_valid =\n\t\t     ATTR_ATIME | ATTR_MTIME | ATTR_ATIME_SET | ATTR_MTIME_SET,\n\t\t.ia_atime = stat->atime,\n\t\t.ia_mtime = stat->mtime,\n\t};\n\n\treturn notify_change(upperdentry, &attr, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notify_change",
          "args": [
            "upperdentry",
            "&attr",
            "NULL"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "190-277",
          "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "stat->mode"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_set_attr(struct dentry *upperdentry, struct kstat *stat)\n{\n\tint err = 0;\n\n\tif (!S_ISLNK(stat->mode)) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_MODE,\n\t\t\t.ia_mode = stat->mode,\n\t\t};\n\t\terr = notify_change(upperdentry, &attr, NULL);\n\t}\n\tif (!err) {\n\t\tstruct iattr attr = {\n\t\t\t.ia_valid = ATTR_UID | ATTR_GID,\n\t\t\t.ia_uid = stat->uid,\n\t\t\t.ia_gid = stat->gid,\n\t\t};\n\t\terr = notify_change(upperdentry, &attr, NULL);\n\t}\n\tif (!err)\n\t\tovl_set_timestamps(upperdentry, stat);\n\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_set_timestamps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
    "lines": "159-169",
    "snippet": "static int ovl_set_timestamps(struct dentry *upperdentry, struct kstat *stat)\n{\n\tstruct iattr attr = {\n\t\t.ia_valid =\n\t\t     ATTR_ATIME | ATTR_MTIME | ATTR_ATIME_SET | ATTR_MTIME_SET,\n\t\t.ia_atime = stat->atime,\n\t\t.ia_mtime = stat->mtime,\n\t};\n\n\treturn notify_change(upperdentry, &attr, NULL);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/splice.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notify_change",
          "args": [
            "upperdentry",
            "&attr",
            "NULL"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "190-277",
          "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_set_timestamps(struct dentry *upperdentry, struct kstat *stat)\n{\n\tstruct iattr attr = {\n\t\t.ia_valid =\n\t\t     ATTR_ATIME | ATTR_MTIME | ATTR_ATIME_SET | ATTR_MTIME_SET,\n\t\t.ia_atime = stat->atime,\n\t\t.ia_mtime = stat->mtime,\n\t};\n\n\treturn notify_change(upperdentry, &attr, NULL);\n}"
  },
  {
    "function_name": "ovl_read_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
    "lines": "125-157",
    "snippet": "static char *ovl_read_symlink(struct dentry *realdentry)\n{\n\tint res;\n\tchar *buf;\n\tstruct inode *inode = realdentry->d_inode;\n\tmm_segment_t old_fs;\n\n\tres = -EINVAL;\n\tif (!inode->i_op->readlink)\n\t\tgoto err;\n\n\tres = -ENOMEM;\n\tbuf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = inode->i_op->readlink(realdentry,\n\t\t\t\t    (char __user *)buf, PAGE_SIZE - 1);\n\tset_fs(old_fs);\n\tif (res < 0) {\n\t\tfree_page((unsigned long) buf);\n\t\tgoto err;\n\t}\n\tbuf[res] = '\\0';\n\n\treturn buf;\n\nerr:\n\treturn ERR_PTR(res);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/splice.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "res"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long) buf"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_op->readlink",
          "args": [
            "realdentry",
            "(char __user *)buf",
            "PAGE_SIZE - 1"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "get_ds()"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ds",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic char *ovl_read_symlink(struct dentry *realdentry)\n{\n\tint res;\n\tchar *buf;\n\tstruct inode *inode = realdentry->d_inode;\n\tmm_segment_t old_fs;\n\n\tres = -EINVAL;\n\tif (!inode->i_op->readlink)\n\t\tgoto err;\n\n\tres = -ENOMEM;\n\tbuf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = inode->i_op->readlink(realdentry,\n\t\t\t\t    (char __user *)buf, PAGE_SIZE - 1);\n\tset_fs(old_fs);\n\tif (res < 0) {\n\t\tfree_page((unsigned long) buf);\n\t\tgoto err;\n\t}\n\tbuf[res] = '\\0';\n\n\treturn buf;\n\nerr:\n\treturn ERR_PTR(res);\n}"
  },
  {
    "function_name": "ovl_copy_up_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
    "lines": "73-123",
    "snippet": "static int ovl_copy_up_data(struct path *old, struct path *new, loff_t len)\n{\n\tstruct file *old_file;\n\tstruct file *new_file;\n\tloff_t old_pos = 0;\n\tloff_t new_pos = 0;\n\tint error = 0;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\told_file = ovl_path_open(old, O_RDONLY);\n\tif (IS_ERR(old_file))\n\t\treturn PTR_ERR(old_file);\n\n\tnew_file = ovl_path_open(new, O_WRONLY);\n\tif (IS_ERR(new_file)) {\n\t\terror = PTR_ERR(new_file);\n\t\tgoto out_fput;\n\t}\n\n\t/* FIXME: copy up sparse files efficiently */\n\twhile (len) {\n\t\tsize_t this_len = OVL_COPY_UP_CHUNK_SIZE;\n\t\tlong bytes;\n\n\t\tif (len < this_len)\n\t\t\tthis_len = len;\n\n\t\tif (signal_pending_state(TASK_KILLABLE, current)) {\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tbytes = do_splice_direct(old_file, &old_pos,\n\t\t\t\t\t new_file, &new_pos,\n\t\t\t\t\t this_len, SPLICE_F_MOVE);\n\t\tif (bytes <= 0) {\n\t\t\terror = bytes;\n\t\t\tbreak;\n\t\t}\n\t\tWARN_ON(old_pos != new_pos);\n\n\t\tlen -= bytes;\n\t}\n\n\tfput(new_file);\nout_fput:\n\tfput(old_file);\n\treturn error;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/splice.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define OVL_COPY_UP_CHUNK_SIZE (1 << 20)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "old_file"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "old_pos != new_pos"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_splice_direct",
          "args": [
            "old_file",
            "&old_pos",
            "new_file",
            "&new_pos",
            "this_len",
            "SPLICE_F_MOVE"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "do_splice_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "1289-1317",
          "snippet": "long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,\n\t\t      loff_t *opos, size_t len, unsigned int flags)\n{\n\tstruct splice_desc sd = {\n\t\t.len\t\t= len,\n\t\t.total_len\t= len,\n\t\t.flags\t\t= flags,\n\t\t.pos\t\t= *ppos,\n\t\t.u.file\t\t= out,\n\t\t.opos\t\t= opos,\n\t};\n\tlong ret;\n\n\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\n\tif (unlikely(out->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tret = rw_verify_area(WRITE, out, opos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tret = splice_direct_to_actor(in, &sd, direct_splice_actor);\n\tif (ret > 0)\n\t\t*ppos = sd.pos;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nlong do_splice_direct(struct file *in, loff_t *ppos, struct file *out,\n\t\t      loff_t *opos, size_t len, unsigned int flags)\n{\n\tstruct splice_desc sd = {\n\t\t.len\t\t= len,\n\t\t.total_len\t= len,\n\t\t.flags\t\t= flags,\n\t\t.pos\t\t= *ppos,\n\t\t.u.file\t\t= out,\n\t\t.opos\t\t= opos,\n\t};\n\tlong ret;\n\n\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\n\tif (unlikely(out->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tret = rw_verify_area(WRITE, out, opos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tret = splice_direct_to_actor(in, &sd, direct_splice_actor);\n\tif (ret > 0)\n\t\t*ppos = sd.pos;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending_state",
          "args": [
            "TASK_KILLABLE",
            "current"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_file"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_file"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_path_open",
          "args": [
            "new",
            "O_WRONLY"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "462-465",
          "snippet": "struct file *ovl_path_open(struct path *path, int flags)\n{\n\treturn dentry_open(path, flags, current_cred());\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct file *ovl_path_open(struct path *path, int flags)\n{\n\treturn dentry_open(path, flags, current_cred());\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "old_file"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "old_file"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\n#define OVL_COPY_UP_CHUNK_SIZE (1 << 20)\n\nstatic int ovl_copy_up_data(struct path *old, struct path *new, loff_t len)\n{\n\tstruct file *old_file;\n\tstruct file *new_file;\n\tloff_t old_pos = 0;\n\tloff_t new_pos = 0;\n\tint error = 0;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\told_file = ovl_path_open(old, O_RDONLY);\n\tif (IS_ERR(old_file))\n\t\treturn PTR_ERR(old_file);\n\n\tnew_file = ovl_path_open(new, O_WRONLY);\n\tif (IS_ERR(new_file)) {\n\t\terror = PTR_ERR(new_file);\n\t\tgoto out_fput;\n\t}\n\n\t/* FIXME: copy up sparse files efficiently */\n\twhile (len) {\n\t\tsize_t this_len = OVL_COPY_UP_CHUNK_SIZE;\n\t\tlong bytes;\n\n\t\tif (len < this_len)\n\t\t\tthis_len = len;\n\n\t\tif (signal_pending_state(TASK_KILLABLE, current)) {\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tbytes = do_splice_direct(old_file, &old_pos,\n\t\t\t\t\t new_file, &new_pos,\n\t\t\t\t\t this_len, SPLICE_F_MOVE);\n\t\tif (bytes <= 0) {\n\t\t\terror = bytes;\n\t\t\tbreak;\n\t\t}\n\t\tWARN_ON(old_pos != new_pos);\n\n\t\tlen -= bytes;\n\t}\n\n\tfput(new_file);\nout_fput:\n\tfput(old_file);\n\treturn error;\n}"
  },
  {
    "function_name": "ovl_copy_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/copy_up.c",
    "lines": "23-71",
    "snippet": "int ovl_copy_xattr(struct dentry *old, struct dentry *new)\n{\n\tssize_t list_size, size;\n\tchar *buf, *name, *value;\n\tint error;\n\n\tif (!old->d_inode->i_op->getxattr ||\n\t    !new->d_inode->i_op->getxattr)\n\t\treturn 0;\n\n\tlist_size = vfs_listxattr(old, NULL, 0);\n\tif (list_size <= 0) {\n\t\tif (list_size == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn list_size;\n\t}\n\n\tbuf = kzalloc(list_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\terror = -ENOMEM;\n\tvalue = kmalloc(XATTR_SIZE_MAX, GFP_KERNEL);\n\tif (!value)\n\t\tgoto out;\n\n\tlist_size = vfs_listxattr(old, buf, list_size);\n\tif (list_size <= 0) {\n\t\terror = list_size;\n\t\tgoto out_free_value;\n\t}\n\n\tfor (name = buf; name < (buf + list_size); name += strlen(name) + 1) {\n\t\tsize = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);\n\t\tif (size <= 0) {\n\t\t\terror = size;\n\t\t\tgoto out_free_value;\n\t\t}\n\t\terror = vfs_setxattr(new, name, value, size, 0);\n\t\tif (error)\n\t\t\tgoto out_free_value;\n\t}\n\nout_free_value:\n\tkfree(value);\nout:\n\tkfree(buf);\n\treturn error;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/splice.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_setxattr",
          "args": [
            "new",
            "name",
            "value",
            "size",
            "0"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "121-142",
          "snippet": "int\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_getxattr",
          "args": [
            "old",
            "name",
            "value",
            "XATTR_SIZE_MAX"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "230-263",
          "snippet": "ssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\tif (inode->i_op->getxattr)\n\t\terror = inode->i_op->getxattr(dentry, name, value, size);\n\telse\n\t\terror = -EOPNOTSUPP;\n\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\tif (inode->i_op->getxattr)\n\t\terror = inode->i_op->getxattr(dentry, name, value, size);\n\telse\n\t\terror = -EOPNOTSUPP;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_listxattr",
          "args": [
            "old",
            "buf",
            "list_size"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_listxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "266-283",
          "snippet": "ssize_t\nvfs_listxattr(struct dentry *d, char *list, size_t size)\n{\n\tssize_t error;\n\n\terror = security_inode_listxattr(d);\n\tif (error)\n\t\treturn error;\n\terror = -EOPNOTSUPP;\n\tif (d->d_inode->i_op->listxattr) {\n\t\terror = d->d_inode->i_op->listxattr(d, list, size);\n\t} else {\n\t\terror = security_inode_listsecurity(d->d_inode, list, size);\n\t\tif (size && error > size)\n\t\t\terror = -ERANGE;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nvfs_listxattr(struct dentry *d, char *list, size_t size)\n{\n\tssize_t error;\n\n\terror = security_inode_listxattr(d);\n\tif (error)\n\t\treturn error;\n\terror = -EOPNOTSUPP;\n\tif (d->d_inode->i_op->listxattr) {\n\t\terror = d->d_inode->i_op->listxattr(d, list, size);\n\t} else {\n\t\terror = security_inode_listsecurity(d->d_inode, list, size);\n\t\tif (size && error > size)\n\t\t\terror = -ERANGE;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "XATTR_SIZE_MAX",
            "GFP_KERNEL"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "list_size",
            "GFP_KERNEL"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ovl_copy_xattr(struct dentry *old, struct dentry *new)\n{\n\tssize_t list_size, size;\n\tchar *buf, *name, *value;\n\tint error;\n\n\tif (!old->d_inode->i_op->getxattr ||\n\t    !new->d_inode->i_op->getxattr)\n\t\treturn 0;\n\n\tlist_size = vfs_listxattr(old, NULL, 0);\n\tif (list_size <= 0) {\n\t\tif (list_size == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn list_size;\n\t}\n\n\tbuf = kzalloc(list_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\terror = -ENOMEM;\n\tvalue = kmalloc(XATTR_SIZE_MAX, GFP_KERNEL);\n\tif (!value)\n\t\tgoto out;\n\n\tlist_size = vfs_listxattr(old, buf, list_size);\n\tif (list_size <= 0) {\n\t\terror = list_size;\n\t\tgoto out_free_value;\n\t}\n\n\tfor (name = buf; name < (buf + list_size); name += strlen(name) + 1) {\n\t\tsize = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);\n\t\tif (size <= 0) {\n\t\t\terror = size;\n\t\t\tgoto out_free_value;\n\t\t}\n\t\terror = vfs_setxattr(new, name, value, size, 0);\n\t\tif (error)\n\t\t\tgoto out_free_value;\n\t}\n\nout_free_value:\n\tkfree(value);\nout:\n\tkfree(buf);\n\treturn error;\n}"
  }
]