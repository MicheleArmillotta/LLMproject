[
  {
    "function_name": "sors_exit(void)\n{\n\tcom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/compress.c",
    "lines": "246-250",
    "snippet": "mpressors_exit(void)\n{\n\tcompr_exit(&lzo_compr);\n\tcompr_exit(&zlib_compr);\n}",
    "includes": [
      "fs.h\"\n\n/* Fake desc",
      "ux/crypto.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lib_compr)",
          "args": [
            "}"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zo_compr);",
          "args": [
            "compr_exi"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/* Fake desc\nux/crypto.h>\n#include \"ubi\n\nmpressors_exit(void)\n{\n\tcompr_exit(&lzo_compr);\n\tcompr_exit(&zlib_compr);\n}"
  },
  {
    "function_name": "sors_init(void)\n{\n\tint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/compress.c",
    "lines": "223-241",
    "snippet": "ifs_compressors_init(void)\n{\n\tint err;\n\n\terr = compr_init(&lzo_compr);\n\tif (err)\n\t\treturn err;\n\n\terr = compr_init(&zlib_compr);\n\tif (err)\n\t\tgoto out_lzo;\n\n\tubifs_compressors[UBIFS_COMPR_NONE] = &none_compr;\n\treturn 0;\n\nout_lzo:\n\tcompr_exit(&lzo_compr);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/* Fake desc",
      "ux/crypto.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [
      "ubifs_compressor none_compr = {\n\t.compr_type = UBIFS_COMPR_NONE,\n\t.name = \"none\",\n\t.capi_name = \"\",\n};\n\n#ifdef CONF",
      "compressor *ubifs_compressors[UBIFS_COMPR_TYPES_CNT];\n\n/**\n * ubif"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zo_compr);",
          "args": [
            "return er"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lib_compr)",
          "args": [
            "if (err)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zo_compr);",
          "args": [
            "if (err)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/* Fake desc\nux/crypto.h>\n#include \"ubi\n\nubifs_compressor none_compr = {\n\t.compr_type = UBIFS_COMPR_NONE,\n\t.name = \"none\",\n\t.capi_name = \"\",\n};\n\n#ifdef CONF;\ncompressor *ubifs_compressors[UBIFS_COMPR_TYPES_CNT];\n\n/**\n * ubif;\n\nifs_compressors_init(void)\n{\n\tint err;\n\n\terr = compr_init(&lzo_compr);\n\tif (err)\n\t\treturn err;\n\n\terr = compr_init(&zlib_compr);\n\tif (err)\n\t\tgoto out_lzo;\n\n\tubifs_compressors[UBIFS_COMPR_NONE] = &none_compr;\n\treturn 0;\n\nout_lzo:\n\tcompr_exit(&lzo_compr);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/compress.c",
    "lines": "210-215",
    "snippet": "ompr_exit(struct ubifs_compressor *compr)\n{\n\tif (compr->capi_name)\n\t\tcrypto_free_comp(compr->cc);\n\treturn;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/* Fake desc",
      "ux/crypto.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "omp(compr->cc);",
          "args": [
            "return;\n}"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/* Fake desc\nux/crypto.h>\n#include \"ubi\n\nompr_exit(struct ubifs_compressor *compr)\n{\n\tif (compr->capi_name)\n\t\tcrypto_free_comp(compr->cc);\n\treturn;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/compress.c",
    "lines": "191-204",
    "snippet": "init compr_init(struct ubifs_compressor *compr)\n{\n\tif (compr->capi_name) {\n\t\tcompr->cc = crypto_alloc_comp(compr->capi_name, 0, 0);\n\t\tif (IS_ERR(compr->cc)) {\n\t\t\tubifs_err(\"cannot initialize compressor %s, error %ld\",\n\t\t\t\t  compr->name, PTR_ERR(compr->cc));\n\t\t\treturn PTR_ERR(compr->cc);\n\t\t}\n\t}\n\n\tubifs_compressors[compr->compr_type] = compr;\n\treturn 0;\n}\n\n/**\n * comp",
    "includes": [
      "fs.h\"\n\n/* Fake desc",
      "ux/crypto.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [
      "compressor *ubifs_compressors[UBIFS_COMPR_TYPES_CNT];\n\n/**\n * ubif"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "->cc);",
          "args": [
            "}\n\t}\n\n\tu"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot init",
          "args": [
            "alize compressor %s, error %ld\",\n\t\t\t\t  compr",
            "PTR_ERR(com",
            "->cc));\n\t\t\treturn"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->cc));",
          "args": [
            "return"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">cc))",
          "args": [
            "ubifs"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "comp(compr->capi_",
          "args": [
            "ame, 0, 0);\n\t\tif",
            "I",
            "E"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/* Fake desc\nux/crypto.h>\n#include \"ubi\n\ncompressor *ubifs_compressors[UBIFS_COMPR_TYPES_CNT];\n\n/**\n * ubif;\n\ninit compr_init(struct ubifs_compressor *compr)\n{\n\tif (compr->capi_name) {\n\t\tcompr->cc = crypto_alloc_comp(compr->capi_name, 0, 0);\n\t\tif (IS_ERR(compr->cc)) {\n\t\t\tubifs_err(\"cannot initialize compressor %s, error %ld\",\n\t\t\t\t  compr->name, PTR_ERR(compr->cc));\n\t\t\treturn PTR_ERR(compr->cc);\n\t\t}\n\t}\n\n\tubifs_compressors[compr->compr_type] = compr;\n\treturn 0;\n}\n\n/**\n * comp"
  },
  {
    "function_name": "ess(const void *",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/compress.c",
    "lines": "147-182",
    "snippet": "ompress(const void *in_buf, int in_len, void *out_buf,\n\t\t     int *out_len, int compr_type)\n{\n\tint err;\n\tstruct ubifs_compressor *compr;\n\n\tif (unlikely(compr_type < 0 || compr_type >= UBIFS_COMPR_TYPES_CNT)) {\n\t\tubifs_err(\"invalid compression type %d\", compr_type);\n\t\treturn -EINVAL;\n\t}\n\n\tcompr = ubifs_compressors[compr_type];\n\n\tif (unlikely(!compr->capi_name)) {\n\t\tubifs_err(\"%s compression is not compiled in\", compr->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (compr_type == UBIFS_COMPR_NONE) {\n\t\tmemcpy(out_buf, in_buf, in_len);\n\t\t*out_len = in_len;\n\t\treturn 0;\n\t}\n\n\tif (compr->decomp_mutex)\n\t\tmutex_lock(compr->decomp_mutex);\n\terr = crypto_comp_decompress(compr->cc, in_buf, in_len, out_buf,\n\t\t\t\t     (unsigned int *)out_len);\n\tif (compr->decomp_mutex)\n\t\tmutex_unlock(compr->decomp_mutex);\n\tif (err)\n\t\tubifs_err(\"cannot decompress %d bytes, compressor %s, error %d\",\n\t\t\t  in_len, compr->name, err);\n\n\treturn err;\n}\n\n/**\n * comp",
    "includes": [
      "fs.h\"\n\n/* Fake desc",
      "ux/crypto.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [
      "compressor *ubifs_compressors[UBIFS_COMPR_TYPES_CNT];\n\n/**\n * ubif"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nnot deco",
          "args": [
            "press %d bytes, compressor %s, error %d\",\n\t\t\t  in_len",
            "->name",
            "err);\n\n\tret",
            "n e"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compr->decom",
          "args": [
            "_mutex);\n\tif (err)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecompress(compr->cc, i",
          "args": [
            "_buf, in_",
            "n, out",
            "uf,",
            "(u",
            "*)out_len);\n\tif (compr"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpr->decom",
          "args": [
            "_mutex);\n\terr = cry"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f, in_",
          "args": [
            "uf, in_",
            "n);",
            "ut_len"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compress",
          "args": [
            "on is not compiled in\", compr->name",
            "return -"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "zero_partial_compressed_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/compress.c",
          "lines": "100-118",
          "snippet": "static void zero_partial_compressed_page(struct page *page,\n\t\tconst s64 initialized_size)\n{\n\tu8 *kp = page_address(page);\n\tunsigned int kp_ofs;\n\n\tntfs_debug(\"Zeroing page region outside initialized size.\");\n\tif (((s64)page->index << PAGE_CACHE_SHIFT) >= initialized_size) {\n\t\t/*\n\t\t * FIXME: Using clear_page() will become wrong when we get\n\t\t * PAGE_CACHE_SIZE != PAGE_SIZE but for now there is no problem.\n\t\t */\n\t\tclear_page(kp);\n\t\treturn;\n\t}\n\tkp_ofs = initialized_size & ~PAGE_CACHE_MASK;\n\tmemset(kp + kp_ofs, 0, PAGE_CACHE_SIZE - kp_ofs);\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"attrib.h\"",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"attrib.h\"\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic void zero_partial_compressed_page(struct page *page,\n\t\tconst s64 initialized_size)\n{\n\tu8 *kp = page_address(page);\n\tunsigned int kp_ofs;\n\n\tntfs_debug(\"Zeroing page region outside initialized size.\");\n\tif (((s64)page->index << PAGE_CACHE_SHIFT) >= initialized_size) {\n\t\t/*\n\t\t * FIXME: Using clear_page() will become wrong when we get\n\t\t * PAGE_CACHE_SIZE != PAGE_SIZE but for now there is no problem.\n\t\t */\n\t\tclear_page(kp);\n\t\treturn;\n\t}\n\tkp_ofs = initialized_size & ~PAGE_CACHE_MASK;\n\tmemset(kp + kp_ofs, 0, PAGE_CACHE_SIZE - kp_ofs);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr->capi",
          "args": [
            "name)) {\n\t\tubifs_"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid com",
          "args": [
            "ression type %d\", compr_type)",
            "return -"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_type <",
          "args": [
            "0 || compr_type >= UBIFS_COMPR_TYPES_CNT)) {\n\t\tubifs_"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/* Fake desc\nux/crypto.h>\n#include \"ubi\n\ncompressor *ubifs_compressors[UBIFS_COMPR_TYPES_CNT];\n\n/**\n * ubif;\n\nompress(const void *in_buf, int in_len, void *out_buf,\n\t\t     int *out_len, int compr_type)\n{\n\tint err;\n\tstruct ubifs_compressor *compr;\n\n\tif (unlikely(compr_type < 0 || compr_type >= UBIFS_COMPR_TYPES_CNT)) {\n\t\tubifs_err(\"invalid compression type %d\", compr_type);\n\t\treturn -EINVAL;\n\t}\n\n\tcompr = ubifs_compressors[compr_type];\n\n\tif (unlikely(!compr->capi_name)) {\n\t\tubifs_err(\"%s compression is not compiled in\", compr->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (compr_type == UBIFS_COMPR_NONE) {\n\t\tmemcpy(out_buf, in_buf, in_len);\n\t\t*out_len = in_len;\n\t\treturn 0;\n\t}\n\n\tif (compr->decomp_mutex)\n\t\tmutex_lock(compr->decomp_mutex);\n\terr = crypto_comp_decompress(compr->cc, in_buf, in_len, out_buf,\n\t\t\t\t     (unsigned int *)out_len);\n\tif (compr->decomp_mutex)\n\t\tmutex_unlock(compr->decomp_mutex);\n\tif (err)\n\t\tubifs_err(\"cannot decompress %d bytes, compressor %s, error %d\",\n\t\t\t  in_len, compr->name, err);\n\n\treturn err;\n}\n\n/**\n * comp"
  },
  {
    "function_name": "s(const void *",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/compress.c",
    "lines": "95-133",
    "snippet": "mpress(const void *in_buf, int in_len, void *out_buf, int *out_len,\n\t\t    int *compr_type)\n{\n\tint err;\n\tstruct ubifs_compressor *compr = ubifs_compressors[*compr_type];\n\n\tif (*compr_type == UBIFS_COMPR_NONE)\n\t\tgoto no_compr;\n\n\t/* If the input data is small, do not even try to compress it */\n\tif (in_len < UBIFS_MIN_COMPR_LEN)\n\t\tgoto no_compr;\n\n\tif (compr->comp_mutex)\n\t\tmutex_lock(compr->comp_mutex);\n\terr = crypto_comp_compress(compr->cc, in_buf, in_len, out_buf,\n\t\t\t\t   (unsigned int *)out_len);\n\tif (compr->comp_mutex)\n\t\tmutex_unlock(compr->comp_mutex);\n\tif (unlikely(err)) {\n\t\tubifs_warn(\"cannot compress %d bytes, compressor %s, error %d, leave data uncompressed\",\n\t\t\t   in_len, compr->name, err);\n\t\t goto no_compr;\n\t}\n\n\t/*\n\t * If the data compressed only slightly, it is better to leave it\n\t * uncompressed to improve read speed.\n\t */\n\tif (in_len - *out_len < UBIFS_MIN_COMPRESS_DIFF)\n\t\tgoto no_compr;\n\n\treturn;\n\nno_compr:\n\tmemcpy(out_buf, in_buf, in_len);\n\t*out_len = in_len;\n\t*compr_type = UBIFS_COMPR_NONE;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/* Fake desc",
      "ux/crypto.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [
      "compressor *ubifs_compressors[UBIFS_COMPR_TYPES_CNT];\n\n/**\n * ubif"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "f, in_",
          "args": [
            "uf, in_",
            "n);\n\t*",
            "t_len"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annot comp",
          "args": [
            "ess %d bytes, compressor %s, error %d, leave data uncompressed\",\n\t\t\t   in_le",
            "->name",
            "err);\n\t\t go",
            "no"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {\n\t\tub",
          "args": [
            "fs_"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compr->comp_",
          "args": [
            "utex);\n\tif (unlik"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ompress(compr->cc, i",
          "args": [
            "_buf, in_",
            "n, out",
            "uf,",
            "(uns",
            "*)out_len);\n\tif (compr"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpr->comp_",
          "args": [
            "utex);\n\terr = cry"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/* Fake desc\nux/crypto.h>\n#include \"ubi\n\ncompressor *ubifs_compressors[UBIFS_COMPR_TYPES_CNT];\n\n/**\n * ubif;\n\nmpress(const void *in_buf, int in_len, void *out_buf, int *out_len,\n\t\t    int *compr_type)\n{\n\tint err;\n\tstruct ubifs_compressor *compr = ubifs_compressors[*compr_type];\n\n\tif (*compr_type == UBIFS_COMPR_NONE)\n\t\tgoto no_compr;\n\n\t/* If the input data is small, do not even try to compress it */\n\tif (in_len < UBIFS_MIN_COMPR_LEN)\n\t\tgoto no_compr;\n\n\tif (compr->comp_mutex)\n\t\tmutex_lock(compr->comp_mutex);\n\terr = crypto_comp_compress(compr->cc, in_buf, in_len, out_buf,\n\t\t\t\t   (unsigned int *)out_len);\n\tif (compr->comp_mutex)\n\t\tmutex_unlock(compr->comp_mutex);\n\tif (unlikely(err)) {\n\t\tubifs_warn(\"cannot compress %d bytes, compressor %s, error %d, leave data uncompressed\",\n\t\t\t   in_len, compr->name, err);\n\t\t goto no_compr;\n\t}\n\n\t/*\n\t * If the data compressed only slightly, it is better to leave it\n\t * uncompressed to improve read speed.\n\t */\n\tif (in_len - *out_len < UBIFS_MIN_COMPRESS_DIFF)\n\t\tgoto no_compr;\n\n\treturn;\n\nno_compr:\n\tmemcpy(out_buf, in_buf, in_len);\n\t*out_len = in_len;\n\t*compr_type = UBIFS_COMPR_NONE;\n}\n\n/**\n * ubif"
  }
]