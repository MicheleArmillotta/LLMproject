[
  {
    "function_name": "xfs_file_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "1508-1803",
    "snippet": "long\nxfs_file_ioctl(\n\tstruct file\t\t*filp,\n\tunsigned int\t\tcmd,\n\tunsigned long\t\tp)\n{\n\tstruct inode\t\t*inode = file_inode(filp);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tvoid\t\t\t__user *arg = (void __user *)p;\n\tint\t\t\tioflags = 0;\n\tint\t\t\terror;\n\n\tif (filp->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= XFS_IO_INVIS;\n\n\ttrace_xfs_file_ioctl(ip);\n\n\tswitch (cmd) {\n\tcase FITRIM:\n\t\treturn xfs_ioc_trim(mp, arg);\n\tcase XFS_IOC_ALLOCSP:\n\tcase XFS_IOC_FREESP:\n\tcase XFS_IOC_RESVSP:\n\tcase XFS_IOC_UNRESVSP:\n\tcase XFS_IOC_ALLOCSP64:\n\tcase XFS_IOC_FREESP64:\n\tcase XFS_IOC_RESVSP64:\n\tcase XFS_IOC_UNRESVSP64:\n\tcase XFS_IOC_ZERO_RANGE: {\n\t\txfs_flock64_t\t\tbf;\n\n\t\tif (copy_from_user(&bf, arg, sizeof(bf)))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_ioc_space(ip, inode, filp, ioflags, cmd, &bf);\n\t}\n\tcase XFS_IOC_DIOINFO: {\n\t\tstruct dioattr\tda;\n\t\txfs_buftarg_t\t*target =\n\t\t\tXFS_IS_REALTIME_INODE(ip) ?\n\t\t\tmp->m_rtdev_targp : mp->m_ddev_targp;\n\n\t\tda.d_mem =  da.d_miniosz = target->bt_logical_sectorsize;\n\t\tda.d_maxiosz = INT_MAX & ~(da.d_miniosz - 1);\n\n\t\tif (copy_to_user(arg, &da, sizeof(da)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_FSBULKSTAT_SINGLE:\n\tcase XFS_IOC_FSBULKSTAT:\n\tcase XFS_IOC_FSINUMBERS:\n\t\treturn xfs_ioc_bulkstat(mp, cmd, arg);\n\n\tcase XFS_IOC_FSGEOMETRY_V1:\n\t\treturn xfs_ioc_fsgeometry_v1(mp, arg);\n\n\tcase XFS_IOC_FSGEOMETRY:\n\t\treturn xfs_ioc_fsgeometry(mp, arg);\n\n\tcase XFS_IOC_GETVERSION:\n\t\treturn put_user(inode->i_generation, (int __user *)arg);\n\n\tcase XFS_IOC_FSGETXATTR:\n\t\treturn xfs_ioc_fsgetxattr(ip, 0, arg);\n\tcase XFS_IOC_FSGETXATTRA:\n\t\treturn xfs_ioc_fsgetxattr(ip, 1, arg);\n\tcase XFS_IOC_FSSETXATTR:\n\t\treturn xfs_ioc_fssetxattr(ip, filp, arg);\n\tcase XFS_IOC_GETXFLAGS:\n\t\treturn xfs_ioc_getxflags(ip, arg);\n\tcase XFS_IOC_SETXFLAGS:\n\t\treturn xfs_ioc_setxflags(ip, filp, arg);\n\n\tcase XFS_IOC_FSSETDM: {\n\t\tstruct fsdmidata\tdmi;\n\n\t\tif (copy_from_user(&dmi, arg, sizeof(dmi)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = xfs_set_dmattrs(ip, dmi.fsd_dmevmask,\n\t\t\t\tdmi.fsd_dmstate);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_GETBMAP:\n\tcase XFS_IOC_GETBMAPA:\n\t\treturn xfs_ioc_getbmap(ip, ioflags, cmd, arg);\n\n\tcase XFS_IOC_GETBMAPX:\n\t\treturn xfs_ioc_getbmapx(ip, arg);\n\n\tcase XFS_IOC_FD_TO_HANDLE:\n\tcase XFS_IOC_PATH_TO_HANDLE:\n\tcase XFS_IOC_PATH_TO_FSHANDLE: {\n\t\txfs_fsop_handlereq_t\threq;\n\n\t\tif (copy_from_user(&hreq, arg, sizeof(hreq)))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_find_handle(cmd, &hreq);\n\t}\n\tcase XFS_IOC_OPEN_BY_HANDLE: {\n\t\txfs_fsop_handlereq_t\threq;\n\n\t\tif (copy_from_user(&hreq, arg, sizeof(xfs_fsop_handlereq_t)))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_open_by_handle(filp, &hreq);\n\t}\n\tcase XFS_IOC_FSSETDM_BY_HANDLE:\n\t\treturn xfs_fssetdm_by_handle(filp, arg);\n\n\tcase XFS_IOC_READLINK_BY_HANDLE: {\n\t\txfs_fsop_handlereq_t\threq;\n\n\t\tif (copy_from_user(&hreq, arg, sizeof(xfs_fsop_handlereq_t)))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_readlink_by_handle(filp, &hreq);\n\t}\n\tcase XFS_IOC_ATTRLIST_BY_HANDLE:\n\t\treturn xfs_attrlist_by_handle(filp, arg);\n\n\tcase XFS_IOC_ATTRMULTI_BY_HANDLE:\n\t\treturn xfs_attrmulti_by_handle(filp, arg);\n\n\tcase XFS_IOC_SWAPEXT: {\n\t\tstruct xfs_swapext\tsxp;\n\n\t\tif (copy_from_user(&sxp, arg, sizeof(xfs_swapext_t)))\n\t\t\treturn -EFAULT;\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_ioc_swapext(&sxp);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_FSCOUNTS: {\n\t\txfs_fsop_counts_t out;\n\n\t\terror = xfs_fs_counts(mp, &out);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (copy_to_user(arg, &out, sizeof(out)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_SET_RESBLKS: {\n\t\txfs_fsop_resblks_t inout;\n\t\t__uint64_t\t   in;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\t\treturn -EROFS;\n\n\t\tif (copy_from_user(&inout, arg, sizeof(inout)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/* input parameter is passed in resblks field of structure */\n\t\tin = inout.resblks;\n\t\terror = xfs_reserve_blocks(mp, &in, &inout);\n\t\tmnt_drop_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (copy_to_user(arg, &inout, sizeof(inout)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_GET_RESBLKS: {\n\t\txfs_fsop_resblks_t out;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\terror = xfs_reserve_blocks(mp, NULL, &out);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (copy_to_user(arg, &out, sizeof(out)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_FSGROWFSDATA: {\n\t\txfs_growfs_data_t in;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_data(mp, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_FSGROWFSLOG: {\n\t\txfs_growfs_log_t in;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_log(mp, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_FSGROWFSRT: {\n\t\txfs_growfs_rt_t in;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_rt(mp, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_GOINGDOWN: {\n\t\t__uint32_t in;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(in, (__uint32_t __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\treturn xfs_fs_goingdown(mp, in);\n\t}\n\n\tcase XFS_IOC_ERROR_INJECTION: {\n\t\txfs_error_injection_t in;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\treturn xfs_errortag_add(in.errtag, mp);\n\t}\n\n\tcase XFS_IOC_ERROR_CLEARALL:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\treturn xfs_errortag_clearall(mp, 1);\n\n\tcase XFS_IOC_FREE_EOFBLOCKS: {\n\t\tstruct xfs_fs_eofblocks eofb;\n\t\tstruct xfs_eofblocks keofb;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\t\treturn -EROFS;\n\n\t\tif (copy_from_user(&eofb, arg, sizeof(eofb)))\n\t\t\treturn -EFAULT;\n\n\t\terror = xfs_fs_eofblocks_from_user(&eofb, &keofb);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\treturn xfs_icache_free_eofblocks(mp, &keofb);\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_icache_free_eofblocks",
          "args": [
            "mp",
            "&keofb"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icache_free_eofblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1291-1303",
          "snippet": "int\nxfs_icache_free_eofblocks(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_eofblocks\t*eofb)\n{\n\tint flags = SYNC_TRYLOCK;\n\n\tif (eofb && (eofb->eof_flags & XFS_EOF_FLAGS_SYNC))\n\t\tflags = SYNC_WAIT;\n\n\treturn xfs_inode_ag_iterator_tag(mp, xfs_inode_free_eofblocks, flags,\n\t\t\t\t\t eofb, XFS_ICI_EOFBLOCKS_TAG);\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_icache_free_eofblocks(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_eofblocks\t*eofb)\n{\n\tint flags = SYNC_TRYLOCK;\n\n\tif (eofb && (eofb->eof_flags & XFS_EOF_FLAGS_SYNC))\n\t\tflags = SYNC_WAIT;\n\n\treturn xfs_inode_ag_iterator_tag(mp, xfs_inode_free_eofblocks, flags,\n\t\t\t\t\t eofb, XFS_ICI_EOFBLOCKS_TAG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_fs_eofblocks_from_user",
          "args": [
            "&eofb",
            "&keofb"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_fs_eofblocks_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.h",
          "lines": "79-113",
          "snippet": "static inline int\nxfs_fs_eofblocks_from_user(\n\tstruct xfs_fs_eofblocks\t\t*src,\n\tstruct xfs_eofblocks\t\t*dst)\n{\n\tif (src->eof_version != XFS_EOFBLOCKS_VERSION)\n\t\treturn -EINVAL;\n\n\tif (src->eof_flags & ~XFS_EOF_FLAGS_VALID)\n\t\treturn -EINVAL;\n\n\tif (memchr_inv(&src->pad32, 0, sizeof(src->pad32)) ||\n\t    memchr_inv(src->pad64, 0, sizeof(src->pad64)))\n\t\treturn -EINVAL;\n\n\tdst->eof_flags = src->eof_flags;\n\tdst->eof_prid = src->eof_prid;\n\tdst->eof_min_file_size = src->eof_min_file_size;\n\tdst->eof_scan_owner = NULLFSINO;\n\n\tdst->eof_uid = INVALID_UID;\n\tif (src->eof_flags & XFS_EOF_FLAGS_UID) {\n\t\tdst->eof_uid = make_kuid(current_user_ns(), src->eof_uid);\n\t\tif (!uid_valid(dst->eof_uid))\n\t\t\treturn -EINVAL;\n\t}\n\n\tdst->eof_gid = INVALID_GID;\n\tif (src->eof_flags & XFS_EOF_FLAGS_GID) {\n\t\tdst->eof_gid = make_kgid(current_user_ns(), src->eof_gid);\n\t\tif (!gid_valid(dst->eof_gid))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_fs_eofblocks_from_user(\n\tstruct xfs_fs_eofblocks\t\t*src,\n\tstruct xfs_eofblocks\t\t*dst)\n{\n\tif (src->eof_version != XFS_EOFBLOCKS_VERSION)\n\t\treturn -EINVAL;\n\n\tif (src->eof_flags & ~XFS_EOF_FLAGS_VALID)\n\t\treturn -EINVAL;\n\n\tif (memchr_inv(&src->pad32, 0, sizeof(src->pad32)) ||\n\t    memchr_inv(src->pad64, 0, sizeof(src->pad64)))\n\t\treturn -EINVAL;\n\n\tdst->eof_flags = src->eof_flags;\n\tdst->eof_prid = src->eof_prid;\n\tdst->eof_min_file_size = src->eof_min_file_size;\n\tdst->eof_scan_owner = NULLFSINO;\n\n\tdst->eof_uid = INVALID_UID;\n\tif (src->eof_flags & XFS_EOF_FLAGS_UID) {\n\t\tdst->eof_uid = make_kuid(current_user_ns(), src->eof_uid);\n\t\tif (!uid_valid(dst->eof_uid))\n\t\t\treturn -EINVAL;\n\t}\n\n\tdst->eof_gid = INVALID_GID;\n\tif (src->eof_flags & XFS_EOF_FLAGS_GID) {\n\t\tdst->eof_gid = make_kgid(current_user_ns(), src->eof_gid);\n\t\tif (!gid_valid(dst->eof_gid))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&eofb",
            "arg",
            "sizeof(eofb)"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_errortag_clearall",
          "args": [
            "mp",
            "1"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_errortag_clearall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "92-120",
          "snippet": "int\nxfs_errortag_clearall(xfs_mount_t *mp, int loud)\n{\n\tint64_t fsid;\n\tint cleared = 0;\n\tint i;\n\n\tmemcpy(&fsid, mp->m_fixedfsid, sizeof(xfs_fsid_t));\n\n\n\tfor (i = 0; i < XFS_NUM_INJECT_ERROR; i++) {\n\t\tif ((fsid == 0LL || xfs_etest_fsid[i] == fsid) &&\n\t\t     xfs_etest[i] != 0) {\n\t\t\tcleared = 1;\n\t\t\txfs_warn(mp, \"Clearing XFS error tag #%d\",\n\t\t\t\txfs_etest[i]);\n\t\t\txfs_etest[i] = 0;\n\t\t\txfs_etest_fsid[i] = 0LL;\n\t\t\tkmem_free(xfs_etest_fsname[i]);\n\t\t\txfs_etest_fsname[i] = NULL;\n\t\t\txfs_error_test_active--;\n\t\t}\n\t}\n\n\tif (loud || cleared)\n\t\txfs_warn(mp, \"Cleared all XFS error tags for filesystem\");\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nint\nxfs_errortag_clearall(xfs_mount_t *mp, int loud)\n{\n\tint64_t fsid;\n\tint cleared = 0;\n\tint i;\n\n\tmemcpy(&fsid, mp->m_fixedfsid, sizeof(xfs_fsid_t));\n\n\n\tfor (i = 0; i < XFS_NUM_INJECT_ERROR; i++) {\n\t\tif ((fsid == 0LL || xfs_etest_fsid[i] == fsid) &&\n\t\t     xfs_etest[i] != 0) {\n\t\t\tcleared = 1;\n\t\t\txfs_warn(mp, \"Clearing XFS error tag #%d\",\n\t\t\t\txfs_etest[i]);\n\t\t\txfs_etest[i] = 0;\n\t\t\txfs_etest_fsid[i] = 0LL;\n\t\t\tkmem_free(xfs_etest_fsname[i]);\n\t\t\txfs_etest_fsname[i] = NULL;\n\t\t\txfs_error_test_active--;\n\t\t}\n\t}\n\n\tif (loud || cleared)\n\t\txfs_warn(mp, \"Cleared all XFS error tags for filesystem\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_errortag_add",
          "args": [
            "in.errtag",
            "mp"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_errortag_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "57-90",
          "snippet": "int\nxfs_errortag_add(int error_tag, xfs_mount_t *mp)\n{\n\tint i;\n\tint len;\n\tint64_t fsid;\n\n\tmemcpy(&fsid, mp->m_fixedfsid, sizeof(xfs_fsid_t));\n\n\tfor (i = 0; i < XFS_NUM_INJECT_ERROR; i++)  {\n\t\tif (xfs_etest_fsid[i] == fsid && xfs_etest[i] == error_tag) {\n\t\t\txfs_warn(mp, \"error tag #%d on\", error_tag);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < XFS_NUM_INJECT_ERROR; i++)  {\n\t\tif (xfs_etest[i] == 0) {\n\t\t\txfs_warn(mp, \"Turned on XFS error tag #%d\",\n\t\t\t\terror_tag);\n\t\t\txfs_etest[i] = error_tag;\n\t\t\txfs_etest_fsid[i] = fsid;\n\t\t\tlen = strlen(mp->m_fsname);\n\t\t\txfs_etest_fsname[i] = kmem_alloc(len + 1, KM_SLEEP);\n\t\t\tstrcpy(xfs_etest_fsname[i], mp->m_fsname);\n\t\t\txfs_error_test_active++;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\txfs_warn(mp, \"error tag overflow, too many turned on\");\n\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nint\nxfs_errortag_add(int error_tag, xfs_mount_t *mp)\n{\n\tint i;\n\tint len;\n\tint64_t fsid;\n\n\tmemcpy(&fsid, mp->m_fixedfsid, sizeof(xfs_fsid_t));\n\n\tfor (i = 0; i < XFS_NUM_INJECT_ERROR; i++)  {\n\t\tif (xfs_etest_fsid[i] == fsid && xfs_etest[i] == error_tag) {\n\t\t\txfs_warn(mp, \"error tag #%d on\", error_tag);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < XFS_NUM_INJECT_ERROR; i++)  {\n\t\tif (xfs_etest[i] == 0) {\n\t\t\txfs_warn(mp, \"Turned on XFS error tag #%d\",\n\t\t\t\terror_tag);\n\t\t\txfs_etest[i] = error_tag;\n\t\t\txfs_etest_fsid[i] = fsid;\n\t\t\tlen = strlen(mp->m_fsname);\n\t\t\txfs_etest_fsname[i] = kmem_alloc(len + 1, KM_SLEEP);\n\t\t\tstrcpy(xfs_etest_fsname[i], mp->m_fsname);\n\t\t\txfs_error_test_active++;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\txfs_warn(mp, \"error tag overflow, too many turned on\");\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_fs_goingdown",
          "args": [
            "mp",
            "in"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_fs_goingdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
          "lines": "766-794",
          "snippet": "int\nxfs_fs_goingdown(\n\txfs_mount_t\t*mp,\n\t__uint32_t\tinflags)\n{\n\tswitch (inflags) {\n\tcase XFS_FSOP_GOING_FLAGS_DEFAULT: {\n\t\tstruct super_block *sb = freeze_bdev(mp->m_super->s_bdev);\n\n\t\tif (sb && !IS_ERR(sb)) {\n\t\t\txfs_force_shutdown(mp, SHUTDOWN_FORCE_UMOUNT);\n\t\t\tthaw_bdev(sb->s_bdev, sb);\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase XFS_FSOP_GOING_FLAGS_LOGFLUSH:\n\t\txfs_force_shutdown(mp, SHUTDOWN_FORCE_UMOUNT);\n\t\tbreak;\n\tcase XFS_FSOP_GOING_FLAGS_NOLOGFLUSH:\n\t\txfs_force_shutdown(mp,\n\t\t\t\tSHUTDOWN_FORCE_UMOUNT | SHUTDOWN_LOG_IO_ERROR);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_fs_goingdown(\n\txfs_mount_t\t*mp,\n\t__uint32_t\tinflags)\n{\n\tswitch (inflags) {\n\tcase XFS_FSOP_GOING_FLAGS_DEFAULT: {\n\t\tstruct super_block *sb = freeze_bdev(mp->m_super->s_bdev);\n\n\t\tif (sb && !IS_ERR(sb)) {\n\t\t\txfs_force_shutdown(mp, SHUTDOWN_FORCE_UMOUNT);\n\t\t\tthaw_bdev(sb->s_bdev, sb);\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase XFS_FSOP_GOING_FLAGS_LOGFLUSH:\n\t\txfs_force_shutdown(mp, SHUTDOWN_FORCE_UMOUNT);\n\t\tbreak;\n\tcase XFS_FSOP_GOING_FLAGS_NOLOGFLUSH:\n\t\txfs_force_shutdown(mp,\n\t\t\t\tSHUTDOWN_FORCE_UMOUNT | SHUTDOWN_LOG_IO_ERROR);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "in",
            "(__uint32_t __user *)arg"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_growfs_rt",
          "args": [
            "mp",
            "&in"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_growfs_rt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "884-1090",
          "snippet": "int\nxfs_growfs_rt(\n\txfs_mount_t\t*mp,\t\t/* mount point for filesystem */\n\txfs_growfs_rt_t\t*in)\t\t/* growfs rt input struct */\n{\n\txfs_rtblock_t\tbmbno;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* temporary buffer */\n\tint\t\terror;\t\t/* error return value */\n\txfs_mount_t\t*nmp;\t\t/* new (fake) mount structure */\n\txfs_rfsblock_t\tnrblocks;\t/* new number of realtime blocks */\n\txfs_extlen_t\tnrbmblocks;\t/* new number of rt bitmap blocks */\n\txfs_rtblock_t\tnrextents;\t/* new number of realtime extents */\n\tuint8_t\t\tnrextslog;\t/* new log2 of sb_rextents */\n\txfs_extlen_t\tnrsumblocks;\t/* new number of summary blocks */\n\tuint\t\tnrsumlevels;\t/* new rt summary levels */\n\tuint\t\tnrsumsize;\t/* new size of rt summary, bytes */\n\txfs_sb_t\t*nsbp;\t\t/* new superblock */\n\txfs_extlen_t\trbmblocks;\t/* current number of rt bitmap blocks */\n\txfs_extlen_t\trsumblocks;\t/* current number of rt summary blks */\n\txfs_sb_t\t*sbp;\t\t/* old superblock */\n\txfs_fsblock_t\tsumbno;\t\t/* summary block number */\n\n\tsbp = &mp->m_sb;\n\t/*\n\t * Initial error checking.\n\t */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (mp->m_rtdev_targp == NULL || mp->m_rbmip == NULL ||\n\t    (nrblocks = in->newblocks) <= sbp->sb_rblocks ||\n\t    (sbp->sb_rblocks && (in->extsize != sbp->sb_rextsize)))\n\t\treturn -EINVAL;\n\tif ((error = xfs_sb_validate_fsb_count(sbp, nrblocks)))\n\t\treturn error;\n\t/*\n\t * Read in the last block of the device, make sure it exists.\n\t */\n\terror = xfs_buf_read_uncached(mp->m_rtdev_targp,\n\t\t\t\tXFS_FSB_TO_BB(mp, nrblocks - 1),\n\t\t\t\tXFS_FSB_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\txfs_buf_relse(bp);\n\n\t/*\n\t * Calculate new parameters.  These are the final values to be reached.\n\t */\n\tnrextents = nrblocks;\n\tdo_div(nrextents, in->extsize);\n\tnrbmblocks = howmany_64(nrextents, NBBY * sbp->sb_blocksize);\n\tnrextslog = xfs_highbit32(nrextents);\n\tnrsumlevels = nrextslog + 1;\n\tnrsumsize = (uint)sizeof(xfs_suminfo_t) * nrsumlevels * nrbmblocks;\n\tnrsumblocks = XFS_B_TO_FSB(mp, nrsumsize);\n\tnrsumsize = XFS_FSB_TO_B(mp, nrsumblocks);\n\t/*\n\t * New summary size can't be more than half the size of\n\t * the log.  This prevents us from getting a log overflow,\n\t * since we'll log basically the whole summary file at once.\n\t */\n\tif (nrsumblocks > (mp->m_sb.sb_logblocks >> 1))\n\t\treturn -EINVAL;\n\t/*\n\t * Get the old block counts for bitmap and summary inodes.\n\t * These can't change since other growfs callers are locked out.\n\t */\n\trbmblocks = XFS_B_TO_FSB(mp, mp->m_rbmip->i_d.di_size);\n\trsumblocks = XFS_B_TO_FSB(mp, mp->m_rsumip->i_d.di_size);\n\t/*\n\t * Allocate space to the bitmap and summary files, as necessary.\n\t */\n\terror = xfs_growfs_rt_alloc(mp, rbmblocks, nrbmblocks, mp->m_rbmip);\n\tif (error)\n\t\treturn error;\n\terror = xfs_growfs_rt_alloc(mp, rsumblocks, nrsumblocks, mp->m_rsumip);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Allocate a new (fake) mount/sb.\n\t */\n\tnmp = kmem_alloc(sizeof(*nmp), KM_SLEEP);\n\t/*\n\t * Loop over the bitmap blocks.\n\t * We will do everything one bitmap block at a time.\n\t * Skip the current block if it is exactly full.\n\t * This also deals with the case where there were no rtextents before.\n\t */\n\tfor (bmbno = sbp->sb_rbmblocks -\n\t\t     ((sbp->sb_rextents & ((1 << mp->m_blkbit_log) - 1)) != 0);\n\t     bmbno < nrbmblocks;\n\t     bmbno++) {\n\t\txfs_trans_t\t*tp;\n\t\tint\t\tcancelflags = 0;\n\n\t\t*nmp = *mp;\n\t\tnsbp = &nmp->m_sb;\n\t\t/*\n\t\t * Calculate new sb and mount fields for this round.\n\t\t */\n\t\tnsbp->sb_rextsize = in->extsize;\n\t\tnsbp->sb_rbmblocks = bmbno + 1;\n\t\tnsbp->sb_rblocks =\n\t\t\tXFS_RTMIN(nrblocks,\n\t\t\t\t  nsbp->sb_rbmblocks * NBBY *\n\t\t\t\t  nsbp->sb_blocksize * nsbp->sb_rextsize);\n\t\tnsbp->sb_rextents = nsbp->sb_rblocks;\n\t\tdo_div(nsbp->sb_rextents, nsbp->sb_rextsize);\n\t\tASSERT(nsbp->sb_rextents != 0);\n\t\tnsbp->sb_rextslog = xfs_highbit32(nsbp->sb_rextents);\n\t\tnrsumlevels = nmp->m_rsumlevels = nsbp->sb_rextslog + 1;\n\t\tnrsumsize =\n\t\t\t(uint)sizeof(xfs_suminfo_t) * nrsumlevels *\n\t\t\tnsbp->sb_rbmblocks;\n\t\tnrsumblocks = XFS_B_TO_FSB(mp, nrsumsize);\n\t\tnmp->m_rsumsize = nrsumsize = XFS_FSB_TO_B(mp, nrsumblocks);\n\t\t/*\n\t\t * Start a transaction, get the log reservation.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_GROWFSRT_FREE);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_growrtfree,\n\t\t\t\t\t  0, 0);\n\t\tif (error)\n\t\t\tgoto error_cancel;\n\t\t/*\n\t\t * Lock out other callers by grabbing the bitmap inode lock.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\t/*\n\t\t * Update the bitmap inode's size.\n\t\t */\n\t\tmp->m_rbmip->i_d.di_size =\n\t\t\tnsbp->sb_rbmblocks * nsbp->sb_blocksize;\n\t\txfs_trans_log_inode(tp, mp->m_rbmip, XFS_ILOG_CORE);\n\t\tcancelflags |= XFS_TRANS_ABORT;\n\t\t/*\n\t\t * Get the summary inode into the transaction.\n\t\t */\n\t\txfs_ilock(mp->m_rsumip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rsumip, XFS_ILOCK_EXCL);\n\t\t/*\n\t\t * Update the summary inode's size.\n\t\t */\n\t\tmp->m_rsumip->i_d.di_size = nmp->m_rsumsize;\n\t\txfs_trans_log_inode(tp, mp->m_rsumip, XFS_ILOG_CORE);\n\t\t/*\n\t\t * Copy summary data from old to new sizes.\n\t\t * Do this when the real size (not block-aligned) changes.\n\t\t */\n\t\tif (sbp->sb_rbmblocks != nsbp->sb_rbmblocks ||\n\t\t    mp->m_rsumlevels != nmp->m_rsumlevels) {\n\t\t\terror = xfs_rtcopy_summary(mp, nmp, tp);\n\t\t\tif (error)\n\t\t\t\tgoto error_cancel;\n\t\t}\n\t\t/*\n\t\t * Update superblock fields.\n\t\t */\n\t\tif (nsbp->sb_rextsize != sbp->sb_rextsize)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_REXTSIZE,\n\t\t\t\tnsbp->sb_rextsize - sbp->sb_rextsize);\n\t\tif (nsbp->sb_rbmblocks != sbp->sb_rbmblocks)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_RBMBLOCKS,\n\t\t\t\tnsbp->sb_rbmblocks - sbp->sb_rbmblocks);\n\t\tif (nsbp->sb_rblocks != sbp->sb_rblocks)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_RBLOCKS,\n\t\t\t\tnsbp->sb_rblocks - sbp->sb_rblocks);\n\t\tif (nsbp->sb_rextents != sbp->sb_rextents)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_REXTENTS,\n\t\t\t\tnsbp->sb_rextents - sbp->sb_rextents);\n\t\tif (nsbp->sb_rextslog != sbp->sb_rextslog)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_REXTSLOG,\n\t\t\t\tnsbp->sb_rextslog - sbp->sb_rextslog);\n\t\t/*\n\t\t * Free new extent.\n\t\t */\n\t\tbp = NULL;\n\t\terror = xfs_rtfree_range(nmp, tp, sbp->sb_rextents,\n\t\t\tnsbp->sb_rextents - sbp->sb_rextents, &bp, &sumbno);\n\t\tif (error) {\nerror_cancel:\n\t\t\txfs_trans_cancel(tp, cancelflags);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Mark more blocks free in the superblock.\n\t\t */\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FREXTENTS,\n\t\t\tnsbp->sb_rextents - sbp->sb_rextents);\n\t\t/*\n\t\t * Update mp values into the real mp structure.\n\t\t */\n\t\tmp->m_rsumlevels = nrsumlevels;\n\t\tmp->m_rsumsize = nrsumsize;\n\n\t\terror = xfs_trans_commit(tp, 0);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Free the fake mp structure.\n\t */\n\tkmem_free(nmp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_growfs_rt(\n\txfs_mount_t\t*mp,\t\t/* mount point for filesystem */\n\txfs_growfs_rt_t\t*in)\t\t/* growfs rt input struct */\n{\n\txfs_rtblock_t\tbmbno;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* temporary buffer */\n\tint\t\terror;\t\t/* error return value */\n\txfs_mount_t\t*nmp;\t\t/* new (fake) mount structure */\n\txfs_rfsblock_t\tnrblocks;\t/* new number of realtime blocks */\n\txfs_extlen_t\tnrbmblocks;\t/* new number of rt bitmap blocks */\n\txfs_rtblock_t\tnrextents;\t/* new number of realtime extents */\n\tuint8_t\t\tnrextslog;\t/* new log2 of sb_rextents */\n\txfs_extlen_t\tnrsumblocks;\t/* new number of summary blocks */\n\tuint\t\tnrsumlevels;\t/* new rt summary levels */\n\tuint\t\tnrsumsize;\t/* new size of rt summary, bytes */\n\txfs_sb_t\t*nsbp;\t\t/* new superblock */\n\txfs_extlen_t\trbmblocks;\t/* current number of rt bitmap blocks */\n\txfs_extlen_t\trsumblocks;\t/* current number of rt summary blks */\n\txfs_sb_t\t*sbp;\t\t/* old superblock */\n\txfs_fsblock_t\tsumbno;\t\t/* summary block number */\n\n\tsbp = &mp->m_sb;\n\t/*\n\t * Initial error checking.\n\t */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (mp->m_rtdev_targp == NULL || mp->m_rbmip == NULL ||\n\t    (nrblocks = in->newblocks) <= sbp->sb_rblocks ||\n\t    (sbp->sb_rblocks && (in->extsize != sbp->sb_rextsize)))\n\t\treturn -EINVAL;\n\tif ((error = xfs_sb_validate_fsb_count(sbp, nrblocks)))\n\t\treturn error;\n\t/*\n\t * Read in the last block of the device, make sure it exists.\n\t */\n\terror = xfs_buf_read_uncached(mp->m_rtdev_targp,\n\t\t\t\tXFS_FSB_TO_BB(mp, nrblocks - 1),\n\t\t\t\tXFS_FSB_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\txfs_buf_relse(bp);\n\n\t/*\n\t * Calculate new parameters.  These are the final values to be reached.\n\t */\n\tnrextents = nrblocks;\n\tdo_div(nrextents, in->extsize);\n\tnrbmblocks = howmany_64(nrextents, NBBY * sbp->sb_blocksize);\n\tnrextslog = xfs_highbit32(nrextents);\n\tnrsumlevels = nrextslog + 1;\n\tnrsumsize = (uint)sizeof(xfs_suminfo_t) * nrsumlevels * nrbmblocks;\n\tnrsumblocks = XFS_B_TO_FSB(mp, nrsumsize);\n\tnrsumsize = XFS_FSB_TO_B(mp, nrsumblocks);\n\t/*\n\t * New summary size can't be more than half the size of\n\t * the log.  This prevents us from getting a log overflow,\n\t * since we'll log basically the whole summary file at once.\n\t */\n\tif (nrsumblocks > (mp->m_sb.sb_logblocks >> 1))\n\t\treturn -EINVAL;\n\t/*\n\t * Get the old block counts for bitmap and summary inodes.\n\t * These can't change since other growfs callers are locked out.\n\t */\n\trbmblocks = XFS_B_TO_FSB(mp, mp->m_rbmip->i_d.di_size);\n\trsumblocks = XFS_B_TO_FSB(mp, mp->m_rsumip->i_d.di_size);\n\t/*\n\t * Allocate space to the bitmap and summary files, as necessary.\n\t */\n\terror = xfs_growfs_rt_alloc(mp, rbmblocks, nrbmblocks, mp->m_rbmip);\n\tif (error)\n\t\treturn error;\n\terror = xfs_growfs_rt_alloc(mp, rsumblocks, nrsumblocks, mp->m_rsumip);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Allocate a new (fake) mount/sb.\n\t */\n\tnmp = kmem_alloc(sizeof(*nmp), KM_SLEEP);\n\t/*\n\t * Loop over the bitmap blocks.\n\t * We will do everything one bitmap block at a time.\n\t * Skip the current block if it is exactly full.\n\t * This also deals with the case where there were no rtextents before.\n\t */\n\tfor (bmbno = sbp->sb_rbmblocks -\n\t\t     ((sbp->sb_rextents & ((1 << mp->m_blkbit_log) - 1)) != 0);\n\t     bmbno < nrbmblocks;\n\t     bmbno++) {\n\t\txfs_trans_t\t*tp;\n\t\tint\t\tcancelflags = 0;\n\n\t\t*nmp = *mp;\n\t\tnsbp = &nmp->m_sb;\n\t\t/*\n\t\t * Calculate new sb and mount fields for this round.\n\t\t */\n\t\tnsbp->sb_rextsize = in->extsize;\n\t\tnsbp->sb_rbmblocks = bmbno + 1;\n\t\tnsbp->sb_rblocks =\n\t\t\tXFS_RTMIN(nrblocks,\n\t\t\t\t  nsbp->sb_rbmblocks * NBBY *\n\t\t\t\t  nsbp->sb_blocksize * nsbp->sb_rextsize);\n\t\tnsbp->sb_rextents = nsbp->sb_rblocks;\n\t\tdo_div(nsbp->sb_rextents, nsbp->sb_rextsize);\n\t\tASSERT(nsbp->sb_rextents != 0);\n\t\tnsbp->sb_rextslog = xfs_highbit32(nsbp->sb_rextents);\n\t\tnrsumlevels = nmp->m_rsumlevels = nsbp->sb_rextslog + 1;\n\t\tnrsumsize =\n\t\t\t(uint)sizeof(xfs_suminfo_t) * nrsumlevels *\n\t\t\tnsbp->sb_rbmblocks;\n\t\tnrsumblocks = XFS_B_TO_FSB(mp, nrsumsize);\n\t\tnmp->m_rsumsize = nrsumsize = XFS_FSB_TO_B(mp, nrsumblocks);\n\t\t/*\n\t\t * Start a transaction, get the log reservation.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_GROWFSRT_FREE);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_growrtfree,\n\t\t\t\t\t  0, 0);\n\t\tif (error)\n\t\t\tgoto error_cancel;\n\t\t/*\n\t\t * Lock out other callers by grabbing the bitmap inode lock.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\t/*\n\t\t * Update the bitmap inode's size.\n\t\t */\n\t\tmp->m_rbmip->i_d.di_size =\n\t\t\tnsbp->sb_rbmblocks * nsbp->sb_blocksize;\n\t\txfs_trans_log_inode(tp, mp->m_rbmip, XFS_ILOG_CORE);\n\t\tcancelflags |= XFS_TRANS_ABORT;\n\t\t/*\n\t\t * Get the summary inode into the transaction.\n\t\t */\n\t\txfs_ilock(mp->m_rsumip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rsumip, XFS_ILOCK_EXCL);\n\t\t/*\n\t\t * Update the summary inode's size.\n\t\t */\n\t\tmp->m_rsumip->i_d.di_size = nmp->m_rsumsize;\n\t\txfs_trans_log_inode(tp, mp->m_rsumip, XFS_ILOG_CORE);\n\t\t/*\n\t\t * Copy summary data from old to new sizes.\n\t\t * Do this when the real size (not block-aligned) changes.\n\t\t */\n\t\tif (sbp->sb_rbmblocks != nsbp->sb_rbmblocks ||\n\t\t    mp->m_rsumlevels != nmp->m_rsumlevels) {\n\t\t\terror = xfs_rtcopy_summary(mp, nmp, tp);\n\t\t\tif (error)\n\t\t\t\tgoto error_cancel;\n\t\t}\n\t\t/*\n\t\t * Update superblock fields.\n\t\t */\n\t\tif (nsbp->sb_rextsize != sbp->sb_rextsize)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_REXTSIZE,\n\t\t\t\tnsbp->sb_rextsize - sbp->sb_rextsize);\n\t\tif (nsbp->sb_rbmblocks != sbp->sb_rbmblocks)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_RBMBLOCKS,\n\t\t\t\tnsbp->sb_rbmblocks - sbp->sb_rbmblocks);\n\t\tif (nsbp->sb_rblocks != sbp->sb_rblocks)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_RBLOCKS,\n\t\t\t\tnsbp->sb_rblocks - sbp->sb_rblocks);\n\t\tif (nsbp->sb_rextents != sbp->sb_rextents)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_REXTENTS,\n\t\t\t\tnsbp->sb_rextents - sbp->sb_rextents);\n\t\tif (nsbp->sb_rextslog != sbp->sb_rextslog)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_REXTSLOG,\n\t\t\t\tnsbp->sb_rextslog - sbp->sb_rextslog);\n\t\t/*\n\t\t * Free new extent.\n\t\t */\n\t\tbp = NULL;\n\t\terror = xfs_rtfree_range(nmp, tp, sbp->sb_rextents,\n\t\t\tnsbp->sb_rextents - sbp->sb_rextents, &bp, &sumbno);\n\t\tif (error) {\nerror_cancel:\n\t\t\txfs_trans_cancel(tp, cancelflags);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Mark more blocks free in the superblock.\n\t\t */\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FREXTENTS,\n\t\t\tnsbp->sb_rextents - sbp->sb_rextents);\n\t\t/*\n\t\t * Update mp values into the real mp structure.\n\t\t */\n\t\tmp->m_rsumlevels = nrsumlevels;\n\t\tmp->m_rsumsize = nrsumsize;\n\n\t\terror = xfs_trans_commit(tp, 0);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Free the fake mp structure.\n\t */\n\tkmem_free(nmp);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_growfs_log",
          "args": [
            "mp",
            "&in"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_growfs_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
          "lines": "615-629",
          "snippet": "int\nxfs_growfs_log(\n\txfs_mount_t\t\t*mp,\n\txfs_growfs_log_t\t*in)\n{\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!mutex_trylock(&mp->m_growlock))\n\t\treturn -EWOULDBLOCK;\n\terror = xfs_growfs_log_private(mp, in);\n\tmutex_unlock(&mp->m_growlock);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_growfs_log(\n\txfs_mount_t\t\t*mp,\n\txfs_growfs_log_t\t*in)\n{\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!mutex_trylock(&mp->m_growlock))\n\t\treturn -EWOULDBLOCK;\n\terror = xfs_growfs_log_private(mp, in);\n\tmutex_unlock(&mp->m_growlock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_growfs_data",
          "args": [
            "mp",
            "&in"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_growfs_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
          "lines": "593-613",
          "snippet": "int\nxfs_growfs_data(\n\txfs_mount_t\t\t*mp,\n\txfs_growfs_data_t\t*in)\n{\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!mutex_trylock(&mp->m_growlock))\n\t\treturn -EWOULDBLOCK;\n\terror = xfs_growfs_data_private(mp, in);\n\t/*\n\t * Increment the generation unconditionally, the error could be from\n\t * updating the secondary superblocks, in which case the new size\n\t * is live already.\n\t */\n\tmp->m_generation++;\n\tmutex_unlock(&mp->m_growlock);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_growfs_data(\n\txfs_mount_t\t\t*mp,\n\txfs_growfs_data_t\t*in)\n{\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!mutex_trylock(&mp->m_growlock))\n\t\treturn -EWOULDBLOCK;\n\terror = xfs_growfs_data_private(mp, in);\n\t/*\n\t * Increment the generation unconditionally, the error could be from\n\t * updating the secondary superblocks, in which case the new size\n\t * is live already.\n\t */\n\tmp->m_generation++;\n\tmutex_unlock(&mp->m_growlock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&out",
            "sizeof(out)"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_reserve_blocks",
          "args": [
            "mp",
            "NULL",
            "&out"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_reserve_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
          "lines": "665-764",
          "snippet": "int\nxfs_reserve_blocks(\n\txfs_mount_t             *mp,\n\t__uint64_t              *inval,\n\txfs_fsop_resblks_t      *outval)\n{\n\t__int64_t\t\tlcounter, delta, fdblks_delta;\n\t__uint64_t\t\trequest;\n\n\t/* If inval is null, report current values and return */\n\tif (inval == (__uint64_t *)NULL) {\n\t\tif (!outval)\n\t\t\treturn -EINVAL;\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t\treturn 0;\n\t}\n\n\trequest = *inval;\n\n\t/*\n\t * With per-cpu counters, this becomes an interesting\n\t * problem. we needto work out if we are freeing or allocation\n\t * blocks first, then we can do the modification as necessary.\n\t *\n\t * We do this under the m_sb_lock so that if we are near\n\t * ENOSPC, we will hold out any changes while we work out\n\t * what to do. This means that the amount of free space can\n\t * change while we do this, so we need to retry if we end up\n\t * trying to reserve more space than is available.\n\t *\n\t * We also use the xfs_mod_incore_sb() interface so that we\n\t * don't have to care about whether per cpu counter are\n\t * enabled, disabled or even compiled in....\n\t */\nretry:\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, 0);\n\n\t/*\n\t * If our previous reservation was larger than the current value,\n\t * then move any unused blocks back to the free pool.\n\t */\n\tfdblks_delta = 0;\n\tif (mp->m_resblks > request) {\n\t\tlcounter = mp->m_resblks_avail - request;\n\t\tif (lcounter  > 0) {\t\t/* release unused blocks */\n\t\t\tfdblks_delta = lcounter;\n\t\t\tmp->m_resblks_avail -= lcounter;\n\t\t}\n\t\tmp->m_resblks = request;\n\t} else {\n\t\t__int64_t\tfree;\n\n\t\tfree =  mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tif (!free)\n\t\t\tgoto out; /* ENOSPC and fdblks_delta = 0 */\n\n\t\tdelta = request - mp->m_resblks;\n\t\tlcounter = free - delta;\n\t\tif (lcounter < 0) {\n\t\t\t/* We can't satisfy the request, just get what we can */\n\t\t\tmp->m_resblks += free;\n\t\t\tmp->m_resblks_avail += free;\n\t\t\tfdblks_delta = -free;\n\t\t} else {\n\t\t\tfdblks_delta = -delta;\n\t\t\tmp->m_resblks = request;\n\t\t\tmp->m_resblks_avail += delta;\n\t\t}\n\t}\nout:\n\tif (outval) {\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (fdblks_delta) {\n\t\t/*\n\t\t * If we are putting blocks back here, m_resblks_avail is\n\t\t * already at its max so this will put it in the free pool.\n\t\t *\n\t\t * If we need space, we'll either succeed in getting it\n\t\t * from the free block count or we'll get an enospc. If\n\t\t * we get a ENOSPC, it means things changed while we were\n\t\t * calculating fdblks_delta and so we should try again to\n\t\t * see if there is anything left to reserve.\n\t\t *\n\t\t * Don't set the reserved flag here - we don't want to reserve\n\t\t * the extra reserve blocks from the reserve.....\n\t\t */\n\t\tint error;\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t fdblks_delta, 0);\n\t\tif (error == -ENOSPC)\n\t\t\tgoto retry;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_reserve_blocks(\n\txfs_mount_t             *mp,\n\t__uint64_t              *inval,\n\txfs_fsop_resblks_t      *outval)\n{\n\t__int64_t\t\tlcounter, delta, fdblks_delta;\n\t__uint64_t\t\trequest;\n\n\t/* If inval is null, report current values and return */\n\tif (inval == (__uint64_t *)NULL) {\n\t\tif (!outval)\n\t\t\treturn -EINVAL;\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t\treturn 0;\n\t}\n\n\trequest = *inval;\n\n\t/*\n\t * With per-cpu counters, this becomes an interesting\n\t * problem. we needto work out if we are freeing or allocation\n\t * blocks first, then we can do the modification as necessary.\n\t *\n\t * We do this under the m_sb_lock so that if we are near\n\t * ENOSPC, we will hold out any changes while we work out\n\t * what to do. This means that the amount of free space can\n\t * change while we do this, so we need to retry if we end up\n\t * trying to reserve more space than is available.\n\t *\n\t * We also use the xfs_mod_incore_sb() interface so that we\n\t * don't have to care about whether per cpu counter are\n\t * enabled, disabled or even compiled in....\n\t */\nretry:\n\tspin_lock(&mp->m_sb_lock);\n\txfs_icsb_sync_counters_locked(mp, 0);\n\n\t/*\n\t * If our previous reservation was larger than the current value,\n\t * then move any unused blocks back to the free pool.\n\t */\n\tfdblks_delta = 0;\n\tif (mp->m_resblks > request) {\n\t\tlcounter = mp->m_resblks_avail - request;\n\t\tif (lcounter  > 0) {\t\t/* release unused blocks */\n\t\t\tfdblks_delta = lcounter;\n\t\t\tmp->m_resblks_avail -= lcounter;\n\t\t}\n\t\tmp->m_resblks = request;\n\t} else {\n\t\t__int64_t\tfree;\n\n\t\tfree =  mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tif (!free)\n\t\t\tgoto out; /* ENOSPC and fdblks_delta = 0 */\n\n\t\tdelta = request - mp->m_resblks;\n\t\tlcounter = free - delta;\n\t\tif (lcounter < 0) {\n\t\t\t/* We can't satisfy the request, just get what we can */\n\t\t\tmp->m_resblks += free;\n\t\t\tmp->m_resblks_avail += free;\n\t\t\tfdblks_delta = -free;\n\t\t} else {\n\t\t\tfdblks_delta = -delta;\n\t\t\tmp->m_resblks = request;\n\t\t\tmp->m_resblks_avail += delta;\n\t\t}\n\t}\nout:\n\tif (outval) {\n\t\toutval->resblks = mp->m_resblks;\n\t\toutval->resblks_avail = mp->m_resblks_avail;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (fdblks_delta) {\n\t\t/*\n\t\t * If we are putting blocks back here, m_resblks_avail is\n\t\t * already at its max so this will put it in the free pool.\n\t\t *\n\t\t * If we need space, we'll either succeed in getting it\n\t\t * from the free block count or we'll get an enospc. If\n\t\t * we get a ENOSPC, it means things changed while we were\n\t\t * calculating fdblks_delta and so we should try again to\n\t\t * see if there is anything left to reserve.\n\t\t *\n\t\t * Don't set the reserved flag here - we don't want to reserve\n\t\t * the extra reserve blocks from the reserve.....\n\t\t */\n\t\tint error;\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t fdblks_delta, 0);\n\t\tif (error == -ENOSPC)\n\t\t\tgoto retry;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&inout",
            "sizeof(inout)"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&out",
            "sizeof(out)"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_fs_counts",
          "args": [
            "mp",
            "&out"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_fs_counts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
          "lines": "635-648",
          "snippet": "int\nxfs_fs_counts(\n\txfs_mount_t\t\t*mp,\n\txfs_fsop_counts_t\t*cnt)\n{\n\txfs_icsb_sync_counters(mp, XFS_ICSB_LAZY_COUNT);\n\tspin_lock(&mp->m_sb_lock);\n\tcnt->freedata = mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\tcnt->freertx = mp->m_sb.sb_frextents;\n\tcnt->freeino = mp->m_sb.sb_ifree;\n\tcnt->allocino = mp->m_sb.sb_icount;\n\tspin_unlock(&mp->m_sb_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_fs_counts(\n\txfs_mount_t\t\t*mp,\n\txfs_fsop_counts_t\t*cnt)\n{\n\txfs_icsb_sync_counters(mp, XFS_ICSB_LAZY_COUNT);\n\tspin_lock(&mp->m_sb_lock);\n\tcnt->freedata = mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\tcnt->freertx = mp->m_sb.sb_frextents;\n\tcnt->freeino = mp->m_sb.sb_ifree;\n\tcnt->allocino = mp->m_sb.sb_icount;\n\tspin_unlock(&mp->m_sb_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ioc_swapext",
          "args": [
            "&sxp"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioc_swapext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "1433-1500",
          "snippet": "int\nxfs_ioc_swapext(\n\txfs_swapext_t\t*sxp)\n{\n\txfs_inode_t     *ip, *tip;\n\tstruct fd\tf, tmp;\n\tint\t\terror = 0;\n\n\t/* Pull information for the target fd */\n\tf = fdget((int)sxp->sx_fdtarget);\n\tif (!f.file) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!(f.file->f_mode & FMODE_WRITE) ||\n\t    !(f.file->f_mode & FMODE_READ) ||\n\t    (f.file->f_flags & O_APPEND)) {\n\t\terror = -EBADF;\n\t\tgoto out_put_file;\n\t}\n\n\ttmp = fdget((int)sxp->sx_fdtmp);\n\tif (!tmp.file) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_file;\n\t}\n\n\tif (!(tmp.file->f_mode & FMODE_WRITE) ||\n\t    !(tmp.file->f_mode & FMODE_READ) ||\n\t    (tmp.file->f_flags & O_APPEND)) {\n\t\terror = -EBADF;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (IS_SWAPFILE(file_inode(f.file)) ||\n\t    IS_SWAPFILE(file_inode(tmp.file))) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tip = XFS_I(file_inode(f.file));\n\ttip = XFS_I(file_inode(tmp.file));\n\n\tif (ip->i_mount != tip->i_mount) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (ip->i_ino == tip->i_ino) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\terror = -EIO;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\terror = xfs_swap_extents(ip, tip, sxp);\n\n out_put_tmp_file:\n\tfdput(tmp);\n out_put_file:\n\tfdput(f);\n out:\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_ioc_swapext(\n\txfs_swapext_t\t*sxp)\n{\n\txfs_inode_t     *ip, *tip;\n\tstruct fd\tf, tmp;\n\tint\t\terror = 0;\n\n\t/* Pull information for the target fd */\n\tf = fdget((int)sxp->sx_fdtarget);\n\tif (!f.file) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!(f.file->f_mode & FMODE_WRITE) ||\n\t    !(f.file->f_mode & FMODE_READ) ||\n\t    (f.file->f_flags & O_APPEND)) {\n\t\terror = -EBADF;\n\t\tgoto out_put_file;\n\t}\n\n\ttmp = fdget((int)sxp->sx_fdtmp);\n\tif (!tmp.file) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_file;\n\t}\n\n\tif (!(tmp.file->f_mode & FMODE_WRITE) ||\n\t    !(tmp.file->f_mode & FMODE_READ) ||\n\t    (tmp.file->f_flags & O_APPEND)) {\n\t\terror = -EBADF;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (IS_SWAPFILE(file_inode(f.file)) ||\n\t    IS_SWAPFILE(file_inode(tmp.file))) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tip = XFS_I(file_inode(f.file));\n\ttip = XFS_I(file_inode(tmp.file));\n\n\tif (ip->i_mount != tip->i_mount) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (ip->i_ino == tip->i_ino) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\terror = -EIO;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\terror = xfs_swap_extents(ip, tip, sxp);\n\n out_put_tmp_file:\n\tfdput(tmp);\n out_put_file:\n\tfdput(f);\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attrmulti_by_handle",
          "args": [
            "filp",
            "arg"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attrmulti_by_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "509-599",
          "snippet": "STATIC int\nxfs_attrmulti_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror;\n\txfs_attr_multiop_t\t*ops;\n\txfs_fsop_attrmulti_handlereq_t am_hreq;\n\tstruct dentry\t\t*dentry;\n\tunsigned int\t\ti, size;\n\tunsigned char\t\t*attr_name;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&am_hreq, arg, sizeof(xfs_fsop_attrmulti_handlereq_t)))\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (am_hreq.opcount >= INT_MAX / sizeof(xfs_attr_multiop_t))\n\t\treturn -E2BIG;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &am_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terror = -E2BIG;\n\tsize = am_hreq.opcount * sizeof(xfs_attr_multiop_t);\n\tif (!size || size > 16 * PAGE_SIZE)\n\t\tgoto out_dput;\n\n\tops = memdup_user(am_hreq.ops, size);\n\tif (IS_ERR(ops)) {\n\t\terror = PTR_ERR(ops);\n\t\tgoto out_dput;\n\t}\n\n\terror = -ENOMEM;\n\tattr_name = kmalloc(MAXNAMELEN, GFP_KERNEL);\n\tif (!attr_name)\n\t\tgoto out_kfree_ops;\n\n\terror = 0;\n\tfor (i = 0; i < am_hreq.opcount; i++) {\n\t\tops[i].am_error = strncpy_from_user((char *)attr_name,\n\t\t\t\tops[i].am_attrname, MAXNAMELEN);\n\t\tif (ops[i].am_error == 0 || ops[i].am_error == MAXNAMELEN)\n\t\t\terror = -ERANGE;\n\t\tif (ops[i].am_error < 0)\n\t\t\tbreak;\n\n\t\tswitch (ops[i].am_opcode) {\n\t\tcase ATTR_OP_GET:\n\t\t\tops[i].am_error = xfs_attrmulti_attr_get(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tops[i].am_attrvalue, &ops[i].am_length,\n\t\t\t\t\tops[i].am_flags);\n\t\t\tbreak;\n\t\tcase ATTR_OP_SET:\n\t\t\tops[i].am_error = mnt_want_write_file(parfilp);\n\t\t\tif (ops[i].am_error)\n\t\t\t\tbreak;\n\t\t\tops[i].am_error = xfs_attrmulti_attr_set(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tops[i].am_attrvalue, ops[i].am_length,\n\t\t\t\t\tops[i].am_flags);\n\t\t\tmnt_drop_write_file(parfilp);\n\t\t\tbreak;\n\t\tcase ATTR_OP_REMOVE:\n\t\t\tops[i].am_error = mnt_want_write_file(parfilp);\n\t\t\tif (ops[i].am_error)\n\t\t\t\tbreak;\n\t\t\tops[i].am_error = xfs_attrmulti_attr_remove(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tops[i].am_flags);\n\t\t\tmnt_drop_write_file(parfilp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tops[i].am_error = -EINVAL;\n\t\t}\n\t}\n\n\tif (copy_to_user(am_hreq.ops, ops, size))\n\t\terror = -EFAULT;\n\n\tkfree(attr_name);\n out_kfree_ops:\n\tkfree(ops);\n out_dput:\n\tdput(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_attrmulti_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror;\n\txfs_attr_multiop_t\t*ops;\n\txfs_fsop_attrmulti_handlereq_t am_hreq;\n\tstruct dentry\t\t*dentry;\n\tunsigned int\t\ti, size;\n\tunsigned char\t\t*attr_name;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&am_hreq, arg, sizeof(xfs_fsop_attrmulti_handlereq_t)))\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (am_hreq.opcount >= INT_MAX / sizeof(xfs_attr_multiop_t))\n\t\treturn -E2BIG;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &am_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terror = -E2BIG;\n\tsize = am_hreq.opcount * sizeof(xfs_attr_multiop_t);\n\tif (!size || size > 16 * PAGE_SIZE)\n\t\tgoto out_dput;\n\n\tops = memdup_user(am_hreq.ops, size);\n\tif (IS_ERR(ops)) {\n\t\terror = PTR_ERR(ops);\n\t\tgoto out_dput;\n\t}\n\n\terror = -ENOMEM;\n\tattr_name = kmalloc(MAXNAMELEN, GFP_KERNEL);\n\tif (!attr_name)\n\t\tgoto out_kfree_ops;\n\n\terror = 0;\n\tfor (i = 0; i < am_hreq.opcount; i++) {\n\t\tops[i].am_error = strncpy_from_user((char *)attr_name,\n\t\t\t\tops[i].am_attrname, MAXNAMELEN);\n\t\tif (ops[i].am_error == 0 || ops[i].am_error == MAXNAMELEN)\n\t\t\terror = -ERANGE;\n\t\tif (ops[i].am_error < 0)\n\t\t\tbreak;\n\n\t\tswitch (ops[i].am_opcode) {\n\t\tcase ATTR_OP_GET:\n\t\t\tops[i].am_error = xfs_attrmulti_attr_get(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tops[i].am_attrvalue, &ops[i].am_length,\n\t\t\t\t\tops[i].am_flags);\n\t\t\tbreak;\n\t\tcase ATTR_OP_SET:\n\t\t\tops[i].am_error = mnt_want_write_file(parfilp);\n\t\t\tif (ops[i].am_error)\n\t\t\t\tbreak;\n\t\t\tops[i].am_error = xfs_attrmulti_attr_set(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tops[i].am_attrvalue, ops[i].am_length,\n\t\t\t\t\tops[i].am_flags);\n\t\t\tmnt_drop_write_file(parfilp);\n\t\t\tbreak;\n\t\tcase ATTR_OP_REMOVE:\n\t\t\tops[i].am_error = mnt_want_write_file(parfilp);\n\t\t\tif (ops[i].am_error)\n\t\t\t\tbreak;\n\t\t\tops[i].am_error = xfs_attrmulti_attr_remove(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tops[i].am_flags);\n\t\t\tmnt_drop_write_file(parfilp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tops[i].am_error = -EINVAL;\n\t\t}\n\t}\n\n\tif (copy_to_user(am_hreq.ops, ops, size))\n\t\terror = -EFAULT;\n\n\tkfree(attr_name);\n out_kfree_ops:\n\tkfree(ops);\n out_dput:\n\tdput(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attrlist_by_handle",
          "args": [
            "filp",
            "arg"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attrlist_by_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "398-445",
          "snippet": "STATIC int\nxfs_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror = -ENOMEM;\n\tattrlist_cursor_kern_t\t*cursor;\n\txfs_fsop_attrlist_handlereq_t al_hreq;\n\tstruct dentry\t\t*dentry;\n\tchar\t\t\t*kbuf;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&al_hreq, arg, sizeof(xfs_fsop_attrlist_handlereq_t)))\n\t\treturn -EFAULT;\n\tif (al_hreq.buflen < sizeof(struct attrlist) ||\n\t    al_hreq.buflen > XATTR_LIST_MAX)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Reject flags, only allow namespaces.\n\t */\n\tif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\n\t\treturn -EINVAL;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\n\tif (!kbuf)\n\t\tgoto out_dput;\n\n\tcursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\n\terror = xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,\n\t\t\t\t\tal_hreq.flags, cursor);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(al_hreq.buffer, kbuf, al_hreq.buflen))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\nout_dput:\n\tdput(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror = -ENOMEM;\n\tattrlist_cursor_kern_t\t*cursor;\n\txfs_fsop_attrlist_handlereq_t al_hreq;\n\tstruct dentry\t\t*dentry;\n\tchar\t\t\t*kbuf;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&al_hreq, arg, sizeof(xfs_fsop_attrlist_handlereq_t)))\n\t\treturn -EFAULT;\n\tif (al_hreq.buflen < sizeof(struct attrlist) ||\n\t    al_hreq.buflen > XATTR_LIST_MAX)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Reject flags, only allow namespaces.\n\t */\n\tif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\n\t\treturn -EINVAL;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\n\tif (!kbuf)\n\t\tgoto out_dput;\n\n\tcursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\n\terror = xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,\n\t\t\t\t\tal_hreq.flags, cursor);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(al_hreq.buffer, kbuf, al_hreq.buflen))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\nout_dput:\n\tdput(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_readlink_by_handle",
          "args": [
            "filp",
            "&hreq"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_readlink_by_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "272-318",
          "snippet": "int\nxfs_readlink_by_handle(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tstruct dentry\t\t*dentry;\n\t__u32\t\t\tolen;\n\tvoid\t\t\t*link;\n\tint\t\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\t/* Restrict this handle operation to symlinks only. */\n\tif (!d_is_symlink(dentry)) {\n\t\terror = -EINVAL;\n\t\tgoto out_dput;\n\t}\n\n\tif (copy_from_user(&olen, hreq->ohandlen, sizeof(__u32))) {\n\t\terror = -EFAULT;\n\t\tgoto out_dput;\n\t}\n\n\tlink = kmalloc(MAXPATHLEN+1, GFP_KERNEL);\n\tif (!link) {\n\t\terror = -ENOMEM;\n\t\tgoto out_dput;\n\t}\n\n\terror = xfs_readlink(XFS_I(dentry->d_inode), link);\n\tif (error)\n\t\tgoto out_kfree;\n\terror = readlink_copy(hreq->ohandle, olen, link);\n\tif (error)\n\t\tgoto out_kfree;\n\n out_kfree:\n\tkfree(link);\n out_dput:\n\tdput(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_readlink_by_handle(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tstruct dentry\t\t*dentry;\n\t__u32\t\t\tolen;\n\tvoid\t\t\t*link;\n\tint\t\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\t/* Restrict this handle operation to symlinks only. */\n\tif (!d_is_symlink(dentry)) {\n\t\terror = -EINVAL;\n\t\tgoto out_dput;\n\t}\n\n\tif (copy_from_user(&olen, hreq->ohandlen, sizeof(__u32))) {\n\t\terror = -EFAULT;\n\t\tgoto out_dput;\n\t}\n\n\tlink = kmalloc(MAXPATHLEN+1, GFP_KERNEL);\n\tif (!link) {\n\t\terror = -ENOMEM;\n\t\tgoto out_dput;\n\t}\n\n\terror = xfs_readlink(XFS_I(dentry->d_inode), link);\n\tif (error)\n\t\tgoto out_kfree;\n\terror = readlink_copy(hreq->ohandle, olen, link);\n\tif (error)\n\t\tgoto out_kfree;\n\n out_kfree:\n\tkfree(link);\n out_dput:\n\tdput(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_fssetdm_by_handle",
          "args": [
            "filp",
            "arg"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_fssetdm_by_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "354-396",
          "snippet": "STATIC int\nxfs_fssetdm_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror;\n\tstruct fsdmidata\tfsd;\n\txfs_fsop_setdm_handlereq_t dmhreq;\n\tstruct dentry\t\t*dentry;\n\n\tif (!capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\tif (copy_from_user(&dmhreq, arg, sizeof(xfs_fsop_setdm_handlereq_t)))\n\t\treturn -EFAULT;\n\n\terror = mnt_want_write_file(parfilp);\n\tif (error)\n\t\treturn error;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &dmhreq.hreq);\n\tif (IS_ERR(dentry)) {\n\t\tmnt_drop_write_file(parfilp);\n\t\treturn PTR_ERR(dentry);\n\t}\n\n\tif (IS_IMMUTABLE(dentry->d_inode) || IS_APPEND(dentry->d_inode)) {\n\t\terror = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(&fsd, dmhreq.data, sizeof(fsd))) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terror = xfs_set_dmattrs(XFS_I(dentry->d_inode), fsd.fsd_dmevmask,\n\t\t\t\t fsd.fsd_dmstate);\n\n out:\n\tmnt_drop_write_file(parfilp);\n\tdput(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_fssetdm_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror;\n\tstruct fsdmidata\tfsd;\n\txfs_fsop_setdm_handlereq_t dmhreq;\n\tstruct dentry\t\t*dentry;\n\n\tif (!capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\tif (copy_from_user(&dmhreq, arg, sizeof(xfs_fsop_setdm_handlereq_t)))\n\t\treturn -EFAULT;\n\n\terror = mnt_want_write_file(parfilp);\n\tif (error)\n\t\treturn error;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &dmhreq.hreq);\n\tif (IS_ERR(dentry)) {\n\t\tmnt_drop_write_file(parfilp);\n\t\treturn PTR_ERR(dentry);\n\t}\n\n\tif (IS_IMMUTABLE(dentry->d_inode) || IS_APPEND(dentry->d_inode)) {\n\t\terror = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(&fsd, dmhreq.data, sizeof(fsd))) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terror = xfs_set_dmattrs(XFS_I(dentry->d_inode), fsd.fsd_dmevmask,\n\t\t\t\t fsd.fsd_dmstate);\n\n out:\n\tmnt_drop_write_file(parfilp);\n\tdput(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_open_by_handle",
          "args": [
            "filp",
            "&hreq"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_open_by_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "192-270",
          "snippet": "int\nxfs_open_by_handle(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tconst struct cred\t*cred = current_cred();\n\tint\t\t\terror;\n\tint\t\t\tfd;\n\tint\t\t\tpermflag;\n\tstruct file\t\t*filp;\n\tstruct inode\t\t*inode;\n\tstruct dentry\t\t*dentry;\n\tfmode_t\t\t\tfmode;\n\tstruct path\t\tpath;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\tinode = dentry->d_inode;\n\n\t/* Restrict xfs_open_by_handle to directories & regular files. */\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))) {\n\t\terror = -EPERM;\n\t\tgoto out_dput;\n\t}\n\n#if BITS_PER_LONG != 32\n\threq->oflags |= O_LARGEFILE;\n#endif\n\n\tpermflag = hreq->oflags;\n\tfmode = OPEN_FMODE(permflag);\n\tif ((!(permflag & O_APPEND) || (permflag & O_TRUNC)) &&\n\t    (fmode & FMODE_WRITE) && IS_APPEND(inode)) {\n\t\terror = -EPERM;\n\t\tgoto out_dput;\n\t}\n\n\tif ((fmode & FMODE_WRITE) && IS_IMMUTABLE(inode)) {\n\t\terror = -EACCES;\n\t\tgoto out_dput;\n\t}\n\n\t/* Can't write directories. */\n\tif (S_ISDIR(inode->i_mode) && (fmode & FMODE_WRITE)) {\n\t\terror = -EISDIR;\n\t\tgoto out_dput;\n\t}\n\n\tfd = get_unused_fd_flags(0);\n\tif (fd < 0) {\n\t\terror = fd;\n\t\tgoto out_dput;\n\t}\n\n\tpath.mnt = parfilp->f_path.mnt;\n\tpath.dentry = dentry;\n\tfilp = dentry_open(&path, hreq->oflags, cred);\n\tdput(dentry);\n\tif (IS_ERR(filp)) {\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(filp);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tfilp->f_flags |= O_NOATIME;\n\t\tfilp->f_mode |= FMODE_NOCMTIME;\n\t}\n\n\tfd_install(fd, filp);\n\treturn fd;\n\n out_dput:\n\tdput(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_open_by_handle(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tconst struct cred\t*cred = current_cred();\n\tint\t\t\terror;\n\tint\t\t\tfd;\n\tint\t\t\tpermflag;\n\tstruct file\t\t*filp;\n\tstruct inode\t\t*inode;\n\tstruct dentry\t\t*dentry;\n\tfmode_t\t\t\tfmode;\n\tstruct path\t\tpath;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\tinode = dentry->d_inode;\n\n\t/* Restrict xfs_open_by_handle to directories & regular files. */\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))) {\n\t\terror = -EPERM;\n\t\tgoto out_dput;\n\t}\n\n#if BITS_PER_LONG != 32\n\threq->oflags |= O_LARGEFILE;\n#endif\n\n\tpermflag = hreq->oflags;\n\tfmode = OPEN_FMODE(permflag);\n\tif ((!(permflag & O_APPEND) || (permflag & O_TRUNC)) &&\n\t    (fmode & FMODE_WRITE) && IS_APPEND(inode)) {\n\t\terror = -EPERM;\n\t\tgoto out_dput;\n\t}\n\n\tif ((fmode & FMODE_WRITE) && IS_IMMUTABLE(inode)) {\n\t\terror = -EACCES;\n\t\tgoto out_dput;\n\t}\n\n\t/* Can't write directories. */\n\tif (S_ISDIR(inode->i_mode) && (fmode & FMODE_WRITE)) {\n\t\terror = -EISDIR;\n\t\tgoto out_dput;\n\t}\n\n\tfd = get_unused_fd_flags(0);\n\tif (fd < 0) {\n\t\terror = fd;\n\t\tgoto out_dput;\n\t}\n\n\tpath.mnt = parfilp->f_path.mnt;\n\tpath.dentry = dentry;\n\tfilp = dentry_open(&path, hreq->oflags, cred);\n\tdput(dentry);\n\tif (IS_ERR(filp)) {\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(filp);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tfilp->f_flags |= O_NOATIME;\n\t\tfilp->f_mode |= FMODE_NOCMTIME;\n\t}\n\n\tfd_install(fd, filp);\n\treturn fd;\n\n out_dput:\n\tdput(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_find_handle",
          "args": [
            "cmd",
            "&hreq"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_find_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "63-135",
          "snippet": "int\nxfs_find_handle(\n\tunsigned int\t\tcmd,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tint\t\t\thsize;\n\txfs_handle_t\t\thandle;\n\tstruct inode\t\t*inode;\n\tstruct fd\t\tf = {NULL};\n\tstruct path\t\tpath;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*ip;\n\n\tif (cmd == XFS_IOC_FD_TO_HANDLE) {\n\t\tf = fdget(hreq->fd);\n\t\tif (!f.file)\n\t\t\treturn -EBADF;\n\t\tinode = file_inode(f.file);\n\t} else {\n\t\terror = user_lpath((const char __user *)hreq->path, &path);\n\t\tif (error)\n\t\t\treturn error;\n\t\tinode = path.dentry->d_inode;\n\t}\n\tip = XFS_I(inode);\n\n\t/*\n\t * We can only generate handles for inodes residing on a XFS filesystem,\n\t * and only for regular files, directories or symbolic links.\n\t */\n\terror = -EINVAL;\n\tif (inode->i_sb->s_magic != XFS_SB_MAGIC)\n\t\tgoto out_put;\n\n\terror = -EBADF;\n\tif (!S_ISREG(inode->i_mode) &&\n\t    !S_ISDIR(inode->i_mode) &&\n\t    !S_ISLNK(inode->i_mode))\n\t\tgoto out_put;\n\n\n\tmemcpy(&handle.ha_fsid, ip->i_mount->m_fixedfsid, sizeof(xfs_fsid_t));\n\n\tif (cmd == XFS_IOC_PATH_TO_FSHANDLE) {\n\t\t/*\n\t\t * This handle only contains an fsid, zero the rest.\n\t\t */\n\t\tmemset(&handle.ha_fid, 0, sizeof(handle.ha_fid));\n\t\thsize = sizeof(xfs_fsid_t);\n\t} else {\n\t\thandle.ha_fid.fid_len = sizeof(xfs_fid_t) -\n\t\t\t\t\tsizeof(handle.ha_fid.fid_len);\n\t\thandle.ha_fid.fid_pad = 0;\n\t\thandle.ha_fid.fid_gen = ip->i_d.di_gen;\n\t\thandle.ha_fid.fid_ino = ip->i_ino;\n\n\t\thsize = XFS_HSIZE(handle);\n\t}\n\n\terror = -EFAULT;\n\tif (copy_to_user(hreq->ohandle, &handle, hsize) ||\n\t    copy_to_user(hreq->ohandlen, &hsize, sizeof(__s32)))\n\t\tgoto out_put;\n\n\terror = 0;\n\n out_put:\n\tif (cmd == XFS_IOC_FD_TO_HANDLE)\n\t\tfdput(f);\n\telse\n\t\tpath_put(&path);\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_find_handle(\n\tunsigned int\t\tcmd,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tint\t\t\thsize;\n\txfs_handle_t\t\thandle;\n\tstruct inode\t\t*inode;\n\tstruct fd\t\tf = {NULL};\n\tstruct path\t\tpath;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*ip;\n\n\tif (cmd == XFS_IOC_FD_TO_HANDLE) {\n\t\tf = fdget(hreq->fd);\n\t\tif (!f.file)\n\t\t\treturn -EBADF;\n\t\tinode = file_inode(f.file);\n\t} else {\n\t\terror = user_lpath((const char __user *)hreq->path, &path);\n\t\tif (error)\n\t\t\treturn error;\n\t\tinode = path.dentry->d_inode;\n\t}\n\tip = XFS_I(inode);\n\n\t/*\n\t * We can only generate handles for inodes residing on a XFS filesystem,\n\t * and only for regular files, directories or symbolic links.\n\t */\n\terror = -EINVAL;\n\tif (inode->i_sb->s_magic != XFS_SB_MAGIC)\n\t\tgoto out_put;\n\n\terror = -EBADF;\n\tif (!S_ISREG(inode->i_mode) &&\n\t    !S_ISDIR(inode->i_mode) &&\n\t    !S_ISLNK(inode->i_mode))\n\t\tgoto out_put;\n\n\n\tmemcpy(&handle.ha_fsid, ip->i_mount->m_fixedfsid, sizeof(xfs_fsid_t));\n\n\tif (cmd == XFS_IOC_PATH_TO_FSHANDLE) {\n\t\t/*\n\t\t * This handle only contains an fsid, zero the rest.\n\t\t */\n\t\tmemset(&handle.ha_fid, 0, sizeof(handle.ha_fid));\n\t\thsize = sizeof(xfs_fsid_t);\n\t} else {\n\t\thandle.ha_fid.fid_len = sizeof(xfs_fid_t) -\n\t\t\t\t\tsizeof(handle.ha_fid.fid_len);\n\t\thandle.ha_fid.fid_pad = 0;\n\t\thandle.ha_fid.fid_gen = ip->i_d.di_gen;\n\t\thandle.ha_fid.fid_ino = ip->i_ino;\n\n\t\thsize = XFS_HSIZE(handle);\n\t}\n\n\terror = -EFAULT;\n\tif (copy_to_user(hreq->ohandle, &handle, hsize) ||\n\t    copy_to_user(hreq->ohandlen, &hsize, sizeof(__s32)))\n\t\tgoto out_put;\n\n\terror = 0;\n\n out_put:\n\tif (cmd == XFS_IOC_FD_TO_HANDLE)\n\t\tfdput(f);\n\telse\n\t\tpath_put(&path);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ioc_getbmapx",
          "args": [
            "ip",
            "arg"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioc_getbmapx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "1404-1431",
          "snippet": "STATIC int\nxfs_ioc_getbmapx(\n\tstruct xfs_inode\t*ip,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct getbmapx\t\tbmx;\n\tint\t\t\terror;\n\n\tif (copy_from_user(&bmx, arg, sizeof(bmx)))\n\t\treturn -EFAULT;\n\n\tif (bmx.bmv_count < 2)\n\t\treturn -EINVAL;\n\n\tif (bmx.bmv_iflags & (~BMV_IF_VALID))\n\t\treturn -EINVAL;\n\n\terror = xfs_getbmap(ip, &bmx, xfs_getbmapx_format,\n\t\t\t    (__force struct getbmapx *)arg+1);\n\tif (error)\n\t\treturn error;\n\n\t/* copy back header */\n\tif (copy_to_user(arg, &bmx, sizeof(struct getbmapx)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_ioc_getbmapx(\n\tstruct xfs_inode\t*ip,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct getbmapx\t\tbmx;\n\tint\t\t\terror;\n\n\tif (copy_from_user(&bmx, arg, sizeof(bmx)))\n\t\treturn -EFAULT;\n\n\tif (bmx.bmv_count < 2)\n\t\treturn -EINVAL;\n\n\tif (bmx.bmv_iflags & (~BMV_IF_VALID))\n\t\treturn -EINVAL;\n\n\terror = xfs_getbmap(ip, &bmx, xfs_getbmapx_format,\n\t\t\t    (__force struct getbmapx *)arg+1);\n\tif (error)\n\t\treturn error;\n\n\t/* copy back header */\n\tif (copy_to_user(arg, &bmx, sizeof(struct getbmapx)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ioc_getbmap",
          "args": [
            "ip",
            "ioflags",
            "cmd",
            "arg"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioc_getbmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "1361-1390",
          "snippet": "STATIC int\nxfs_ioc_getbmap(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tioflags,\n\tunsigned int\t\tcmd,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct getbmapx\t\tbmx;\n\tint\t\t\terror;\n\n\tif (copy_from_user(&bmx, arg, sizeof(struct getbmapx)))\n\t\treturn -EFAULT;\n\n\tif (bmx.bmv_count < 2)\n\t\treturn -EINVAL;\n\n\tbmx.bmv_iflags = (cmd == XFS_IOC_GETBMAPA ? BMV_IF_ATTRFORK : 0);\n\tif (ioflags & XFS_IO_INVIS)\n\t\tbmx.bmv_iflags |= BMV_IF_NO_DMAPI_READ;\n\n\terror = xfs_getbmap(ip, &bmx, xfs_getbmap_format,\n\t\t\t    (__force struct getbmap *)arg+1);\n\tif (error)\n\t\treturn error;\n\n\t/* copy back header - only size of getbmap */\n\tif (copy_to_user(arg, &bmx, sizeof(struct getbmap)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_ioc_getbmap(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tioflags,\n\tunsigned int\t\tcmd,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct getbmapx\t\tbmx;\n\tint\t\t\terror;\n\n\tif (copy_from_user(&bmx, arg, sizeof(struct getbmapx)))\n\t\treturn -EFAULT;\n\n\tif (bmx.bmv_count < 2)\n\t\treturn -EINVAL;\n\n\tbmx.bmv_iflags = (cmd == XFS_IOC_GETBMAPA ? BMV_IF_ATTRFORK : 0);\n\tif (ioflags & XFS_IO_INVIS)\n\t\tbmx.bmv_iflags |= BMV_IF_NO_DMAPI_READ;\n\n\terror = xfs_getbmap(ip, &bmx, xfs_getbmap_format,\n\t\t\t    (__force struct getbmap *)arg+1);\n\tif (error)\n\t\treturn error;\n\n\t/* copy back header - only size of getbmap */\n\tif (copy_to_user(arg, &bmx, sizeof(struct getbmap)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_set_dmattrs",
          "args": [
            "ip",
            "dmi.fsd_dmevmask",
            "dmi.fsd_dmstate"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_set_dmattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "320-352",
          "snippet": "int\nxfs_set_dmattrs(\n\txfs_inode_t     *ip,\n\tu_int\t\tevmask,\n\tu_int16_t\tstate)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SET_DMATTRS);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\tip->i_d.di_dmevmask = evmask;\n\tip->i_d.di_dmstate  = state;\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(tp, 0);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_set_dmattrs(\n\txfs_inode_t     *ip,\n\tu_int\t\tevmask,\n\tu_int16_t\tstate)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SET_DMATTRS);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\tip->i_d.di_dmevmask = evmask;\n\tip->i_d.di_dmstate  = state;\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(tp, 0);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ioc_setxflags",
          "args": [
            "ip",
            "filp",
            "arg"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioc_setxflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "1305-1346",
          "snippet": "STATIC int\nxfs_ioc_setxflags(\n\tstruct xfs_inode\t*ip,\n\tstruct file\t\t*filp,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct xfs_trans\t*tp;\n\tstruct fsxattr\t\tfa;\n\tunsigned int\t\tflags;\n\tint\t\t\terror;\n\n\tif (copy_from_user(&flags, arg, sizeof(flags)))\n\t\treturn -EFAULT;\n\n\tif (flags & ~(FS_IMMUTABLE_FL | FS_APPEND_FL | \\\n\t\t      FS_NOATIME_FL | FS_NODUMP_FL | \\\n\t\t      FS_SYNC_FL))\n\t\treturn -EOPNOTSUPP;\n\n\tfa.fsx_xflags = xfs_merge_ioc_xflags(flags, xfs_ip2xflags(ip));\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\n\ttp = xfs_ioctl_setattr_get_trans(ip);\n\tif (IS_ERR(tp)) {\n\t\terror = PTR_ERR(tp);\n\t\tgoto out_drop_write;\n\t}\n\n\terror = xfs_ioctl_setattr_xflags(tp, ip, &fa);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto out_drop_write;\n\t}\n\n\terror = xfs_trans_commit(tp, 0);\nout_drop_write:\n\tmnt_drop_write_file(filp);\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_ioc_setxflags(\n\tstruct xfs_inode\t*ip,\n\tstruct file\t\t*filp,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct xfs_trans\t*tp;\n\tstruct fsxattr\t\tfa;\n\tunsigned int\t\tflags;\n\tint\t\t\terror;\n\n\tif (copy_from_user(&flags, arg, sizeof(flags)))\n\t\treturn -EFAULT;\n\n\tif (flags & ~(FS_IMMUTABLE_FL | FS_APPEND_FL | \\\n\t\t      FS_NOATIME_FL | FS_NODUMP_FL | \\\n\t\t      FS_SYNC_FL))\n\t\treturn -EOPNOTSUPP;\n\n\tfa.fsx_xflags = xfs_merge_ioc_xflags(flags, xfs_ip2xflags(ip));\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\n\ttp = xfs_ioctl_setattr_get_trans(ip);\n\tif (IS_ERR(tp)) {\n\t\terror = PTR_ERR(tp);\n\t\tgoto out_drop_write;\n\t}\n\n\terror = xfs_ioctl_setattr_xflags(tp, ip, &fa);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto out_drop_write;\n\t}\n\n\terror = xfs_trans_commit(tp, 0);\nout_drop_write:\n\tmnt_drop_write_file(filp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ioc_getxflags",
          "args": [
            "ip",
            "arg"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioc_getxflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "1292-1303",
          "snippet": "STATIC int\nxfs_ioc_getxflags(\n\txfs_inode_t\t\t*ip,\n\tvoid\t\t\t__user *arg)\n{\n\tunsigned int\t\tflags;\n\n\tflags = xfs_di2lxflags(ip->i_d.di_flags);\n\tif (copy_to_user(arg, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_ioc_getxflags(\n\txfs_inode_t\t\t*ip,\n\tvoid\t\t\t__user *arg)\n{\n\tunsigned int\t\tflags;\n\n\tflags = xfs_di2lxflags(ip->i_d.di_flags);\n\tif (copy_to_user(arg, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ioc_fssetxattr",
          "args": [
            "ip",
            "filp",
            "arg"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioc_fssetxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "1272-1290",
          "snippet": "STATIC int\nxfs_ioc_fssetxattr(\n\txfs_inode_t\t\t*ip,\n\tstruct file\t\t*filp,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct fsxattr\t\tfa;\n\tint error;\n\n\tif (copy_from_user(&fa, arg, sizeof(fa)))\n\t\treturn -EFAULT;\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\terror = xfs_ioctl_setattr(ip, &fa);\n\tmnt_drop_write_file(filp);\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_ioc_fssetxattr(\n\txfs_inode_t\t\t*ip,\n\tstruct file\t\t*filp,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct fsxattr\t\tfa;\n\tint error;\n\n\tif (copy_from_user(&fa, arg, sizeof(fa)))\n\t\treturn -EFAULT;\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\terror = xfs_ioctl_setattr(ip, &fa);\n\tmnt_drop_write_file(filp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ioc_fsgetxattr",
          "args": [
            "ip",
            "1",
            "arg"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioc_fsgetxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "890-926",
          "snippet": "STATIC int\nxfs_ioc_fsgetxattr(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\tattr,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct fsxattr\t\tfa;\n\n\tmemset(&fa, 0, sizeof(struct fsxattr));\n\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\tfa.fsx_xflags = xfs_ip2xflags(ip);\n\tfa.fsx_extsize = ip->i_d.di_extsize << ip->i_mount->m_sb.sb_blocklog;\n\tfa.fsx_projid = xfs_get_projid(ip);\n\n\tif (attr) {\n\t\tif (ip->i_afp) {\n\t\t\tif (ip->i_afp->if_flags & XFS_IFEXTENTS)\n\t\t\t\tfa.fsx_nextents = ip->i_afp->if_bytes /\n\t\t\t\t\t\t\tsizeof(xfs_bmbt_rec_t);\n\t\t\telse\n\t\t\t\tfa.fsx_nextents = ip->i_d.di_anextents;\n\t\t} else\n\t\t\tfa.fsx_nextents = 0;\n\t} else {\n\t\tif (ip->i_df.if_flags & XFS_IFEXTENTS)\n\t\t\tfa.fsx_nextents = ip->i_df.if_bytes /\n\t\t\t\t\t\tsizeof(xfs_bmbt_rec_t);\n\t\telse\n\t\t\tfa.fsx_nextents = ip->i_d.di_nextents;\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (copy_to_user(arg, &fa, sizeof(fa)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_ioc_fsgetxattr(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\tattr,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct fsxattr\t\tfa;\n\n\tmemset(&fa, 0, sizeof(struct fsxattr));\n\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\tfa.fsx_xflags = xfs_ip2xflags(ip);\n\tfa.fsx_extsize = ip->i_d.di_extsize << ip->i_mount->m_sb.sb_blocklog;\n\tfa.fsx_projid = xfs_get_projid(ip);\n\n\tif (attr) {\n\t\tif (ip->i_afp) {\n\t\t\tif (ip->i_afp->if_flags & XFS_IFEXTENTS)\n\t\t\t\tfa.fsx_nextents = ip->i_afp->if_bytes /\n\t\t\t\t\t\t\tsizeof(xfs_bmbt_rec_t);\n\t\t\telse\n\t\t\t\tfa.fsx_nextents = ip->i_d.di_anextents;\n\t\t} else\n\t\t\tfa.fsx_nextents = 0;\n\t} else {\n\t\tif (ip->i_df.if_flags & XFS_IFEXTENTS)\n\t\t\tfa.fsx_nextents = ip->i_df.if_bytes /\n\t\t\t\t\t\tsizeof(xfs_bmbt_rec_t);\n\t\telse\n\t\t\tfa.fsx_nextents = ip->i_d.di_nextents;\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (copy_to_user(arg, &fa, sizeof(fa)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "inode->i_generation",
            "(int __user *)arg"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ioc_fsgeometry",
          "args": [
            "mp",
            "arg"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioc_fsgeometry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "819-834",
          "snippet": "STATIC int\nxfs_ioc_fsgeometry(\n\txfs_mount_t\t\t*mp,\n\tvoid\t\t\t__user *arg)\n{\n\txfs_fsop_geom_t\t\tfsgeo;\n\tint\t\t\terror;\n\n\terror = xfs_fs_geometry(mp, &fsgeo, 4);\n\tif (error)\n\t\treturn error;\n\n\tif (copy_to_user(arg, &fsgeo, sizeof(fsgeo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_ioc_fsgeometry(\n\txfs_mount_t\t\t*mp,\n\tvoid\t\t\t__user *arg)\n{\n\txfs_fsop_geom_t\t\tfsgeo;\n\tint\t\t\terror;\n\n\terror = xfs_fs_geometry(mp, &fsgeo, 4);\n\tif (error)\n\t\treturn error;\n\n\tif (copy_to_user(arg, &fsgeo, sizeof(fsgeo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ioc_fsgeometry_v1",
          "args": [
            "mp",
            "arg"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioc_fsgeometry_v1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "797-817",
          "snippet": "STATIC int\nxfs_ioc_fsgeometry_v1(\n\txfs_mount_t\t\t*mp,\n\tvoid\t\t\t__user *arg)\n{\n\txfs_fsop_geom_t         fsgeo;\n\tint\t\t\terror;\n\n\terror = xfs_fs_geometry(mp, &fsgeo, 3);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Caller should have passed an argument of type\n\t * xfs_fsop_geom_v1_t.  This is a proper subset of the\n\t * xfs_fsop_geom_t that xfs_fs_geometry() fills in.\n\t */\n\tif (copy_to_user(arg, &fsgeo, sizeof(xfs_fsop_geom_v1_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_ioc_fsgeometry_v1(\n\txfs_mount_t\t\t*mp,\n\tvoid\t\t\t__user *arg)\n{\n\txfs_fsop_geom_t         fsgeo;\n\tint\t\t\terror;\n\n\terror = xfs_fs_geometry(mp, &fsgeo, 3);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Caller should have passed an argument of type\n\t * xfs_fsop_geom_v1_t.  This is a proper subset of the\n\t * xfs_fsop_geom_t that xfs_fs_geometry() fills in.\n\t */\n\tif (copy_to_user(arg, &fsgeo, sizeof(xfs_fsop_geom_v1_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ioc_bulkstat",
          "args": [
            "mp",
            "cmd",
            "arg"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioc_bulkstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "738-795",
          "snippet": "STATIC int\nxfs_ioc_bulkstat(\n\txfs_mount_t\t\t*mp,\n\tunsigned int\t\tcmd,\n\tvoid\t\t\t__user *arg)\n{\n\txfs_fsop_bulkreq_t\tbulkreq;\n\tint\t\t\tcount;\t/* # of records returned */\n\txfs_ino_t\t\tinlast;\t/* last inode number */\n\tint\t\t\tdone;\n\tint\t\t\terror;\n\n\t/* done = 1 if there are more stats to get and if bulkstat */\n\t/* should be called again (unused here, but used in dmapi) */\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tif (copy_from_user(&bulkreq, arg, sizeof(xfs_fsop_bulkreq_t)))\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(&inlast, bulkreq.lastip, sizeof(__s64)))\n\t\treturn -EFAULT;\n\n\tif ((count = bulkreq.icount) <= 0)\n\t\treturn -EINVAL;\n\n\tif (bulkreq.ubuffer == NULL)\n\t\treturn -EINVAL;\n\n\tif (cmd == XFS_IOC_FSINUMBERS)\n\t\terror = xfs_inumbers(mp, &inlast, &count,\n\t\t\t\t\tbulkreq.ubuffer, xfs_inumbers_fmt);\n\telse if (cmd == XFS_IOC_FSBULKSTAT_SINGLE)\n\t\terror = xfs_bulkstat_one(mp, inlast, bulkreq.ubuffer,\n\t\t\t\t\tsizeof(xfs_bstat_t), NULL, &done);\n\telse\t/* XFS_IOC_FSBULKSTAT */\n\t\terror = xfs_bulkstat(mp, &inlast, &count, xfs_bulkstat_one,\n\t\t\t\t     sizeof(xfs_bstat_t), bulkreq.ubuffer,\n\t\t\t\t     &done);\n\n\tif (error)\n\t\treturn error;\n\n\tif (bulkreq.ocount != NULL) {\n\t\tif (copy_to_user(bulkreq.lastip, &inlast,\n\t\t\t\t\t\tsizeof(xfs_ino_t)))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_to_user(bulkreq.ocount, &count, sizeof(count)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_ioc_bulkstat(\n\txfs_mount_t\t\t*mp,\n\tunsigned int\t\tcmd,\n\tvoid\t\t\t__user *arg)\n{\n\txfs_fsop_bulkreq_t\tbulkreq;\n\tint\t\t\tcount;\t/* # of records returned */\n\txfs_ino_t\t\tinlast;\t/* last inode number */\n\tint\t\t\tdone;\n\tint\t\t\terror;\n\n\t/* done = 1 if there are more stats to get and if bulkstat */\n\t/* should be called again (unused here, but used in dmapi) */\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tif (copy_from_user(&bulkreq, arg, sizeof(xfs_fsop_bulkreq_t)))\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(&inlast, bulkreq.lastip, sizeof(__s64)))\n\t\treturn -EFAULT;\n\n\tif ((count = bulkreq.icount) <= 0)\n\t\treturn -EINVAL;\n\n\tif (bulkreq.ubuffer == NULL)\n\t\treturn -EINVAL;\n\n\tif (cmd == XFS_IOC_FSINUMBERS)\n\t\terror = xfs_inumbers(mp, &inlast, &count,\n\t\t\t\t\tbulkreq.ubuffer, xfs_inumbers_fmt);\n\telse if (cmd == XFS_IOC_FSBULKSTAT_SINGLE)\n\t\terror = xfs_bulkstat_one(mp, inlast, bulkreq.ubuffer,\n\t\t\t\t\tsizeof(xfs_bstat_t), NULL, &done);\n\telse\t/* XFS_IOC_FSBULKSTAT */\n\t\terror = xfs_bulkstat(mp, &inlast, &count, xfs_bulkstat_one,\n\t\t\t\t     sizeof(xfs_bstat_t), bulkreq.ubuffer,\n\t\t\t\t     &done);\n\n\tif (error)\n\t\treturn error;\n\n\tif (bulkreq.ocount != NULL) {\n\t\tif (copy_to_user(bulkreq.lastip, &inlast,\n\t\t\t\t\t\tsizeof(xfs_ino_t)))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_to_user(bulkreq.ocount, &count, sizeof(count)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&da",
            "sizeof(da)"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ioc_space",
          "args": [
            "ip",
            "inode",
            "filp",
            "ioflags",
            "cmd",
            "&bf"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioc_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "601-736",
          "snippet": "int\nxfs_ioc_space(\n\tstruct xfs_inode\t*ip,\n\tstruct inode\t\t*inode,\n\tstruct file\t\t*filp,\n\tint\t\t\tioflags,\n\tunsigned int\t\tcmd,\n\txfs_flock64_t\t\t*bf)\n{\n\tstruct iattr\t\tiattr;\n\tenum xfs_prealloc_flags\tflags = 0;\n\tuint\t\t\tiolock = XFS_IOLOCK_EXCL;\n\tint\t\t\terror;\n\n\t/*\n\t * Only allow the sys admin to reserve space unless\n\t * unwritten extents are enabled.\n\t */\n\tif (!xfs_sb_version_hasextflgbit(&ip->i_mount->m_sb) &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (inode->i_flags & (S_IMMUTABLE|S_APPEND))\n\t\treturn -EPERM;\n\n\tif (!(filp->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (filp->f_flags & O_DSYNC)\n\t\tflags |= XFS_PREALLOC_SYNC;\n\tif (ioflags & XFS_IO_INVIS)\t\n\t\tflags |= XFS_PREALLOC_INVISIBLE;\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, iolock);\n\terror = xfs_break_layouts(inode, &iolock);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tswitch (bf->l_whence) {\n\tcase 0: /*SEEK_SET*/\n\t\tbreak;\n\tcase 1: /*SEEK_CUR*/\n\t\tbf->l_start += filp->f_pos;\n\t\tbreak;\n\tcase 2: /*SEEK_END*/\n\t\tbf->l_start += XFS_ISIZE(ip);\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * length of <= 0 for resv/unresv/zero is invalid.  length for\n\t * alloc/free is ignored completely and we have no idea what userspace\n\t * might have set it to, so set it to zero to allow range\n\t * checks to pass.\n\t */\n\tswitch (cmd) {\n\tcase XFS_IOC_ZERO_RANGE:\n\tcase XFS_IOC_RESVSP:\n\tcase XFS_IOC_RESVSP64:\n\tcase XFS_IOC_UNRESVSP:\n\tcase XFS_IOC_UNRESVSP64:\n\t\tif (bf->l_len <= 0) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbf->l_len = 0;\n\t\tbreak;\n\t}\n\n\tif (bf->l_start < 0 ||\n\t    bf->l_start > inode->i_sb->s_maxbytes ||\n\t    bf->l_start + bf->l_len < 0 ||\n\t    bf->l_start + bf->l_len >= inode->i_sb->s_maxbytes) {\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase XFS_IOC_ZERO_RANGE:\n\t\tflags |= XFS_PREALLOC_SET;\n\t\terror = xfs_zero_file_space(ip, bf->l_start, bf->l_len);\n\t\tbreak;\n\tcase XFS_IOC_RESVSP:\n\tcase XFS_IOC_RESVSP64:\n\t\tflags |= XFS_PREALLOC_SET;\n\t\terror = xfs_alloc_file_space(ip, bf->l_start, bf->l_len,\n\t\t\t\t\t\tXFS_BMAPI_PREALLOC);\n\t\tbreak;\n\tcase XFS_IOC_UNRESVSP:\n\tcase XFS_IOC_UNRESVSP64:\n\t\terror = xfs_free_file_space(ip, bf->l_start, bf->l_len);\n\t\tbreak;\n\tcase XFS_IOC_ALLOCSP:\n\tcase XFS_IOC_ALLOCSP64:\n\tcase XFS_IOC_FREESP:\n\tcase XFS_IOC_FREESP64:\n\t\tflags |= XFS_PREALLOC_CLEAR;\n\t\tif (bf->l_start > XFS_ISIZE(ip)) {\n\t\t\terror = xfs_alloc_file_space(ip, XFS_ISIZE(ip),\n\t\t\t\t\tbf->l_start - XFS_ISIZE(ip), 0);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tiattr.ia_valid = ATTR_SIZE;\n\t\tiattr.ia_size = bf->l_start;\n\n\t\terror = xfs_setattr_size(ip, &iattr);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tgoto out_unlock;\n\n\terror = xfs_update_prealloc_flags(ip, flags);\n\nout_unlock:\n\txfs_iunlock(ip, iolock);\n\tmnt_drop_write_file(filp);\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_ioc_space(\n\tstruct xfs_inode\t*ip,\n\tstruct inode\t\t*inode,\n\tstruct file\t\t*filp,\n\tint\t\t\tioflags,\n\tunsigned int\t\tcmd,\n\txfs_flock64_t\t\t*bf)\n{\n\tstruct iattr\t\tiattr;\n\tenum xfs_prealloc_flags\tflags = 0;\n\tuint\t\t\tiolock = XFS_IOLOCK_EXCL;\n\tint\t\t\terror;\n\n\t/*\n\t * Only allow the sys admin to reserve space unless\n\t * unwritten extents are enabled.\n\t */\n\tif (!xfs_sb_version_hasextflgbit(&ip->i_mount->m_sb) &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (inode->i_flags & (S_IMMUTABLE|S_APPEND))\n\t\treturn -EPERM;\n\n\tif (!(filp->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (filp->f_flags & O_DSYNC)\n\t\tflags |= XFS_PREALLOC_SYNC;\n\tif (ioflags & XFS_IO_INVIS)\t\n\t\tflags |= XFS_PREALLOC_INVISIBLE;\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, iolock);\n\terror = xfs_break_layouts(inode, &iolock);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tswitch (bf->l_whence) {\n\tcase 0: /*SEEK_SET*/\n\t\tbreak;\n\tcase 1: /*SEEK_CUR*/\n\t\tbf->l_start += filp->f_pos;\n\t\tbreak;\n\tcase 2: /*SEEK_END*/\n\t\tbf->l_start += XFS_ISIZE(ip);\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * length of <= 0 for resv/unresv/zero is invalid.  length for\n\t * alloc/free is ignored completely and we have no idea what userspace\n\t * might have set it to, so set it to zero to allow range\n\t * checks to pass.\n\t */\n\tswitch (cmd) {\n\tcase XFS_IOC_ZERO_RANGE:\n\tcase XFS_IOC_RESVSP:\n\tcase XFS_IOC_RESVSP64:\n\tcase XFS_IOC_UNRESVSP:\n\tcase XFS_IOC_UNRESVSP64:\n\t\tif (bf->l_len <= 0) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbf->l_len = 0;\n\t\tbreak;\n\t}\n\n\tif (bf->l_start < 0 ||\n\t    bf->l_start > inode->i_sb->s_maxbytes ||\n\t    bf->l_start + bf->l_len < 0 ||\n\t    bf->l_start + bf->l_len >= inode->i_sb->s_maxbytes) {\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase XFS_IOC_ZERO_RANGE:\n\t\tflags |= XFS_PREALLOC_SET;\n\t\terror = xfs_zero_file_space(ip, bf->l_start, bf->l_len);\n\t\tbreak;\n\tcase XFS_IOC_RESVSP:\n\tcase XFS_IOC_RESVSP64:\n\t\tflags |= XFS_PREALLOC_SET;\n\t\terror = xfs_alloc_file_space(ip, bf->l_start, bf->l_len,\n\t\t\t\t\t\tXFS_BMAPI_PREALLOC);\n\t\tbreak;\n\tcase XFS_IOC_UNRESVSP:\n\tcase XFS_IOC_UNRESVSP64:\n\t\terror = xfs_free_file_space(ip, bf->l_start, bf->l_len);\n\t\tbreak;\n\tcase XFS_IOC_ALLOCSP:\n\tcase XFS_IOC_ALLOCSP64:\n\tcase XFS_IOC_FREESP:\n\tcase XFS_IOC_FREESP64:\n\t\tflags |= XFS_PREALLOC_CLEAR;\n\t\tif (bf->l_start > XFS_ISIZE(ip)) {\n\t\t\terror = xfs_alloc_file_space(ip, XFS_ISIZE(ip),\n\t\t\t\t\tbf->l_start - XFS_ISIZE(ip), 0);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tiattr.ia_valid = ATTR_SIZE;\n\t\tiattr.ia_size = bf->l_start;\n\n\t\terror = xfs_setattr_size(ip, &iattr);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tgoto out_unlock;\n\n\terror = xfs_update_prealloc_flags(ip, flags);\n\nout_unlock:\n\txfs_iunlock(ip, iolock);\n\tmnt_drop_write_file(filp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ioc_trim",
          "args": [
            "mp",
            "arg"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioc_trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_discard.c",
          "lines": "154-210",
          "snippet": "int\nxfs_ioc_trim(\n\tstruct xfs_mount\t\t*mp,\n\tstruct fstrim_range __user\t*urange)\n{\n\tstruct request_queue\t*q = bdev_get_queue(mp->m_ddev_targp->bt_bdev);\n\tunsigned int\t\tgranularity = q->limits.discard_granularity;\n\tstruct fstrim_range\trange;\n\txfs_daddr_t\t\tstart, end, minlen;\n\txfs_agnumber_t\t\tstart_agno, end_agno, agno;\n\t__uint64_t\t\tblocks_trimmed = 0;\n\tint\t\t\terror, last_error = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!blk_queue_discard(q))\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&range, urange, sizeof(range)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Truncating down the len isn't actually quite correct, but using\n\t * BBTOB would mean we trivially get overflows for values\n\t * of ULLONG_MAX or slightly lower.  And ULLONG_MAX is the default\n\t * used by the fstrim application.  In the end it really doesn't\n\t * matter as trimming blocks is an advisory interface.\n\t */\n\tif (range.start >= XFS_FSB_TO_B(mp, mp->m_sb.sb_dblocks) ||\n\t    range.minlen > XFS_FSB_TO_B(mp, XFS_ALLOC_AG_MAX_USABLE(mp)) ||\n\t    range.len < mp->m_sb.sb_blocksize)\n\t\treturn -EINVAL;\n\n\tstart = BTOBB(range.start);\n\tend = start + BTOBBT(range.len) - 1;\n\tminlen = BTOBB(max_t(u64, granularity, range.minlen));\n\n\tif (end > XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks) - 1)\n\t\tend = XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks)- 1;\n\n\tstart_agno = xfs_daddr_to_agno(mp, start);\n\tend_agno = xfs_daddr_to_agno(mp, end);\n\n\tfor (agno = start_agno; agno <= end_agno; agno++) {\n\t\terror = xfs_trim_extents(mp, agno, start, end, minlen,\n\t\t\t\t\t  &blocks_trimmed);\n\t\tif (error)\n\t\t\tlast_error = error;\n\t}\n\n\tif (last_error)\n\t\treturn last_error;\n\n\trange.len = XFS_FSB_TO_B(mp, blocks_trimmed);\n\tif (copy_to_user(urange, &range, sizeof(range)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nint\nxfs_ioc_trim(\n\tstruct xfs_mount\t\t*mp,\n\tstruct fstrim_range __user\t*urange)\n{\n\tstruct request_queue\t*q = bdev_get_queue(mp->m_ddev_targp->bt_bdev);\n\tunsigned int\t\tgranularity = q->limits.discard_granularity;\n\tstruct fstrim_range\trange;\n\txfs_daddr_t\t\tstart, end, minlen;\n\txfs_agnumber_t\t\tstart_agno, end_agno, agno;\n\t__uint64_t\t\tblocks_trimmed = 0;\n\tint\t\t\terror, last_error = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!blk_queue_discard(q))\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&range, urange, sizeof(range)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Truncating down the len isn't actually quite correct, but using\n\t * BBTOB would mean we trivially get overflows for values\n\t * of ULLONG_MAX or slightly lower.  And ULLONG_MAX is the default\n\t * used by the fstrim application.  In the end it really doesn't\n\t * matter as trimming blocks is an advisory interface.\n\t */\n\tif (range.start >= XFS_FSB_TO_B(mp, mp->m_sb.sb_dblocks) ||\n\t    range.minlen > XFS_FSB_TO_B(mp, XFS_ALLOC_AG_MAX_USABLE(mp)) ||\n\t    range.len < mp->m_sb.sb_blocksize)\n\t\treturn -EINVAL;\n\n\tstart = BTOBB(range.start);\n\tend = start + BTOBBT(range.len) - 1;\n\tminlen = BTOBB(max_t(u64, granularity, range.minlen));\n\n\tif (end > XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks) - 1)\n\t\tend = XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks)- 1;\n\n\tstart_agno = xfs_daddr_to_agno(mp, start);\n\tend_agno = xfs_daddr_to_agno(mp, end);\n\n\tfor (agno = start_agno; agno <= end_agno; agno++) {\n\t\terror = xfs_trim_extents(mp, agno, start, end, minlen,\n\t\t\t\t\t  &blocks_trimmed);\n\t\tif (error)\n\t\t\tlast_error = error;\n\t}\n\n\tif (last_error)\n\t\treturn last_error;\n\n\trange.len = XFS_FSB_TO_B(mp, blocks_trimmed);\n\tif (copy_to_user(urange, &range, sizeof(range)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_file_ioctl",
          "args": [
            "ip"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nlong\nxfs_file_ioctl(\n\tstruct file\t\t*filp,\n\tunsigned int\t\tcmd,\n\tunsigned long\t\tp)\n{\n\tstruct inode\t\t*inode = file_inode(filp);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tvoid\t\t\t__user *arg = (void __user *)p;\n\tint\t\t\tioflags = 0;\n\tint\t\t\terror;\n\n\tif (filp->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= XFS_IO_INVIS;\n\n\ttrace_xfs_file_ioctl(ip);\n\n\tswitch (cmd) {\n\tcase FITRIM:\n\t\treturn xfs_ioc_trim(mp, arg);\n\tcase XFS_IOC_ALLOCSP:\n\tcase XFS_IOC_FREESP:\n\tcase XFS_IOC_RESVSP:\n\tcase XFS_IOC_UNRESVSP:\n\tcase XFS_IOC_ALLOCSP64:\n\tcase XFS_IOC_FREESP64:\n\tcase XFS_IOC_RESVSP64:\n\tcase XFS_IOC_UNRESVSP64:\n\tcase XFS_IOC_ZERO_RANGE: {\n\t\txfs_flock64_t\t\tbf;\n\n\t\tif (copy_from_user(&bf, arg, sizeof(bf)))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_ioc_space(ip, inode, filp, ioflags, cmd, &bf);\n\t}\n\tcase XFS_IOC_DIOINFO: {\n\t\tstruct dioattr\tda;\n\t\txfs_buftarg_t\t*target =\n\t\t\tXFS_IS_REALTIME_INODE(ip) ?\n\t\t\tmp->m_rtdev_targp : mp->m_ddev_targp;\n\n\t\tda.d_mem =  da.d_miniosz = target->bt_logical_sectorsize;\n\t\tda.d_maxiosz = INT_MAX & ~(da.d_miniosz - 1);\n\n\t\tif (copy_to_user(arg, &da, sizeof(da)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_FSBULKSTAT_SINGLE:\n\tcase XFS_IOC_FSBULKSTAT:\n\tcase XFS_IOC_FSINUMBERS:\n\t\treturn xfs_ioc_bulkstat(mp, cmd, arg);\n\n\tcase XFS_IOC_FSGEOMETRY_V1:\n\t\treturn xfs_ioc_fsgeometry_v1(mp, arg);\n\n\tcase XFS_IOC_FSGEOMETRY:\n\t\treturn xfs_ioc_fsgeometry(mp, arg);\n\n\tcase XFS_IOC_GETVERSION:\n\t\treturn put_user(inode->i_generation, (int __user *)arg);\n\n\tcase XFS_IOC_FSGETXATTR:\n\t\treturn xfs_ioc_fsgetxattr(ip, 0, arg);\n\tcase XFS_IOC_FSGETXATTRA:\n\t\treturn xfs_ioc_fsgetxattr(ip, 1, arg);\n\tcase XFS_IOC_FSSETXATTR:\n\t\treturn xfs_ioc_fssetxattr(ip, filp, arg);\n\tcase XFS_IOC_GETXFLAGS:\n\t\treturn xfs_ioc_getxflags(ip, arg);\n\tcase XFS_IOC_SETXFLAGS:\n\t\treturn xfs_ioc_setxflags(ip, filp, arg);\n\n\tcase XFS_IOC_FSSETDM: {\n\t\tstruct fsdmidata\tdmi;\n\n\t\tif (copy_from_user(&dmi, arg, sizeof(dmi)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = xfs_set_dmattrs(ip, dmi.fsd_dmevmask,\n\t\t\t\tdmi.fsd_dmstate);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_GETBMAP:\n\tcase XFS_IOC_GETBMAPA:\n\t\treturn xfs_ioc_getbmap(ip, ioflags, cmd, arg);\n\n\tcase XFS_IOC_GETBMAPX:\n\t\treturn xfs_ioc_getbmapx(ip, arg);\n\n\tcase XFS_IOC_FD_TO_HANDLE:\n\tcase XFS_IOC_PATH_TO_HANDLE:\n\tcase XFS_IOC_PATH_TO_FSHANDLE: {\n\t\txfs_fsop_handlereq_t\threq;\n\n\t\tif (copy_from_user(&hreq, arg, sizeof(hreq)))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_find_handle(cmd, &hreq);\n\t}\n\tcase XFS_IOC_OPEN_BY_HANDLE: {\n\t\txfs_fsop_handlereq_t\threq;\n\n\t\tif (copy_from_user(&hreq, arg, sizeof(xfs_fsop_handlereq_t)))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_open_by_handle(filp, &hreq);\n\t}\n\tcase XFS_IOC_FSSETDM_BY_HANDLE:\n\t\treturn xfs_fssetdm_by_handle(filp, arg);\n\n\tcase XFS_IOC_READLINK_BY_HANDLE: {\n\t\txfs_fsop_handlereq_t\threq;\n\n\t\tif (copy_from_user(&hreq, arg, sizeof(xfs_fsop_handlereq_t)))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_readlink_by_handle(filp, &hreq);\n\t}\n\tcase XFS_IOC_ATTRLIST_BY_HANDLE:\n\t\treturn xfs_attrlist_by_handle(filp, arg);\n\n\tcase XFS_IOC_ATTRMULTI_BY_HANDLE:\n\t\treturn xfs_attrmulti_by_handle(filp, arg);\n\n\tcase XFS_IOC_SWAPEXT: {\n\t\tstruct xfs_swapext\tsxp;\n\n\t\tif (copy_from_user(&sxp, arg, sizeof(xfs_swapext_t)))\n\t\t\treturn -EFAULT;\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_ioc_swapext(&sxp);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_FSCOUNTS: {\n\t\txfs_fsop_counts_t out;\n\n\t\terror = xfs_fs_counts(mp, &out);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (copy_to_user(arg, &out, sizeof(out)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_SET_RESBLKS: {\n\t\txfs_fsop_resblks_t inout;\n\t\t__uint64_t\t   in;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\t\treturn -EROFS;\n\n\t\tif (copy_from_user(&inout, arg, sizeof(inout)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/* input parameter is passed in resblks field of structure */\n\t\tin = inout.resblks;\n\t\terror = xfs_reserve_blocks(mp, &in, &inout);\n\t\tmnt_drop_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (copy_to_user(arg, &inout, sizeof(inout)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_GET_RESBLKS: {\n\t\txfs_fsop_resblks_t out;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\terror = xfs_reserve_blocks(mp, NULL, &out);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (copy_to_user(arg, &out, sizeof(out)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_FSGROWFSDATA: {\n\t\txfs_growfs_data_t in;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_data(mp, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_FSGROWFSLOG: {\n\t\txfs_growfs_log_t in;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_log(mp, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_FSGROWFSRT: {\n\t\txfs_growfs_rt_t in;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_rt(mp, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_GOINGDOWN: {\n\t\t__uint32_t in;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(in, (__uint32_t __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\treturn xfs_fs_goingdown(mp, in);\n\t}\n\n\tcase XFS_IOC_ERROR_INJECTION: {\n\t\txfs_error_injection_t in;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\treturn xfs_errortag_add(in.errtag, mp);\n\t}\n\n\tcase XFS_IOC_ERROR_CLEARALL:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\treturn xfs_errortag_clearall(mp, 1);\n\n\tcase XFS_IOC_FREE_EOFBLOCKS: {\n\t\tstruct xfs_fs_eofblocks eofb;\n\t\tstruct xfs_eofblocks keofb;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\t\treturn -EROFS;\n\n\t\tif (copy_from_user(&eofb, arg, sizeof(eofb)))\n\t\t\treturn -EFAULT;\n\n\t\terror = xfs_fs_eofblocks_from_user(&eofb, &keofb);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\treturn xfs_icache_free_eofblocks(mp, &keofb);\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
  },
  {
    "function_name": "xfs_ioc_swapext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "1433-1500",
    "snippet": "int\nxfs_ioc_swapext(\n\txfs_swapext_t\t*sxp)\n{\n\txfs_inode_t     *ip, *tip;\n\tstruct fd\tf, tmp;\n\tint\t\terror = 0;\n\n\t/* Pull information for the target fd */\n\tf = fdget((int)sxp->sx_fdtarget);\n\tif (!f.file) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!(f.file->f_mode & FMODE_WRITE) ||\n\t    !(f.file->f_mode & FMODE_READ) ||\n\t    (f.file->f_flags & O_APPEND)) {\n\t\terror = -EBADF;\n\t\tgoto out_put_file;\n\t}\n\n\ttmp = fdget((int)sxp->sx_fdtmp);\n\tif (!tmp.file) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_file;\n\t}\n\n\tif (!(tmp.file->f_mode & FMODE_WRITE) ||\n\t    !(tmp.file->f_mode & FMODE_READ) ||\n\t    (tmp.file->f_flags & O_APPEND)) {\n\t\terror = -EBADF;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (IS_SWAPFILE(file_inode(f.file)) ||\n\t    IS_SWAPFILE(file_inode(tmp.file))) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tip = XFS_I(file_inode(f.file));\n\ttip = XFS_I(file_inode(tmp.file));\n\n\tif (ip->i_mount != tip->i_mount) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (ip->i_ino == tip->i_ino) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\terror = -EIO;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\terror = xfs_swap_extents(ip, tip, sxp);\n\n out_put_tmp_file:\n\tfdput(tmp);\n out_put_file:\n\tfdput(f);\n out:\n\treturn error;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "fdput_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "273-278",
          "snippet": "static inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_swap_extents",
          "args": [
            "ip",
            "tip",
            "sxp"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_swap_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "1612-1860",
          "snippet": "int\nxfs_swap_extents(\n\txfs_inode_t\t*ip,\t/* target inode */\n\txfs_inode_t\t*tip,\t/* tmp inode */\n\txfs_swapext_t\t*sxp)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_trans_t\t*tp;\n\txfs_bstat_t\t*sbp = &sxp->sx_stat;\n\txfs_ifork_t\t*tempifp, *ifp, *tifp;\n\tint\t\tsrc_log_flags, target_log_flags;\n\tint\t\terror = 0;\n\tint\t\taforkblks = 0;\n\tint\t\ttaforkblks = 0;\n\t__uint64_t\ttmp;\n\tint\t\tlock_flags;\n\n\ttempifp = kmem_alloc(sizeof(xfs_ifork_t), KM_MAYFAIL);\n\tif (!tempifp) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Lock up the inodes against other IO and truncate to begin with.\n\t * Then we can ensure the inodes are flushed and have no page cache\n\t * safely. Once we have done this we can take the ilocks and do the rest\n\t * of the checks.\n\t */\n\tlock_flags = XFS_IOLOCK_EXCL;\n\txfs_lock_two_inodes(ip, tip, XFS_IOLOCK_EXCL);\n\n\t/* Verify that both files have the same format */\n\tif ((ip->i_d.di_mode & S_IFMT) != (tip->i_d.di_mode & S_IFMT)) {\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Verify both files are either real-time or non-realtime */\n\tif (XFS_IS_REALTIME_INODE(ip) != XFS_IS_REALTIME_INODE(tip)) {\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\terror = xfs_swap_extent_flush(ip);\n\tif (error)\n\t\tgoto out_unlock;\n\terror = xfs_swap_extent_flush(tip);\n\tif (error)\n\t\tgoto out_unlock;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SWAPEXT);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto out_unlock;\n\t}\n\txfs_lock_two_inodes(ip, tip, XFS_ILOCK_EXCL);\n\tlock_flags |= XFS_ILOCK_EXCL;\n\n\t/* Verify all data are being swapped */\n\tif (sxp->sx_offset != 0 ||\n\t    sxp->sx_length != ip->i_d.di_size ||\n\t    sxp->sx_length != tip->i_d.di_size) {\n\t\terror = -EFAULT;\n\t\tgoto out_trans_cancel;\n\t}\n\n\ttrace_xfs_swap_extent_before(ip, 0);\n\ttrace_xfs_swap_extent_before(tip, 1);\n\n\t/* check inode formats now that data is flushed */\n\terror = xfs_swap_extents_check_format(ip, tip);\n\tif (error) {\n\t\txfs_notice(mp,\n\t\t    \"%s: inode 0x%llx format is incompatible for exchanging.\",\n\t\t\t\t__func__, ip->i_ino);\n\t\tgoto out_trans_cancel;\n\t}\n\n\t/*\n\t * Compare the current change & modify times with that\n\t * passed in.  If they differ, we abort this swap.\n\t * This is the mechanism used to ensure the calling\n\t * process that the file was not changed out from\n\t * under it.\n\t */\n\tif ((sbp->bs_ctime.tv_sec != VFS_I(ip)->i_ctime.tv_sec) ||\n\t    (sbp->bs_ctime.tv_nsec != VFS_I(ip)->i_ctime.tv_nsec) ||\n\t    (sbp->bs_mtime.tv_sec != VFS_I(ip)->i_mtime.tv_sec) ||\n\t    (sbp->bs_mtime.tv_nsec != VFS_I(ip)->i_mtime.tv_nsec)) {\n\t\terror = -EBUSY;\n\t\tgoto out_trans_cancel;\n\t}\n\t/*\n\t * Count the number of extended attribute blocks\n\t */\n\tif ( ((XFS_IFORK_Q(ip) != 0) && (ip->i_d.di_anextents > 0)) &&\n\t     (ip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)) {\n\t\terror = xfs_bmap_count_blocks(tp, ip, XFS_ATTR_FORK, &aforkblks);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\tif ( ((XFS_IFORK_Q(tip) != 0) && (tip->i_d.di_anextents > 0)) &&\n\t     (tip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)) {\n\t\terror = xfs_bmap_count_blocks(tp, tip, XFS_ATTR_FORK,\n\t\t\t&taforkblks);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\txfs_trans_ijoin(tp, ip, lock_flags);\n\txfs_trans_ijoin(tp, tip, lock_flags);\n\n\t/*\n\t * Before we've swapped the forks, lets set the owners of the forks\n\t * appropriately. We have to do this as we are demand paging the btree\n\t * buffers, and so the validation done on read will expect the owner\n\t * field to be correctly set. Once we change the owners, we can swap the\n\t * inode forks.\n\t *\n\t * Note the trickiness in setting the log flags - we set the owner log\n\t * flag on the opposite inode (i.e. the inode we are setting the new\n\t * owner to be) because once we swap the forks and log that, log\n\t * recovery is going to see the fork as owned by the swapped inode,\n\t * not the pre-swapped inodes.\n\t */\n\tsrc_log_flags = XFS_ILOG_CORE;\n\ttarget_log_flags = XFS_ILOG_CORE;\n\tif (ip->i_d.di_version == 3 &&\n\t    ip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\n\t\ttarget_log_flags |= XFS_ILOG_DOWNER;\n\t\terror = xfs_bmbt_change_owner(tp, ip, XFS_DATA_FORK,\n\t\t\t\t\t      tip->i_ino, NULL);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\tif (tip->i_d.di_version == 3 &&\n\t    tip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\n\t\tsrc_log_flags |= XFS_ILOG_DOWNER;\n\t\terror = xfs_bmbt_change_owner(tp, tip, XFS_DATA_FORK,\n\t\t\t\t\t      ip->i_ino, NULL);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\t/*\n\t * Swap the data forks of the inodes\n\t */\n\tifp = &ip->i_df;\n\ttifp = &tip->i_df;\n\t*tempifp = *ifp;\t/* struct copy */\n\t*ifp = *tifp;\t\t/* struct copy */\n\t*tifp = *tempifp;\t/* struct copy */\n\n\t/*\n\t * Fix the on-disk inode values\n\t */\n\ttmp = (__uint64_t)ip->i_d.di_nblocks;\n\tip->i_d.di_nblocks = tip->i_d.di_nblocks - taforkblks + aforkblks;\n\ttip->i_d.di_nblocks = tmp + taforkblks - aforkblks;\n\n\ttmp = (__uint64_t) ip->i_d.di_nextents;\n\tip->i_d.di_nextents = tip->i_d.di_nextents;\n\ttip->i_d.di_nextents = tmp;\n\n\ttmp = (__uint64_t) ip->i_d.di_format;\n\tip->i_d.di_format = tip->i_d.di_format;\n\ttip->i_d.di_format = tmp;\n\n\t/*\n\t * The extents in the source inode could still contain speculative\n\t * preallocation beyond EOF (e.g. the file is open but not modified\n\t * while defrag is in progress). In that case, we need to copy over the\n\t * number of delalloc blocks the data fork in the source inode is\n\t * tracking beyond EOF so that when the fork is truncated away when the\n\t * temporary inode is unlinked we don't underrun the i_delayed_blks\n\t * counter on that inode.\n\t */\n\tASSERT(tip->i_delayed_blks == 0);\n\ttip->i_delayed_blks = ip->i_delayed_blks;\n\tip->i_delayed_blks = 0;\n\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/* If the extents fit in the inode, fix the\n\t\t * pointer.  Otherwise it's already NULL or\n\t\t * pointing to the extent.\n\t\t */\n\t\tif (ip->i_d.di_nextents <= XFS_INLINE_EXTS) {\n\t\t\tifp->if_u1.if_extents =\n\t\t\t\tifp->if_u2.if_inline_ext;\n\t\t}\n\t\tsrc_log_flags |= XFS_ILOG_DEXT;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tASSERT(ip->i_d.di_version < 3 ||\n\t\t       (src_log_flags & XFS_ILOG_DOWNER));\n\t\tsrc_log_flags |= XFS_ILOG_DBROOT;\n\t\tbreak;\n\t}\n\n\tswitch (tip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/* If the extents fit in the inode, fix the\n\t\t * pointer.  Otherwise it's already NULL or\n\t\t * pointing to the extent.\n\t\t */\n\t\tif (tip->i_d.di_nextents <= XFS_INLINE_EXTS) {\n\t\t\ttifp->if_u1.if_extents =\n\t\t\t\ttifp->if_u2.if_inline_ext;\n\t\t}\n\t\ttarget_log_flags |= XFS_ILOG_DEXT;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\ttarget_log_flags |= XFS_ILOG_DBROOT;\n\t\tASSERT(tip->i_d.di_version < 3 ||\n\t\t       (target_log_flags & XFS_ILOG_DOWNER));\n\t\tbreak;\n\t}\n\n\txfs_trans_log_inode(tp, ip,  src_log_flags);\n\txfs_trans_log_inode(tp, tip, target_log_flags);\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp, 0);\n\n\ttrace_xfs_swap_extent_after(ip, 0);\n\ttrace_xfs_swap_extent_after(tip, 1);\nout:\n\tkmem_free(tempifp);\n\treturn error;\n\nout_unlock:\n\txfs_iunlock(ip, lock_flags);\n\txfs_iunlock(tip, lock_flags);\n\tgoto out;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp, 0);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_swap_extents(\n\txfs_inode_t\t*ip,\t/* target inode */\n\txfs_inode_t\t*tip,\t/* tmp inode */\n\txfs_swapext_t\t*sxp)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_trans_t\t*tp;\n\txfs_bstat_t\t*sbp = &sxp->sx_stat;\n\txfs_ifork_t\t*tempifp, *ifp, *tifp;\n\tint\t\tsrc_log_flags, target_log_flags;\n\tint\t\terror = 0;\n\tint\t\taforkblks = 0;\n\tint\t\ttaforkblks = 0;\n\t__uint64_t\ttmp;\n\tint\t\tlock_flags;\n\n\ttempifp = kmem_alloc(sizeof(xfs_ifork_t), KM_MAYFAIL);\n\tif (!tempifp) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Lock up the inodes against other IO and truncate to begin with.\n\t * Then we can ensure the inodes are flushed and have no page cache\n\t * safely. Once we have done this we can take the ilocks and do the rest\n\t * of the checks.\n\t */\n\tlock_flags = XFS_IOLOCK_EXCL;\n\txfs_lock_two_inodes(ip, tip, XFS_IOLOCK_EXCL);\n\n\t/* Verify that both files have the same format */\n\tif ((ip->i_d.di_mode & S_IFMT) != (tip->i_d.di_mode & S_IFMT)) {\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Verify both files are either real-time or non-realtime */\n\tif (XFS_IS_REALTIME_INODE(ip) != XFS_IS_REALTIME_INODE(tip)) {\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\terror = xfs_swap_extent_flush(ip);\n\tif (error)\n\t\tgoto out_unlock;\n\terror = xfs_swap_extent_flush(tip);\n\tif (error)\n\t\tgoto out_unlock;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SWAPEXT);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto out_unlock;\n\t}\n\txfs_lock_two_inodes(ip, tip, XFS_ILOCK_EXCL);\n\tlock_flags |= XFS_ILOCK_EXCL;\n\n\t/* Verify all data are being swapped */\n\tif (sxp->sx_offset != 0 ||\n\t    sxp->sx_length != ip->i_d.di_size ||\n\t    sxp->sx_length != tip->i_d.di_size) {\n\t\terror = -EFAULT;\n\t\tgoto out_trans_cancel;\n\t}\n\n\ttrace_xfs_swap_extent_before(ip, 0);\n\ttrace_xfs_swap_extent_before(tip, 1);\n\n\t/* check inode formats now that data is flushed */\n\terror = xfs_swap_extents_check_format(ip, tip);\n\tif (error) {\n\t\txfs_notice(mp,\n\t\t    \"%s: inode 0x%llx format is incompatible for exchanging.\",\n\t\t\t\t__func__, ip->i_ino);\n\t\tgoto out_trans_cancel;\n\t}\n\n\t/*\n\t * Compare the current change & modify times with that\n\t * passed in.  If they differ, we abort this swap.\n\t * This is the mechanism used to ensure the calling\n\t * process that the file was not changed out from\n\t * under it.\n\t */\n\tif ((sbp->bs_ctime.tv_sec != VFS_I(ip)->i_ctime.tv_sec) ||\n\t    (sbp->bs_ctime.tv_nsec != VFS_I(ip)->i_ctime.tv_nsec) ||\n\t    (sbp->bs_mtime.tv_sec != VFS_I(ip)->i_mtime.tv_sec) ||\n\t    (sbp->bs_mtime.tv_nsec != VFS_I(ip)->i_mtime.tv_nsec)) {\n\t\terror = -EBUSY;\n\t\tgoto out_trans_cancel;\n\t}\n\t/*\n\t * Count the number of extended attribute blocks\n\t */\n\tif ( ((XFS_IFORK_Q(ip) != 0) && (ip->i_d.di_anextents > 0)) &&\n\t     (ip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)) {\n\t\terror = xfs_bmap_count_blocks(tp, ip, XFS_ATTR_FORK, &aforkblks);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\tif ( ((XFS_IFORK_Q(tip) != 0) && (tip->i_d.di_anextents > 0)) &&\n\t     (tip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)) {\n\t\terror = xfs_bmap_count_blocks(tp, tip, XFS_ATTR_FORK,\n\t\t\t&taforkblks);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\txfs_trans_ijoin(tp, ip, lock_flags);\n\txfs_trans_ijoin(tp, tip, lock_flags);\n\n\t/*\n\t * Before we've swapped the forks, lets set the owners of the forks\n\t * appropriately. We have to do this as we are demand paging the btree\n\t * buffers, and so the validation done on read will expect the owner\n\t * field to be correctly set. Once we change the owners, we can swap the\n\t * inode forks.\n\t *\n\t * Note the trickiness in setting the log flags - we set the owner log\n\t * flag on the opposite inode (i.e. the inode we are setting the new\n\t * owner to be) because once we swap the forks and log that, log\n\t * recovery is going to see the fork as owned by the swapped inode,\n\t * not the pre-swapped inodes.\n\t */\n\tsrc_log_flags = XFS_ILOG_CORE;\n\ttarget_log_flags = XFS_ILOG_CORE;\n\tif (ip->i_d.di_version == 3 &&\n\t    ip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\n\t\ttarget_log_flags |= XFS_ILOG_DOWNER;\n\t\terror = xfs_bmbt_change_owner(tp, ip, XFS_DATA_FORK,\n\t\t\t\t\t      tip->i_ino, NULL);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\tif (tip->i_d.di_version == 3 &&\n\t    tip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\n\t\tsrc_log_flags |= XFS_ILOG_DOWNER;\n\t\terror = xfs_bmbt_change_owner(tp, tip, XFS_DATA_FORK,\n\t\t\t\t\t      ip->i_ino, NULL);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\t/*\n\t * Swap the data forks of the inodes\n\t */\n\tifp = &ip->i_df;\n\ttifp = &tip->i_df;\n\t*tempifp = *ifp;\t/* struct copy */\n\t*ifp = *tifp;\t\t/* struct copy */\n\t*tifp = *tempifp;\t/* struct copy */\n\n\t/*\n\t * Fix the on-disk inode values\n\t */\n\ttmp = (__uint64_t)ip->i_d.di_nblocks;\n\tip->i_d.di_nblocks = tip->i_d.di_nblocks - taforkblks + aforkblks;\n\ttip->i_d.di_nblocks = tmp + taforkblks - aforkblks;\n\n\ttmp = (__uint64_t) ip->i_d.di_nextents;\n\tip->i_d.di_nextents = tip->i_d.di_nextents;\n\ttip->i_d.di_nextents = tmp;\n\n\ttmp = (__uint64_t) ip->i_d.di_format;\n\tip->i_d.di_format = tip->i_d.di_format;\n\ttip->i_d.di_format = tmp;\n\n\t/*\n\t * The extents in the source inode could still contain speculative\n\t * preallocation beyond EOF (e.g. the file is open but not modified\n\t * while defrag is in progress). In that case, we need to copy over the\n\t * number of delalloc blocks the data fork in the source inode is\n\t * tracking beyond EOF so that when the fork is truncated away when the\n\t * temporary inode is unlinked we don't underrun the i_delayed_blks\n\t * counter on that inode.\n\t */\n\tASSERT(tip->i_delayed_blks == 0);\n\ttip->i_delayed_blks = ip->i_delayed_blks;\n\tip->i_delayed_blks = 0;\n\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/* If the extents fit in the inode, fix the\n\t\t * pointer.  Otherwise it's already NULL or\n\t\t * pointing to the extent.\n\t\t */\n\t\tif (ip->i_d.di_nextents <= XFS_INLINE_EXTS) {\n\t\t\tifp->if_u1.if_extents =\n\t\t\t\tifp->if_u2.if_inline_ext;\n\t\t}\n\t\tsrc_log_flags |= XFS_ILOG_DEXT;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tASSERT(ip->i_d.di_version < 3 ||\n\t\t       (src_log_flags & XFS_ILOG_DOWNER));\n\t\tsrc_log_flags |= XFS_ILOG_DBROOT;\n\t\tbreak;\n\t}\n\n\tswitch (tip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/* If the extents fit in the inode, fix the\n\t\t * pointer.  Otherwise it's already NULL or\n\t\t * pointing to the extent.\n\t\t */\n\t\tif (tip->i_d.di_nextents <= XFS_INLINE_EXTS) {\n\t\t\ttifp->if_u1.if_extents =\n\t\t\t\ttifp->if_u2.if_inline_ext;\n\t\t}\n\t\ttarget_log_flags |= XFS_ILOG_DEXT;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\ttarget_log_flags |= XFS_ILOG_DBROOT;\n\t\tASSERT(tip->i_d.di_version < 3 ||\n\t\t       (target_log_flags & XFS_ILOG_DOWNER));\n\t\tbreak;\n\t}\n\n\txfs_trans_log_inode(tp, ip,  src_log_flags);\n\txfs_trans_log_inode(tp, tip, target_log_flags);\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp, 0);\n\n\ttrace_xfs_swap_extent_after(ip, 0);\n\ttrace_xfs_swap_extent_after(tip, 1);\nout:\n\tkmem_free(tempifp);\n\treturn error;\n\nout_unlock:\n\txfs_iunlock(ip, lock_flags);\n\txfs_iunlock(tip, lock_flags);\n\tgoto out;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp, 0);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "ip->i_mount"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "file_inode(tmp.file)"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "tmp.file"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SWAPFILE",
          "args": [
            "file_inode(tmp.file)"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SWAPFILE",
          "args": [
            "file_inode(f.file)"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "(int)sxp->sx_fdtmp"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "706-718",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_ioc_swapext(\n\txfs_swapext_t\t*sxp)\n{\n\txfs_inode_t     *ip, *tip;\n\tstruct fd\tf, tmp;\n\tint\t\terror = 0;\n\n\t/* Pull information for the target fd */\n\tf = fdget((int)sxp->sx_fdtarget);\n\tif (!f.file) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!(f.file->f_mode & FMODE_WRITE) ||\n\t    !(f.file->f_mode & FMODE_READ) ||\n\t    (f.file->f_flags & O_APPEND)) {\n\t\terror = -EBADF;\n\t\tgoto out_put_file;\n\t}\n\n\ttmp = fdget((int)sxp->sx_fdtmp);\n\tif (!tmp.file) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_file;\n\t}\n\n\tif (!(tmp.file->f_mode & FMODE_WRITE) ||\n\t    !(tmp.file->f_mode & FMODE_READ) ||\n\t    (tmp.file->f_flags & O_APPEND)) {\n\t\terror = -EBADF;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (IS_SWAPFILE(file_inode(f.file)) ||\n\t    IS_SWAPFILE(file_inode(tmp.file))) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tip = XFS_I(file_inode(f.file));\n\ttip = XFS_I(file_inode(tmp.file));\n\n\tif (ip->i_mount != tip->i_mount) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (ip->i_ino == tip->i_ino) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\terror = -EIO;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\terror = xfs_swap_extents(ip, tip, sxp);\n\n out_put_tmp_file:\n\tfdput(tmp);\n out_put_file:\n\tfdput(f);\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_ioc_getbmapx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "1404-1431",
    "snippet": "STATIC int\nxfs_ioc_getbmapx(\n\tstruct xfs_inode\t*ip,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct getbmapx\t\tbmx;\n\tint\t\t\terror;\n\n\tif (copy_from_user(&bmx, arg, sizeof(bmx)))\n\t\treturn -EFAULT;\n\n\tif (bmx.bmv_count < 2)\n\t\treturn -EINVAL;\n\n\tif (bmx.bmv_iflags & (~BMV_IF_VALID))\n\t\treturn -EINVAL;\n\n\terror = xfs_getbmap(ip, &bmx, xfs_getbmapx_format,\n\t\t\t    (__force struct getbmapx *)arg+1);\n\tif (error)\n\t\treturn error;\n\n\t/* copy back header */\n\tif (copy_to_user(arg, &bmx, sizeof(struct getbmapx)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&bmx",
            "sizeof(struct getbmapx)"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_getbmap",
          "args": [
            "ip",
            "&bmx",
            "xfs_getbmapx_format",
            "(__force struct getbmapx *)arg+1"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_getbmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "489-715",
          "snippet": "int\t\t\t\t\t\t/* error code */\nxfs_getbmap(\n\txfs_inode_t\t\t*ip,\n\tstruct getbmapx\t\t*bmv,\t\t/* user bmap structure */\n\txfs_bmap_format_t\tformatter,\t/* format to user */\n\tvoid\t\t\t*arg)\t\t/* formatter arg */\n{\n\t__int64_t\t\tbmvend;\t\t/* last block requested */\n\tint\t\t\terror = 0;\t/* return value */\n\t__int64_t\t\tfixlen;\t\t/* length for -1 case */\n\tint\t\t\ti;\t\t/* extent number */\n\tint\t\t\tlock;\t\t/* lock state */\n\txfs_bmbt_irec_t\t\t*map;\t\t/* buffer for user's data */\n\txfs_mount_t\t\t*mp;\t\t/* file system mount point */\n\tint\t\t\tnex;\t\t/* # of user extents can do */\n\tint\t\t\tnexleft;\t/* # of user extents left */\n\tint\t\t\tsubnex;\t\t/* # of bmapi's can do */\n\tint\t\t\tnmap;\t\t/* number of map entries */\n\tstruct getbmapx\t\t*out;\t\t/* output structure */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tint\t\t\tprealloced;\t/* this is a file with\n\t\t\t\t\t\t * preallocated data space */\n\tint\t\t\tiflags;\t\t/* interface flags */\n\tint\t\t\tbmapi_flags;\t/* flags for xfs_bmapi */\n\tint\t\t\tcur_ext = 0;\n\n\tmp = ip->i_mount;\n\tiflags = bmv->bmv_iflags;\n\twhichfork = iflags & BMV_IF_ATTRFORK ? XFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tif (whichfork == XFS_ATTR_FORK) {\n\t\tif (XFS_IFORK_Q(ip)) {\n\t\t\tif (ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS &&\n\t\t\t    ip->i_d.di_aformat != XFS_DINODE_FMT_BTREE &&\n\t\t\t    ip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (unlikely(\n\t\t\t   ip->i_d.di_aformat != 0 &&\n\t\t\t   ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_getbmap\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t ip->i_mount);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tprealloced = 0;\n\t\tfixlen = 1LL << 32;\n\t} else {\n\t\tif (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS &&\n\t\t    ip->i_d.di_format != XFS_DINODE_FMT_BTREE &&\n\t\t    ip->i_d.di_format != XFS_DINODE_FMT_LOCAL)\n\t\t\treturn -EINVAL;\n\n\t\tif (xfs_get_extsz_hint(ip) ||\n\t\t    ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC|XFS_DIFLAG_APPEND)){\n\t\t\tprealloced = 1;\n\t\t\tfixlen = mp->m_super->s_maxbytes;\n\t\t} else {\n\t\t\tprealloced = 0;\n\t\t\tfixlen = XFS_ISIZE(ip);\n\t\t}\n\t}\n\n\tif (bmv->bmv_length == -1) {\n\t\tfixlen = XFS_FSB_TO_BB(mp, XFS_B_TO_FSB(mp, fixlen));\n\t\tbmv->bmv_length =\n\t\t\tmax_t(__int64_t, fixlen - bmv->bmv_offset, 0);\n\t} else if (bmv->bmv_length == 0) {\n\t\tbmv->bmv_entries = 0;\n\t\treturn 0;\n\t} else if (bmv->bmv_length < 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tnex = bmv->bmv_count - 1;\n\tif (nex <= 0)\n\t\treturn -EINVAL;\n\tbmvend = bmv->bmv_offset + bmv->bmv_length;\n\n\n\tif (bmv->bmv_count > ULONG_MAX / sizeof(struct getbmapx))\n\t\treturn -ENOMEM;\n\tout = kmem_zalloc_large(bmv->bmv_count * sizeof(struct getbmapx), 0);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\txfs_ilock(ip, XFS_IOLOCK_SHARED);\n\tif (whichfork == XFS_DATA_FORK) {\n\t\tif (!(iflags & BMV_IF_DELALLOC) &&\n\t\t    (ip->i_delayed_blks || XFS_ISIZE(ip) > ip->i_d.di_size)) {\n\t\t\terror = filemap_write_and_wait(VFS_I(ip)->i_mapping);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock_iolock;\n\n\t\t\t/*\n\t\t\t * Even after flushing the inode, there can still be\n\t\t\t * delalloc blocks on the inode beyond EOF due to\n\t\t\t * speculative preallocation.  These are not removed\n\t\t\t * until the release function is called or the inode\n\t\t\t * is inactivated.  Hence we cannot assert here that\n\t\t\t * ip->i_delayed_blks == 0.\n\t\t\t */\n\t\t}\n\n\t\tlock = xfs_ilock_data_map_shared(ip);\n\t} else {\n\t\tlock = xfs_ilock_attr_map_shared(ip);\n\t}\n\n\t/*\n\t * Don't let nex be bigger than the number of extents\n\t * we can have assuming alternating holes and real extents.\n\t */\n\tif (nex > XFS_IFORK_NEXTENTS(ip, whichfork) * 2 + 1)\n\t\tnex = XFS_IFORK_NEXTENTS(ip, whichfork) * 2 + 1;\n\n\tbmapi_flags = xfs_bmapi_aflag(whichfork);\n\tif (!(iflags & BMV_IF_PREALLOC))\n\t\tbmapi_flags |= XFS_BMAPI_IGSTATE;\n\n\t/*\n\t * Allocate enough space to handle \"subnex\" maps at a time.\n\t */\n\terror = -ENOMEM;\n\tsubnex = 16;\n\tmap = kmem_alloc(subnex * sizeof(*map), KM_MAYFAIL | KM_NOFS);\n\tif (!map)\n\t\tgoto out_unlock_ilock;\n\n\tbmv->bmv_entries = 0;\n\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) == 0 &&\n\t    (whichfork == XFS_ATTR_FORK || !(iflags & BMV_IF_DELALLOC))) {\n\t\terror = 0;\n\t\tgoto out_free_map;\n\t}\n\n\tnexleft = nex;\n\n\tdo {\n\t\tnmap = (nexleft > subnex) ? subnex : nexleft;\n\t\terror = xfs_bmapi_read(ip, XFS_BB_TO_FSBT(mp, bmv->bmv_offset),\n\t\t\t\t       XFS_BB_TO_FSB(mp, bmv->bmv_length),\n\t\t\t\t       map, &nmap, bmapi_flags);\n\t\tif (error)\n\t\t\tgoto out_free_map;\n\t\tASSERT(nmap <= subnex);\n\n\t\tfor (i = 0; i < nmap && nexleft && bmv->bmv_length; i++) {\n\t\t\tout[cur_ext].bmv_oflags = 0;\n\t\t\tif (map[i].br_state == XFS_EXT_UNWRITTEN)\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_PREALLOC;\n\t\t\telse if (map[i].br_startblock == DELAYSTARTBLOCK)\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_DELALLOC;\n\t\t\tout[cur_ext].bmv_offset =\n\t\t\t\tXFS_FSB_TO_BB(mp, map[i].br_startoff);\n\t\t\tout[cur_ext].bmv_length =\n\t\t\t\tXFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\tout[cur_ext].bmv_unused1 = 0;\n\t\t\tout[cur_ext].bmv_unused2 = 0;\n\n\t\t\t/*\n\t\t\t * delayed allocation extents that start beyond EOF can\n\t\t\t * occur due to speculative EOF allocation when the\n\t\t\t * delalloc extent is larger than the largest freespace\n\t\t\t * extent at conversion time. These extents cannot be\n\t\t\t * converted by data writeback, so can exist here even\n\t\t\t * if we are not supposed to be finding delalloc\n\t\t\t * extents.\n\t\t\t */\n\t\t\tif (map[i].br_startblock == DELAYSTARTBLOCK &&\n\t\t\t    map[i].br_startoff <= XFS_B_TO_FSB(mp, XFS_ISIZE(ip)))\n\t\t\t\tASSERT((iflags & BMV_IF_DELALLOC) != 0);\n\n                        if (map[i].br_startblock == HOLESTARTBLOCK &&\n\t\t\t    whichfork == XFS_ATTR_FORK) {\n\t\t\t\t/* came to the end of attribute fork */\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_LAST;\n\t\t\t\tgoto out_free_map;\n\t\t\t}\n\n\t\t\tif (!xfs_getbmapx_fix_eof_hole(ip, &out[cur_ext],\n\t\t\t\t\tprealloced, bmvend,\n\t\t\t\t\tmap[i].br_startblock))\n\t\t\t\tgoto out_free_map;\n\n\t\t\tbmv->bmv_offset =\n\t\t\t\tout[cur_ext].bmv_offset +\n\t\t\t\tout[cur_ext].bmv_length;\n\t\t\tbmv->bmv_length =\n\t\t\t\tmax_t(__int64_t, 0, bmvend - bmv->bmv_offset);\n\n\t\t\t/*\n\t\t\t * In case we don't want to return the hole,\n\t\t\t * don't increase cur_ext so that we can reuse\n\t\t\t * it in the next loop.\n\t\t\t */\n\t\t\tif ((iflags & BMV_IF_NO_HOLES) &&\n\t\t\t    map[i].br_startblock == HOLESTARTBLOCK) {\n\t\t\t\tmemset(&out[cur_ext], 0, sizeof(out[cur_ext]));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnexleft--;\n\t\t\tbmv->bmv_entries++;\n\t\t\tcur_ext++;\n\t\t}\n\t} while (nmap && nexleft && bmv->bmv_length);\n\n out_free_map:\n\tkmem_free(map);\n out_unlock_ilock:\n\txfs_iunlock(ip, lock);\n out_unlock_iolock:\n\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\n\tfor (i = 0; i < cur_ext; i++) {\n\t\tint full = 0;\t/* user array is full */\n\n\t\t/* format results & advance arg */\n\t\terror = formatter(&arg, &out[i], &full);\n\t\tif (error || full)\n\t\t\tbreak;\n\t}\n\n\tkmem_free(out);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error code */\nxfs_getbmap(\n\txfs_inode_t\t\t*ip,\n\tstruct getbmapx\t\t*bmv,\t\t/* user bmap structure */\n\txfs_bmap_format_t\tformatter,\t/* format to user */\n\tvoid\t\t\t*arg)\t\t/* formatter arg */\n{\n\t__int64_t\t\tbmvend;\t\t/* last block requested */\n\tint\t\t\terror = 0;\t/* return value */\n\t__int64_t\t\tfixlen;\t\t/* length for -1 case */\n\tint\t\t\ti;\t\t/* extent number */\n\tint\t\t\tlock;\t\t/* lock state */\n\txfs_bmbt_irec_t\t\t*map;\t\t/* buffer for user's data */\n\txfs_mount_t\t\t*mp;\t\t/* file system mount point */\n\tint\t\t\tnex;\t\t/* # of user extents can do */\n\tint\t\t\tnexleft;\t/* # of user extents left */\n\tint\t\t\tsubnex;\t\t/* # of bmapi's can do */\n\tint\t\t\tnmap;\t\t/* number of map entries */\n\tstruct getbmapx\t\t*out;\t\t/* output structure */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tint\t\t\tprealloced;\t/* this is a file with\n\t\t\t\t\t\t * preallocated data space */\n\tint\t\t\tiflags;\t\t/* interface flags */\n\tint\t\t\tbmapi_flags;\t/* flags for xfs_bmapi */\n\tint\t\t\tcur_ext = 0;\n\n\tmp = ip->i_mount;\n\tiflags = bmv->bmv_iflags;\n\twhichfork = iflags & BMV_IF_ATTRFORK ? XFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tif (whichfork == XFS_ATTR_FORK) {\n\t\tif (XFS_IFORK_Q(ip)) {\n\t\t\tif (ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS &&\n\t\t\t    ip->i_d.di_aformat != XFS_DINODE_FMT_BTREE &&\n\t\t\t    ip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (unlikely(\n\t\t\t   ip->i_d.di_aformat != 0 &&\n\t\t\t   ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_getbmap\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t ip->i_mount);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tprealloced = 0;\n\t\tfixlen = 1LL << 32;\n\t} else {\n\t\tif (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS &&\n\t\t    ip->i_d.di_format != XFS_DINODE_FMT_BTREE &&\n\t\t    ip->i_d.di_format != XFS_DINODE_FMT_LOCAL)\n\t\t\treturn -EINVAL;\n\n\t\tif (xfs_get_extsz_hint(ip) ||\n\t\t    ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC|XFS_DIFLAG_APPEND)){\n\t\t\tprealloced = 1;\n\t\t\tfixlen = mp->m_super->s_maxbytes;\n\t\t} else {\n\t\t\tprealloced = 0;\n\t\t\tfixlen = XFS_ISIZE(ip);\n\t\t}\n\t}\n\n\tif (bmv->bmv_length == -1) {\n\t\tfixlen = XFS_FSB_TO_BB(mp, XFS_B_TO_FSB(mp, fixlen));\n\t\tbmv->bmv_length =\n\t\t\tmax_t(__int64_t, fixlen - bmv->bmv_offset, 0);\n\t} else if (bmv->bmv_length == 0) {\n\t\tbmv->bmv_entries = 0;\n\t\treturn 0;\n\t} else if (bmv->bmv_length < 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tnex = bmv->bmv_count - 1;\n\tif (nex <= 0)\n\t\treturn -EINVAL;\n\tbmvend = bmv->bmv_offset + bmv->bmv_length;\n\n\n\tif (bmv->bmv_count > ULONG_MAX / sizeof(struct getbmapx))\n\t\treturn -ENOMEM;\n\tout = kmem_zalloc_large(bmv->bmv_count * sizeof(struct getbmapx), 0);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\txfs_ilock(ip, XFS_IOLOCK_SHARED);\n\tif (whichfork == XFS_DATA_FORK) {\n\t\tif (!(iflags & BMV_IF_DELALLOC) &&\n\t\t    (ip->i_delayed_blks || XFS_ISIZE(ip) > ip->i_d.di_size)) {\n\t\t\terror = filemap_write_and_wait(VFS_I(ip)->i_mapping);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock_iolock;\n\n\t\t\t/*\n\t\t\t * Even after flushing the inode, there can still be\n\t\t\t * delalloc blocks on the inode beyond EOF due to\n\t\t\t * speculative preallocation.  These are not removed\n\t\t\t * until the release function is called or the inode\n\t\t\t * is inactivated.  Hence we cannot assert here that\n\t\t\t * ip->i_delayed_blks == 0.\n\t\t\t */\n\t\t}\n\n\t\tlock = xfs_ilock_data_map_shared(ip);\n\t} else {\n\t\tlock = xfs_ilock_attr_map_shared(ip);\n\t}\n\n\t/*\n\t * Don't let nex be bigger than the number of extents\n\t * we can have assuming alternating holes and real extents.\n\t */\n\tif (nex > XFS_IFORK_NEXTENTS(ip, whichfork) * 2 + 1)\n\t\tnex = XFS_IFORK_NEXTENTS(ip, whichfork) * 2 + 1;\n\n\tbmapi_flags = xfs_bmapi_aflag(whichfork);\n\tif (!(iflags & BMV_IF_PREALLOC))\n\t\tbmapi_flags |= XFS_BMAPI_IGSTATE;\n\n\t/*\n\t * Allocate enough space to handle \"subnex\" maps at a time.\n\t */\n\terror = -ENOMEM;\n\tsubnex = 16;\n\tmap = kmem_alloc(subnex * sizeof(*map), KM_MAYFAIL | KM_NOFS);\n\tif (!map)\n\t\tgoto out_unlock_ilock;\n\n\tbmv->bmv_entries = 0;\n\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) == 0 &&\n\t    (whichfork == XFS_ATTR_FORK || !(iflags & BMV_IF_DELALLOC))) {\n\t\terror = 0;\n\t\tgoto out_free_map;\n\t}\n\n\tnexleft = nex;\n\n\tdo {\n\t\tnmap = (nexleft > subnex) ? subnex : nexleft;\n\t\terror = xfs_bmapi_read(ip, XFS_BB_TO_FSBT(mp, bmv->bmv_offset),\n\t\t\t\t       XFS_BB_TO_FSB(mp, bmv->bmv_length),\n\t\t\t\t       map, &nmap, bmapi_flags);\n\t\tif (error)\n\t\t\tgoto out_free_map;\n\t\tASSERT(nmap <= subnex);\n\n\t\tfor (i = 0; i < nmap && nexleft && bmv->bmv_length; i++) {\n\t\t\tout[cur_ext].bmv_oflags = 0;\n\t\t\tif (map[i].br_state == XFS_EXT_UNWRITTEN)\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_PREALLOC;\n\t\t\telse if (map[i].br_startblock == DELAYSTARTBLOCK)\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_DELALLOC;\n\t\t\tout[cur_ext].bmv_offset =\n\t\t\t\tXFS_FSB_TO_BB(mp, map[i].br_startoff);\n\t\t\tout[cur_ext].bmv_length =\n\t\t\t\tXFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\tout[cur_ext].bmv_unused1 = 0;\n\t\t\tout[cur_ext].bmv_unused2 = 0;\n\n\t\t\t/*\n\t\t\t * delayed allocation extents that start beyond EOF can\n\t\t\t * occur due to speculative EOF allocation when the\n\t\t\t * delalloc extent is larger than the largest freespace\n\t\t\t * extent at conversion time. These extents cannot be\n\t\t\t * converted by data writeback, so can exist here even\n\t\t\t * if we are not supposed to be finding delalloc\n\t\t\t * extents.\n\t\t\t */\n\t\t\tif (map[i].br_startblock == DELAYSTARTBLOCK &&\n\t\t\t    map[i].br_startoff <= XFS_B_TO_FSB(mp, XFS_ISIZE(ip)))\n\t\t\t\tASSERT((iflags & BMV_IF_DELALLOC) != 0);\n\n                        if (map[i].br_startblock == HOLESTARTBLOCK &&\n\t\t\t    whichfork == XFS_ATTR_FORK) {\n\t\t\t\t/* came to the end of attribute fork */\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_LAST;\n\t\t\t\tgoto out_free_map;\n\t\t\t}\n\n\t\t\tif (!xfs_getbmapx_fix_eof_hole(ip, &out[cur_ext],\n\t\t\t\t\tprealloced, bmvend,\n\t\t\t\t\tmap[i].br_startblock))\n\t\t\t\tgoto out_free_map;\n\n\t\t\tbmv->bmv_offset =\n\t\t\t\tout[cur_ext].bmv_offset +\n\t\t\t\tout[cur_ext].bmv_length;\n\t\t\tbmv->bmv_length =\n\t\t\t\tmax_t(__int64_t, 0, bmvend - bmv->bmv_offset);\n\n\t\t\t/*\n\t\t\t * In case we don't want to return the hole,\n\t\t\t * don't increase cur_ext so that we can reuse\n\t\t\t * it in the next loop.\n\t\t\t */\n\t\t\tif ((iflags & BMV_IF_NO_HOLES) &&\n\t\t\t    map[i].br_startblock == HOLESTARTBLOCK) {\n\t\t\t\tmemset(&out[cur_ext], 0, sizeof(out[cur_ext]));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnexleft--;\n\t\t\tbmv->bmv_entries++;\n\t\t\tcur_ext++;\n\t\t}\n\t} while (nmap && nexleft && bmv->bmv_length);\n\n out_free_map:\n\tkmem_free(map);\n out_unlock_ilock:\n\txfs_iunlock(ip, lock);\n out_unlock_iolock:\n\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\n\tfor (i = 0; i < cur_ext; i++) {\n\t\tint full = 0;\t/* user array is full */\n\n\t\t/* format results & advance arg */\n\t\terror = formatter(&arg, &out[i], &full);\n\t\tif (error || full)\n\t\t\tbreak;\n\t}\n\n\tkmem_free(out);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&bmx",
            "arg",
            "sizeof(bmx)"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_ioc_getbmapx(\n\tstruct xfs_inode\t*ip,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct getbmapx\t\tbmx;\n\tint\t\t\terror;\n\n\tif (copy_from_user(&bmx, arg, sizeof(bmx)))\n\t\treturn -EFAULT;\n\n\tif (bmx.bmv_count < 2)\n\t\treturn -EINVAL;\n\n\tif (bmx.bmv_iflags & (~BMV_IF_VALID))\n\t\treturn -EINVAL;\n\n\terror = xfs_getbmap(ip, &bmx, xfs_getbmapx_format,\n\t\t\t    (__force struct getbmapx *)arg+1);\n\tif (error)\n\t\treturn error;\n\n\t/* copy back header */\n\tif (copy_to_user(arg, &bmx, sizeof(struct getbmapx)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_getbmapx_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "1392-1402",
    "snippet": "STATIC int\nxfs_getbmapx_format(void **ap, struct getbmapx *bmv, int *full)\n{\n\tstruct getbmapx __user\t*base = (struct getbmapx __user *)*ap;\n\n\tif (copy_to_user(base, bmv, sizeof(struct getbmapx)))\n\t\treturn -EFAULT;\n\n\t*ap += sizeof(struct getbmapx);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "base",
            "bmv",
            "sizeof(struct getbmapx)"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_getbmapx_format(void **ap, struct getbmapx *bmv, int *full)\n{\n\tstruct getbmapx __user\t*base = (struct getbmapx __user *)*ap;\n\n\tif (copy_to_user(base, bmv, sizeof(struct getbmapx)))\n\t\treturn -EFAULT;\n\n\t*ap += sizeof(struct getbmapx);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ioc_getbmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "1361-1390",
    "snippet": "STATIC int\nxfs_ioc_getbmap(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tioflags,\n\tunsigned int\t\tcmd,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct getbmapx\t\tbmx;\n\tint\t\t\terror;\n\n\tif (copy_from_user(&bmx, arg, sizeof(struct getbmapx)))\n\t\treturn -EFAULT;\n\n\tif (bmx.bmv_count < 2)\n\t\treturn -EINVAL;\n\n\tbmx.bmv_iflags = (cmd == XFS_IOC_GETBMAPA ? BMV_IF_ATTRFORK : 0);\n\tif (ioflags & XFS_IO_INVIS)\n\t\tbmx.bmv_iflags |= BMV_IF_NO_DMAPI_READ;\n\n\terror = xfs_getbmap(ip, &bmx, xfs_getbmap_format,\n\t\t\t    (__force struct getbmap *)arg+1);\n\tif (error)\n\t\treturn error;\n\n\t/* copy back header - only size of getbmap */\n\tif (copy_to_user(arg, &bmx, sizeof(struct getbmap)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&bmx",
            "sizeof(struct getbmap)"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_getbmap",
          "args": [
            "ip",
            "&bmx",
            "xfs_getbmap_format",
            "(__force struct getbmap *)arg+1"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_getbmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "489-715",
          "snippet": "int\t\t\t\t\t\t/* error code */\nxfs_getbmap(\n\txfs_inode_t\t\t*ip,\n\tstruct getbmapx\t\t*bmv,\t\t/* user bmap structure */\n\txfs_bmap_format_t\tformatter,\t/* format to user */\n\tvoid\t\t\t*arg)\t\t/* formatter arg */\n{\n\t__int64_t\t\tbmvend;\t\t/* last block requested */\n\tint\t\t\terror = 0;\t/* return value */\n\t__int64_t\t\tfixlen;\t\t/* length for -1 case */\n\tint\t\t\ti;\t\t/* extent number */\n\tint\t\t\tlock;\t\t/* lock state */\n\txfs_bmbt_irec_t\t\t*map;\t\t/* buffer for user's data */\n\txfs_mount_t\t\t*mp;\t\t/* file system mount point */\n\tint\t\t\tnex;\t\t/* # of user extents can do */\n\tint\t\t\tnexleft;\t/* # of user extents left */\n\tint\t\t\tsubnex;\t\t/* # of bmapi's can do */\n\tint\t\t\tnmap;\t\t/* number of map entries */\n\tstruct getbmapx\t\t*out;\t\t/* output structure */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tint\t\t\tprealloced;\t/* this is a file with\n\t\t\t\t\t\t * preallocated data space */\n\tint\t\t\tiflags;\t\t/* interface flags */\n\tint\t\t\tbmapi_flags;\t/* flags for xfs_bmapi */\n\tint\t\t\tcur_ext = 0;\n\n\tmp = ip->i_mount;\n\tiflags = bmv->bmv_iflags;\n\twhichfork = iflags & BMV_IF_ATTRFORK ? XFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tif (whichfork == XFS_ATTR_FORK) {\n\t\tif (XFS_IFORK_Q(ip)) {\n\t\t\tif (ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS &&\n\t\t\t    ip->i_d.di_aformat != XFS_DINODE_FMT_BTREE &&\n\t\t\t    ip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (unlikely(\n\t\t\t   ip->i_d.di_aformat != 0 &&\n\t\t\t   ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_getbmap\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t ip->i_mount);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tprealloced = 0;\n\t\tfixlen = 1LL << 32;\n\t} else {\n\t\tif (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS &&\n\t\t    ip->i_d.di_format != XFS_DINODE_FMT_BTREE &&\n\t\t    ip->i_d.di_format != XFS_DINODE_FMT_LOCAL)\n\t\t\treturn -EINVAL;\n\n\t\tif (xfs_get_extsz_hint(ip) ||\n\t\t    ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC|XFS_DIFLAG_APPEND)){\n\t\t\tprealloced = 1;\n\t\t\tfixlen = mp->m_super->s_maxbytes;\n\t\t} else {\n\t\t\tprealloced = 0;\n\t\t\tfixlen = XFS_ISIZE(ip);\n\t\t}\n\t}\n\n\tif (bmv->bmv_length == -1) {\n\t\tfixlen = XFS_FSB_TO_BB(mp, XFS_B_TO_FSB(mp, fixlen));\n\t\tbmv->bmv_length =\n\t\t\tmax_t(__int64_t, fixlen - bmv->bmv_offset, 0);\n\t} else if (bmv->bmv_length == 0) {\n\t\tbmv->bmv_entries = 0;\n\t\treturn 0;\n\t} else if (bmv->bmv_length < 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tnex = bmv->bmv_count - 1;\n\tif (nex <= 0)\n\t\treturn -EINVAL;\n\tbmvend = bmv->bmv_offset + bmv->bmv_length;\n\n\n\tif (bmv->bmv_count > ULONG_MAX / sizeof(struct getbmapx))\n\t\treturn -ENOMEM;\n\tout = kmem_zalloc_large(bmv->bmv_count * sizeof(struct getbmapx), 0);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\txfs_ilock(ip, XFS_IOLOCK_SHARED);\n\tif (whichfork == XFS_DATA_FORK) {\n\t\tif (!(iflags & BMV_IF_DELALLOC) &&\n\t\t    (ip->i_delayed_blks || XFS_ISIZE(ip) > ip->i_d.di_size)) {\n\t\t\terror = filemap_write_and_wait(VFS_I(ip)->i_mapping);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock_iolock;\n\n\t\t\t/*\n\t\t\t * Even after flushing the inode, there can still be\n\t\t\t * delalloc blocks on the inode beyond EOF due to\n\t\t\t * speculative preallocation.  These are not removed\n\t\t\t * until the release function is called or the inode\n\t\t\t * is inactivated.  Hence we cannot assert here that\n\t\t\t * ip->i_delayed_blks == 0.\n\t\t\t */\n\t\t}\n\n\t\tlock = xfs_ilock_data_map_shared(ip);\n\t} else {\n\t\tlock = xfs_ilock_attr_map_shared(ip);\n\t}\n\n\t/*\n\t * Don't let nex be bigger than the number of extents\n\t * we can have assuming alternating holes and real extents.\n\t */\n\tif (nex > XFS_IFORK_NEXTENTS(ip, whichfork) * 2 + 1)\n\t\tnex = XFS_IFORK_NEXTENTS(ip, whichfork) * 2 + 1;\n\n\tbmapi_flags = xfs_bmapi_aflag(whichfork);\n\tif (!(iflags & BMV_IF_PREALLOC))\n\t\tbmapi_flags |= XFS_BMAPI_IGSTATE;\n\n\t/*\n\t * Allocate enough space to handle \"subnex\" maps at a time.\n\t */\n\terror = -ENOMEM;\n\tsubnex = 16;\n\tmap = kmem_alloc(subnex * sizeof(*map), KM_MAYFAIL | KM_NOFS);\n\tif (!map)\n\t\tgoto out_unlock_ilock;\n\n\tbmv->bmv_entries = 0;\n\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) == 0 &&\n\t    (whichfork == XFS_ATTR_FORK || !(iflags & BMV_IF_DELALLOC))) {\n\t\terror = 0;\n\t\tgoto out_free_map;\n\t}\n\n\tnexleft = nex;\n\n\tdo {\n\t\tnmap = (nexleft > subnex) ? subnex : nexleft;\n\t\terror = xfs_bmapi_read(ip, XFS_BB_TO_FSBT(mp, bmv->bmv_offset),\n\t\t\t\t       XFS_BB_TO_FSB(mp, bmv->bmv_length),\n\t\t\t\t       map, &nmap, bmapi_flags);\n\t\tif (error)\n\t\t\tgoto out_free_map;\n\t\tASSERT(nmap <= subnex);\n\n\t\tfor (i = 0; i < nmap && nexleft && bmv->bmv_length; i++) {\n\t\t\tout[cur_ext].bmv_oflags = 0;\n\t\t\tif (map[i].br_state == XFS_EXT_UNWRITTEN)\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_PREALLOC;\n\t\t\telse if (map[i].br_startblock == DELAYSTARTBLOCK)\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_DELALLOC;\n\t\t\tout[cur_ext].bmv_offset =\n\t\t\t\tXFS_FSB_TO_BB(mp, map[i].br_startoff);\n\t\t\tout[cur_ext].bmv_length =\n\t\t\t\tXFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\tout[cur_ext].bmv_unused1 = 0;\n\t\t\tout[cur_ext].bmv_unused2 = 0;\n\n\t\t\t/*\n\t\t\t * delayed allocation extents that start beyond EOF can\n\t\t\t * occur due to speculative EOF allocation when the\n\t\t\t * delalloc extent is larger than the largest freespace\n\t\t\t * extent at conversion time. These extents cannot be\n\t\t\t * converted by data writeback, so can exist here even\n\t\t\t * if we are not supposed to be finding delalloc\n\t\t\t * extents.\n\t\t\t */\n\t\t\tif (map[i].br_startblock == DELAYSTARTBLOCK &&\n\t\t\t    map[i].br_startoff <= XFS_B_TO_FSB(mp, XFS_ISIZE(ip)))\n\t\t\t\tASSERT((iflags & BMV_IF_DELALLOC) != 0);\n\n                        if (map[i].br_startblock == HOLESTARTBLOCK &&\n\t\t\t    whichfork == XFS_ATTR_FORK) {\n\t\t\t\t/* came to the end of attribute fork */\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_LAST;\n\t\t\t\tgoto out_free_map;\n\t\t\t}\n\n\t\t\tif (!xfs_getbmapx_fix_eof_hole(ip, &out[cur_ext],\n\t\t\t\t\tprealloced, bmvend,\n\t\t\t\t\tmap[i].br_startblock))\n\t\t\t\tgoto out_free_map;\n\n\t\t\tbmv->bmv_offset =\n\t\t\t\tout[cur_ext].bmv_offset +\n\t\t\t\tout[cur_ext].bmv_length;\n\t\t\tbmv->bmv_length =\n\t\t\t\tmax_t(__int64_t, 0, bmvend - bmv->bmv_offset);\n\n\t\t\t/*\n\t\t\t * In case we don't want to return the hole,\n\t\t\t * don't increase cur_ext so that we can reuse\n\t\t\t * it in the next loop.\n\t\t\t */\n\t\t\tif ((iflags & BMV_IF_NO_HOLES) &&\n\t\t\t    map[i].br_startblock == HOLESTARTBLOCK) {\n\t\t\t\tmemset(&out[cur_ext], 0, sizeof(out[cur_ext]));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnexleft--;\n\t\t\tbmv->bmv_entries++;\n\t\t\tcur_ext++;\n\t\t}\n\t} while (nmap && nexleft && bmv->bmv_length);\n\n out_free_map:\n\tkmem_free(map);\n out_unlock_ilock:\n\txfs_iunlock(ip, lock);\n out_unlock_iolock:\n\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\n\tfor (i = 0; i < cur_ext; i++) {\n\t\tint full = 0;\t/* user array is full */\n\n\t\t/* format results & advance arg */\n\t\terror = formatter(&arg, &out[i], &full);\n\t\tif (error || full)\n\t\t\tbreak;\n\t}\n\n\tkmem_free(out);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error code */\nxfs_getbmap(\n\txfs_inode_t\t\t*ip,\n\tstruct getbmapx\t\t*bmv,\t\t/* user bmap structure */\n\txfs_bmap_format_t\tformatter,\t/* format to user */\n\tvoid\t\t\t*arg)\t\t/* formatter arg */\n{\n\t__int64_t\t\tbmvend;\t\t/* last block requested */\n\tint\t\t\terror = 0;\t/* return value */\n\t__int64_t\t\tfixlen;\t\t/* length for -1 case */\n\tint\t\t\ti;\t\t/* extent number */\n\tint\t\t\tlock;\t\t/* lock state */\n\txfs_bmbt_irec_t\t\t*map;\t\t/* buffer for user's data */\n\txfs_mount_t\t\t*mp;\t\t/* file system mount point */\n\tint\t\t\tnex;\t\t/* # of user extents can do */\n\tint\t\t\tnexleft;\t/* # of user extents left */\n\tint\t\t\tsubnex;\t\t/* # of bmapi's can do */\n\tint\t\t\tnmap;\t\t/* number of map entries */\n\tstruct getbmapx\t\t*out;\t\t/* output structure */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tint\t\t\tprealloced;\t/* this is a file with\n\t\t\t\t\t\t * preallocated data space */\n\tint\t\t\tiflags;\t\t/* interface flags */\n\tint\t\t\tbmapi_flags;\t/* flags for xfs_bmapi */\n\tint\t\t\tcur_ext = 0;\n\n\tmp = ip->i_mount;\n\tiflags = bmv->bmv_iflags;\n\twhichfork = iflags & BMV_IF_ATTRFORK ? XFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tif (whichfork == XFS_ATTR_FORK) {\n\t\tif (XFS_IFORK_Q(ip)) {\n\t\t\tif (ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS &&\n\t\t\t    ip->i_d.di_aformat != XFS_DINODE_FMT_BTREE &&\n\t\t\t    ip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (unlikely(\n\t\t\t   ip->i_d.di_aformat != 0 &&\n\t\t\t   ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_getbmap\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t ip->i_mount);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tprealloced = 0;\n\t\tfixlen = 1LL << 32;\n\t} else {\n\t\tif (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS &&\n\t\t    ip->i_d.di_format != XFS_DINODE_FMT_BTREE &&\n\t\t    ip->i_d.di_format != XFS_DINODE_FMT_LOCAL)\n\t\t\treturn -EINVAL;\n\n\t\tif (xfs_get_extsz_hint(ip) ||\n\t\t    ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC|XFS_DIFLAG_APPEND)){\n\t\t\tprealloced = 1;\n\t\t\tfixlen = mp->m_super->s_maxbytes;\n\t\t} else {\n\t\t\tprealloced = 0;\n\t\t\tfixlen = XFS_ISIZE(ip);\n\t\t}\n\t}\n\n\tif (bmv->bmv_length == -1) {\n\t\tfixlen = XFS_FSB_TO_BB(mp, XFS_B_TO_FSB(mp, fixlen));\n\t\tbmv->bmv_length =\n\t\t\tmax_t(__int64_t, fixlen - bmv->bmv_offset, 0);\n\t} else if (bmv->bmv_length == 0) {\n\t\tbmv->bmv_entries = 0;\n\t\treturn 0;\n\t} else if (bmv->bmv_length < 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tnex = bmv->bmv_count - 1;\n\tif (nex <= 0)\n\t\treturn -EINVAL;\n\tbmvend = bmv->bmv_offset + bmv->bmv_length;\n\n\n\tif (bmv->bmv_count > ULONG_MAX / sizeof(struct getbmapx))\n\t\treturn -ENOMEM;\n\tout = kmem_zalloc_large(bmv->bmv_count * sizeof(struct getbmapx), 0);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\txfs_ilock(ip, XFS_IOLOCK_SHARED);\n\tif (whichfork == XFS_DATA_FORK) {\n\t\tif (!(iflags & BMV_IF_DELALLOC) &&\n\t\t    (ip->i_delayed_blks || XFS_ISIZE(ip) > ip->i_d.di_size)) {\n\t\t\terror = filemap_write_and_wait(VFS_I(ip)->i_mapping);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock_iolock;\n\n\t\t\t/*\n\t\t\t * Even after flushing the inode, there can still be\n\t\t\t * delalloc blocks on the inode beyond EOF due to\n\t\t\t * speculative preallocation.  These are not removed\n\t\t\t * until the release function is called or the inode\n\t\t\t * is inactivated.  Hence we cannot assert here that\n\t\t\t * ip->i_delayed_blks == 0.\n\t\t\t */\n\t\t}\n\n\t\tlock = xfs_ilock_data_map_shared(ip);\n\t} else {\n\t\tlock = xfs_ilock_attr_map_shared(ip);\n\t}\n\n\t/*\n\t * Don't let nex be bigger than the number of extents\n\t * we can have assuming alternating holes and real extents.\n\t */\n\tif (nex > XFS_IFORK_NEXTENTS(ip, whichfork) * 2 + 1)\n\t\tnex = XFS_IFORK_NEXTENTS(ip, whichfork) * 2 + 1;\n\n\tbmapi_flags = xfs_bmapi_aflag(whichfork);\n\tif (!(iflags & BMV_IF_PREALLOC))\n\t\tbmapi_flags |= XFS_BMAPI_IGSTATE;\n\n\t/*\n\t * Allocate enough space to handle \"subnex\" maps at a time.\n\t */\n\terror = -ENOMEM;\n\tsubnex = 16;\n\tmap = kmem_alloc(subnex * sizeof(*map), KM_MAYFAIL | KM_NOFS);\n\tif (!map)\n\t\tgoto out_unlock_ilock;\n\n\tbmv->bmv_entries = 0;\n\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) == 0 &&\n\t    (whichfork == XFS_ATTR_FORK || !(iflags & BMV_IF_DELALLOC))) {\n\t\terror = 0;\n\t\tgoto out_free_map;\n\t}\n\n\tnexleft = nex;\n\n\tdo {\n\t\tnmap = (nexleft > subnex) ? subnex : nexleft;\n\t\terror = xfs_bmapi_read(ip, XFS_BB_TO_FSBT(mp, bmv->bmv_offset),\n\t\t\t\t       XFS_BB_TO_FSB(mp, bmv->bmv_length),\n\t\t\t\t       map, &nmap, bmapi_flags);\n\t\tif (error)\n\t\t\tgoto out_free_map;\n\t\tASSERT(nmap <= subnex);\n\n\t\tfor (i = 0; i < nmap && nexleft && bmv->bmv_length; i++) {\n\t\t\tout[cur_ext].bmv_oflags = 0;\n\t\t\tif (map[i].br_state == XFS_EXT_UNWRITTEN)\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_PREALLOC;\n\t\t\telse if (map[i].br_startblock == DELAYSTARTBLOCK)\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_DELALLOC;\n\t\t\tout[cur_ext].bmv_offset =\n\t\t\t\tXFS_FSB_TO_BB(mp, map[i].br_startoff);\n\t\t\tout[cur_ext].bmv_length =\n\t\t\t\tXFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\tout[cur_ext].bmv_unused1 = 0;\n\t\t\tout[cur_ext].bmv_unused2 = 0;\n\n\t\t\t/*\n\t\t\t * delayed allocation extents that start beyond EOF can\n\t\t\t * occur due to speculative EOF allocation when the\n\t\t\t * delalloc extent is larger than the largest freespace\n\t\t\t * extent at conversion time. These extents cannot be\n\t\t\t * converted by data writeback, so can exist here even\n\t\t\t * if we are not supposed to be finding delalloc\n\t\t\t * extents.\n\t\t\t */\n\t\t\tif (map[i].br_startblock == DELAYSTARTBLOCK &&\n\t\t\t    map[i].br_startoff <= XFS_B_TO_FSB(mp, XFS_ISIZE(ip)))\n\t\t\t\tASSERT((iflags & BMV_IF_DELALLOC) != 0);\n\n                        if (map[i].br_startblock == HOLESTARTBLOCK &&\n\t\t\t    whichfork == XFS_ATTR_FORK) {\n\t\t\t\t/* came to the end of attribute fork */\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_LAST;\n\t\t\t\tgoto out_free_map;\n\t\t\t}\n\n\t\t\tif (!xfs_getbmapx_fix_eof_hole(ip, &out[cur_ext],\n\t\t\t\t\tprealloced, bmvend,\n\t\t\t\t\tmap[i].br_startblock))\n\t\t\t\tgoto out_free_map;\n\n\t\t\tbmv->bmv_offset =\n\t\t\t\tout[cur_ext].bmv_offset +\n\t\t\t\tout[cur_ext].bmv_length;\n\t\t\tbmv->bmv_length =\n\t\t\t\tmax_t(__int64_t, 0, bmvend - bmv->bmv_offset);\n\n\t\t\t/*\n\t\t\t * In case we don't want to return the hole,\n\t\t\t * don't increase cur_ext so that we can reuse\n\t\t\t * it in the next loop.\n\t\t\t */\n\t\t\tif ((iflags & BMV_IF_NO_HOLES) &&\n\t\t\t    map[i].br_startblock == HOLESTARTBLOCK) {\n\t\t\t\tmemset(&out[cur_ext], 0, sizeof(out[cur_ext]));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnexleft--;\n\t\t\tbmv->bmv_entries++;\n\t\t\tcur_ext++;\n\t\t}\n\t} while (nmap && nexleft && bmv->bmv_length);\n\n out_free_map:\n\tkmem_free(map);\n out_unlock_ilock:\n\txfs_iunlock(ip, lock);\n out_unlock_iolock:\n\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\n\tfor (i = 0; i < cur_ext; i++) {\n\t\tint full = 0;\t/* user array is full */\n\n\t\t/* format results & advance arg */\n\t\terror = formatter(&arg, &out[i], &full);\n\t\tif (error || full)\n\t\t\tbreak;\n\t}\n\n\tkmem_free(out);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&bmx",
            "arg",
            "sizeof(struct getbmapx)"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_ioc_getbmap(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tioflags,\n\tunsigned int\t\tcmd,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct getbmapx\t\tbmx;\n\tint\t\t\terror;\n\n\tif (copy_from_user(&bmx, arg, sizeof(struct getbmapx)))\n\t\treturn -EFAULT;\n\n\tif (bmx.bmv_count < 2)\n\t\treturn -EINVAL;\n\n\tbmx.bmv_iflags = (cmd == XFS_IOC_GETBMAPA ? BMV_IF_ATTRFORK : 0);\n\tif (ioflags & XFS_IO_INVIS)\n\t\tbmx.bmv_iflags |= BMV_IF_NO_DMAPI_READ;\n\n\terror = xfs_getbmap(ip, &bmx, xfs_getbmap_format,\n\t\t\t    (__force struct getbmap *)arg+1);\n\tif (error)\n\t\treturn error;\n\n\t/* copy back header - only size of getbmap */\n\tif (copy_to_user(arg, &bmx, sizeof(struct getbmap)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_getbmap_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "1348-1359",
    "snippet": "STATIC int\nxfs_getbmap_format(void **ap, struct getbmapx *bmv, int *full)\n{\n\tstruct getbmap __user\t*base = (struct getbmap __user *)*ap;\n\n\t/* copy only getbmap portion (not getbmapx) */\n\tif (copy_to_user(base, bmv, sizeof(struct getbmap)))\n\t\treturn -EFAULT;\n\n\t*ap += sizeof(struct getbmap);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "base",
            "bmv",
            "sizeof(struct getbmap)"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_getbmap_format(void **ap, struct getbmapx *bmv, int *full)\n{\n\tstruct getbmap __user\t*base = (struct getbmap __user *)*ap;\n\n\t/* copy only getbmap portion (not getbmapx) */\n\tif (copy_to_user(base, bmv, sizeof(struct getbmap)))\n\t\treturn -EFAULT;\n\n\t*ap += sizeof(struct getbmap);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ioc_setxflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "1305-1346",
    "snippet": "STATIC int\nxfs_ioc_setxflags(\n\tstruct xfs_inode\t*ip,\n\tstruct file\t\t*filp,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct xfs_trans\t*tp;\n\tstruct fsxattr\t\tfa;\n\tunsigned int\t\tflags;\n\tint\t\t\terror;\n\n\tif (copy_from_user(&flags, arg, sizeof(flags)))\n\t\treturn -EFAULT;\n\n\tif (flags & ~(FS_IMMUTABLE_FL | FS_APPEND_FL | \\\n\t\t      FS_NOATIME_FL | FS_NODUMP_FL | \\\n\t\t      FS_SYNC_FL))\n\t\treturn -EOPNOTSUPP;\n\n\tfa.fsx_xflags = xfs_merge_ioc_xflags(flags, xfs_ip2xflags(ip));\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\n\ttp = xfs_ioctl_setattr_get_trans(ip);\n\tif (IS_ERR(tp)) {\n\t\terror = PTR_ERR(tp);\n\t\tgoto out_drop_write;\n\t}\n\n\terror = xfs_ioctl_setattr_xflags(tp, ip, &fa);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto out_drop_write;\n\t}\n\n\terror = xfs_trans_commit(tp, 0);\nout_drop_write:\n\tmnt_drop_write_file(filp);\n\treturn error;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "0"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "0"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ioctl_setattr_xflags",
          "args": [
            "tp",
            "ip",
            "&fa"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioctl_setattr_xflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "995-1030",
          "snippet": "static int\nxfs_ioctl_setattr_xflags(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct fsxattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\t/* Can't change realtime flag if any extents are allocated. */\n\tif ((ip->i_d.di_nextents || ip->i_delayed_blks) &&\n\t    XFS_IS_REALTIME_INODE(ip) != (fa->fsx_xflags & XFS_XFLAG_REALTIME))\n\t\treturn -EINVAL;\n\n\t/* If realtime flag is set then must have realtime device */\n\tif (fa->fsx_xflags & XFS_XFLAG_REALTIME) {\n\t\tif (mp->m_sb.sb_rblocks == 0 || mp->m_sb.sb_rextsize == 0 ||\n\t\t    (ip->i_d.di_extsize % mp->m_sb.sb_rextsize))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Can't modify an immutable/append-only file unless\n\t * we have appropriate permission.\n\t */\n\tif (((ip->i_d.di_flags & (XFS_DIFLAG_IMMUTABLE | XFS_DIFLAG_APPEND)) ||\n\t     (fa->fsx_xflags & (XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND))) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\treturn -EPERM;\n\n\txfs_set_diflags(ip, fa->fsx_xflags);\n\txfs_diflags_to_linux(ip);\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\tXFS_STATS_INC(xs_ig_attrchg);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic int\nxfs_ioctl_setattr_xflags(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct fsxattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\t/* Can't change realtime flag if any extents are allocated. */\n\tif ((ip->i_d.di_nextents || ip->i_delayed_blks) &&\n\t    XFS_IS_REALTIME_INODE(ip) != (fa->fsx_xflags & XFS_XFLAG_REALTIME))\n\t\treturn -EINVAL;\n\n\t/* If realtime flag is set then must have realtime device */\n\tif (fa->fsx_xflags & XFS_XFLAG_REALTIME) {\n\t\tif (mp->m_sb.sb_rblocks == 0 || mp->m_sb.sb_rextsize == 0 ||\n\t\t    (ip->i_d.di_extsize % mp->m_sb.sb_rextsize))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Can't modify an immutable/append-only file unless\n\t * we have appropriate permission.\n\t */\n\tif (((ip->i_d.di_flags & (XFS_DIFLAG_IMMUTABLE | XFS_DIFLAG_APPEND)) ||\n\t     (fa->fsx_xflags & (XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND))) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\treturn -EPERM;\n\n\txfs_set_diflags(ip, fa->fsx_xflags);\n\txfs_diflags_to_linux(ip);\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\tXFS_STATS_INC(xs_ig_attrchg);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tp"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tp"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ioctl_setattr_get_trans",
          "args": [
            "ip"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioctl_setattr_get_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "1038-1078",
          "snippet": "static struct xfs_trans *\nxfs_ioctl_setattr_get_trans(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn ERR_PTR(-EIO);\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error)\n\t\tgoto out_cancel;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * CAP_FOWNER overrides the following restrictions:\n\t *\n\t * The user ID of the calling process must be equal to the file owner\n\t * ID, except in cases where the CAP_FSETID capability is applicable.\n\t */\n\tif (!inode_owner_or_capable(VFS_I(ip))) {\n\t\terror = -EPERM;\n\t\tgoto out_cancel;\n\t}\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\treturn tp;\n\nout_cancel:\n\txfs_trans_cancel(tp, 0);\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic struct xfs_trans *\nxfs_ioctl_setattr_get_trans(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn ERR_PTR(-EIO);\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error)\n\t\tgoto out_cancel;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * CAP_FOWNER overrides the following restrictions:\n\t *\n\t * The user ID of the calling process must be equal to the file owner\n\t * ID, except in cases where the CAP_FSETID capability is applicable.\n\t */\n\tif (!inode_owner_or_capable(VFS_I(ip))) {\n\t\terror = -EPERM;\n\t\tgoto out_cancel;\n\t}\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\treturn tp;\n\nout_cancel:\n\txfs_trans_cancel(tp, 0);\n\treturn ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_merge_ioc_xflags",
          "args": [
            "flags",
            "xfs_ip2xflags(ip)"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_merge_ioc_xflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "840-869",
          "snippet": "STATIC unsigned int\nxfs_merge_ioc_xflags(\n\tunsigned int\tflags,\n\tunsigned int\tstart)\n{\n\tunsigned int\txflags = start;\n\n\tif (flags & FS_IMMUTABLE_FL)\n\t\txflags |= XFS_XFLAG_IMMUTABLE;\n\telse\n\t\txflags &= ~XFS_XFLAG_IMMUTABLE;\n\tif (flags & FS_APPEND_FL)\n\t\txflags |= XFS_XFLAG_APPEND;\n\telse\n\t\txflags &= ~XFS_XFLAG_APPEND;\n\tif (flags & FS_SYNC_FL)\n\t\txflags |= XFS_XFLAG_SYNC;\n\telse\n\t\txflags &= ~XFS_XFLAG_SYNC;\n\tif (flags & FS_NOATIME_FL)\n\t\txflags |= XFS_XFLAG_NOATIME;\n\telse\n\t\txflags &= ~XFS_XFLAG_NOATIME;\n\tif (flags & FS_NODUMP_FL)\n\t\txflags |= XFS_XFLAG_NODUMP;\n\telse\n\t\txflags &= ~XFS_XFLAG_NODUMP;\n\n\treturn xflags;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC unsigned int\nxfs_merge_ioc_xflags(\n\tunsigned int\tflags,\n\tunsigned int\tstart)\n{\n\tunsigned int\txflags = start;\n\n\tif (flags & FS_IMMUTABLE_FL)\n\t\txflags |= XFS_XFLAG_IMMUTABLE;\n\telse\n\t\txflags &= ~XFS_XFLAG_IMMUTABLE;\n\tif (flags & FS_APPEND_FL)\n\t\txflags |= XFS_XFLAG_APPEND;\n\telse\n\t\txflags &= ~XFS_XFLAG_APPEND;\n\tif (flags & FS_SYNC_FL)\n\t\txflags |= XFS_XFLAG_SYNC;\n\telse\n\t\txflags &= ~XFS_XFLAG_SYNC;\n\tif (flags & FS_NOATIME_FL)\n\t\txflags |= XFS_XFLAG_NOATIME;\n\telse\n\t\txflags &= ~XFS_XFLAG_NOATIME;\n\tif (flags & FS_NODUMP_FL)\n\t\txflags |= XFS_XFLAG_NODUMP;\n\telse\n\t\txflags &= ~XFS_XFLAG_NODUMP;\n\n\treturn xflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ip2xflags",
          "args": [
            "ip"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ip2xflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "546-554",
          "snippet": "uint\nxfs_ip2xflags(\n\txfs_inode_t\t\t*ip)\n{\n\txfs_icdinode_t\t\t*dic = &ip->i_d;\n\n\treturn _xfs_dic2xflags(dic->di_flags) |\n\t\t\t\t(XFS_IFORK_Q(ip) ? XFS_XFLAG_HASATTR : 0);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nuint\nxfs_ip2xflags(\n\txfs_inode_t\t\t*ip)\n{\n\txfs_icdinode_t\t\t*dic = &ip->i_d;\n\n\treturn _xfs_dic2xflags(dic->di_flags) |\n\t\t\t\t(XFS_IFORK_Q(ip) ? XFS_XFLAG_HASATTR : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&flags",
            "arg",
            "sizeof(flags)"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_ioc_setxflags(\n\tstruct xfs_inode\t*ip,\n\tstruct file\t\t*filp,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct xfs_trans\t*tp;\n\tstruct fsxattr\t\tfa;\n\tunsigned int\t\tflags;\n\tint\t\t\terror;\n\n\tif (copy_from_user(&flags, arg, sizeof(flags)))\n\t\treturn -EFAULT;\n\n\tif (flags & ~(FS_IMMUTABLE_FL | FS_APPEND_FL | \\\n\t\t      FS_NOATIME_FL | FS_NODUMP_FL | \\\n\t\t      FS_SYNC_FL))\n\t\treturn -EOPNOTSUPP;\n\n\tfa.fsx_xflags = xfs_merge_ioc_xflags(flags, xfs_ip2xflags(ip));\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\n\ttp = xfs_ioctl_setattr_get_trans(ip);\n\tif (IS_ERR(tp)) {\n\t\terror = PTR_ERR(tp);\n\t\tgoto out_drop_write;\n\t}\n\n\terror = xfs_ioctl_setattr_xflags(tp, ip, &fa);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto out_drop_write;\n\t}\n\n\terror = xfs_trans_commit(tp, 0);\nout_drop_write:\n\tmnt_drop_write_file(filp);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_ioc_getxflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "1292-1303",
    "snippet": "STATIC int\nxfs_ioc_getxflags(\n\txfs_inode_t\t\t*ip,\n\tvoid\t\t\t__user *arg)\n{\n\tunsigned int\t\tflags;\n\n\tflags = xfs_di2lxflags(ip->i_d.di_flags);\n\tif (copy_to_user(arg, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&flags",
            "sizeof(flags)"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_di2lxflags",
          "args": [
            "ip->i_d.di_flags"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_di2lxflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "871-888",
          "snippet": "STATIC unsigned int\nxfs_di2lxflags(\n\t__uint16_t\tdi_flags)\n{\n\tunsigned int\tflags = 0;\n\n\tif (di_flags & XFS_DIFLAG_IMMUTABLE)\n\t\tflags |= FS_IMMUTABLE_FL;\n\tif (di_flags & XFS_DIFLAG_APPEND)\n\t\tflags |= FS_APPEND_FL;\n\tif (di_flags & XFS_DIFLAG_SYNC)\n\t\tflags |= FS_SYNC_FL;\n\tif (di_flags & XFS_DIFLAG_NOATIME)\n\t\tflags |= FS_NOATIME_FL;\n\tif (di_flags & XFS_DIFLAG_NODUMP)\n\t\tflags |= FS_NODUMP_FL;\n\treturn flags;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC unsigned int\nxfs_di2lxflags(\n\t__uint16_t\tdi_flags)\n{\n\tunsigned int\tflags = 0;\n\n\tif (di_flags & XFS_DIFLAG_IMMUTABLE)\n\t\tflags |= FS_IMMUTABLE_FL;\n\tif (di_flags & XFS_DIFLAG_APPEND)\n\t\tflags |= FS_APPEND_FL;\n\tif (di_flags & XFS_DIFLAG_SYNC)\n\t\tflags |= FS_SYNC_FL;\n\tif (di_flags & XFS_DIFLAG_NOATIME)\n\t\tflags |= FS_NOATIME_FL;\n\tif (di_flags & XFS_DIFLAG_NODUMP)\n\t\tflags |= FS_NODUMP_FL;\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_ioc_getxflags(\n\txfs_inode_t\t\t*ip,\n\tvoid\t\t\t__user *arg)\n{\n\tunsigned int\t\tflags;\n\n\tflags = xfs_di2lxflags(ip->i_d.di_flags);\n\tif (copy_to_user(arg, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ioc_fssetxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "1272-1290",
    "snippet": "STATIC int\nxfs_ioc_fssetxattr(\n\txfs_inode_t\t\t*ip,\n\tstruct file\t\t*filp,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct fsxattr\t\tfa;\n\tint error;\n\n\tif (copy_from_user(&fa, arg, sizeof(fa)))\n\t\treturn -EFAULT;\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\terror = xfs_ioctl_setattr(ip, &fa);\n\tmnt_drop_write_file(filp);\n\treturn error;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ioctl_setattr",
          "args": [
            "ip",
            "&fa"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioctl_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "1164-1270",
          "snippet": "STATIC int\nxfs_ioctl_setattr(\n\txfs_inode_t\t\t*ip,\n\tstruct fsxattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tstruct xfs_dquot\t*olddquot = NULL;\n\tint\t\t\tcode;\n\n\ttrace_xfs_ioctl_setattr(ip);\n\n\tcode = xfs_ioctl_setattr_check_projid(ip, fa);\n\tif (code)\n\t\treturn code;\n\n\t/*\n\t * If disk quotas is on, we make sure that the dquots do exist on disk,\n\t * before we start any other transactions. Trying to do this later\n\t * is messy. We don't care to take a readlock to look at the ids\n\t * in inode here, because we can't hold it across the trans_reserve.\n\t * If the IDs do change before we take the ilock, we're covered\n\t * because the i_*dquot fields will get updated anyway.\n\t */\n\tif (XFS_IS_QUOTA_ON(mp)) {\n\t\tcode = xfs_qm_vop_dqalloc(ip, ip->i_d.di_uid,\n\t\t\t\t\t ip->i_d.di_gid, fa->fsx_projid,\n\t\t\t\t\t XFS_QMOPT_PQUOTA, &udqp, NULL, &pdqp);\n\t\tif (code)\n\t\t\treturn code;\n\t}\n\n\ttp = xfs_ioctl_setattr_get_trans(ip);\n\tif (IS_ERR(tp)) {\n\t\tcode = PTR_ERR(tp);\n\t\tgoto error_free_dquots;\n\t}\n\n\n\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp) &&\n\t    xfs_get_projid(ip) != fa->fsx_projid) {\n\t\tcode = xfs_qm_vop_chown_reserve(tp, ip, udqp, NULL, pdqp,\n\t\t\t\tcapable(CAP_FOWNER) ?  XFS_QMOPT_FORCE_RES : 0);\n\t\tif (code)\t/* out of quota */\n\t\t\tgoto error_trans_cancel;\n\t}\n\n\tcode = xfs_ioctl_setattr_check_extsize(ip, fa);\n\tif (code)\n\t\tgoto error_trans_cancel;\n\n\tcode = xfs_ioctl_setattr_xflags(tp, ip, fa);\n\tif (code)\n\t\tgoto error_trans_cancel;\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.  CAP_FSETID\n\t * overrides the following restrictions:\n\t *\n\t * The set-user-ID and set-group-ID bits of a file will be cleared upon\n\t * successful return from chown()\n\t */\n\n\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n\t    !capable_wrt_inode_uidgid(VFS_I(ip), CAP_FSETID))\n\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n\n\t/* Change the ownerships and register project quota modifications */\n\tif (xfs_get_projid(ip) != fa->fsx_projid) {\n\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp)) {\n\t\t\tolddquot = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t&ip->i_pdquot, pdqp);\n\t\t}\n\t\tASSERT(ip->i_d.di_version > 1);\n\t\txfs_set_projid(ip, fa->fsx_projid);\n\t}\n\n\t/*\n\t * Only set the extent size hint if we've already determined that the\n\t * extent size hint should be set on the inode. If no extent size flags\n\t * are set on the inode then unconditionally clear the extent size hint.\n\t */\n\tif (ip->i_d.di_flags & (XFS_DIFLAG_EXTSIZE | XFS_DIFLAG_EXTSZINHERIT))\n\t\tip->i_d.di_extsize = fa->fsx_extsize >> mp->m_sb.sb_blocklog;\n\telse\n\t\tip->i_d.di_extsize = 0;\n\n\tcode = xfs_trans_commit(tp, 0);\n\n\t/*\n\t * Release any dquot(s) the inode had kept before chown.\n\t */\n\txfs_qm_dqrele(olddquot);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(pdqp);\n\n\treturn code;\n\nerror_trans_cancel:\n\txfs_trans_cancel(tp, 0);\nerror_free_dquots:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(pdqp);\n\treturn code;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_ioctl_setattr(\n\txfs_inode_t\t\t*ip,\n\tstruct fsxattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tstruct xfs_dquot\t*olddquot = NULL;\n\tint\t\t\tcode;\n\n\ttrace_xfs_ioctl_setattr(ip);\n\n\tcode = xfs_ioctl_setattr_check_projid(ip, fa);\n\tif (code)\n\t\treturn code;\n\n\t/*\n\t * If disk quotas is on, we make sure that the dquots do exist on disk,\n\t * before we start any other transactions. Trying to do this later\n\t * is messy. We don't care to take a readlock to look at the ids\n\t * in inode here, because we can't hold it across the trans_reserve.\n\t * If the IDs do change before we take the ilock, we're covered\n\t * because the i_*dquot fields will get updated anyway.\n\t */\n\tif (XFS_IS_QUOTA_ON(mp)) {\n\t\tcode = xfs_qm_vop_dqalloc(ip, ip->i_d.di_uid,\n\t\t\t\t\t ip->i_d.di_gid, fa->fsx_projid,\n\t\t\t\t\t XFS_QMOPT_PQUOTA, &udqp, NULL, &pdqp);\n\t\tif (code)\n\t\t\treturn code;\n\t}\n\n\ttp = xfs_ioctl_setattr_get_trans(ip);\n\tif (IS_ERR(tp)) {\n\t\tcode = PTR_ERR(tp);\n\t\tgoto error_free_dquots;\n\t}\n\n\n\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp) &&\n\t    xfs_get_projid(ip) != fa->fsx_projid) {\n\t\tcode = xfs_qm_vop_chown_reserve(tp, ip, udqp, NULL, pdqp,\n\t\t\t\tcapable(CAP_FOWNER) ?  XFS_QMOPT_FORCE_RES : 0);\n\t\tif (code)\t/* out of quota */\n\t\t\tgoto error_trans_cancel;\n\t}\n\n\tcode = xfs_ioctl_setattr_check_extsize(ip, fa);\n\tif (code)\n\t\tgoto error_trans_cancel;\n\n\tcode = xfs_ioctl_setattr_xflags(tp, ip, fa);\n\tif (code)\n\t\tgoto error_trans_cancel;\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.  CAP_FSETID\n\t * overrides the following restrictions:\n\t *\n\t * The set-user-ID and set-group-ID bits of a file will be cleared upon\n\t * successful return from chown()\n\t */\n\n\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n\t    !capable_wrt_inode_uidgid(VFS_I(ip), CAP_FSETID))\n\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n\n\t/* Change the ownerships and register project quota modifications */\n\tif (xfs_get_projid(ip) != fa->fsx_projid) {\n\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp)) {\n\t\t\tolddquot = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t&ip->i_pdquot, pdqp);\n\t\t}\n\t\tASSERT(ip->i_d.di_version > 1);\n\t\txfs_set_projid(ip, fa->fsx_projid);\n\t}\n\n\t/*\n\t * Only set the extent size hint if we've already determined that the\n\t * extent size hint should be set on the inode. If no extent size flags\n\t * are set on the inode then unconditionally clear the extent size hint.\n\t */\n\tif (ip->i_d.di_flags & (XFS_DIFLAG_EXTSIZE | XFS_DIFLAG_EXTSZINHERIT))\n\t\tip->i_d.di_extsize = fa->fsx_extsize >> mp->m_sb.sb_blocklog;\n\telse\n\t\tip->i_d.di_extsize = 0;\n\n\tcode = xfs_trans_commit(tp, 0);\n\n\t/*\n\t * Release any dquot(s) the inode had kept before chown.\n\t */\n\txfs_qm_dqrele(olddquot);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(pdqp);\n\n\treturn code;\n\nerror_trans_cancel:\n\txfs_trans_cancel(tp, 0);\nerror_free_dquots:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(pdqp);\n\treturn code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&fa",
            "arg",
            "sizeof(fa)"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_ioc_fssetxattr(\n\txfs_inode_t\t\t*ip,\n\tstruct file\t\t*filp,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct fsxattr\t\tfa;\n\tint error;\n\n\tif (copy_from_user(&fa, arg, sizeof(fa)))\n\t\treturn -EFAULT;\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\terror = xfs_ioctl_setattr(ip, &fa);\n\tmnt_drop_write_file(filp);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_ioctl_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "1164-1270",
    "snippet": "STATIC int\nxfs_ioctl_setattr(\n\txfs_inode_t\t\t*ip,\n\tstruct fsxattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tstruct xfs_dquot\t*olddquot = NULL;\n\tint\t\t\tcode;\n\n\ttrace_xfs_ioctl_setattr(ip);\n\n\tcode = xfs_ioctl_setattr_check_projid(ip, fa);\n\tif (code)\n\t\treturn code;\n\n\t/*\n\t * If disk quotas is on, we make sure that the dquots do exist on disk,\n\t * before we start any other transactions. Trying to do this later\n\t * is messy. We don't care to take a readlock to look at the ids\n\t * in inode here, because we can't hold it across the trans_reserve.\n\t * If the IDs do change before we take the ilock, we're covered\n\t * because the i_*dquot fields will get updated anyway.\n\t */\n\tif (XFS_IS_QUOTA_ON(mp)) {\n\t\tcode = xfs_qm_vop_dqalloc(ip, ip->i_d.di_uid,\n\t\t\t\t\t ip->i_d.di_gid, fa->fsx_projid,\n\t\t\t\t\t XFS_QMOPT_PQUOTA, &udqp, NULL, &pdqp);\n\t\tif (code)\n\t\t\treturn code;\n\t}\n\n\ttp = xfs_ioctl_setattr_get_trans(ip);\n\tif (IS_ERR(tp)) {\n\t\tcode = PTR_ERR(tp);\n\t\tgoto error_free_dquots;\n\t}\n\n\n\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp) &&\n\t    xfs_get_projid(ip) != fa->fsx_projid) {\n\t\tcode = xfs_qm_vop_chown_reserve(tp, ip, udqp, NULL, pdqp,\n\t\t\t\tcapable(CAP_FOWNER) ?  XFS_QMOPT_FORCE_RES : 0);\n\t\tif (code)\t/* out of quota */\n\t\t\tgoto error_trans_cancel;\n\t}\n\n\tcode = xfs_ioctl_setattr_check_extsize(ip, fa);\n\tif (code)\n\t\tgoto error_trans_cancel;\n\n\tcode = xfs_ioctl_setattr_xflags(tp, ip, fa);\n\tif (code)\n\t\tgoto error_trans_cancel;\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.  CAP_FSETID\n\t * overrides the following restrictions:\n\t *\n\t * The set-user-ID and set-group-ID bits of a file will be cleared upon\n\t * successful return from chown()\n\t */\n\n\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n\t    !capable_wrt_inode_uidgid(VFS_I(ip), CAP_FSETID))\n\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n\n\t/* Change the ownerships and register project quota modifications */\n\tif (xfs_get_projid(ip) != fa->fsx_projid) {\n\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp)) {\n\t\t\tolddquot = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t&ip->i_pdquot, pdqp);\n\t\t}\n\t\tASSERT(ip->i_d.di_version > 1);\n\t\txfs_set_projid(ip, fa->fsx_projid);\n\t}\n\n\t/*\n\t * Only set the extent size hint if we've already determined that the\n\t * extent size hint should be set on the inode. If no extent size flags\n\t * are set on the inode then unconditionally clear the extent size hint.\n\t */\n\tif (ip->i_d.di_flags & (XFS_DIFLAG_EXTSIZE | XFS_DIFLAG_EXTSZINHERIT))\n\t\tip->i_d.di_extsize = fa->fsx_extsize >> mp->m_sb.sb_blocklog;\n\telse\n\t\tip->i_d.di_extsize = 0;\n\n\tcode = xfs_trans_commit(tp, 0);\n\n\t/*\n\t * Release any dquot(s) the inode had kept before chown.\n\t */\n\txfs_qm_dqrele(olddquot);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(pdqp);\n\n\treturn code;\n\nerror_trans_cancel:\n\txfs_trans_cancel(tp, 0);\nerror_free_dquots:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(pdqp);\n\treturn code;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_dqrele",
          "args": [
            "pdqp"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqrele",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "862-879",
          "snippet": "void\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "0"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "0"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_set_projid",
          "args": [
            "ip",
            "fa->fsx_projid"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_set_projid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "187-193",
          "snippet": "static inline void\nxfs_set_projid(struct xfs_inode *ip,\n\t\tprid_t projid)\n{\n\tip->i_d.di_projid_hi = (__uint16_t) (projid >> 16);\n\tip->i_d.di_projid_lo = (__uint16_t) (projid & 0xffff);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline void\nxfs_set_projid(struct xfs_inode *ip,\n\t\tprid_t projid)\n{\n\tip->i_d.di_projid_hi = (__uint16_t) (projid >> 16);\n\tip->i_d.di_projid_lo = (__uint16_t) (projid & 0xffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_version > 1"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_vop_chown",
          "args": [
            "tp",
            "ip",
            "&ip->i_pdquot",
            "pdqp"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_vop_chown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "1738-1772",
          "snippet": "xfs_dquot_t *\nxfs_qm_vop_chown(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\txfs_dquot_t\t**IO_olddq,\n\txfs_dquot_t\t*newdq)\n{\n\txfs_dquot_t\t*prevdq;\n\tuint\t\tbfield = XFS_IS_REALTIME_INODE(ip) ?\n\t\t\t\t XFS_TRANS_DQ_RTBCOUNT : XFS_TRANS_DQ_BCOUNT;\n\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(XFS_IS_QUOTA_RUNNING(ip->i_mount));\n\n\t/* old dquot */\n\tprevdq = *IO_olddq;\n\tASSERT(prevdq);\n\tASSERT(prevdq != newdq);\n\n\txfs_trans_mod_dquot(tp, prevdq, bfield, -(ip->i_d.di_nblocks));\n\txfs_trans_mod_dquot(tp, prevdq, XFS_TRANS_DQ_ICOUNT, -1);\n\n\t/* the sparkling new dquot */\n\txfs_trans_mod_dquot(tp, newdq, bfield, ip->i_d.di_nblocks);\n\txfs_trans_mod_dquot(tp, newdq, XFS_TRANS_DQ_ICOUNT, 1);\n\n\t/*\n\t * Take an extra reference, because the inode is going to keep\n\t * this dquot pointer even after the trans_commit.\n\t */\n\t*IO_olddq = xfs_qm_dqhold(newdq);\n\n\treturn prevdq;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dquot_t *\nxfs_qm_vop_chown(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\txfs_dquot_t\t**IO_olddq,\n\txfs_dquot_t\t*newdq)\n{\n\txfs_dquot_t\t*prevdq;\n\tuint\t\tbfield = XFS_IS_REALTIME_INODE(ip) ?\n\t\t\t\t XFS_TRANS_DQ_RTBCOUNT : XFS_TRANS_DQ_BCOUNT;\n\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(XFS_IS_QUOTA_RUNNING(ip->i_mount));\n\n\t/* old dquot */\n\tprevdq = *IO_olddq;\n\tASSERT(prevdq);\n\tASSERT(prevdq != newdq);\n\n\txfs_trans_mod_dquot(tp, prevdq, bfield, -(ip->i_d.di_nblocks));\n\txfs_trans_mod_dquot(tp, prevdq, XFS_TRANS_DQ_ICOUNT, -1);\n\n\t/* the sparkling new dquot */\n\txfs_trans_mod_dquot(tp, newdq, bfield, ip->i_d.di_nblocks);\n\txfs_trans_mod_dquot(tp, newdq, XFS_TRANS_DQ_ICOUNT, 1);\n\n\t/*\n\t * Take an extra reference, because the inode is going to keep\n\t * this dquot pointer even after the trans_commit.\n\t */\n\t*IO_olddq = xfs_qm_dqhold(newdq);\n\n\treturn prevdq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_get_projid",
          "args": [
            "ip"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_projid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "181-185",
          "snippet": "static inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable_wrt_inode_uidgid",
          "args": [
            "VFS_I(ip)",
            "CAP_FSETID"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ioctl_setattr_xflags",
          "args": [
            "tp",
            "ip",
            "fa"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioctl_setattr_xflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "995-1030",
          "snippet": "static int\nxfs_ioctl_setattr_xflags(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct fsxattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\t/* Can't change realtime flag if any extents are allocated. */\n\tif ((ip->i_d.di_nextents || ip->i_delayed_blks) &&\n\t    XFS_IS_REALTIME_INODE(ip) != (fa->fsx_xflags & XFS_XFLAG_REALTIME))\n\t\treturn -EINVAL;\n\n\t/* If realtime flag is set then must have realtime device */\n\tif (fa->fsx_xflags & XFS_XFLAG_REALTIME) {\n\t\tif (mp->m_sb.sb_rblocks == 0 || mp->m_sb.sb_rextsize == 0 ||\n\t\t    (ip->i_d.di_extsize % mp->m_sb.sb_rextsize))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Can't modify an immutable/append-only file unless\n\t * we have appropriate permission.\n\t */\n\tif (((ip->i_d.di_flags & (XFS_DIFLAG_IMMUTABLE | XFS_DIFLAG_APPEND)) ||\n\t     (fa->fsx_xflags & (XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND))) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\treturn -EPERM;\n\n\txfs_set_diflags(ip, fa->fsx_xflags);\n\txfs_diflags_to_linux(ip);\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\tXFS_STATS_INC(xs_ig_attrchg);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic int\nxfs_ioctl_setattr_xflags(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct fsxattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\t/* Can't change realtime flag if any extents are allocated. */\n\tif ((ip->i_d.di_nextents || ip->i_delayed_blks) &&\n\t    XFS_IS_REALTIME_INODE(ip) != (fa->fsx_xflags & XFS_XFLAG_REALTIME))\n\t\treturn -EINVAL;\n\n\t/* If realtime flag is set then must have realtime device */\n\tif (fa->fsx_xflags & XFS_XFLAG_REALTIME) {\n\t\tif (mp->m_sb.sb_rblocks == 0 || mp->m_sb.sb_rextsize == 0 ||\n\t\t    (ip->i_d.di_extsize % mp->m_sb.sb_rextsize))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Can't modify an immutable/append-only file unless\n\t * we have appropriate permission.\n\t */\n\tif (((ip->i_d.di_flags & (XFS_DIFLAG_IMMUTABLE | XFS_DIFLAG_APPEND)) ||\n\t     (fa->fsx_xflags & (XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND))) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\treturn -EPERM;\n\n\txfs_set_diflags(ip, fa->fsx_xflags);\n\txfs_diflags_to_linux(ip);\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\tXFS_STATS_INC(xs_ig_attrchg);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ioctl_setattr_check_extsize",
          "args": [
            "ip",
            "fa"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioctl_setattr_check_extsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "1094-1135",
          "snippet": "static int\nxfs_ioctl_setattr_check_extsize(\n\tstruct xfs_inode\t*ip,\n\tstruct fsxattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif ((fa->fsx_xflags & XFS_XFLAG_EXTSIZE) && !S_ISREG(ip->i_d.di_mode))\n\t\treturn -EINVAL;\n\n\tif ((fa->fsx_xflags & XFS_XFLAG_EXTSZINHERIT) &&\n\t    !S_ISDIR(ip->i_d.di_mode))\n\t\treturn -EINVAL;\n\n\tif (S_ISREG(ip->i_d.di_mode) && ip->i_d.di_nextents &&\n\t    ((ip->i_d.di_extsize << mp->m_sb.sb_blocklog) != fa->fsx_extsize))\n\t\treturn -EINVAL;\n\n\tif (fa->fsx_extsize != 0) {\n\t\txfs_extlen_t    size;\n\t\txfs_fsblock_t   extsize_fsb;\n\n\t\textsize_fsb = XFS_B_TO_FSB(mp, fa->fsx_extsize);\n\t\tif (extsize_fsb > MAXEXTLEN)\n\t\t\treturn -EINVAL;\n\n\t\tif (XFS_IS_REALTIME_INODE(ip) ||\n\t\t    (fa->fsx_xflags & XFS_XFLAG_REALTIME)) {\n\t\t\tsize = mp->m_sb.sb_rextsize << mp->m_sb.sb_blocklog;\n\t\t} else {\n\t\t\tsize = mp->m_sb.sb_blocksize;\n\t\t\tif (extsize_fsb > mp->m_sb.sb_agblocks / 2)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (fa->fsx_extsize % size)\n\t\t\treturn -EINVAL;\n\t} else\n\t\tfa->fsx_xflags &= ~(XFS_XFLAG_EXTSIZE | XFS_XFLAG_EXTSZINHERIT);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic int\nxfs_ioctl_setattr_check_extsize(\n\tstruct xfs_inode\t*ip,\n\tstruct fsxattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif ((fa->fsx_xflags & XFS_XFLAG_EXTSIZE) && !S_ISREG(ip->i_d.di_mode))\n\t\treturn -EINVAL;\n\n\tif ((fa->fsx_xflags & XFS_XFLAG_EXTSZINHERIT) &&\n\t    !S_ISDIR(ip->i_d.di_mode))\n\t\treturn -EINVAL;\n\n\tif (S_ISREG(ip->i_d.di_mode) && ip->i_d.di_nextents &&\n\t    ((ip->i_d.di_extsize << mp->m_sb.sb_blocklog) != fa->fsx_extsize))\n\t\treturn -EINVAL;\n\n\tif (fa->fsx_extsize != 0) {\n\t\txfs_extlen_t    size;\n\t\txfs_fsblock_t   extsize_fsb;\n\n\t\textsize_fsb = XFS_B_TO_FSB(mp, fa->fsx_extsize);\n\t\tif (extsize_fsb > MAXEXTLEN)\n\t\t\treturn -EINVAL;\n\n\t\tif (XFS_IS_REALTIME_INODE(ip) ||\n\t\t    (fa->fsx_xflags & XFS_XFLAG_REALTIME)) {\n\t\t\tsize = mp->m_sb.sb_rextsize << mp->m_sb.sb_blocklog;\n\t\t} else {\n\t\t\tsize = mp->m_sb.sb_blocksize;\n\t\t\tif (extsize_fsb > mp->m_sb.sb_agblocks / 2)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (fa->fsx_extsize % size)\n\t\t\treturn -EINVAL;\n\t} else\n\t\tfa->fsx_xflags &= ~(XFS_XFLAG_EXTSIZE | XFS_XFLAG_EXTSZINHERIT);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_vop_chown_reserve",
          "args": [
            "tp",
            "ip",
            "udqp",
            "NULL",
            "pdqp",
            "capable(CAP_FOWNER) ?  XFS_QMOPT_FORCE_RES : 0"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_vop_chown_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "1777-1867",
          "snippet": "int\nxfs_qm_vop_chown_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\tdelblks, blkflags, prjflags = 0;\n\tstruct xfs_dquot\t*udq_unres = NULL;\n\tstruct xfs_dquot\t*gdq_unres = NULL;\n\tstruct xfs_dquot\t*pdq_unres = NULL;\n\tstruct xfs_dquot\t*udq_delblks = NULL;\n\tstruct xfs_dquot\t*gdq_delblks = NULL;\n\tstruct xfs_dquot\t*pdq_delblks = NULL;\n\tint\t\t\terror;\n\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\tdelblks = ip->i_delayed_blks;\n\tblkflags = XFS_IS_REALTIME_INODE(ip) ?\n\t\t\tXFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS;\n\n\tif (XFS_IS_UQUOTA_ON(mp) && udqp &&\n\t    ip->i_d.di_uid != be32_to_cpu(udqp->q_core.d_id)) {\n\t\tudq_delblks = udqp;\n\t\t/*\n\t\t * If there are delayed allocation blocks, then we have to\n\t\t * unreserve those from the old dquot, and add them to the\n\t\t * new dquot.\n\t\t */\n\t\tif (delblks) {\n\t\t\tASSERT(ip->i_udquot);\n\t\t\tudq_unres = ip->i_udquot;\n\t\t}\n\t}\n\tif (XFS_IS_GQUOTA_ON(ip->i_mount) && gdqp &&\n\t    ip->i_d.di_gid != be32_to_cpu(gdqp->q_core.d_id)) {\n\t\tgdq_delblks = gdqp;\n\t\tif (delblks) {\n\t\t\tASSERT(ip->i_gdquot);\n\t\t\tgdq_unres = ip->i_gdquot;\n\t\t}\n\t}\n\n\tif (XFS_IS_PQUOTA_ON(ip->i_mount) && pdqp &&\n\t    xfs_get_projid(ip) != be32_to_cpu(pdqp->q_core.d_id)) {\n\t\tprjflags = XFS_QMOPT_ENOSPC;\n\t\tpdq_delblks = pdqp;\n\t\tif (delblks) {\n\t\t\tASSERT(ip->i_pdquot);\n\t\t\tpdq_unres = ip->i_pdquot;\n\t\t}\n\t}\n\n\terror = xfs_trans_reserve_quota_bydquots(tp, ip->i_mount,\n\t\t\t\tudq_delblks, gdq_delblks, pdq_delblks,\n\t\t\t\tip->i_d.di_nblocks, 1,\n\t\t\t\tflags | blkflags | prjflags);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Do the delayed blks reservations/unreservations now. Since, these\n\t * are done without the help of a transaction, if a reservation fails\n\t * its previous reservations won't be automatically undone by trans\n\t * code. So, we have to do it manually here.\n\t */\n\tif (delblks) {\n\t\t/*\n\t\t * Do the reservations first. Unreservation can't fail.\n\t\t */\n\t\tASSERT(udq_delblks || gdq_delblks || pdq_delblks);\n\t\tASSERT(udq_unres || gdq_unres || pdq_unres);\n\t\terror = xfs_trans_reserve_quota_bydquots(NULL, ip->i_mount,\n\t\t\t    udq_delblks, gdq_delblks, pdq_delblks,\n\t\t\t    (xfs_qcnt_t)delblks, 0,\n\t\t\t    flags | blkflags | prjflags);\n\t\tif (error)\n\t\t\treturn error;\n\t\txfs_trans_reserve_quota_bydquots(NULL, ip->i_mount,\n\t\t\t\tudq_unres, gdq_unres, pdq_unres,\n\t\t\t\t-((xfs_qcnt_t)delblks), 0, blkflags);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_vop_chown_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\tdelblks, blkflags, prjflags = 0;\n\tstruct xfs_dquot\t*udq_unres = NULL;\n\tstruct xfs_dquot\t*gdq_unres = NULL;\n\tstruct xfs_dquot\t*pdq_unres = NULL;\n\tstruct xfs_dquot\t*udq_delblks = NULL;\n\tstruct xfs_dquot\t*gdq_delblks = NULL;\n\tstruct xfs_dquot\t*pdq_delblks = NULL;\n\tint\t\t\terror;\n\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\tdelblks = ip->i_delayed_blks;\n\tblkflags = XFS_IS_REALTIME_INODE(ip) ?\n\t\t\tXFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS;\n\n\tif (XFS_IS_UQUOTA_ON(mp) && udqp &&\n\t    ip->i_d.di_uid != be32_to_cpu(udqp->q_core.d_id)) {\n\t\tudq_delblks = udqp;\n\t\t/*\n\t\t * If there are delayed allocation blocks, then we have to\n\t\t * unreserve those from the old dquot, and add them to the\n\t\t * new dquot.\n\t\t */\n\t\tif (delblks) {\n\t\t\tASSERT(ip->i_udquot);\n\t\t\tudq_unres = ip->i_udquot;\n\t\t}\n\t}\n\tif (XFS_IS_GQUOTA_ON(ip->i_mount) && gdqp &&\n\t    ip->i_d.di_gid != be32_to_cpu(gdqp->q_core.d_id)) {\n\t\tgdq_delblks = gdqp;\n\t\tif (delblks) {\n\t\t\tASSERT(ip->i_gdquot);\n\t\t\tgdq_unres = ip->i_gdquot;\n\t\t}\n\t}\n\n\tif (XFS_IS_PQUOTA_ON(ip->i_mount) && pdqp &&\n\t    xfs_get_projid(ip) != be32_to_cpu(pdqp->q_core.d_id)) {\n\t\tprjflags = XFS_QMOPT_ENOSPC;\n\t\tpdq_delblks = pdqp;\n\t\tif (delblks) {\n\t\t\tASSERT(ip->i_pdquot);\n\t\t\tpdq_unres = ip->i_pdquot;\n\t\t}\n\t}\n\n\terror = xfs_trans_reserve_quota_bydquots(tp, ip->i_mount,\n\t\t\t\tudq_delblks, gdq_delblks, pdq_delblks,\n\t\t\t\tip->i_d.di_nblocks, 1,\n\t\t\t\tflags | blkflags | prjflags);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Do the delayed blks reservations/unreservations now. Since, these\n\t * are done without the help of a transaction, if a reservation fails\n\t * its previous reservations won't be automatically undone by trans\n\t * code. So, we have to do it manually here.\n\t */\n\tif (delblks) {\n\t\t/*\n\t\t * Do the reservations first. Unreservation can't fail.\n\t\t */\n\t\tASSERT(udq_delblks || gdq_delblks || pdq_delblks);\n\t\tASSERT(udq_unres || gdq_unres || pdq_unres);\n\t\terror = xfs_trans_reserve_quota_bydquots(NULL, ip->i_mount,\n\t\t\t    udq_delblks, gdq_delblks, pdq_delblks,\n\t\t\t    (xfs_qcnt_t)delblks, 0,\n\t\t\t    flags | blkflags | prjflags);\n\t\tif (error)\n\t\t\treturn error;\n\t\txfs_trans_reserve_quota_bydquots(NULL, ip->i_mount,\n\t\t\t\tudq_unres, gdq_unres, pdq_unres,\n\t\t\t\t-((xfs_qcnt_t)delblks), 0, blkflags);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_FOWNER"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tp"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tp"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ioctl_setattr_get_trans",
          "args": [
            "ip"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioctl_setattr_get_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "1038-1078",
          "snippet": "static struct xfs_trans *\nxfs_ioctl_setattr_get_trans(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn ERR_PTR(-EIO);\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error)\n\t\tgoto out_cancel;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * CAP_FOWNER overrides the following restrictions:\n\t *\n\t * The user ID of the calling process must be equal to the file owner\n\t * ID, except in cases where the CAP_FSETID capability is applicable.\n\t */\n\tif (!inode_owner_or_capable(VFS_I(ip))) {\n\t\terror = -EPERM;\n\t\tgoto out_cancel;\n\t}\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\treturn tp;\n\nout_cancel:\n\txfs_trans_cancel(tp, 0);\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic struct xfs_trans *\nxfs_ioctl_setattr_get_trans(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn ERR_PTR(-EIO);\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error)\n\t\tgoto out_cancel;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * CAP_FOWNER overrides the following restrictions:\n\t *\n\t * The user ID of the calling process must be equal to the file owner\n\t * ID, except in cases where the CAP_FSETID capability is applicable.\n\t */\n\tif (!inode_owner_or_capable(VFS_I(ip))) {\n\t\terror = -EPERM;\n\t\tgoto out_cancel;\n\t}\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\treturn tp;\n\nout_cancel:\n\txfs_trans_cancel(tp, 0);\n\treturn ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_vop_dqalloc",
          "args": [
            "ip",
            "ip->i_d.di_uid",
            "ip->i_d.di_gid",
            "fa->fsx_projid",
            "XFS_QMOPT_PQUOTA",
            "&udqp",
            "NULL",
            "&pdqp"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_vop_dqalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_quota.h",
          "lines": "105-114",
          "snippet": "static inline int\nxfs_qm_vop_dqalloc(struct xfs_inode *ip, xfs_dqid_t uid, xfs_dqid_t gid,\n\t\tprid_t prid, uint flags, struct xfs_dquot **udqp,\n\t\tstruct xfs_dquot **gdqp, struct xfs_dquot **pdqp)\n{\n\t*udqp = NULL;\n\t*gdqp = NULL;\n\t*pdqp = NULL;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_quota_defs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_quota_defs.h\"\n\nstatic inline int\nxfs_qm_vop_dqalloc(struct xfs_inode *ip, xfs_dqid_t uid, xfs_dqid_t gid,\n\t\tprid_t prid, uint flags, struct xfs_dquot **udqp,\n\t\tstruct xfs_dquot **gdqp, struct xfs_dquot **pdqp)\n{\n\t*udqp = NULL;\n\t*gdqp = NULL;\n\t*pdqp = NULL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ioctl_setattr_check_projid",
          "args": [
            "ip",
            "fa"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioctl_setattr_check_projid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "1137-1162",
          "snippet": "static int\nxfs_ioctl_setattr_check_projid(\n\tstruct xfs_inode\t*ip,\n\tstruct fsxattr\t\t*fa)\n{\n\t/* Disallow 32bit project ids if projid32bit feature is not enabled. */\n\tif (fa->fsx_projid > (__uint16_t)-1 &&\n\t    !xfs_sb_version_hasprojid32bit(&ip->i_mount->m_sb))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Project Quota ID state is only allowed to change from within the init\n\t * namespace. Enforce that restriction only if we are trying to change\n\t * the quota ID state. Everything else is allowed in user namespaces.\n\t */\n\tif (current_user_ns() == &init_user_ns)\n\t\treturn 0;\n\n\tif (xfs_get_projid(ip) != fa->fsx_projid)\n\t\treturn -EINVAL;\n\tif ((fa->fsx_xflags & XFS_XFLAG_PROJINHERIT) !=\n\t    (ip->i_d.di_flags & XFS_DIFLAG_PROJINHERIT))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic int\nxfs_ioctl_setattr_check_projid(\n\tstruct xfs_inode\t*ip,\n\tstruct fsxattr\t\t*fa)\n{\n\t/* Disallow 32bit project ids if projid32bit feature is not enabled. */\n\tif (fa->fsx_projid > (__uint16_t)-1 &&\n\t    !xfs_sb_version_hasprojid32bit(&ip->i_mount->m_sb))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Project Quota ID state is only allowed to change from within the init\n\t * namespace. Enforce that restriction only if we are trying to change\n\t * the quota ID state. Everything else is allowed in user namespaces.\n\t */\n\tif (current_user_ns() == &init_user_ns)\n\t\treturn 0;\n\n\tif (xfs_get_projid(ip) != fa->fsx_projid)\n\t\treturn -EINVAL;\n\tif ((fa->fsx_xflags & XFS_XFLAG_PROJINHERIT) !=\n\t    (ip->i_d.di_flags & XFS_DIFLAG_PROJINHERIT))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_ioctl_setattr",
          "args": [
            "ip"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_ioctl_setattr(\n\txfs_inode_t\t\t*ip,\n\tstruct fsxattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tstruct xfs_dquot\t*olddquot = NULL;\n\tint\t\t\tcode;\n\n\ttrace_xfs_ioctl_setattr(ip);\n\n\tcode = xfs_ioctl_setattr_check_projid(ip, fa);\n\tif (code)\n\t\treturn code;\n\n\t/*\n\t * If disk quotas is on, we make sure that the dquots do exist on disk,\n\t * before we start any other transactions. Trying to do this later\n\t * is messy. We don't care to take a readlock to look at the ids\n\t * in inode here, because we can't hold it across the trans_reserve.\n\t * If the IDs do change before we take the ilock, we're covered\n\t * because the i_*dquot fields will get updated anyway.\n\t */\n\tif (XFS_IS_QUOTA_ON(mp)) {\n\t\tcode = xfs_qm_vop_dqalloc(ip, ip->i_d.di_uid,\n\t\t\t\t\t ip->i_d.di_gid, fa->fsx_projid,\n\t\t\t\t\t XFS_QMOPT_PQUOTA, &udqp, NULL, &pdqp);\n\t\tif (code)\n\t\t\treturn code;\n\t}\n\n\ttp = xfs_ioctl_setattr_get_trans(ip);\n\tif (IS_ERR(tp)) {\n\t\tcode = PTR_ERR(tp);\n\t\tgoto error_free_dquots;\n\t}\n\n\n\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp) &&\n\t    xfs_get_projid(ip) != fa->fsx_projid) {\n\t\tcode = xfs_qm_vop_chown_reserve(tp, ip, udqp, NULL, pdqp,\n\t\t\t\tcapable(CAP_FOWNER) ?  XFS_QMOPT_FORCE_RES : 0);\n\t\tif (code)\t/* out of quota */\n\t\t\tgoto error_trans_cancel;\n\t}\n\n\tcode = xfs_ioctl_setattr_check_extsize(ip, fa);\n\tif (code)\n\t\tgoto error_trans_cancel;\n\n\tcode = xfs_ioctl_setattr_xflags(tp, ip, fa);\n\tif (code)\n\t\tgoto error_trans_cancel;\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.  CAP_FSETID\n\t * overrides the following restrictions:\n\t *\n\t * The set-user-ID and set-group-ID bits of a file will be cleared upon\n\t * successful return from chown()\n\t */\n\n\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n\t    !capable_wrt_inode_uidgid(VFS_I(ip), CAP_FSETID))\n\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n\n\t/* Change the ownerships and register project quota modifications */\n\tif (xfs_get_projid(ip) != fa->fsx_projid) {\n\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp)) {\n\t\t\tolddquot = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t&ip->i_pdquot, pdqp);\n\t\t}\n\t\tASSERT(ip->i_d.di_version > 1);\n\t\txfs_set_projid(ip, fa->fsx_projid);\n\t}\n\n\t/*\n\t * Only set the extent size hint if we've already determined that the\n\t * extent size hint should be set on the inode. If no extent size flags\n\t * are set on the inode then unconditionally clear the extent size hint.\n\t */\n\tif (ip->i_d.di_flags & (XFS_DIFLAG_EXTSIZE | XFS_DIFLAG_EXTSZINHERIT))\n\t\tip->i_d.di_extsize = fa->fsx_extsize >> mp->m_sb.sb_blocklog;\n\telse\n\t\tip->i_d.di_extsize = 0;\n\n\tcode = xfs_trans_commit(tp, 0);\n\n\t/*\n\t * Release any dquot(s) the inode had kept before chown.\n\t */\n\txfs_qm_dqrele(olddquot);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(pdqp);\n\n\treturn code;\n\nerror_trans_cancel:\n\txfs_trans_cancel(tp, 0);\nerror_free_dquots:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(pdqp);\n\treturn code;\n}"
  },
  {
    "function_name": "xfs_ioctl_setattr_check_projid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "1137-1162",
    "snippet": "static int\nxfs_ioctl_setattr_check_projid(\n\tstruct xfs_inode\t*ip,\n\tstruct fsxattr\t\t*fa)\n{\n\t/* Disallow 32bit project ids if projid32bit feature is not enabled. */\n\tif (fa->fsx_projid > (__uint16_t)-1 &&\n\t    !xfs_sb_version_hasprojid32bit(&ip->i_mount->m_sb))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Project Quota ID state is only allowed to change from within the init\n\t * namespace. Enforce that restriction only if we are trying to change\n\t * the quota ID state. Everything else is allowed in user namespaces.\n\t */\n\tif (current_user_ns() == &init_user_ns)\n\t\treturn 0;\n\n\tif (xfs_get_projid(ip) != fa->fsx_projid)\n\t\treturn -EINVAL;\n\tif ((fa->fsx_xflags & XFS_XFLAG_PROJINHERIT) !=\n\t    (ip->i_d.di_flags & XFS_DIFLAG_PROJINHERIT))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_get_projid",
          "args": [
            "ip"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_projid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "181-185",
          "snippet": "static inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasprojid32bit",
          "args": [
            "&ip->i_mount->m_sb"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasprojid32bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "468-473",
          "snippet": "static inline bool xfs_sb_version_hasprojid32bit(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_PROJID32BIT));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION2_PROJID32BIT\t0x00000080\t/* 32 bit project id */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION2_PROJID32BIT\t0x00000080\t/* 32 bit project id */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_hasprojid32bit(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_PROJID32BIT));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic int\nxfs_ioctl_setattr_check_projid(\n\tstruct xfs_inode\t*ip,\n\tstruct fsxattr\t\t*fa)\n{\n\t/* Disallow 32bit project ids if projid32bit feature is not enabled. */\n\tif (fa->fsx_projid > (__uint16_t)-1 &&\n\t    !xfs_sb_version_hasprojid32bit(&ip->i_mount->m_sb))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Project Quota ID state is only allowed to change from within the init\n\t * namespace. Enforce that restriction only if we are trying to change\n\t * the quota ID state. Everything else is allowed in user namespaces.\n\t */\n\tif (current_user_ns() == &init_user_ns)\n\t\treturn 0;\n\n\tif (xfs_get_projid(ip) != fa->fsx_projid)\n\t\treturn -EINVAL;\n\tif ((fa->fsx_xflags & XFS_XFLAG_PROJINHERIT) !=\n\t    (ip->i_d.di_flags & XFS_DIFLAG_PROJINHERIT))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ioctl_setattr_check_extsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "1094-1135",
    "snippet": "static int\nxfs_ioctl_setattr_check_extsize(\n\tstruct xfs_inode\t*ip,\n\tstruct fsxattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif ((fa->fsx_xflags & XFS_XFLAG_EXTSIZE) && !S_ISREG(ip->i_d.di_mode))\n\t\treturn -EINVAL;\n\n\tif ((fa->fsx_xflags & XFS_XFLAG_EXTSZINHERIT) &&\n\t    !S_ISDIR(ip->i_d.di_mode))\n\t\treturn -EINVAL;\n\n\tif (S_ISREG(ip->i_d.di_mode) && ip->i_d.di_nextents &&\n\t    ((ip->i_d.di_extsize << mp->m_sb.sb_blocklog) != fa->fsx_extsize))\n\t\treturn -EINVAL;\n\n\tif (fa->fsx_extsize != 0) {\n\t\txfs_extlen_t    size;\n\t\txfs_fsblock_t   extsize_fsb;\n\n\t\textsize_fsb = XFS_B_TO_FSB(mp, fa->fsx_extsize);\n\t\tif (extsize_fsb > MAXEXTLEN)\n\t\t\treturn -EINVAL;\n\n\t\tif (XFS_IS_REALTIME_INODE(ip) ||\n\t\t    (fa->fsx_xflags & XFS_XFLAG_REALTIME)) {\n\t\t\tsize = mp->m_sb.sb_rextsize << mp->m_sb.sb_blocklog;\n\t\t} else {\n\t\t\tsize = mp->m_sb.sb_blocksize;\n\t\t\tif (extsize_fsb > mp->m_sb.sb_agblocks / 2)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (fa->fsx_extsize % size)\n\t\t\treturn -EINVAL;\n\t} else\n\t\tfa->fsx_xflags &= ~(XFS_XFLAG_EXTSIZE | XFS_XFLAG_EXTSZINHERIT);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "fa->fsx_extsize"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ip->i_d.di_mode"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_d.di_mode"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ip->i_d.di_mode"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic int\nxfs_ioctl_setattr_check_extsize(\n\tstruct xfs_inode\t*ip,\n\tstruct fsxattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif ((fa->fsx_xflags & XFS_XFLAG_EXTSIZE) && !S_ISREG(ip->i_d.di_mode))\n\t\treturn -EINVAL;\n\n\tif ((fa->fsx_xflags & XFS_XFLAG_EXTSZINHERIT) &&\n\t    !S_ISDIR(ip->i_d.di_mode))\n\t\treturn -EINVAL;\n\n\tif (S_ISREG(ip->i_d.di_mode) && ip->i_d.di_nextents &&\n\t    ((ip->i_d.di_extsize << mp->m_sb.sb_blocklog) != fa->fsx_extsize))\n\t\treturn -EINVAL;\n\n\tif (fa->fsx_extsize != 0) {\n\t\txfs_extlen_t    size;\n\t\txfs_fsblock_t   extsize_fsb;\n\n\t\textsize_fsb = XFS_B_TO_FSB(mp, fa->fsx_extsize);\n\t\tif (extsize_fsb > MAXEXTLEN)\n\t\t\treturn -EINVAL;\n\n\t\tif (XFS_IS_REALTIME_INODE(ip) ||\n\t\t    (fa->fsx_xflags & XFS_XFLAG_REALTIME)) {\n\t\t\tsize = mp->m_sb.sb_rextsize << mp->m_sb.sb_blocklog;\n\t\t} else {\n\t\t\tsize = mp->m_sb.sb_blocksize;\n\t\t\tif (extsize_fsb > mp->m_sb.sb_agblocks / 2)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (fa->fsx_extsize % size)\n\t\t\treturn -EINVAL;\n\t} else\n\t\tfa->fsx_xflags &= ~(XFS_XFLAG_EXTSIZE | XFS_XFLAG_EXTSZINHERIT);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ioctl_setattr_get_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "1038-1078",
    "snippet": "static struct xfs_trans *\nxfs_ioctl_setattr_get_trans(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn ERR_PTR(-EIO);\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error)\n\t\tgoto out_cancel;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * CAP_FOWNER overrides the following restrictions:\n\t *\n\t * The user ID of the calling process must be equal to the file owner\n\t * ID, except in cases where the CAP_FSETID capability is applicable.\n\t */\n\tif (!inode_owner_or_capable(VFS_I(ip))) {\n\t\terror = -EPERM;\n\t\tgoto out_cancel;\n\t}\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\treturn tp;\n\nout_cancel:\n\txfs_trans_cancel(tp, 0);\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "0"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_set_sync",
          "args": [
            "tp"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_owner_or_capable",
          "args": [
            "VFS_I(ip)"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_ichange",
            "0",
            "0"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_SETATTR_NOT_SIZE"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EROFS"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic struct xfs_trans *\nxfs_ioctl_setattr_get_trans(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn ERR_PTR(-EIO);\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error)\n\t\tgoto out_cancel;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * CAP_FOWNER overrides the following restrictions:\n\t *\n\t * The user ID of the calling process must be equal to the file owner\n\t * ID, except in cases where the CAP_FSETID capability is applicable.\n\t */\n\tif (!inode_owner_or_capable(VFS_I(ip))) {\n\t\terror = -EPERM;\n\t\tgoto out_cancel;\n\t}\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\treturn tp;\n\nout_cancel:\n\txfs_trans_cancel(tp, 0);\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "xfs_ioctl_setattr_xflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "995-1030",
    "snippet": "static int\nxfs_ioctl_setattr_xflags(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct fsxattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\t/* Can't change realtime flag if any extents are allocated. */\n\tif ((ip->i_d.di_nextents || ip->i_delayed_blks) &&\n\t    XFS_IS_REALTIME_INODE(ip) != (fa->fsx_xflags & XFS_XFLAG_REALTIME))\n\t\treturn -EINVAL;\n\n\t/* If realtime flag is set then must have realtime device */\n\tif (fa->fsx_xflags & XFS_XFLAG_REALTIME) {\n\t\tif (mp->m_sb.sb_rblocks == 0 || mp->m_sb.sb_rextsize == 0 ||\n\t\t    (ip->i_d.di_extsize % mp->m_sb.sb_rextsize))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Can't modify an immutable/append-only file unless\n\t * we have appropriate permission.\n\t */\n\tif (((ip->i_d.di_flags & (XFS_DIFLAG_IMMUTABLE | XFS_DIFLAG_APPEND)) ||\n\t     (fa->fsx_xflags & (XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND))) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\treturn -EPERM;\n\n\txfs_set_diflags(ip, fa->fsx_xflags);\n\txfs_diflags_to_linux(ip);\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\tXFS_STATS_INC(xs_ig_attrchg);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_ig_attrchg"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "XFS_ILOG_CORE"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ichgtime",
          "args": [
            "tp",
            "ip",
            "XFS_ICHGTIME_CHG"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ichgtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "64-90",
          "snippet": "void\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_diflags_to_linux",
          "args": [
            "ip"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_diflags_to_linux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "970-993",
          "snippet": "STATIC void\nxfs_diflags_to_linux(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tunsigned int\t\txflags = xfs_ip2xflags(ip);\n\n\tif (xflags & XFS_XFLAG_IMMUTABLE)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\telse\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\tif (xflags & XFS_XFLAG_APPEND)\n\t\tinode->i_flags |= S_APPEND;\n\telse\n\t\tinode->i_flags &= ~S_APPEND;\n\tif (xflags & XFS_XFLAG_SYNC)\n\t\tinode->i_flags |= S_SYNC;\n\telse\n\t\tinode->i_flags &= ~S_SYNC;\n\tif (xflags & XFS_XFLAG_NOATIME)\n\t\tinode->i_flags |= S_NOATIME;\n\telse\n\t\tinode->i_flags &= ~S_NOATIME;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_diflags_to_linux(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tunsigned int\t\txflags = xfs_ip2xflags(ip);\n\n\tif (xflags & XFS_XFLAG_IMMUTABLE)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\telse\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\tif (xflags & XFS_XFLAG_APPEND)\n\t\tinode->i_flags |= S_APPEND;\n\telse\n\t\tinode->i_flags &= ~S_APPEND;\n\tif (xflags & XFS_XFLAG_SYNC)\n\t\tinode->i_flags |= S_SYNC;\n\telse\n\t\tinode->i_flags &= ~S_SYNC;\n\tif (xflags & XFS_XFLAG_NOATIME)\n\t\tinode->i_flags |= S_NOATIME;\n\telse\n\t\tinode->i_flags &= ~S_NOATIME;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_set_diflags",
          "args": [
            "ip",
            "fa->fsx_xflags"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_set_diflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "928-968",
          "snippet": "STATIC void\nxfs_set_diflags(\n\tstruct xfs_inode\t*ip,\n\tunsigned int\t\txflags)\n{\n\tunsigned int\t\tdi_flags;\n\n\t/* can't set PREALLOC this way, just preserve it */\n\tdi_flags = (ip->i_d.di_flags & XFS_DIFLAG_PREALLOC);\n\tif (xflags & XFS_XFLAG_IMMUTABLE)\n\t\tdi_flags |= XFS_DIFLAG_IMMUTABLE;\n\tif (xflags & XFS_XFLAG_APPEND)\n\t\tdi_flags |= XFS_DIFLAG_APPEND;\n\tif (xflags & XFS_XFLAG_SYNC)\n\t\tdi_flags |= XFS_DIFLAG_SYNC;\n\tif (xflags & XFS_XFLAG_NOATIME)\n\t\tdi_flags |= XFS_DIFLAG_NOATIME;\n\tif (xflags & XFS_XFLAG_NODUMP)\n\t\tdi_flags |= XFS_DIFLAG_NODUMP;\n\tif (xflags & XFS_XFLAG_NODEFRAG)\n\t\tdi_flags |= XFS_DIFLAG_NODEFRAG;\n\tif (xflags & XFS_XFLAG_FILESTREAM)\n\t\tdi_flags |= XFS_DIFLAG_FILESTREAM;\n\tif (S_ISDIR(ip->i_d.di_mode)) {\n\t\tif (xflags & XFS_XFLAG_RTINHERIT)\n\t\t\tdi_flags |= XFS_DIFLAG_RTINHERIT;\n\t\tif (xflags & XFS_XFLAG_NOSYMLINKS)\n\t\t\tdi_flags |= XFS_DIFLAG_NOSYMLINKS;\n\t\tif (xflags & XFS_XFLAG_EXTSZINHERIT)\n\t\t\tdi_flags |= XFS_DIFLAG_EXTSZINHERIT;\n\t\tif (xflags & XFS_XFLAG_PROJINHERIT)\n\t\t\tdi_flags |= XFS_DIFLAG_PROJINHERIT;\n\t} else if (S_ISREG(ip->i_d.di_mode)) {\n\t\tif (xflags & XFS_XFLAG_REALTIME)\n\t\t\tdi_flags |= XFS_DIFLAG_REALTIME;\n\t\tif (xflags & XFS_XFLAG_EXTSIZE)\n\t\t\tdi_flags |= XFS_DIFLAG_EXTSIZE;\n\t}\n\n\tip->i_d.di_flags = di_flags;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_set_diflags(\n\tstruct xfs_inode\t*ip,\n\tunsigned int\t\txflags)\n{\n\tunsigned int\t\tdi_flags;\n\n\t/* can't set PREALLOC this way, just preserve it */\n\tdi_flags = (ip->i_d.di_flags & XFS_DIFLAG_PREALLOC);\n\tif (xflags & XFS_XFLAG_IMMUTABLE)\n\t\tdi_flags |= XFS_DIFLAG_IMMUTABLE;\n\tif (xflags & XFS_XFLAG_APPEND)\n\t\tdi_flags |= XFS_DIFLAG_APPEND;\n\tif (xflags & XFS_XFLAG_SYNC)\n\t\tdi_flags |= XFS_DIFLAG_SYNC;\n\tif (xflags & XFS_XFLAG_NOATIME)\n\t\tdi_flags |= XFS_DIFLAG_NOATIME;\n\tif (xflags & XFS_XFLAG_NODUMP)\n\t\tdi_flags |= XFS_DIFLAG_NODUMP;\n\tif (xflags & XFS_XFLAG_NODEFRAG)\n\t\tdi_flags |= XFS_DIFLAG_NODEFRAG;\n\tif (xflags & XFS_XFLAG_FILESTREAM)\n\t\tdi_flags |= XFS_DIFLAG_FILESTREAM;\n\tif (S_ISDIR(ip->i_d.di_mode)) {\n\t\tif (xflags & XFS_XFLAG_RTINHERIT)\n\t\t\tdi_flags |= XFS_DIFLAG_RTINHERIT;\n\t\tif (xflags & XFS_XFLAG_NOSYMLINKS)\n\t\t\tdi_flags |= XFS_DIFLAG_NOSYMLINKS;\n\t\tif (xflags & XFS_XFLAG_EXTSZINHERIT)\n\t\t\tdi_flags |= XFS_DIFLAG_EXTSZINHERIT;\n\t\tif (xflags & XFS_XFLAG_PROJINHERIT)\n\t\t\tdi_flags |= XFS_DIFLAG_PROJINHERIT;\n\t} else if (S_ISREG(ip->i_d.di_mode)) {\n\t\tif (xflags & XFS_XFLAG_REALTIME)\n\t\t\tdi_flags |= XFS_DIFLAG_REALTIME;\n\t\tif (xflags & XFS_XFLAG_EXTSIZE)\n\t\t\tdi_flags |= XFS_DIFLAG_EXTSIZE;\n\t}\n\n\tip->i_d.di_flags = di_flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_LINUX_IMMUTABLE"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic int\nxfs_ioctl_setattr_xflags(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct fsxattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\t/* Can't change realtime flag if any extents are allocated. */\n\tif ((ip->i_d.di_nextents || ip->i_delayed_blks) &&\n\t    XFS_IS_REALTIME_INODE(ip) != (fa->fsx_xflags & XFS_XFLAG_REALTIME))\n\t\treturn -EINVAL;\n\n\t/* If realtime flag is set then must have realtime device */\n\tif (fa->fsx_xflags & XFS_XFLAG_REALTIME) {\n\t\tif (mp->m_sb.sb_rblocks == 0 || mp->m_sb.sb_rextsize == 0 ||\n\t\t    (ip->i_d.di_extsize % mp->m_sb.sb_rextsize))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Can't modify an immutable/append-only file unless\n\t * we have appropriate permission.\n\t */\n\tif (((ip->i_d.di_flags & (XFS_DIFLAG_IMMUTABLE | XFS_DIFLAG_APPEND)) ||\n\t     (fa->fsx_xflags & (XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND))) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\treturn -EPERM;\n\n\txfs_set_diflags(ip, fa->fsx_xflags);\n\txfs_diflags_to_linux(ip);\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\tXFS_STATS_INC(xs_ig_attrchg);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_diflags_to_linux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "970-993",
    "snippet": "STATIC void\nxfs_diflags_to_linux(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tunsigned int\t\txflags = xfs_ip2xflags(ip);\n\n\tif (xflags & XFS_XFLAG_IMMUTABLE)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\telse\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\tif (xflags & XFS_XFLAG_APPEND)\n\t\tinode->i_flags |= S_APPEND;\n\telse\n\t\tinode->i_flags &= ~S_APPEND;\n\tif (xflags & XFS_XFLAG_SYNC)\n\t\tinode->i_flags |= S_SYNC;\n\telse\n\t\tinode->i_flags &= ~S_SYNC;\n\tif (xflags & XFS_XFLAG_NOATIME)\n\t\tinode->i_flags |= S_NOATIME;\n\telse\n\t\tinode->i_flags &= ~S_NOATIME;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_ip2xflags",
          "args": [
            "ip"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ip2xflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "546-554",
          "snippet": "uint\nxfs_ip2xflags(\n\txfs_inode_t\t\t*ip)\n{\n\txfs_icdinode_t\t\t*dic = &ip->i_d;\n\n\treturn _xfs_dic2xflags(dic->di_flags) |\n\t\t\t\t(XFS_IFORK_Q(ip) ? XFS_XFLAG_HASATTR : 0);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nuint\nxfs_ip2xflags(\n\txfs_inode_t\t\t*ip)\n{\n\txfs_icdinode_t\t\t*dic = &ip->i_d;\n\n\treturn _xfs_dic2xflags(dic->di_flags) |\n\t\t\t\t(XFS_IFORK_Q(ip) ? XFS_XFLAG_HASATTR : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_diflags_to_linux(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tunsigned int\t\txflags = xfs_ip2xflags(ip);\n\n\tif (xflags & XFS_XFLAG_IMMUTABLE)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\telse\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\tif (xflags & XFS_XFLAG_APPEND)\n\t\tinode->i_flags |= S_APPEND;\n\telse\n\t\tinode->i_flags &= ~S_APPEND;\n\tif (xflags & XFS_XFLAG_SYNC)\n\t\tinode->i_flags |= S_SYNC;\n\telse\n\t\tinode->i_flags &= ~S_SYNC;\n\tif (xflags & XFS_XFLAG_NOATIME)\n\t\tinode->i_flags |= S_NOATIME;\n\telse\n\t\tinode->i_flags &= ~S_NOATIME;\n}"
  },
  {
    "function_name": "xfs_set_diflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "928-968",
    "snippet": "STATIC void\nxfs_set_diflags(\n\tstruct xfs_inode\t*ip,\n\tunsigned int\t\txflags)\n{\n\tunsigned int\t\tdi_flags;\n\n\t/* can't set PREALLOC this way, just preserve it */\n\tdi_flags = (ip->i_d.di_flags & XFS_DIFLAG_PREALLOC);\n\tif (xflags & XFS_XFLAG_IMMUTABLE)\n\t\tdi_flags |= XFS_DIFLAG_IMMUTABLE;\n\tif (xflags & XFS_XFLAG_APPEND)\n\t\tdi_flags |= XFS_DIFLAG_APPEND;\n\tif (xflags & XFS_XFLAG_SYNC)\n\t\tdi_flags |= XFS_DIFLAG_SYNC;\n\tif (xflags & XFS_XFLAG_NOATIME)\n\t\tdi_flags |= XFS_DIFLAG_NOATIME;\n\tif (xflags & XFS_XFLAG_NODUMP)\n\t\tdi_flags |= XFS_DIFLAG_NODUMP;\n\tif (xflags & XFS_XFLAG_NODEFRAG)\n\t\tdi_flags |= XFS_DIFLAG_NODEFRAG;\n\tif (xflags & XFS_XFLAG_FILESTREAM)\n\t\tdi_flags |= XFS_DIFLAG_FILESTREAM;\n\tif (S_ISDIR(ip->i_d.di_mode)) {\n\t\tif (xflags & XFS_XFLAG_RTINHERIT)\n\t\t\tdi_flags |= XFS_DIFLAG_RTINHERIT;\n\t\tif (xflags & XFS_XFLAG_NOSYMLINKS)\n\t\t\tdi_flags |= XFS_DIFLAG_NOSYMLINKS;\n\t\tif (xflags & XFS_XFLAG_EXTSZINHERIT)\n\t\t\tdi_flags |= XFS_DIFLAG_EXTSZINHERIT;\n\t\tif (xflags & XFS_XFLAG_PROJINHERIT)\n\t\t\tdi_flags |= XFS_DIFLAG_PROJINHERIT;\n\t} else if (S_ISREG(ip->i_d.di_mode)) {\n\t\tif (xflags & XFS_XFLAG_REALTIME)\n\t\t\tdi_flags |= XFS_DIFLAG_REALTIME;\n\t\tif (xflags & XFS_XFLAG_EXTSIZE)\n\t\t\tdi_flags |= XFS_DIFLAG_EXTSIZE;\n\t}\n\n\tip->i_d.di_flags = di_flags;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ip->i_d.di_mode"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_d.di_mode"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_set_diflags(\n\tstruct xfs_inode\t*ip,\n\tunsigned int\t\txflags)\n{\n\tunsigned int\t\tdi_flags;\n\n\t/* can't set PREALLOC this way, just preserve it */\n\tdi_flags = (ip->i_d.di_flags & XFS_DIFLAG_PREALLOC);\n\tif (xflags & XFS_XFLAG_IMMUTABLE)\n\t\tdi_flags |= XFS_DIFLAG_IMMUTABLE;\n\tif (xflags & XFS_XFLAG_APPEND)\n\t\tdi_flags |= XFS_DIFLAG_APPEND;\n\tif (xflags & XFS_XFLAG_SYNC)\n\t\tdi_flags |= XFS_DIFLAG_SYNC;\n\tif (xflags & XFS_XFLAG_NOATIME)\n\t\tdi_flags |= XFS_DIFLAG_NOATIME;\n\tif (xflags & XFS_XFLAG_NODUMP)\n\t\tdi_flags |= XFS_DIFLAG_NODUMP;\n\tif (xflags & XFS_XFLAG_NODEFRAG)\n\t\tdi_flags |= XFS_DIFLAG_NODEFRAG;\n\tif (xflags & XFS_XFLAG_FILESTREAM)\n\t\tdi_flags |= XFS_DIFLAG_FILESTREAM;\n\tif (S_ISDIR(ip->i_d.di_mode)) {\n\t\tif (xflags & XFS_XFLAG_RTINHERIT)\n\t\t\tdi_flags |= XFS_DIFLAG_RTINHERIT;\n\t\tif (xflags & XFS_XFLAG_NOSYMLINKS)\n\t\t\tdi_flags |= XFS_DIFLAG_NOSYMLINKS;\n\t\tif (xflags & XFS_XFLAG_EXTSZINHERIT)\n\t\t\tdi_flags |= XFS_DIFLAG_EXTSZINHERIT;\n\t\tif (xflags & XFS_XFLAG_PROJINHERIT)\n\t\t\tdi_flags |= XFS_DIFLAG_PROJINHERIT;\n\t} else if (S_ISREG(ip->i_d.di_mode)) {\n\t\tif (xflags & XFS_XFLAG_REALTIME)\n\t\t\tdi_flags |= XFS_DIFLAG_REALTIME;\n\t\tif (xflags & XFS_XFLAG_EXTSIZE)\n\t\t\tdi_flags |= XFS_DIFLAG_EXTSIZE;\n\t}\n\n\tip->i_d.di_flags = di_flags;\n}"
  },
  {
    "function_name": "xfs_ioc_fsgetxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "890-926",
    "snippet": "STATIC int\nxfs_ioc_fsgetxattr(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\tattr,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct fsxattr\t\tfa;\n\n\tmemset(&fa, 0, sizeof(struct fsxattr));\n\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\tfa.fsx_xflags = xfs_ip2xflags(ip);\n\tfa.fsx_extsize = ip->i_d.di_extsize << ip->i_mount->m_sb.sb_blocklog;\n\tfa.fsx_projid = xfs_get_projid(ip);\n\n\tif (attr) {\n\t\tif (ip->i_afp) {\n\t\t\tif (ip->i_afp->if_flags & XFS_IFEXTENTS)\n\t\t\t\tfa.fsx_nextents = ip->i_afp->if_bytes /\n\t\t\t\t\t\t\tsizeof(xfs_bmbt_rec_t);\n\t\t\telse\n\t\t\t\tfa.fsx_nextents = ip->i_d.di_anextents;\n\t\t} else\n\t\t\tfa.fsx_nextents = 0;\n\t} else {\n\t\tif (ip->i_df.if_flags & XFS_IFEXTENTS)\n\t\t\tfa.fsx_nextents = ip->i_df.if_bytes /\n\t\t\t\t\t\tsizeof(xfs_bmbt_rec_t);\n\t\telse\n\t\t\tfa.fsx_nextents = ip->i_d.di_nextents;\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (copy_to_user(arg, &fa, sizeof(fa)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&fa",
            "sizeof(fa)"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_SHARED"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_get_projid",
          "args": [
            "ip"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_projid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "181-185",
          "snippet": "static inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ip2xflags",
          "args": [
            "ip"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ip2xflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "546-554",
          "snippet": "uint\nxfs_ip2xflags(\n\txfs_inode_t\t\t*ip)\n{\n\txfs_icdinode_t\t\t*dic = &ip->i_d;\n\n\treturn _xfs_dic2xflags(dic->di_flags) |\n\t\t\t\t(XFS_IFORK_Q(ip) ? XFS_XFLAG_HASATTR : 0);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nuint\nxfs_ip2xflags(\n\txfs_inode_t\t\t*ip)\n{\n\txfs_icdinode_t\t\t*dic = &ip->i_d;\n\n\treturn _xfs_dic2xflags(dic->di_flags) |\n\t\t\t\t(XFS_IFORK_Q(ip) ? XFS_XFLAG_HASATTR : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_SHARED"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fa",
            "0",
            "sizeof(struct fsxattr)"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_ioc_fsgetxattr(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\tattr,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct fsxattr\t\tfa;\n\n\tmemset(&fa, 0, sizeof(struct fsxattr));\n\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\tfa.fsx_xflags = xfs_ip2xflags(ip);\n\tfa.fsx_extsize = ip->i_d.di_extsize << ip->i_mount->m_sb.sb_blocklog;\n\tfa.fsx_projid = xfs_get_projid(ip);\n\n\tif (attr) {\n\t\tif (ip->i_afp) {\n\t\t\tif (ip->i_afp->if_flags & XFS_IFEXTENTS)\n\t\t\t\tfa.fsx_nextents = ip->i_afp->if_bytes /\n\t\t\t\t\t\t\tsizeof(xfs_bmbt_rec_t);\n\t\t\telse\n\t\t\t\tfa.fsx_nextents = ip->i_d.di_anextents;\n\t\t} else\n\t\t\tfa.fsx_nextents = 0;\n\t} else {\n\t\tif (ip->i_df.if_flags & XFS_IFEXTENTS)\n\t\t\tfa.fsx_nextents = ip->i_df.if_bytes /\n\t\t\t\t\t\tsizeof(xfs_bmbt_rec_t);\n\t\telse\n\t\t\tfa.fsx_nextents = ip->i_d.di_nextents;\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (copy_to_user(arg, &fa, sizeof(fa)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_di2lxflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "871-888",
    "snippet": "STATIC unsigned int\nxfs_di2lxflags(\n\t__uint16_t\tdi_flags)\n{\n\tunsigned int\tflags = 0;\n\n\tif (di_flags & XFS_DIFLAG_IMMUTABLE)\n\t\tflags |= FS_IMMUTABLE_FL;\n\tif (di_flags & XFS_DIFLAG_APPEND)\n\t\tflags |= FS_APPEND_FL;\n\tif (di_flags & XFS_DIFLAG_SYNC)\n\t\tflags |= FS_SYNC_FL;\n\tif (di_flags & XFS_DIFLAG_NOATIME)\n\t\tflags |= FS_NOATIME_FL;\n\tif (di_flags & XFS_DIFLAG_NODUMP)\n\t\tflags |= FS_NODUMP_FL;\n\treturn flags;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC unsigned int\nxfs_di2lxflags(\n\t__uint16_t\tdi_flags)\n{\n\tunsigned int\tflags = 0;\n\n\tif (di_flags & XFS_DIFLAG_IMMUTABLE)\n\t\tflags |= FS_IMMUTABLE_FL;\n\tif (di_flags & XFS_DIFLAG_APPEND)\n\t\tflags |= FS_APPEND_FL;\n\tif (di_flags & XFS_DIFLAG_SYNC)\n\t\tflags |= FS_SYNC_FL;\n\tif (di_flags & XFS_DIFLAG_NOATIME)\n\t\tflags |= FS_NOATIME_FL;\n\tif (di_flags & XFS_DIFLAG_NODUMP)\n\t\tflags |= FS_NODUMP_FL;\n\treturn flags;\n}"
  },
  {
    "function_name": "xfs_merge_ioc_xflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "840-869",
    "snippet": "STATIC unsigned int\nxfs_merge_ioc_xflags(\n\tunsigned int\tflags,\n\tunsigned int\tstart)\n{\n\tunsigned int\txflags = start;\n\n\tif (flags & FS_IMMUTABLE_FL)\n\t\txflags |= XFS_XFLAG_IMMUTABLE;\n\telse\n\t\txflags &= ~XFS_XFLAG_IMMUTABLE;\n\tif (flags & FS_APPEND_FL)\n\t\txflags |= XFS_XFLAG_APPEND;\n\telse\n\t\txflags &= ~XFS_XFLAG_APPEND;\n\tif (flags & FS_SYNC_FL)\n\t\txflags |= XFS_XFLAG_SYNC;\n\telse\n\t\txflags &= ~XFS_XFLAG_SYNC;\n\tif (flags & FS_NOATIME_FL)\n\t\txflags |= XFS_XFLAG_NOATIME;\n\telse\n\t\txflags &= ~XFS_XFLAG_NOATIME;\n\tif (flags & FS_NODUMP_FL)\n\t\txflags |= XFS_XFLAG_NODUMP;\n\telse\n\t\txflags &= ~XFS_XFLAG_NODUMP;\n\n\treturn xflags;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC unsigned int\nxfs_merge_ioc_xflags(\n\tunsigned int\tflags,\n\tunsigned int\tstart)\n{\n\tunsigned int\txflags = start;\n\n\tif (flags & FS_IMMUTABLE_FL)\n\t\txflags |= XFS_XFLAG_IMMUTABLE;\n\telse\n\t\txflags &= ~XFS_XFLAG_IMMUTABLE;\n\tif (flags & FS_APPEND_FL)\n\t\txflags |= XFS_XFLAG_APPEND;\n\telse\n\t\txflags &= ~XFS_XFLAG_APPEND;\n\tif (flags & FS_SYNC_FL)\n\t\txflags |= XFS_XFLAG_SYNC;\n\telse\n\t\txflags &= ~XFS_XFLAG_SYNC;\n\tif (flags & FS_NOATIME_FL)\n\t\txflags |= XFS_XFLAG_NOATIME;\n\telse\n\t\txflags &= ~XFS_XFLAG_NOATIME;\n\tif (flags & FS_NODUMP_FL)\n\t\txflags |= XFS_XFLAG_NODUMP;\n\telse\n\t\txflags &= ~XFS_XFLAG_NODUMP;\n\n\treturn xflags;\n}"
  },
  {
    "function_name": "xfs_ioc_fsgeometry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "819-834",
    "snippet": "STATIC int\nxfs_ioc_fsgeometry(\n\txfs_mount_t\t\t*mp,\n\tvoid\t\t\t__user *arg)\n{\n\txfs_fsop_geom_t\t\tfsgeo;\n\tint\t\t\terror;\n\n\terror = xfs_fs_geometry(mp, &fsgeo, 4);\n\tif (error)\n\t\treturn error;\n\n\tif (copy_to_user(arg, &fsgeo, sizeof(fsgeo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&fsgeo",
            "sizeof(fsgeo)"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_fs_geometry",
          "args": [
            "mp",
            "&fsgeo",
            "4"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_fs_geometry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
          "lines": "48-117",
          "snippet": "int\nxfs_fs_geometry(\n\txfs_mount_t\t\t*mp,\n\txfs_fsop_geom_t\t\t*geo,\n\tint\t\t\tnew_version)\n{\n\n\tmemset(geo, 0, sizeof(*geo));\n\n\tgeo->blocksize = mp->m_sb.sb_blocksize;\n\tgeo->rtextsize = mp->m_sb.sb_rextsize;\n\tgeo->agblocks = mp->m_sb.sb_agblocks;\n\tgeo->agcount = mp->m_sb.sb_agcount;\n\tgeo->logblocks = mp->m_sb.sb_logblocks;\n\tgeo->sectsize = mp->m_sb.sb_sectsize;\n\tgeo->inodesize = mp->m_sb.sb_inodesize;\n\tgeo->imaxpct = mp->m_sb.sb_imax_pct;\n\tgeo->datablocks = mp->m_sb.sb_dblocks;\n\tgeo->rtblocks = mp->m_sb.sb_rblocks;\n\tgeo->rtextents = mp->m_sb.sb_rextents;\n\tgeo->logstart = mp->m_sb.sb_logstart;\n\tASSERT(sizeof(geo->uuid)==sizeof(mp->m_sb.sb_uuid));\n\tmemcpy(geo->uuid, &mp->m_sb.sb_uuid, sizeof(mp->m_sb.sb_uuid));\n\tif (new_version >= 2) {\n\t\tgeo->sunit = mp->m_sb.sb_unit;\n\t\tgeo->swidth = mp->m_sb.sb_width;\n\t}\n\tif (new_version >= 3) {\n\t\tgeo->version = XFS_FSOP_GEOM_VERSION;\n\t\tgeo->flags = XFS_FSOP_GEOM_FLAGS_NLINK |\n\t\t\t     XFS_FSOP_GEOM_FLAGS_DIRV2 |\n\t\t\t(xfs_sb_version_hasattr(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_ATTR : 0) |\n\t\t\t(xfs_sb_version_hasquota(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_QUOTA : 0) |\n\t\t\t(xfs_sb_version_hasalign(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_IALIGN : 0) |\n\t\t\t(xfs_sb_version_hasdalign(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_DALIGN : 0) |\n\t\t\t(xfs_sb_version_hasextflgbit(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_EXTFLG : 0) |\n\t\t\t(xfs_sb_version_hassector(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_SECTOR : 0) |\n\t\t\t(xfs_sb_version_hasasciici(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_DIRV2CI : 0) |\n\t\t\t(xfs_sb_version_haslazysbcount(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_LAZYSB : 0) |\n\t\t\t(xfs_sb_version_hasattr2(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_ATTR2 : 0) |\n\t\t\t(xfs_sb_version_hasprojid32bit(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_PROJID32 : 0) |\n\t\t\t(xfs_sb_version_hascrc(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_V5SB : 0) |\n\t\t\t(xfs_sb_version_hasftype(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_FTYPE : 0) |\n\t\t\t(xfs_sb_version_hasfinobt(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_FINOBT : 0);\n\t\tgeo->logsectsize = xfs_sb_version_hassector(&mp->m_sb) ?\n\t\t\t\tmp->m_sb.sb_logsectsize : BBSIZE;\n\t\tgeo->rtsectsize = mp->m_sb.sb_blocksize;\n\t\tgeo->dirblocksize = mp->m_dir_geo->blksize;\n\t}\n\tif (new_version >= 4) {\n\t\tgeo->flags |=\n\t\t\t(xfs_sb_version_haslogv2(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_LOGV2 : 0);\n\t\tgeo->logsunit = mp->m_sb.sb_logsunit;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_fs_geometry(\n\txfs_mount_t\t\t*mp,\n\txfs_fsop_geom_t\t\t*geo,\n\tint\t\t\tnew_version)\n{\n\n\tmemset(geo, 0, sizeof(*geo));\n\n\tgeo->blocksize = mp->m_sb.sb_blocksize;\n\tgeo->rtextsize = mp->m_sb.sb_rextsize;\n\tgeo->agblocks = mp->m_sb.sb_agblocks;\n\tgeo->agcount = mp->m_sb.sb_agcount;\n\tgeo->logblocks = mp->m_sb.sb_logblocks;\n\tgeo->sectsize = mp->m_sb.sb_sectsize;\n\tgeo->inodesize = mp->m_sb.sb_inodesize;\n\tgeo->imaxpct = mp->m_sb.sb_imax_pct;\n\tgeo->datablocks = mp->m_sb.sb_dblocks;\n\tgeo->rtblocks = mp->m_sb.sb_rblocks;\n\tgeo->rtextents = mp->m_sb.sb_rextents;\n\tgeo->logstart = mp->m_sb.sb_logstart;\n\tASSERT(sizeof(geo->uuid)==sizeof(mp->m_sb.sb_uuid));\n\tmemcpy(geo->uuid, &mp->m_sb.sb_uuid, sizeof(mp->m_sb.sb_uuid));\n\tif (new_version >= 2) {\n\t\tgeo->sunit = mp->m_sb.sb_unit;\n\t\tgeo->swidth = mp->m_sb.sb_width;\n\t}\n\tif (new_version >= 3) {\n\t\tgeo->version = XFS_FSOP_GEOM_VERSION;\n\t\tgeo->flags = XFS_FSOP_GEOM_FLAGS_NLINK |\n\t\t\t     XFS_FSOP_GEOM_FLAGS_DIRV2 |\n\t\t\t(xfs_sb_version_hasattr(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_ATTR : 0) |\n\t\t\t(xfs_sb_version_hasquota(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_QUOTA : 0) |\n\t\t\t(xfs_sb_version_hasalign(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_IALIGN : 0) |\n\t\t\t(xfs_sb_version_hasdalign(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_DALIGN : 0) |\n\t\t\t(xfs_sb_version_hasextflgbit(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_EXTFLG : 0) |\n\t\t\t(xfs_sb_version_hassector(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_SECTOR : 0) |\n\t\t\t(xfs_sb_version_hasasciici(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_DIRV2CI : 0) |\n\t\t\t(xfs_sb_version_haslazysbcount(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_LAZYSB : 0) |\n\t\t\t(xfs_sb_version_hasattr2(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_ATTR2 : 0) |\n\t\t\t(xfs_sb_version_hasprojid32bit(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_PROJID32 : 0) |\n\t\t\t(xfs_sb_version_hascrc(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_V5SB : 0) |\n\t\t\t(xfs_sb_version_hasftype(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_FTYPE : 0) |\n\t\t\t(xfs_sb_version_hasfinobt(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_FINOBT : 0);\n\t\tgeo->logsectsize = xfs_sb_version_hassector(&mp->m_sb) ?\n\t\t\t\tmp->m_sb.sb_logsectsize : BBSIZE;\n\t\tgeo->rtsectsize = mp->m_sb.sb_blocksize;\n\t\tgeo->dirblocksize = mp->m_dir_geo->blksize;\n\t}\n\tif (new_version >= 4) {\n\t\tgeo->flags |=\n\t\t\t(xfs_sb_version_haslogv2(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_LOGV2 : 0);\n\t\tgeo->logsunit = mp->m_sb.sb_logsunit;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_ioc_fsgeometry(\n\txfs_mount_t\t\t*mp,\n\tvoid\t\t\t__user *arg)\n{\n\txfs_fsop_geom_t\t\tfsgeo;\n\tint\t\t\terror;\n\n\terror = xfs_fs_geometry(mp, &fsgeo, 4);\n\tif (error)\n\t\treturn error;\n\n\tif (copy_to_user(arg, &fsgeo, sizeof(fsgeo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ioc_fsgeometry_v1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "797-817",
    "snippet": "STATIC int\nxfs_ioc_fsgeometry_v1(\n\txfs_mount_t\t\t*mp,\n\tvoid\t\t\t__user *arg)\n{\n\txfs_fsop_geom_t         fsgeo;\n\tint\t\t\terror;\n\n\terror = xfs_fs_geometry(mp, &fsgeo, 3);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Caller should have passed an argument of type\n\t * xfs_fsop_geom_v1_t.  This is a proper subset of the\n\t * xfs_fsop_geom_t that xfs_fs_geometry() fills in.\n\t */\n\tif (copy_to_user(arg, &fsgeo, sizeof(xfs_fsop_geom_v1_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&fsgeo",
            "sizeof(xfs_fsop_geom_v1_t)"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_fs_geometry",
          "args": [
            "mp",
            "&fsgeo",
            "3"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_fs_geometry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
          "lines": "48-117",
          "snippet": "int\nxfs_fs_geometry(\n\txfs_mount_t\t\t*mp,\n\txfs_fsop_geom_t\t\t*geo,\n\tint\t\t\tnew_version)\n{\n\n\tmemset(geo, 0, sizeof(*geo));\n\n\tgeo->blocksize = mp->m_sb.sb_blocksize;\n\tgeo->rtextsize = mp->m_sb.sb_rextsize;\n\tgeo->agblocks = mp->m_sb.sb_agblocks;\n\tgeo->agcount = mp->m_sb.sb_agcount;\n\tgeo->logblocks = mp->m_sb.sb_logblocks;\n\tgeo->sectsize = mp->m_sb.sb_sectsize;\n\tgeo->inodesize = mp->m_sb.sb_inodesize;\n\tgeo->imaxpct = mp->m_sb.sb_imax_pct;\n\tgeo->datablocks = mp->m_sb.sb_dblocks;\n\tgeo->rtblocks = mp->m_sb.sb_rblocks;\n\tgeo->rtextents = mp->m_sb.sb_rextents;\n\tgeo->logstart = mp->m_sb.sb_logstart;\n\tASSERT(sizeof(geo->uuid)==sizeof(mp->m_sb.sb_uuid));\n\tmemcpy(geo->uuid, &mp->m_sb.sb_uuid, sizeof(mp->m_sb.sb_uuid));\n\tif (new_version >= 2) {\n\t\tgeo->sunit = mp->m_sb.sb_unit;\n\t\tgeo->swidth = mp->m_sb.sb_width;\n\t}\n\tif (new_version >= 3) {\n\t\tgeo->version = XFS_FSOP_GEOM_VERSION;\n\t\tgeo->flags = XFS_FSOP_GEOM_FLAGS_NLINK |\n\t\t\t     XFS_FSOP_GEOM_FLAGS_DIRV2 |\n\t\t\t(xfs_sb_version_hasattr(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_ATTR : 0) |\n\t\t\t(xfs_sb_version_hasquota(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_QUOTA : 0) |\n\t\t\t(xfs_sb_version_hasalign(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_IALIGN : 0) |\n\t\t\t(xfs_sb_version_hasdalign(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_DALIGN : 0) |\n\t\t\t(xfs_sb_version_hasextflgbit(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_EXTFLG : 0) |\n\t\t\t(xfs_sb_version_hassector(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_SECTOR : 0) |\n\t\t\t(xfs_sb_version_hasasciici(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_DIRV2CI : 0) |\n\t\t\t(xfs_sb_version_haslazysbcount(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_LAZYSB : 0) |\n\t\t\t(xfs_sb_version_hasattr2(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_ATTR2 : 0) |\n\t\t\t(xfs_sb_version_hasprojid32bit(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_PROJID32 : 0) |\n\t\t\t(xfs_sb_version_hascrc(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_V5SB : 0) |\n\t\t\t(xfs_sb_version_hasftype(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_FTYPE : 0) |\n\t\t\t(xfs_sb_version_hasfinobt(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_FINOBT : 0);\n\t\tgeo->logsectsize = xfs_sb_version_hassector(&mp->m_sb) ?\n\t\t\t\tmp->m_sb.sb_logsectsize : BBSIZE;\n\t\tgeo->rtsectsize = mp->m_sb.sb_blocksize;\n\t\tgeo->dirblocksize = mp->m_dir_geo->blksize;\n\t}\n\tif (new_version >= 4) {\n\t\tgeo->flags |=\n\t\t\t(xfs_sb_version_haslogv2(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_LOGV2 : 0);\n\t\tgeo->logsunit = mp->m_sb.sb_logsunit;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_fs_geometry(\n\txfs_mount_t\t\t*mp,\n\txfs_fsop_geom_t\t\t*geo,\n\tint\t\t\tnew_version)\n{\n\n\tmemset(geo, 0, sizeof(*geo));\n\n\tgeo->blocksize = mp->m_sb.sb_blocksize;\n\tgeo->rtextsize = mp->m_sb.sb_rextsize;\n\tgeo->agblocks = mp->m_sb.sb_agblocks;\n\tgeo->agcount = mp->m_sb.sb_agcount;\n\tgeo->logblocks = mp->m_sb.sb_logblocks;\n\tgeo->sectsize = mp->m_sb.sb_sectsize;\n\tgeo->inodesize = mp->m_sb.sb_inodesize;\n\tgeo->imaxpct = mp->m_sb.sb_imax_pct;\n\tgeo->datablocks = mp->m_sb.sb_dblocks;\n\tgeo->rtblocks = mp->m_sb.sb_rblocks;\n\tgeo->rtextents = mp->m_sb.sb_rextents;\n\tgeo->logstart = mp->m_sb.sb_logstart;\n\tASSERT(sizeof(geo->uuid)==sizeof(mp->m_sb.sb_uuid));\n\tmemcpy(geo->uuid, &mp->m_sb.sb_uuid, sizeof(mp->m_sb.sb_uuid));\n\tif (new_version >= 2) {\n\t\tgeo->sunit = mp->m_sb.sb_unit;\n\t\tgeo->swidth = mp->m_sb.sb_width;\n\t}\n\tif (new_version >= 3) {\n\t\tgeo->version = XFS_FSOP_GEOM_VERSION;\n\t\tgeo->flags = XFS_FSOP_GEOM_FLAGS_NLINK |\n\t\t\t     XFS_FSOP_GEOM_FLAGS_DIRV2 |\n\t\t\t(xfs_sb_version_hasattr(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_ATTR : 0) |\n\t\t\t(xfs_sb_version_hasquota(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_QUOTA : 0) |\n\t\t\t(xfs_sb_version_hasalign(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_IALIGN : 0) |\n\t\t\t(xfs_sb_version_hasdalign(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_DALIGN : 0) |\n\t\t\t(xfs_sb_version_hasextflgbit(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_EXTFLG : 0) |\n\t\t\t(xfs_sb_version_hassector(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_SECTOR : 0) |\n\t\t\t(xfs_sb_version_hasasciici(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_DIRV2CI : 0) |\n\t\t\t(xfs_sb_version_haslazysbcount(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_LAZYSB : 0) |\n\t\t\t(xfs_sb_version_hasattr2(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_ATTR2 : 0) |\n\t\t\t(xfs_sb_version_hasprojid32bit(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_PROJID32 : 0) |\n\t\t\t(xfs_sb_version_hascrc(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_V5SB : 0) |\n\t\t\t(xfs_sb_version_hasftype(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_FTYPE : 0) |\n\t\t\t(xfs_sb_version_hasfinobt(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_FINOBT : 0);\n\t\tgeo->logsectsize = xfs_sb_version_hassector(&mp->m_sb) ?\n\t\t\t\tmp->m_sb.sb_logsectsize : BBSIZE;\n\t\tgeo->rtsectsize = mp->m_sb.sb_blocksize;\n\t\tgeo->dirblocksize = mp->m_dir_geo->blksize;\n\t}\n\tif (new_version >= 4) {\n\t\tgeo->flags |=\n\t\t\t(xfs_sb_version_haslogv2(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_LOGV2 : 0);\n\t\tgeo->logsunit = mp->m_sb.sb_logsunit;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_ioc_fsgeometry_v1(\n\txfs_mount_t\t\t*mp,\n\tvoid\t\t\t__user *arg)\n{\n\txfs_fsop_geom_t         fsgeo;\n\tint\t\t\terror;\n\n\terror = xfs_fs_geometry(mp, &fsgeo, 3);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Caller should have passed an argument of type\n\t * xfs_fsop_geom_v1_t.  This is a proper subset of the\n\t * xfs_fsop_geom_t that xfs_fs_geometry() fills in.\n\t */\n\tif (copy_to_user(arg, &fsgeo, sizeof(xfs_fsop_geom_v1_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ioc_bulkstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "738-795",
    "snippet": "STATIC int\nxfs_ioc_bulkstat(\n\txfs_mount_t\t\t*mp,\n\tunsigned int\t\tcmd,\n\tvoid\t\t\t__user *arg)\n{\n\txfs_fsop_bulkreq_t\tbulkreq;\n\tint\t\t\tcount;\t/* # of records returned */\n\txfs_ino_t\t\tinlast;\t/* last inode number */\n\tint\t\t\tdone;\n\tint\t\t\terror;\n\n\t/* done = 1 if there are more stats to get and if bulkstat */\n\t/* should be called again (unused here, but used in dmapi) */\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tif (copy_from_user(&bulkreq, arg, sizeof(xfs_fsop_bulkreq_t)))\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(&inlast, bulkreq.lastip, sizeof(__s64)))\n\t\treturn -EFAULT;\n\n\tif ((count = bulkreq.icount) <= 0)\n\t\treturn -EINVAL;\n\n\tif (bulkreq.ubuffer == NULL)\n\t\treturn -EINVAL;\n\n\tif (cmd == XFS_IOC_FSINUMBERS)\n\t\terror = xfs_inumbers(mp, &inlast, &count,\n\t\t\t\t\tbulkreq.ubuffer, xfs_inumbers_fmt);\n\telse if (cmd == XFS_IOC_FSBULKSTAT_SINGLE)\n\t\terror = xfs_bulkstat_one(mp, inlast, bulkreq.ubuffer,\n\t\t\t\t\tsizeof(xfs_bstat_t), NULL, &done);\n\telse\t/* XFS_IOC_FSBULKSTAT */\n\t\terror = xfs_bulkstat(mp, &inlast, &count, xfs_bulkstat_one,\n\t\t\t\t     sizeof(xfs_bstat_t), bulkreq.ubuffer,\n\t\t\t\t     &done);\n\n\tif (error)\n\t\treturn error;\n\n\tif (bulkreq.ocount != NULL) {\n\t\tif (copy_to_user(bulkreq.lastip, &inlast,\n\t\t\t\t\t\tsizeof(xfs_ino_t)))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_to_user(bulkreq.ocount, &count, sizeof(count)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "bulkreq.ocount",
            "&count",
            "sizeof(count)"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "bulkreq.lastip",
            "&inlast",
            "sizeof(xfs_ino_t)"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bulkstat",
          "args": [
            "mp",
            "&inlast",
            "&count",
            "xfs_bulkstat_one",
            "sizeof(xfs_bstat_t)",
            "bulkreq.ubuffer",
            "&done"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bulkstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
          "lines": "340-531",
          "snippet": "int\t\t\t\t\t/* error status */\nxfs_bulkstat(\n\txfs_mount_t\t\t*mp,\t/* mount point for filesystem */\n\txfs_ino_t\t\t*lastinop, /* last inode returned */\n\tint\t\t\t*ubcountp, /* size of buffer/count returned */\n\tbulkstat_one_pf\t\tformatter, /* func that'd fill a single buf */\n\tsize_t\t\t\tstatstruct_size, /* sizeof struct filling */\n\tchar\t\t\t__user *ubuffer, /* buffer with inode stats */\n\tint\t\t\t*done)\t/* 1 if there are more stats to get */\n{\n\txfs_buf_t\t\t*agbp;\t/* agi header buffer */\n\txfs_agino_t\t\tagino;\t/* inode # in allocation group */\n\txfs_agnumber_t\t\tagno;\t/* allocation group number */\n\txfs_btree_cur_t\t\t*cur;\t/* btree cursor for ialloc btree */\n\tsize_t\t\t\tirbsize; /* size of irec buffer in bytes */\n\txfs_inobt_rec_incore_t\t*irbuf;\t/* start of irec buffer */\n\tint\t\t\tnirbuf;\t/* size of irbuf */\n\tint\t\t\tubcount; /* size of user's buffer */\n\tstruct xfs_bulkstat_agichunk ac;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Get the last inode value, see if there's nothing to do.\n\t */\n\tagno = XFS_INO_TO_AGNO(mp, *lastinop);\n\tagino = XFS_INO_TO_AGINO(mp, *lastinop);\n\tif (agno >= mp->m_sb.sb_agcount ||\n\t    *lastinop != XFS_AGINO_TO_INO(mp, agno, agino)) {\n\t\t*done = 1;\n\t\t*ubcountp = 0;\n\t\treturn 0;\n\t}\n\n\tubcount = *ubcountp; /* statstruct's */\n\tac.ac_ubuffer = &ubuffer;\n\tac.ac_ubleft = ubcount * statstruct_size; /* bytes */;\n\tac.ac_ubelem = 0;\n\n\t*ubcountp = 0;\n\t*done = 0;\n\n\tirbuf = kmem_zalloc_greedy(&irbsize, PAGE_SIZE, PAGE_SIZE * 4);\n\tif (!irbuf)\n\t\treturn -ENOMEM;\n\n\tnirbuf = irbsize / sizeof(*irbuf);\n\n\t/*\n\t * Loop over the allocation groups, starting from the last\n\t * inode returned; 0 means start of the allocation group.\n\t */\n\twhile (agno < mp->m_sb.sb_agcount) {\n\t\tstruct xfs_inobt_rec_incore\t*irbp = irbuf;\n\t\tstruct xfs_inobt_rec_incore\t*irbufend = irbuf + nirbuf;\n\t\tbool\t\t\t\tend_of_ag = false;\n\t\tint\t\t\t\ticount = 0;\n\t\tint\t\t\t\tstat;\n\n\t\terror = xfs_ialloc_read_agi(mp, NULL, agno, &agbp);\n\t\tif (error)\n\t\t\tbreak;\n\t\t/*\n\t\t * Allocate and initialize a btree cursor for ialloc btree.\n\t\t */\n\t\tcur = xfs_inobt_init_cursor(mp, NULL, agbp, agno,\n\t\t\t\t\t    XFS_BTNUM_INO);\n\t\tif (agino > 0) {\n\t\t\t/*\n\t\t\t * In the middle of an allocation group, we need to get\n\t\t\t * the remainder of the chunk we're in.\n\t\t\t */\n\t\t\tstruct xfs_inobt_rec_incore\tr;\n\n\t\t\terror = xfs_bulkstat_grab_ichunk(cur, agino, &icount, &r);\n\t\t\tif (error)\n\t\t\t\tgoto del_cursor;\n\t\t\tif (icount) {\n\t\t\t\tirbp->ir_startino = r.ir_startino;\n\t\t\t\tirbp->ir_freecount = r.ir_freecount;\n\t\t\t\tirbp->ir_free = r.ir_free;\n\t\t\t\tirbp++;\n\t\t\t}\n\t\t\t/* Increment to the next record */\n\t\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\t} else {\n\t\t\t/* Start of ag.  Lookup the first inode chunk */\n\t\t\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &stat);\n\t\t}\n\t\tif (error || stat == 0) {\n\t\t\tend_of_ag = true;\n\t\t\tgoto del_cursor;\n\t\t}\n\n\t\t/*\n\t\t * Loop through inode btree records in this ag,\n\t\t * until we run out of inodes or space in the buffer.\n\t\t */\n\t\twhile (irbp < irbufend && icount < ubcount) {\n\t\t\tstruct xfs_inobt_rec_incore\tr;\n\n\t\t\terror = xfs_inobt_get_rec(cur, &r, &stat);\n\t\t\tif (error || stat == 0) {\n\t\t\t\tend_of_ag = true;\n\t\t\t\tgoto del_cursor;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If this chunk has any allocated inodes, save it.\n\t\t\t * Also start read-ahead now for this chunk.\n\t\t\t */\n\t\t\tif (r.ir_freecount < XFS_INODES_PER_CHUNK) {\n\t\t\t\txfs_bulkstat_ichunk_ra(mp, agno, &r);\n\t\t\t\tirbp->ir_startino = r.ir_startino;\n\t\t\t\tirbp->ir_freecount = r.ir_freecount;\n\t\t\t\tirbp->ir_free = r.ir_free;\n\t\t\t\tirbp++;\n\t\t\t\ticount += XFS_INODES_PER_CHUNK - r.ir_freecount;\n\t\t\t}\n\t\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\t\tif (error || stat == 0) {\n\t\t\t\tend_of_ag = true;\n\t\t\t\tgoto del_cursor;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * Drop the btree buffers and the agi buffer as we can't hold any\n\t\t * of the locks these represent when calling iget. If there is a\n\t\t * pending error, then we are done.\n\t\t */\ndel_cursor:\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\txfs_buf_relse(agbp);\n\t\tif (error)\n\t\t\tbreak;\n\t\t/*\n\t\t * Now format all the good inodes into the user's buffer. The\n\t\t * call to xfs_bulkstat_ag_ichunk() sets up the agino pointer\n\t\t * for the next loop iteration.\n\t\t */\n\t\tirbufend = irbp;\n\t\tfor (irbp = irbuf;\n\t\t     irbp < irbufend && ac.ac_ubleft >= statstruct_size;\n\t\t     irbp++) {\n\t\t\terror = xfs_bulkstat_ag_ichunk(mp, agno, irbp,\n\t\t\t\t\tformatter, statstruct_size, &ac,\n\t\t\t\t\t&agino);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * If we've run out of space or had a formatting error, we\n\t\t * are now done\n\t\t */\n\t\tif (ac.ac_ubleft < statstruct_size || error)\n\t\t\tbreak;\n\n\t\tif (end_of_ag) {\n\t\t\tagno++;\n\t\t\tagino = 0;\n\t\t}\n\t}\n\t/*\n\t * Done, we're either out of filesystem or space to put the data.\n\t */\n\tkmem_free(irbuf);\n\t*ubcountp = ac.ac_ubelem;\n\n\t/*\n\t * We found some inodes, so clear the error status and return them.\n\t * The lastino pointer will point directly at the inode that triggered\n\t * any error that occurred, so on the next call the error will be\n\t * triggered again and propagated to userspace as there will be no\n\t * formatted inodes in the buffer.\n\t */\n\tif (ac.ac_ubelem)\n\t\terror = 0;\n\n\t/*\n\t * If we ran out of filesystem, lastino will point off the end of\n\t * the filesystem so the next call will return immediately.\n\t */\n\t*lastinop = XFS_AGINO_TO_INO(mp, agno, agino);\n\tif (agno >= mp->m_sb.sb_agcount)\n\t\t*done = 1;\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error status */\nxfs_bulkstat(\n\txfs_mount_t\t\t*mp,\t/* mount point for filesystem */\n\txfs_ino_t\t\t*lastinop, /* last inode returned */\n\tint\t\t\t*ubcountp, /* size of buffer/count returned */\n\tbulkstat_one_pf\t\tformatter, /* func that'd fill a single buf */\n\tsize_t\t\t\tstatstruct_size, /* sizeof struct filling */\n\tchar\t\t\t__user *ubuffer, /* buffer with inode stats */\n\tint\t\t\t*done)\t/* 1 if there are more stats to get */\n{\n\txfs_buf_t\t\t*agbp;\t/* agi header buffer */\n\txfs_agino_t\t\tagino;\t/* inode # in allocation group */\n\txfs_agnumber_t\t\tagno;\t/* allocation group number */\n\txfs_btree_cur_t\t\t*cur;\t/* btree cursor for ialloc btree */\n\tsize_t\t\t\tirbsize; /* size of irec buffer in bytes */\n\txfs_inobt_rec_incore_t\t*irbuf;\t/* start of irec buffer */\n\tint\t\t\tnirbuf;\t/* size of irbuf */\n\tint\t\t\tubcount; /* size of user's buffer */\n\tstruct xfs_bulkstat_agichunk ac;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Get the last inode value, see if there's nothing to do.\n\t */\n\tagno = XFS_INO_TO_AGNO(mp, *lastinop);\n\tagino = XFS_INO_TO_AGINO(mp, *lastinop);\n\tif (agno >= mp->m_sb.sb_agcount ||\n\t    *lastinop != XFS_AGINO_TO_INO(mp, agno, agino)) {\n\t\t*done = 1;\n\t\t*ubcountp = 0;\n\t\treturn 0;\n\t}\n\n\tubcount = *ubcountp; /* statstruct's */\n\tac.ac_ubuffer = &ubuffer;\n\tac.ac_ubleft = ubcount * statstruct_size; /* bytes */;\n\tac.ac_ubelem = 0;\n\n\t*ubcountp = 0;\n\t*done = 0;\n\n\tirbuf = kmem_zalloc_greedy(&irbsize, PAGE_SIZE, PAGE_SIZE * 4);\n\tif (!irbuf)\n\t\treturn -ENOMEM;\n\n\tnirbuf = irbsize / sizeof(*irbuf);\n\n\t/*\n\t * Loop over the allocation groups, starting from the last\n\t * inode returned; 0 means start of the allocation group.\n\t */\n\twhile (agno < mp->m_sb.sb_agcount) {\n\t\tstruct xfs_inobt_rec_incore\t*irbp = irbuf;\n\t\tstruct xfs_inobt_rec_incore\t*irbufend = irbuf + nirbuf;\n\t\tbool\t\t\t\tend_of_ag = false;\n\t\tint\t\t\t\ticount = 0;\n\t\tint\t\t\t\tstat;\n\n\t\terror = xfs_ialloc_read_agi(mp, NULL, agno, &agbp);\n\t\tif (error)\n\t\t\tbreak;\n\t\t/*\n\t\t * Allocate and initialize a btree cursor for ialloc btree.\n\t\t */\n\t\tcur = xfs_inobt_init_cursor(mp, NULL, agbp, agno,\n\t\t\t\t\t    XFS_BTNUM_INO);\n\t\tif (agino > 0) {\n\t\t\t/*\n\t\t\t * In the middle of an allocation group, we need to get\n\t\t\t * the remainder of the chunk we're in.\n\t\t\t */\n\t\t\tstruct xfs_inobt_rec_incore\tr;\n\n\t\t\terror = xfs_bulkstat_grab_ichunk(cur, agino, &icount, &r);\n\t\t\tif (error)\n\t\t\t\tgoto del_cursor;\n\t\t\tif (icount) {\n\t\t\t\tirbp->ir_startino = r.ir_startino;\n\t\t\t\tirbp->ir_freecount = r.ir_freecount;\n\t\t\t\tirbp->ir_free = r.ir_free;\n\t\t\t\tirbp++;\n\t\t\t}\n\t\t\t/* Increment to the next record */\n\t\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\t} else {\n\t\t\t/* Start of ag.  Lookup the first inode chunk */\n\t\t\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &stat);\n\t\t}\n\t\tif (error || stat == 0) {\n\t\t\tend_of_ag = true;\n\t\t\tgoto del_cursor;\n\t\t}\n\n\t\t/*\n\t\t * Loop through inode btree records in this ag,\n\t\t * until we run out of inodes or space in the buffer.\n\t\t */\n\t\twhile (irbp < irbufend && icount < ubcount) {\n\t\t\tstruct xfs_inobt_rec_incore\tr;\n\n\t\t\terror = xfs_inobt_get_rec(cur, &r, &stat);\n\t\t\tif (error || stat == 0) {\n\t\t\t\tend_of_ag = true;\n\t\t\t\tgoto del_cursor;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If this chunk has any allocated inodes, save it.\n\t\t\t * Also start read-ahead now for this chunk.\n\t\t\t */\n\t\t\tif (r.ir_freecount < XFS_INODES_PER_CHUNK) {\n\t\t\t\txfs_bulkstat_ichunk_ra(mp, agno, &r);\n\t\t\t\tirbp->ir_startino = r.ir_startino;\n\t\t\t\tirbp->ir_freecount = r.ir_freecount;\n\t\t\t\tirbp->ir_free = r.ir_free;\n\t\t\t\tirbp++;\n\t\t\t\ticount += XFS_INODES_PER_CHUNK - r.ir_freecount;\n\t\t\t}\n\t\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\t\tif (error || stat == 0) {\n\t\t\t\tend_of_ag = true;\n\t\t\t\tgoto del_cursor;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * Drop the btree buffers and the agi buffer as we can't hold any\n\t\t * of the locks these represent when calling iget. If there is a\n\t\t * pending error, then we are done.\n\t\t */\ndel_cursor:\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\txfs_buf_relse(agbp);\n\t\tif (error)\n\t\t\tbreak;\n\t\t/*\n\t\t * Now format all the good inodes into the user's buffer. The\n\t\t * call to xfs_bulkstat_ag_ichunk() sets up the agino pointer\n\t\t * for the next loop iteration.\n\t\t */\n\t\tirbufend = irbp;\n\t\tfor (irbp = irbuf;\n\t\t     irbp < irbufend && ac.ac_ubleft >= statstruct_size;\n\t\t     irbp++) {\n\t\t\terror = xfs_bulkstat_ag_ichunk(mp, agno, irbp,\n\t\t\t\t\tformatter, statstruct_size, &ac,\n\t\t\t\t\t&agino);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * If we've run out of space or had a formatting error, we\n\t\t * are now done\n\t\t */\n\t\tif (ac.ac_ubleft < statstruct_size || error)\n\t\t\tbreak;\n\n\t\tif (end_of_ag) {\n\t\t\tagno++;\n\t\t\tagino = 0;\n\t\t}\n\t}\n\t/*\n\t * Done, we're either out of filesystem or space to put the data.\n\t */\n\tkmem_free(irbuf);\n\t*ubcountp = ac.ac_ubelem;\n\n\t/*\n\t * We found some inodes, so clear the error status and return them.\n\t * The lastino pointer will point directly at the inode that triggered\n\t * any error that occurred, so on the next call the error will be\n\t * triggered again and propagated to userspace as there will be no\n\t * formatted inodes in the buffer.\n\t */\n\tif (ac.ac_ubelem)\n\t\terror = 0;\n\n\t/*\n\t * If we ran out of filesystem, lastino will point off the end of\n\t * the filesystem so the next call will return immediately.\n\t */\n\t*lastinop = XFS_AGINO_TO_INO(mp, agno, agino);\n\tif (agno >= mp->m_sb.sb_agcount)\n\t\t*done = 1;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bulkstat_one",
          "args": [
            "mp",
            "inlast",
            "bulkreq.ubuffer",
            "sizeof(xfs_bstat_t)",
            "NULL",
            "&done"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bulkstat_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
          "lines": "158-169",
          "snippet": "int\nxfs_bulkstat_one(\n\txfs_mount_t\t*mp,\t\t/* mount point for filesystem */\n\txfs_ino_t\tino,\t\t/* inode number to get data for */\n\tvoid\t\t__user *buffer,\t/* buffer to place output in */\n\tint\t\tubsize,\t\t/* size of buffer */\n\tint\t\t*ubused,\t/* bytes used by me */\n\tint\t\t*stat)\t\t/* BULKSTAT_RV_... */\n{\n\treturn xfs_bulkstat_one_int(mp, ino, buffer, ubsize,\n\t\t\t\t    xfs_bulkstat_one_fmt, ubused, stat);\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bulkstat_one(\n\txfs_mount_t\t*mp,\t\t/* mount point for filesystem */\n\txfs_ino_t\tino,\t\t/* inode number to get data for */\n\tvoid\t\t__user *buffer,\t/* buffer to place output in */\n\tint\t\tubsize,\t\t/* size of buffer */\n\tint\t\t*ubused,\t/* bytes used by me */\n\tint\t\t*stat)\t\t/* BULKSTAT_RV_... */\n{\n\treturn xfs_bulkstat_one_int(mp, ino, buffer, ubsize,\n\t\t\t\t    xfs_bulkstat_one_fmt, ubused, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inumbers",
          "args": [
            "mp",
            "&inlast",
            "&count",
            "bulkreq.ubuffer",
            "xfs_inumbers_fmt"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inumbers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
          "lines": "549-652",
          "snippet": "int\t\t\t\t\t/* error status */\nxfs_inumbers(\n\tstruct xfs_mount\t*mp,/* mount point for filesystem */\n\txfs_ino_t\t\t*lastino,/* last inode returned */\n\tint\t\t\t*count,/* size of buffer/count returned */\n\tvoid\t\t\t__user *ubuffer,/* buffer with inode descriptions */\n\tinumbers_fmt_pf\t\tformatter)\n{\n\txfs_agnumber_t\t\tagno = XFS_INO_TO_AGNO(mp, *lastino);\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, *lastino);\n\tstruct xfs_btree_cur\t*cur = NULL;\n\tstruct xfs_buf\t\t*agbp = NULL;\n\tstruct xfs_inogrp\t*buffer;\n\tint\t\t\tbcount;\n\tint\t\t\tleft = *count;\n\tint\t\t\tbufidx = 0;\n\tint\t\t\terror = 0;\n\n\t*count = 0;\n\tif (agno >= mp->m_sb.sb_agcount ||\n\t    *lastino != XFS_AGINO_TO_INO(mp, agno, agino))\n\t\treturn error;\n\n\tbcount = MIN(left, (int)(PAGE_SIZE / sizeof(*buffer)));\n\tbuffer = kmem_alloc(bcount * sizeof(*buffer), KM_SLEEP);\n\tdo {\n\t\tstruct xfs_inobt_rec_incore\tr;\n\t\tint\t\t\t\tstat;\n\n\t\tif (!agbp) {\n\t\t\terror = xfs_ialloc_read_agi(mp, NULL, agno, &agbp);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t\tcur = xfs_inobt_init_cursor(mp, NULL, agbp, agno,\n\t\t\t\t\t\t    XFS_BTNUM_INO);\n\t\t\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_GE,\n\t\t\t\t\t\t &stat);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tif (!stat)\n\t\t\t\tgoto next_ag;\n\t\t}\n\n\t\terror = xfs_inobt_get_rec(cur, &r, &stat);\n\t\tif (error)\n\t\t\tbreak;\n\t\tif (!stat)\n\t\t\tgoto next_ag;\n\n\t\tagino = r.ir_startino + XFS_INODES_PER_CHUNK - 1;\n\t\tbuffer[bufidx].xi_startino =\n\t\t\tXFS_AGINO_TO_INO(mp, agno, r.ir_startino);\n\t\tbuffer[bufidx].xi_alloccount =\n\t\t\tXFS_INODES_PER_CHUNK - r.ir_freecount;\n\t\tbuffer[bufidx].xi_allocmask = ~r.ir_free;\n\t\tif (++bufidx == bcount) {\n\t\t\tlong\twritten;\n\n\t\t\terror = formatter(ubuffer, buffer, bufidx, &written);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tubuffer += written;\n\t\t\t*count += bufidx;\n\t\t\tbufidx = 0;\n\t\t}\n\t\tif (!--left)\n\t\t\tbreak;\n\n\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\tif (error)\n\t\t\tbreak;\n\t\tif (stat)\n\t\t\tcontinue;\n\nnext_ag:\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\tcur = NULL;\n\t\txfs_buf_relse(agbp);\n\t\tagbp = NULL;\n\t\tagino = 0;\n\t\tagno++;\n\t} while (agno < mp->m_sb.sb_agcount);\n\n\tif (!error) {\n\t\tif (bufidx) {\n\t\t\tlong\twritten;\n\n\t\t\terror = formatter(ubuffer, buffer, bufidx, &written);\n\t\t\tif (!error)\n\t\t\t\t*count += bufidx;\n\t\t}\n\t\t*lastino = XFS_AGINO_TO_INO(mp, agno, agino);\n\t}\n\n\tkmem_free(buffer);\n\tif (cur)\n\t\txfs_btree_del_cursor(cur, (error ? XFS_BTREE_ERROR :\n\t\t\t\t\t   XFS_BTREE_NOERROR));\n\tif (agbp)\n\t\txfs_buf_relse(agbp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error status */\nxfs_inumbers(\n\tstruct xfs_mount\t*mp,/* mount point for filesystem */\n\txfs_ino_t\t\t*lastino,/* last inode returned */\n\tint\t\t\t*count,/* size of buffer/count returned */\n\tvoid\t\t\t__user *ubuffer,/* buffer with inode descriptions */\n\tinumbers_fmt_pf\t\tformatter)\n{\n\txfs_agnumber_t\t\tagno = XFS_INO_TO_AGNO(mp, *lastino);\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, *lastino);\n\tstruct xfs_btree_cur\t*cur = NULL;\n\tstruct xfs_buf\t\t*agbp = NULL;\n\tstruct xfs_inogrp\t*buffer;\n\tint\t\t\tbcount;\n\tint\t\t\tleft = *count;\n\tint\t\t\tbufidx = 0;\n\tint\t\t\terror = 0;\n\n\t*count = 0;\n\tif (agno >= mp->m_sb.sb_agcount ||\n\t    *lastino != XFS_AGINO_TO_INO(mp, agno, agino))\n\t\treturn error;\n\n\tbcount = MIN(left, (int)(PAGE_SIZE / sizeof(*buffer)));\n\tbuffer = kmem_alloc(bcount * sizeof(*buffer), KM_SLEEP);\n\tdo {\n\t\tstruct xfs_inobt_rec_incore\tr;\n\t\tint\t\t\t\tstat;\n\n\t\tif (!agbp) {\n\t\t\terror = xfs_ialloc_read_agi(mp, NULL, agno, &agbp);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t\tcur = xfs_inobt_init_cursor(mp, NULL, agbp, agno,\n\t\t\t\t\t\t    XFS_BTNUM_INO);\n\t\t\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_GE,\n\t\t\t\t\t\t &stat);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tif (!stat)\n\t\t\t\tgoto next_ag;\n\t\t}\n\n\t\terror = xfs_inobt_get_rec(cur, &r, &stat);\n\t\tif (error)\n\t\t\tbreak;\n\t\tif (!stat)\n\t\t\tgoto next_ag;\n\n\t\tagino = r.ir_startino + XFS_INODES_PER_CHUNK - 1;\n\t\tbuffer[bufidx].xi_startino =\n\t\t\tXFS_AGINO_TO_INO(mp, agno, r.ir_startino);\n\t\tbuffer[bufidx].xi_alloccount =\n\t\t\tXFS_INODES_PER_CHUNK - r.ir_freecount;\n\t\tbuffer[bufidx].xi_allocmask = ~r.ir_free;\n\t\tif (++bufidx == bcount) {\n\t\t\tlong\twritten;\n\n\t\t\terror = formatter(ubuffer, buffer, bufidx, &written);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tubuffer += written;\n\t\t\t*count += bufidx;\n\t\t\tbufidx = 0;\n\t\t}\n\t\tif (!--left)\n\t\t\tbreak;\n\n\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\tif (error)\n\t\t\tbreak;\n\t\tif (stat)\n\t\t\tcontinue;\n\nnext_ag:\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\tcur = NULL;\n\t\txfs_buf_relse(agbp);\n\t\tagbp = NULL;\n\t\tagino = 0;\n\t\tagno++;\n\t} while (agno < mp->m_sb.sb_agcount);\n\n\tif (!error) {\n\t\tif (bufidx) {\n\t\t\tlong\twritten;\n\n\t\t\terror = formatter(ubuffer, buffer, bufidx, &written);\n\t\t\tif (!error)\n\t\t\t\t*count += bufidx;\n\t\t}\n\t\t*lastino = XFS_AGINO_TO_INO(mp, agno, agino);\n\t}\n\n\tkmem_free(buffer);\n\tif (cur)\n\t\txfs_btree_del_cursor(cur, (error ? XFS_BTREE_ERROR :\n\t\t\t\t\t   XFS_BTREE_NOERROR));\n\tif (agbp)\n\t\txfs_buf_relse(agbp);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&inlast",
            "bulkreq.lastip",
            "sizeof(__s64)"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_ioc_bulkstat(\n\txfs_mount_t\t\t*mp,\n\tunsigned int\t\tcmd,\n\tvoid\t\t\t__user *arg)\n{\n\txfs_fsop_bulkreq_t\tbulkreq;\n\tint\t\t\tcount;\t/* # of records returned */\n\txfs_ino_t\t\tinlast;\t/* last inode number */\n\tint\t\t\tdone;\n\tint\t\t\terror;\n\n\t/* done = 1 if there are more stats to get and if bulkstat */\n\t/* should be called again (unused here, but used in dmapi) */\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tif (copy_from_user(&bulkreq, arg, sizeof(xfs_fsop_bulkreq_t)))\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(&inlast, bulkreq.lastip, sizeof(__s64)))\n\t\treturn -EFAULT;\n\n\tif ((count = bulkreq.icount) <= 0)\n\t\treturn -EINVAL;\n\n\tif (bulkreq.ubuffer == NULL)\n\t\treturn -EINVAL;\n\n\tif (cmd == XFS_IOC_FSINUMBERS)\n\t\terror = xfs_inumbers(mp, &inlast, &count,\n\t\t\t\t\tbulkreq.ubuffer, xfs_inumbers_fmt);\n\telse if (cmd == XFS_IOC_FSBULKSTAT_SINGLE)\n\t\terror = xfs_bulkstat_one(mp, inlast, bulkreq.ubuffer,\n\t\t\t\t\tsizeof(xfs_bstat_t), NULL, &done);\n\telse\t/* XFS_IOC_FSBULKSTAT */\n\t\terror = xfs_bulkstat(mp, &inlast, &count, xfs_bulkstat_one,\n\t\t\t\t     sizeof(xfs_bstat_t), bulkreq.ubuffer,\n\t\t\t\t     &done);\n\n\tif (error)\n\t\treturn error;\n\n\tif (bulkreq.ocount != NULL) {\n\t\tif (copy_to_user(bulkreq.lastip, &inlast,\n\t\t\t\t\t\tsizeof(xfs_ino_t)))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_to_user(bulkreq.ocount, &count, sizeof(count)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ioc_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "601-736",
    "snippet": "int\nxfs_ioc_space(\n\tstruct xfs_inode\t*ip,\n\tstruct inode\t\t*inode,\n\tstruct file\t\t*filp,\n\tint\t\t\tioflags,\n\tunsigned int\t\tcmd,\n\txfs_flock64_t\t\t*bf)\n{\n\tstruct iattr\t\tiattr;\n\tenum xfs_prealloc_flags\tflags = 0;\n\tuint\t\t\tiolock = XFS_IOLOCK_EXCL;\n\tint\t\t\terror;\n\n\t/*\n\t * Only allow the sys admin to reserve space unless\n\t * unwritten extents are enabled.\n\t */\n\tif (!xfs_sb_version_hasextflgbit(&ip->i_mount->m_sb) &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (inode->i_flags & (S_IMMUTABLE|S_APPEND))\n\t\treturn -EPERM;\n\n\tif (!(filp->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (filp->f_flags & O_DSYNC)\n\t\tflags |= XFS_PREALLOC_SYNC;\n\tif (ioflags & XFS_IO_INVIS)\t\n\t\tflags |= XFS_PREALLOC_INVISIBLE;\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, iolock);\n\terror = xfs_break_layouts(inode, &iolock);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tswitch (bf->l_whence) {\n\tcase 0: /*SEEK_SET*/\n\t\tbreak;\n\tcase 1: /*SEEK_CUR*/\n\t\tbf->l_start += filp->f_pos;\n\t\tbreak;\n\tcase 2: /*SEEK_END*/\n\t\tbf->l_start += XFS_ISIZE(ip);\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * length of <= 0 for resv/unresv/zero is invalid.  length for\n\t * alloc/free is ignored completely and we have no idea what userspace\n\t * might have set it to, so set it to zero to allow range\n\t * checks to pass.\n\t */\n\tswitch (cmd) {\n\tcase XFS_IOC_ZERO_RANGE:\n\tcase XFS_IOC_RESVSP:\n\tcase XFS_IOC_RESVSP64:\n\tcase XFS_IOC_UNRESVSP:\n\tcase XFS_IOC_UNRESVSP64:\n\t\tif (bf->l_len <= 0) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbf->l_len = 0;\n\t\tbreak;\n\t}\n\n\tif (bf->l_start < 0 ||\n\t    bf->l_start > inode->i_sb->s_maxbytes ||\n\t    bf->l_start + bf->l_len < 0 ||\n\t    bf->l_start + bf->l_len >= inode->i_sb->s_maxbytes) {\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase XFS_IOC_ZERO_RANGE:\n\t\tflags |= XFS_PREALLOC_SET;\n\t\terror = xfs_zero_file_space(ip, bf->l_start, bf->l_len);\n\t\tbreak;\n\tcase XFS_IOC_RESVSP:\n\tcase XFS_IOC_RESVSP64:\n\t\tflags |= XFS_PREALLOC_SET;\n\t\terror = xfs_alloc_file_space(ip, bf->l_start, bf->l_len,\n\t\t\t\t\t\tXFS_BMAPI_PREALLOC);\n\t\tbreak;\n\tcase XFS_IOC_UNRESVSP:\n\tcase XFS_IOC_UNRESVSP64:\n\t\terror = xfs_free_file_space(ip, bf->l_start, bf->l_len);\n\t\tbreak;\n\tcase XFS_IOC_ALLOCSP:\n\tcase XFS_IOC_ALLOCSP64:\n\tcase XFS_IOC_FREESP:\n\tcase XFS_IOC_FREESP64:\n\t\tflags |= XFS_PREALLOC_CLEAR;\n\t\tif (bf->l_start > XFS_ISIZE(ip)) {\n\t\t\terror = xfs_alloc_file_space(ip, XFS_ISIZE(ip),\n\t\t\t\t\tbf->l_start - XFS_ISIZE(ip), 0);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tiattr.ia_valid = ATTR_SIZE;\n\t\tiattr.ia_size = bf->l_start;\n\n\t\terror = xfs_setattr_size(ip, &iattr);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tgoto out_unlock;\n\n\terror = xfs_update_prealloc_flags(ip, flags);\n\nout_unlock:\n\txfs_iunlock(ip, iolock);\n\tmnt_drop_write_file(filp);\n\treturn error;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "iolock"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_update_prealloc_flags",
          "args": [
            "ip",
            "flags"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_update_prealloc_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "131-165",
          "snippet": "int\nxfs_update_prealloc_flags(\n\tstruct xfs_inode\t*ip,\n\tenum xfs_prealloc_flags\tflags)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = xfs_trans_alloc(ip->i_mount, XFS_TRANS_WRITEID);\n\terror = xfs_trans_reserve(tp, &M_RES(ip->i_mount)->tr_writeid, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\tif (!(flags & XFS_PREALLOC_INVISIBLE)) {\n\t\tip->i_d.di_mode &= ~S_ISUID;\n\t\tif (ip->i_d.di_mode & S_IXGRP)\n\t\t\tip->i_d.di_mode &= ~S_ISGID;\n\t\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\t}\n\n\tif (flags & XFS_PREALLOC_SET)\n\t\tip->i_d.di_flags |= XFS_DIFLAG_PREALLOC;\n\tif (flags & XFS_PREALLOC_CLEAR)\n\t\tip->i_d.di_flags &= ~XFS_DIFLAG_PREALLOC;\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\tif (flags & XFS_PREALLOC_SYNC)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_update_prealloc_flags(\n\tstruct xfs_inode\t*ip,\n\tenum xfs_prealloc_flags\tflags)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = xfs_trans_alloc(ip->i_mount, XFS_TRANS_WRITEID);\n\terror = xfs_trans_reserve(tp, &M_RES(ip->i_mount)->tr_writeid, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\tif (!(flags & XFS_PREALLOC_INVISIBLE)) {\n\t\tip->i_d.di_mode &= ~S_ISUID;\n\t\tif (ip->i_d.di_mode & S_IXGRP)\n\t\t\tip->i_d.di_mode &= ~S_ISGID;\n\t\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\t}\n\n\tif (flags & XFS_PREALLOC_SET)\n\t\tip->i_d.di_flags |= XFS_DIFLAG_PREALLOC;\n\tif (flags & XFS_PREALLOC_CLEAR)\n\t\tip->i_d.di_flags &= ~XFS_DIFLAG_PREALLOC;\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\tif (flags & XFS_PREALLOC_SYNC)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_setattr_size",
          "args": [
            "ip",
            "&iattr"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setattr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "742-964",
          "snippet": "int\nxfs_setattr_size(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\txfs_off_t\t\toldsize, newsize;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tuint\t\t\tlock_flags = 0;\n\tuint\t\t\tcommit_flags = 0;\n\tbool\t\t\tdid_zeroing = false;\n\n\ttrace_xfs_setattr(ip);\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn -EROFS;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(S_ISREG(ip->i_d.di_mode));\n\tASSERT((iattr->ia_valid & (ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_ATIME_SET|\n\t\tATTR_MTIME_SET|ATTR_KILL_PRIV|ATTR_TIMES_SET)) == 0);\n\n\toldsize = inode->i_size;\n\tnewsize = iattr->ia_size;\n\n\t/*\n\t * Short circuit the truncate case for zero length files.\n\t */\n\tif (newsize == 0 && oldsize == 0 && ip->i_d.di_nextents == 0) {\n\t\tif (!(iattr->ia_valid & (ATTR_CTIME|ATTR_MTIME)))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Use the regular setattr path to update the timestamps.\n\t\t */\n\t\tiattr->ia_valid &= ~ATTR_SIZE;\n\t\treturn xfs_setattr_nonsize(ip, iattr, 0);\n\t}\n\n\t/*\n\t * Make sure that the dquots are attached to the inode.\n\t */\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * File data changes must be complete before we start the transaction to\n\t * modify the inode.  This needs to be done before joining the inode to\n\t * the transaction because the inode cannot be unlocked once it is a\n\t * part of the transaction.\n\t *\n\t * Start with zeroing any data block beyond EOF that we may expose on\n\t * file extension.\n\t */\n\tif (newsize > oldsize) {\n\t\terror = xfs_zero_eof(ip, newsize, oldsize, &did_zeroing);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We are going to log the inode size change in this transaction so\n\t * any previous writes that are beyond the on disk EOF and the new\n\t * EOF that have not been written out need to be written here.  If we\n\t * do not write the data out, we expose ourselves to the null files\n\t * problem. Note that this includes any block zeroing we did above;\n\t * otherwise those blocks may not be zeroed after a crash.\n\t */\n\tif (newsize > ip->i_d.di_size &&\n\t    (oldsize != ip->i_d.di_size || did_zeroing)) {\n\t\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t\t      ip->i_d.di_size, newsize);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* Now wait for all direct I/O to complete. */\n\tinode_dio_wait(inode);\n\n\t/*\n\t * Do all the page cache truncate work outside the transaction context\n\t * as the \"lock\" order is page lock->log space reservation.  i.e.\n\t * locking pages inside the transaction can ABBA deadlock with\n\t * writeback. We have to do the VFS inode size update before we truncate\n\t * the pagecache, however, to avoid racing with page faults beyond the\n\t * new EOF they are not serialised against truncate operations except by\n\t * page locks and size updates.\n\t *\n\t * Hence we are in a situation where a truncate can fail with ENOMEM\n\t * from xfs_trans_reserve(), but having already truncated the in-memory\n\t * version of the file (i.e. made user visible changes). There's not\n\t * much we can do about this, except to hope that the caller sees ENOMEM\n\t * and retries the truncate operation.\n\t */\n\terror = block_truncate_page(inode->i_mapping, newsize, xfs_get_blocks);\n\tif (error)\n\t\treturn error;\n\ttruncate_setsize(inode, newsize);\n\n\t/*\n\t * The \"we can't serialise against page faults\" pain gets worse.\n\t *\n\t * If the file is mapped then we have to clean the page at the old EOF\n\t * when extending the file. Extending the file can expose changes the\n\t * underlying page mapping (e.g. from beyond EOF to a hole or\n\t * unwritten), and so on the next attempt to write to that page we need\n\t * to remap it for write. i.e. we need .page_mkwrite() to be called.\n\t * Hence we need to clean the page to clean the pte and so a new write\n\t * fault will be triggered appropriately.\n\t *\n\t * If we do it before we change the inode size, then we can race with a\n\t * page fault that maps the page with exactly the same problem. If we do\n\t * it after we change the file size, then a new page fault can come in\n\t * and allocate space before we've run the rest of the truncate\n\t * transaction. That's kinda grotesque, but it's better than have data\n\t * over a hole, and so that's the lesser evil that has been chosen here.\n\t *\n\t * The real solution, however, is to have some mechanism for locking out\n\t * page faults while a truncate is in progress.\n\t */\n\tif (newsize > oldsize && mapping_mapped(VFS_I(ip)->i_mapping)) {\n\t\terror = filemap_write_and_wait_range(\n\t\t\t\tVFS_I(ip)->i_mapping,\n\t\t\t\tround_down(oldsize, PAGE_CACHE_SIZE),\n\t\t\t\tround_up(oldsize, PAGE_CACHE_SIZE) - 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tcommit_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tlock_flags |= XFS_ILOCK_EXCL;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Only change the c/mtime if we are changing the size or we are\n\t * explicitly asked to change it.  This handles the semantic difference\n\t * between truncate() and ftruncate() as implemented in the VFS.\n\t *\n\t * The regular truncate() case without ATTR_CTIME and ATTR_MTIME is a\n\t * special case where we need to update the times despite not having\n\t * these flags set.  For all other operations the VFS set these flags\n\t * explicitly if it wants a timestamp update.\n\t */\n\tif (newsize != oldsize &&\n\t    !(iattr->ia_valid & (ATTR_CTIME | ATTR_MTIME))) {\n\t\tiattr->ia_ctime = iattr->ia_mtime =\n\t\t\tcurrent_fs_time(inode->i_sb);\n\t\tiattr->ia_valid |= ATTR_CTIME | ATTR_MTIME;\n\t}\n\n\t/*\n\t * The first thing we do is set the size to new_size permanently on\n\t * disk.  This way we don't have to worry about anyone ever being able\n\t * to look at the data being freed even in the face of a crash.\n\t * What we're getting around here is the case where we free a block, it\n\t * is allocated to another file, it is written to, and then we crash.\n\t * If the new data gets written to the file but the log buffers\n\t * containing the free and reallocation don't, then we'd end up with\n\t * garbage in the blocks being freed.  As long as we make the new size\n\t * permanent before actually freeing any blocks it doesn't matter if\n\t * they get written to.\n\t */\n\tip->i_d.di_size = newsize;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (newsize <= oldsize) {\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, newsize);\n\t\tif (error)\n\t\t\tgoto out_trans_abort;\n\n\t\t/*\n\t\t * Truncated \"down\", so we're removing references to old data\n\t\t * here - if we delay flushing for a long time, we expose\n\t\t * ourselves unduly to the notorious NULL files problem.  So,\n\t\t * we mark this inode and flush it when the file is closed,\n\t\t * and do not wait the usual (long) time for writeout.\n\t\t */\n\t\txfs_iflags_set(ip, XFS_ITRUNCATED);\n\n\t\t/* A truncate down always removes post-EOF blocks. */\n\t\txfs_inode_clear_eofblocks_tag(ip);\n\t}\n\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (iattr->ia_valid & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\nout_unlock:\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\n\treturn error;\n\nout_trans_abort:\n\tcommit_flags |= XFS_TRANS_ABORT;\nout_trans_cancel:\n\txfs_trans_cancel(tp, commit_flags);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_setattr_size(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\txfs_off_t\t\toldsize, newsize;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tuint\t\t\tlock_flags = 0;\n\tuint\t\t\tcommit_flags = 0;\n\tbool\t\t\tdid_zeroing = false;\n\n\ttrace_xfs_setattr(ip);\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn -EROFS;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(S_ISREG(ip->i_d.di_mode));\n\tASSERT((iattr->ia_valid & (ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_ATIME_SET|\n\t\tATTR_MTIME_SET|ATTR_KILL_PRIV|ATTR_TIMES_SET)) == 0);\n\n\toldsize = inode->i_size;\n\tnewsize = iattr->ia_size;\n\n\t/*\n\t * Short circuit the truncate case for zero length files.\n\t */\n\tif (newsize == 0 && oldsize == 0 && ip->i_d.di_nextents == 0) {\n\t\tif (!(iattr->ia_valid & (ATTR_CTIME|ATTR_MTIME)))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Use the regular setattr path to update the timestamps.\n\t\t */\n\t\tiattr->ia_valid &= ~ATTR_SIZE;\n\t\treturn xfs_setattr_nonsize(ip, iattr, 0);\n\t}\n\n\t/*\n\t * Make sure that the dquots are attached to the inode.\n\t */\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * File data changes must be complete before we start the transaction to\n\t * modify the inode.  This needs to be done before joining the inode to\n\t * the transaction because the inode cannot be unlocked once it is a\n\t * part of the transaction.\n\t *\n\t * Start with zeroing any data block beyond EOF that we may expose on\n\t * file extension.\n\t */\n\tif (newsize > oldsize) {\n\t\terror = xfs_zero_eof(ip, newsize, oldsize, &did_zeroing);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We are going to log the inode size change in this transaction so\n\t * any previous writes that are beyond the on disk EOF and the new\n\t * EOF that have not been written out need to be written here.  If we\n\t * do not write the data out, we expose ourselves to the null files\n\t * problem. Note that this includes any block zeroing we did above;\n\t * otherwise those blocks may not be zeroed after a crash.\n\t */\n\tif (newsize > ip->i_d.di_size &&\n\t    (oldsize != ip->i_d.di_size || did_zeroing)) {\n\t\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t\t      ip->i_d.di_size, newsize);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* Now wait for all direct I/O to complete. */\n\tinode_dio_wait(inode);\n\n\t/*\n\t * Do all the page cache truncate work outside the transaction context\n\t * as the \"lock\" order is page lock->log space reservation.  i.e.\n\t * locking pages inside the transaction can ABBA deadlock with\n\t * writeback. We have to do the VFS inode size update before we truncate\n\t * the pagecache, however, to avoid racing with page faults beyond the\n\t * new EOF they are not serialised against truncate operations except by\n\t * page locks and size updates.\n\t *\n\t * Hence we are in a situation where a truncate can fail with ENOMEM\n\t * from xfs_trans_reserve(), but having already truncated the in-memory\n\t * version of the file (i.e. made user visible changes). There's not\n\t * much we can do about this, except to hope that the caller sees ENOMEM\n\t * and retries the truncate operation.\n\t */\n\terror = block_truncate_page(inode->i_mapping, newsize, xfs_get_blocks);\n\tif (error)\n\t\treturn error;\n\ttruncate_setsize(inode, newsize);\n\n\t/*\n\t * The \"we can't serialise against page faults\" pain gets worse.\n\t *\n\t * If the file is mapped then we have to clean the page at the old EOF\n\t * when extending the file. Extending the file can expose changes the\n\t * underlying page mapping (e.g. from beyond EOF to a hole or\n\t * unwritten), and so on the next attempt to write to that page we need\n\t * to remap it for write. i.e. we need .page_mkwrite() to be called.\n\t * Hence we need to clean the page to clean the pte and so a new write\n\t * fault will be triggered appropriately.\n\t *\n\t * If we do it before we change the inode size, then we can race with a\n\t * page fault that maps the page with exactly the same problem. If we do\n\t * it after we change the file size, then a new page fault can come in\n\t * and allocate space before we've run the rest of the truncate\n\t * transaction. That's kinda grotesque, but it's better than have data\n\t * over a hole, and so that's the lesser evil that has been chosen here.\n\t *\n\t * The real solution, however, is to have some mechanism for locking out\n\t * page faults while a truncate is in progress.\n\t */\n\tif (newsize > oldsize && mapping_mapped(VFS_I(ip)->i_mapping)) {\n\t\terror = filemap_write_and_wait_range(\n\t\t\t\tVFS_I(ip)->i_mapping,\n\t\t\t\tround_down(oldsize, PAGE_CACHE_SIZE),\n\t\t\t\tround_up(oldsize, PAGE_CACHE_SIZE) - 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tcommit_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tlock_flags |= XFS_ILOCK_EXCL;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Only change the c/mtime if we are changing the size or we are\n\t * explicitly asked to change it.  This handles the semantic difference\n\t * between truncate() and ftruncate() as implemented in the VFS.\n\t *\n\t * The regular truncate() case without ATTR_CTIME and ATTR_MTIME is a\n\t * special case where we need to update the times despite not having\n\t * these flags set.  For all other operations the VFS set these flags\n\t * explicitly if it wants a timestamp update.\n\t */\n\tif (newsize != oldsize &&\n\t    !(iattr->ia_valid & (ATTR_CTIME | ATTR_MTIME))) {\n\t\tiattr->ia_ctime = iattr->ia_mtime =\n\t\t\tcurrent_fs_time(inode->i_sb);\n\t\tiattr->ia_valid |= ATTR_CTIME | ATTR_MTIME;\n\t}\n\n\t/*\n\t * The first thing we do is set the size to new_size permanently on\n\t * disk.  This way we don't have to worry about anyone ever being able\n\t * to look at the data being freed even in the face of a crash.\n\t * What we're getting around here is the case where we free a block, it\n\t * is allocated to another file, it is written to, and then we crash.\n\t * If the new data gets written to the file but the log buffers\n\t * containing the free and reallocation don't, then we'd end up with\n\t * garbage in the blocks being freed.  As long as we make the new size\n\t * permanent before actually freeing any blocks it doesn't matter if\n\t * they get written to.\n\t */\n\tip->i_d.di_size = newsize;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (newsize <= oldsize) {\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, newsize);\n\t\tif (error)\n\t\t\tgoto out_trans_abort;\n\n\t\t/*\n\t\t * Truncated \"down\", so we're removing references to old data\n\t\t * here - if we delay flushing for a long time, we expose\n\t\t * ourselves unduly to the notorious NULL files problem.  So,\n\t\t * we mark this inode and flush it when the file is closed,\n\t\t * and do not wait the usual (long) time for writeout.\n\t\t */\n\t\txfs_iflags_set(ip, XFS_ITRUNCATED);\n\n\t\t/* A truncate down always removes post-EOF blocks. */\n\t\txfs_inode_clear_eofblocks_tag(ip);\n\t}\n\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (iattr->ia_valid & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\nout_unlock:\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\n\treturn error;\n\nout_trans_abort:\n\tcommit_flags |= XFS_TRANS_ABORT;\nout_trans_cancel:\n\txfs_trans_cancel(tp, commit_flags);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_file_space",
          "args": [
            "ip",
            "XFS_ISIZE(ip)",
            "bf->l_start - XFS_ISIZE(ip)",
            "0"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_file_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "928-1083",
          "snippet": "int\nxfs_alloc_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen,\n\tint\t\t\talloc_type)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\txfs_off_t\t\tcount;\n\txfs_filblks_t\t\tallocated_fsb;\n\txfs_filblks_t\t\tallocatesize_fsb;\n\txfs_extlen_t\t\textsz, temp;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_fsblock_t\t\tfirstfsb;\n\tint\t\t\tnimaps;\n\tint\t\t\tquota_flag;\n\tint\t\t\trt;\n\txfs_trans_t\t\t*tp;\n\txfs_bmbt_irec_t\t\timaps[1], *imapp;\n\txfs_bmap_free_t\t\tfree_list;\n\tuint\t\t\tqblocks, resblks, resrtextents;\n\tint\t\t\tcommitted;\n\tint\t\t\terror;\n\n\ttrace_xfs_alloc_file_space(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\trt = XFS_IS_REALTIME_INODE(ip);\n\textsz = xfs_get_extsz_hint(ip);\n\n\tcount = len;\n\timapp = &imaps[0];\n\tnimaps = 1;\n\tstartoffset_fsb\t= XFS_B_TO_FSBT(mp, offset);\n\tallocatesize_fsb = XFS_B_TO_FSB(mp, count);\n\n\t/*\n\t * Allocate file space until done or until there is an error\n\t */\n\twhile (allocatesize_fsb && !error) {\n\t\txfs_fileoff_t\ts, e;\n\n\t\t/*\n\t\t * Determine space reservations for data/realtime.\n\t\t */\n\t\tif (unlikely(extsz)) {\n\t\t\ts = startoffset_fsb;\n\t\t\tdo_div(s, extsz);\n\t\t\ts *= extsz;\n\t\t\te = startoffset_fsb + allocatesize_fsb;\n\t\t\tif ((temp = do_mod(startoffset_fsb, extsz)))\n\t\t\t\te += temp;\n\t\t\tif ((temp = do_mod(e, extsz)))\n\t\t\t\te += extsz - temp;\n\t\t} else {\n\t\t\ts = 0;\n\t\t\te = allocatesize_fsb;\n\t\t}\n\n\t\t/*\n\t\t * The transaction reservation is limited to a 32-bit block\n\t\t * count, hence we need to limit the number of blocks we are\n\t\t * trying to reserve to avoid an overflow. We can't allocate\n\t\t * more than @nimaps extents, and an extent is limited on disk\n\t\t * to MAXEXTLEN (21 bits), so use that to enforce the limit.\n\t\t */\n\t\tresblks = min_t(xfs_fileoff_t, (e - s), (MAXEXTLEN * nimaps));\n\t\tif (unlikely(rt)) {\n\t\t\tresrtextents = qblocks = resblks;\n\t\t\tresrtextents /= mp->m_sb.sb_rextsize;\n\t\t\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\t\t\tquota_flag = XFS_QMOPT_RES_RTBLKS;\n\t\t} else {\n\t\t\tresrtextents = 0;\n\t\t\tresblks = qblocks = XFS_DIOSTRAT_SPACE_RES(mp, resblks);\n\t\t\tquota_flag = XFS_QMOPT_RES_REGBLKS;\n\t\t}\n\n\t\t/*\n\t\t * Allocate and setup the transaction.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\t\t  resblks, resrtextents);\n\t\t/*\n\t\t * Check for running out of space\n\t\t */\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Free the transaction structure.\n\t\t\t */\n\t\t\tASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota_nblks(tp, ip, qblocks,\n\t\t\t\t\t\t      0, quota_flag);\n\t\tif (error)\n\t\t\tgoto error1;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\terror = xfs_bmapi_write(tp, ip, startoffset_fsb,\n\t\t\t\t\tallocatesize_fsb, alloc_type, &firstfsb,\n\t\t\t\t\t0, imapp, &nimaps, &free_list);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/*\n\t\t * Complete the transaction\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error) {\n\t\t\tbreak;\n\t\t}\n\n\t\tallocated_fsb = imapp->br_blockcount;\n\n\t\tif (nimaps == 0) {\n\t\t\terror = -ENOSPC;\n\t\t\tbreak;\n\t\t}\n\n\t\tstartoffset_fsb += allocated_fsb;\n\t\tallocatesize_fsb -= allocated_fsb;\n\t}\n\n\treturn error;\n\nerror0:\t/* Cancel bmap, unlock inode, unreserve quota blocks, cancel trans */\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_unreserve_quota_nblks(tp, ip, (long)qblocks, 0, quota_flag);\n\nerror1:\t/* Just cancel transaction */\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_alloc_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen,\n\tint\t\t\talloc_type)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\txfs_off_t\t\tcount;\n\txfs_filblks_t\t\tallocated_fsb;\n\txfs_filblks_t\t\tallocatesize_fsb;\n\txfs_extlen_t\t\textsz, temp;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_fsblock_t\t\tfirstfsb;\n\tint\t\t\tnimaps;\n\tint\t\t\tquota_flag;\n\tint\t\t\trt;\n\txfs_trans_t\t\t*tp;\n\txfs_bmbt_irec_t\t\timaps[1], *imapp;\n\txfs_bmap_free_t\t\tfree_list;\n\tuint\t\t\tqblocks, resblks, resrtextents;\n\tint\t\t\tcommitted;\n\tint\t\t\terror;\n\n\ttrace_xfs_alloc_file_space(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\trt = XFS_IS_REALTIME_INODE(ip);\n\textsz = xfs_get_extsz_hint(ip);\n\n\tcount = len;\n\timapp = &imaps[0];\n\tnimaps = 1;\n\tstartoffset_fsb\t= XFS_B_TO_FSBT(mp, offset);\n\tallocatesize_fsb = XFS_B_TO_FSB(mp, count);\n\n\t/*\n\t * Allocate file space until done or until there is an error\n\t */\n\twhile (allocatesize_fsb && !error) {\n\t\txfs_fileoff_t\ts, e;\n\n\t\t/*\n\t\t * Determine space reservations for data/realtime.\n\t\t */\n\t\tif (unlikely(extsz)) {\n\t\t\ts = startoffset_fsb;\n\t\t\tdo_div(s, extsz);\n\t\t\ts *= extsz;\n\t\t\te = startoffset_fsb + allocatesize_fsb;\n\t\t\tif ((temp = do_mod(startoffset_fsb, extsz)))\n\t\t\t\te += temp;\n\t\t\tif ((temp = do_mod(e, extsz)))\n\t\t\t\te += extsz - temp;\n\t\t} else {\n\t\t\ts = 0;\n\t\t\te = allocatesize_fsb;\n\t\t}\n\n\t\t/*\n\t\t * The transaction reservation is limited to a 32-bit block\n\t\t * count, hence we need to limit the number of blocks we are\n\t\t * trying to reserve to avoid an overflow. We can't allocate\n\t\t * more than @nimaps extents, and an extent is limited on disk\n\t\t * to MAXEXTLEN (21 bits), so use that to enforce the limit.\n\t\t */\n\t\tresblks = min_t(xfs_fileoff_t, (e - s), (MAXEXTLEN * nimaps));\n\t\tif (unlikely(rt)) {\n\t\t\tresrtextents = qblocks = resblks;\n\t\t\tresrtextents /= mp->m_sb.sb_rextsize;\n\t\t\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\t\t\tquota_flag = XFS_QMOPT_RES_RTBLKS;\n\t\t} else {\n\t\t\tresrtextents = 0;\n\t\t\tresblks = qblocks = XFS_DIOSTRAT_SPACE_RES(mp, resblks);\n\t\t\tquota_flag = XFS_QMOPT_RES_REGBLKS;\n\t\t}\n\n\t\t/*\n\t\t * Allocate and setup the transaction.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\t\t  resblks, resrtextents);\n\t\t/*\n\t\t * Check for running out of space\n\t\t */\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Free the transaction structure.\n\t\t\t */\n\t\t\tASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota_nblks(tp, ip, qblocks,\n\t\t\t\t\t\t      0, quota_flag);\n\t\tif (error)\n\t\t\tgoto error1;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\terror = xfs_bmapi_write(tp, ip, startoffset_fsb,\n\t\t\t\t\tallocatesize_fsb, alloc_type, &firstfsb,\n\t\t\t\t\t0, imapp, &nimaps, &free_list);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/*\n\t\t * Complete the transaction\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error) {\n\t\t\tbreak;\n\t\t}\n\n\t\tallocated_fsb = imapp->br_blockcount;\n\n\t\tif (nimaps == 0) {\n\t\t\terror = -ENOSPC;\n\t\t\tbreak;\n\t\t}\n\n\t\tstartoffset_fsb += allocated_fsb;\n\t\tallocatesize_fsb -= allocated_fsb;\n\t}\n\n\treturn error;\n\nerror0:\t/* Cancel bmap, unlock inode, unreserve quota blocks, cancel trans */\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_unreserve_quota_nblks(tp, ip, (long)qblocks, 0, quota_flag);\n\nerror1:\t/* Just cancel transaction */\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ISIZE",
          "args": [
            "ip"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_free_file_space",
          "args": [
            "ip",
            "bf->l_start",
            "bf->l_len"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_file_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "1165-1336",
          "snippet": "int\nxfs_free_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tint\t\t\tcommitted;\n\tint\t\t\tdone;\n\txfs_fileoff_t\t\tendoffset_fsb;\n\tint\t\t\terror;\n\txfs_fsblock_t\t\tfirstfsb;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_bmbt_irec_t\t\timap;\n\txfs_off_t\t\tioffset;\n\txfs_off_t\t\tiendoffset;\n\txfs_extlen_t\t\tmod=0;\n\txfs_mount_t\t\t*mp;\n\tint\t\t\tnimap;\n\tuint\t\t\tresblks;\n\txfs_off_t\t\trounding;\n\tint\t\t\trt;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_trans_t\t\t*tp;\n\n\tmp = ip->i_mount;\n\n\ttrace_xfs_free_file_space(ip);\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = 0;\n\tif (len <= 0)\t/* if nothing being freed */\n\t\treturn error;\n\trt = XFS_IS_REALTIME_INODE(ip);\n\tstartoffset_fsb\t= XFS_B_TO_FSB(mp, offset);\n\tendoffset_fsb = XFS_B_TO_FSBT(mp, offset + len);\n\n\t/* wait for the completion of any pending DIOs */\n\tinode_dio_wait(VFS_I(ip));\n\n\trounding = max_t(xfs_off_t, 1 << mp->m_sb.sb_blocklog, PAGE_CACHE_SIZE);\n\tioffset = round_down(offset, rounding);\n\tiendoffset = round_up(offset + len, rounding) - 1;\n\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping, ioffset,\n\t\t\t\t\t     iendoffset);\n\tif (error)\n\t\tgoto out;\n\ttruncate_pagecache_range(VFS_I(ip), ioffset, iendoffset);\n\n\t/*\n\t * Need to zero the stuff we're not freeing, on disk.\n\t * If it's a realtime file & can't use unwritten extents then we\n\t * actually need to zero the extent edges.  Otherwise xfs_bunmapi\n\t * will take care of it for us.\n\t */\n\tif (rt && !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, startoffset_fsb, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\txfs_daddr_t\tblock;\n\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tblock = imap.br_startblock;\n\t\t\tmod = do_div(block, mp->m_sb.sb_rextsize);\n\t\t\tif (mod)\n\t\t\t\tstartoffset_fsb += mp->m_sb.sb_rextsize - mod;\n\t\t}\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, endoffset_fsb - 1, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tmod++;\n\t\t\tif (mod && (mod != mp->m_sb.sb_rextsize))\n\t\t\t\tendoffset_fsb -= mod;\n\t\t}\n\t}\n\tif ((done = (endoffset_fsb <= startoffset_fsb)))\n\t\t/*\n\t\t * One contiguous piece to clear\n\t\t */\n\t\terror = xfs_zero_remaining_bytes(ip, offset, offset + len - 1);\n\telse {\n\t\t/*\n\t\t * Some full blocks, possibly two pieces to clear\n\t\t */\n\t\tif (offset < XFS_FSB_TO_B(mp, startoffset_fsb))\n\t\t\terror = xfs_zero_remaining_bytes(ip, offset,\n\t\t\t\tXFS_FSB_TO_B(mp, startoffset_fsb) - 1);\n\t\tif (!error &&\n\t\t    XFS_FSB_TO_B(mp, endoffset_fsb) < offset + len)\n\t\t\terror = xfs_zero_remaining_bytes(ip,\n\t\t\t\tXFS_FSB_TO_B(mp, endoffset_fsb),\n\t\t\t\toffset + len - 1);\n\t}\n\n\t/*\n\t * free file space until done or until there is an error\n\t */\n\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\twhile (!error && !done) {\n\n\t\t/*\n\t\t * allocate and setup the transaction. Allow this\n\t\t * transaction to dip into the reserve blocks to ensure\n\t\t * the freeing of the space succeeds at ENOSPC.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write, resblks, 0);\n\n\t\t/*\n\t\t * check for running out of space\n\t\t */\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Free the transaction structure.\n\t\t\t */\n\t\t\tASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota(tp, mp,\n\t\t\t\tip->i_udquot, ip->i_gdquot, ip->i_pdquot,\n\t\t\t\tresblks, 0, XFS_QMOPT_RES_REGBLKS);\n\t\tif (error)\n\t\t\tgoto error1;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * issue the bunmapi() call to free the blocks\n\t\t */\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\terror = xfs_bunmapi(tp, ip, startoffset_fsb,\n\t\t\t\t  endoffset_fsb - startoffset_fsb,\n\t\t\t\t  0, 2, &firstfsb, &free_list, &done);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/*\n\t\t * complete the transaction\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t}\n\n out:\n\treturn error;\n\n error0:\n\txfs_bmap_cancel(&free_list);\n error1:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\tgoto out;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_free_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tint\t\t\tcommitted;\n\tint\t\t\tdone;\n\txfs_fileoff_t\t\tendoffset_fsb;\n\tint\t\t\terror;\n\txfs_fsblock_t\t\tfirstfsb;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_bmbt_irec_t\t\timap;\n\txfs_off_t\t\tioffset;\n\txfs_off_t\t\tiendoffset;\n\txfs_extlen_t\t\tmod=0;\n\txfs_mount_t\t\t*mp;\n\tint\t\t\tnimap;\n\tuint\t\t\tresblks;\n\txfs_off_t\t\trounding;\n\tint\t\t\trt;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_trans_t\t\t*tp;\n\n\tmp = ip->i_mount;\n\n\ttrace_xfs_free_file_space(ip);\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = 0;\n\tif (len <= 0)\t/* if nothing being freed */\n\t\treturn error;\n\trt = XFS_IS_REALTIME_INODE(ip);\n\tstartoffset_fsb\t= XFS_B_TO_FSB(mp, offset);\n\tendoffset_fsb = XFS_B_TO_FSBT(mp, offset + len);\n\n\t/* wait for the completion of any pending DIOs */\n\tinode_dio_wait(VFS_I(ip));\n\n\trounding = max_t(xfs_off_t, 1 << mp->m_sb.sb_blocklog, PAGE_CACHE_SIZE);\n\tioffset = round_down(offset, rounding);\n\tiendoffset = round_up(offset + len, rounding) - 1;\n\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping, ioffset,\n\t\t\t\t\t     iendoffset);\n\tif (error)\n\t\tgoto out;\n\ttruncate_pagecache_range(VFS_I(ip), ioffset, iendoffset);\n\n\t/*\n\t * Need to zero the stuff we're not freeing, on disk.\n\t * If it's a realtime file & can't use unwritten extents then we\n\t * actually need to zero the extent edges.  Otherwise xfs_bunmapi\n\t * will take care of it for us.\n\t */\n\tif (rt && !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, startoffset_fsb, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\txfs_daddr_t\tblock;\n\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tblock = imap.br_startblock;\n\t\t\tmod = do_div(block, mp->m_sb.sb_rextsize);\n\t\t\tif (mod)\n\t\t\t\tstartoffset_fsb += mp->m_sb.sb_rextsize - mod;\n\t\t}\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, endoffset_fsb - 1, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tmod++;\n\t\t\tif (mod && (mod != mp->m_sb.sb_rextsize))\n\t\t\t\tendoffset_fsb -= mod;\n\t\t}\n\t}\n\tif ((done = (endoffset_fsb <= startoffset_fsb)))\n\t\t/*\n\t\t * One contiguous piece to clear\n\t\t */\n\t\terror = xfs_zero_remaining_bytes(ip, offset, offset + len - 1);\n\telse {\n\t\t/*\n\t\t * Some full blocks, possibly two pieces to clear\n\t\t */\n\t\tif (offset < XFS_FSB_TO_B(mp, startoffset_fsb))\n\t\t\terror = xfs_zero_remaining_bytes(ip, offset,\n\t\t\t\tXFS_FSB_TO_B(mp, startoffset_fsb) - 1);\n\t\tif (!error &&\n\t\t    XFS_FSB_TO_B(mp, endoffset_fsb) < offset + len)\n\t\t\terror = xfs_zero_remaining_bytes(ip,\n\t\t\t\tXFS_FSB_TO_B(mp, endoffset_fsb),\n\t\t\t\toffset + len - 1);\n\t}\n\n\t/*\n\t * free file space until done or until there is an error\n\t */\n\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\twhile (!error && !done) {\n\n\t\t/*\n\t\t * allocate and setup the transaction. Allow this\n\t\t * transaction to dip into the reserve blocks to ensure\n\t\t * the freeing of the space succeeds at ENOSPC.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write, resblks, 0);\n\n\t\t/*\n\t\t * check for running out of space\n\t\t */\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Free the transaction structure.\n\t\t\t */\n\t\t\tASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota(tp, mp,\n\t\t\t\tip->i_udquot, ip->i_gdquot, ip->i_pdquot,\n\t\t\t\tresblks, 0, XFS_QMOPT_RES_REGBLKS);\n\t\tif (error)\n\t\t\tgoto error1;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * issue the bunmapi() call to free the blocks\n\t\t */\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\terror = xfs_bunmapi(tp, ip, startoffset_fsb,\n\t\t\t\t  endoffset_fsb - startoffset_fsb,\n\t\t\t\t  0, 2, &firstfsb, &free_list, &done);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/*\n\t\t * complete the transaction\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t}\n\n out:\n\treturn error;\n\n error0:\n\txfs_bmap_cancel(&free_list);\n error1:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_zero_file_space",
          "args": [
            "ip",
            "bf->l_start",
            "bf->l_len"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_zero_file_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "1342-1376",
          "snippet": "int\nxfs_zero_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\tblksize;\n\tint\t\t\terror;\n\n\ttrace_xfs_zero_file_space(ip);\n\n\tblksize = 1 << mp->m_sb.sb_blocklog;\n\n\t/*\n\t * Punch a hole and prealloc the range. We use hole punch rather than\n\t * unwritten extent conversion for two reasons:\n\t *\n\t * 1.) Hole punch handles partial block zeroing for us.\n\t *\n\t * 2.) If prealloc returns ENOSPC, the file range is still zero-valued\n\t * by virtue of the hole punch.\n\t */\n\terror = xfs_free_file_space(ip, offset, len);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_alloc_file_space(ip, round_down(offset, blksize),\n\t\t\t\t     round_up(offset + len, blksize) -\n\t\t\t\t     round_down(offset, blksize),\n\t\t\t\t     XFS_BMAPI_PREALLOC);\nout:\n\treturn error;\n\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_zero_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\tblksize;\n\tint\t\t\terror;\n\n\ttrace_xfs_zero_file_space(ip);\n\n\tblksize = 1 << mp->m_sb.sb_blocklog;\n\n\t/*\n\t * Punch a hole and prealloc the range. We use hole punch rather than\n\t * unwritten extent conversion for two reasons:\n\t *\n\t * 1.) Hole punch handles partial block zeroing for us.\n\t *\n\t * 2.) If prealloc returns ENOSPC, the file range is still zero-valued\n\t * by virtue of the hole punch.\n\t */\n\terror = xfs_free_file_space(ip, offset, len);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_alloc_file_space(ip, round_down(offset, blksize),\n\t\t\t\t     round_up(offset + len, blksize) -\n\t\t\t\t     round_down(offset, blksize),\n\t\t\t\t     XFS_BMAPI_PREALLOC);\nout:\n\treturn error;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_break_layouts",
          "args": [
            "inode",
            "&iolock"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_break_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_pnfs.h",
          "lines": "13-16",
          "snippet": "static inline int xfs_break_layouts(struct inode *inode, uint *iolock)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_break_layouts(struct inode *inode, uint *iolock)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "iolock"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasextflgbit",
          "args": [
            "&ip->i_mount->m_sb"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasextflgbit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "416-420",
          "snippet": "static inline bool xfs_sb_version_hasextflgbit(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_EXTFLGBIT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_EXTFLGBIT\t0x1000",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_EXTFLGBIT\t0x1000\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_hasextflgbit(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_EXTFLGBIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_ioc_space(\n\tstruct xfs_inode\t*ip,\n\tstruct inode\t\t*inode,\n\tstruct file\t\t*filp,\n\tint\t\t\tioflags,\n\tunsigned int\t\tcmd,\n\txfs_flock64_t\t\t*bf)\n{\n\tstruct iattr\t\tiattr;\n\tenum xfs_prealloc_flags\tflags = 0;\n\tuint\t\t\tiolock = XFS_IOLOCK_EXCL;\n\tint\t\t\terror;\n\n\t/*\n\t * Only allow the sys admin to reserve space unless\n\t * unwritten extents are enabled.\n\t */\n\tif (!xfs_sb_version_hasextflgbit(&ip->i_mount->m_sb) &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (inode->i_flags & (S_IMMUTABLE|S_APPEND))\n\t\treturn -EPERM;\n\n\tif (!(filp->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (filp->f_flags & O_DSYNC)\n\t\tflags |= XFS_PREALLOC_SYNC;\n\tif (ioflags & XFS_IO_INVIS)\t\n\t\tflags |= XFS_PREALLOC_INVISIBLE;\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, iolock);\n\terror = xfs_break_layouts(inode, &iolock);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tswitch (bf->l_whence) {\n\tcase 0: /*SEEK_SET*/\n\t\tbreak;\n\tcase 1: /*SEEK_CUR*/\n\t\tbf->l_start += filp->f_pos;\n\t\tbreak;\n\tcase 2: /*SEEK_END*/\n\t\tbf->l_start += XFS_ISIZE(ip);\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * length of <= 0 for resv/unresv/zero is invalid.  length for\n\t * alloc/free is ignored completely and we have no idea what userspace\n\t * might have set it to, so set it to zero to allow range\n\t * checks to pass.\n\t */\n\tswitch (cmd) {\n\tcase XFS_IOC_ZERO_RANGE:\n\tcase XFS_IOC_RESVSP:\n\tcase XFS_IOC_RESVSP64:\n\tcase XFS_IOC_UNRESVSP:\n\tcase XFS_IOC_UNRESVSP64:\n\t\tif (bf->l_len <= 0) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbf->l_len = 0;\n\t\tbreak;\n\t}\n\n\tif (bf->l_start < 0 ||\n\t    bf->l_start > inode->i_sb->s_maxbytes ||\n\t    bf->l_start + bf->l_len < 0 ||\n\t    bf->l_start + bf->l_len >= inode->i_sb->s_maxbytes) {\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase XFS_IOC_ZERO_RANGE:\n\t\tflags |= XFS_PREALLOC_SET;\n\t\terror = xfs_zero_file_space(ip, bf->l_start, bf->l_len);\n\t\tbreak;\n\tcase XFS_IOC_RESVSP:\n\tcase XFS_IOC_RESVSP64:\n\t\tflags |= XFS_PREALLOC_SET;\n\t\terror = xfs_alloc_file_space(ip, bf->l_start, bf->l_len,\n\t\t\t\t\t\tXFS_BMAPI_PREALLOC);\n\t\tbreak;\n\tcase XFS_IOC_UNRESVSP:\n\tcase XFS_IOC_UNRESVSP64:\n\t\terror = xfs_free_file_space(ip, bf->l_start, bf->l_len);\n\t\tbreak;\n\tcase XFS_IOC_ALLOCSP:\n\tcase XFS_IOC_ALLOCSP64:\n\tcase XFS_IOC_FREESP:\n\tcase XFS_IOC_FREESP64:\n\t\tflags |= XFS_PREALLOC_CLEAR;\n\t\tif (bf->l_start > XFS_ISIZE(ip)) {\n\t\t\terror = xfs_alloc_file_space(ip, XFS_ISIZE(ip),\n\t\t\t\t\tbf->l_start - XFS_ISIZE(ip), 0);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tiattr.ia_valid = ATTR_SIZE;\n\t\tiattr.ia_size = bf->l_start;\n\n\t\terror = xfs_setattr_size(ip, &iattr);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tgoto out_unlock;\n\n\terror = xfs_update_prealloc_flags(ip, flags);\n\nout_unlock:\n\txfs_iunlock(ip, iolock);\n\tmnt_drop_write_file(filp);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_attrmulti_by_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "509-599",
    "snippet": "STATIC int\nxfs_attrmulti_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror;\n\txfs_attr_multiop_t\t*ops;\n\txfs_fsop_attrmulti_handlereq_t am_hreq;\n\tstruct dentry\t\t*dentry;\n\tunsigned int\t\ti, size;\n\tunsigned char\t\t*attr_name;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&am_hreq, arg, sizeof(xfs_fsop_attrmulti_handlereq_t)))\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (am_hreq.opcount >= INT_MAX / sizeof(xfs_attr_multiop_t))\n\t\treturn -E2BIG;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &am_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terror = -E2BIG;\n\tsize = am_hreq.opcount * sizeof(xfs_attr_multiop_t);\n\tif (!size || size > 16 * PAGE_SIZE)\n\t\tgoto out_dput;\n\n\tops = memdup_user(am_hreq.ops, size);\n\tif (IS_ERR(ops)) {\n\t\terror = PTR_ERR(ops);\n\t\tgoto out_dput;\n\t}\n\n\terror = -ENOMEM;\n\tattr_name = kmalloc(MAXNAMELEN, GFP_KERNEL);\n\tif (!attr_name)\n\t\tgoto out_kfree_ops;\n\n\terror = 0;\n\tfor (i = 0; i < am_hreq.opcount; i++) {\n\t\tops[i].am_error = strncpy_from_user((char *)attr_name,\n\t\t\t\tops[i].am_attrname, MAXNAMELEN);\n\t\tif (ops[i].am_error == 0 || ops[i].am_error == MAXNAMELEN)\n\t\t\terror = -ERANGE;\n\t\tif (ops[i].am_error < 0)\n\t\t\tbreak;\n\n\t\tswitch (ops[i].am_opcode) {\n\t\tcase ATTR_OP_GET:\n\t\t\tops[i].am_error = xfs_attrmulti_attr_get(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tops[i].am_attrvalue, &ops[i].am_length,\n\t\t\t\t\tops[i].am_flags);\n\t\t\tbreak;\n\t\tcase ATTR_OP_SET:\n\t\t\tops[i].am_error = mnt_want_write_file(parfilp);\n\t\t\tif (ops[i].am_error)\n\t\t\t\tbreak;\n\t\t\tops[i].am_error = xfs_attrmulti_attr_set(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tops[i].am_attrvalue, ops[i].am_length,\n\t\t\t\t\tops[i].am_flags);\n\t\t\tmnt_drop_write_file(parfilp);\n\t\t\tbreak;\n\t\tcase ATTR_OP_REMOVE:\n\t\t\tops[i].am_error = mnt_want_write_file(parfilp);\n\t\t\tif (ops[i].am_error)\n\t\t\t\tbreak;\n\t\t\tops[i].am_error = xfs_attrmulti_attr_remove(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tops[i].am_flags);\n\t\t\tmnt_drop_write_file(parfilp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tops[i].am_error = -EINVAL;\n\t\t}\n\t}\n\n\tif (copy_to_user(am_hreq.ops, ops, size))\n\t\terror = -EFAULT;\n\n\tkfree(attr_name);\n out_kfree_ops:\n\tkfree(ops);\n out_dput:\n\tdput(dentry);\n\treturn error;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ops"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "attr_name"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "am_hreq.ops",
            "ops",
            "size"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "parfilp"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attrmulti_attr_remove",
          "args": [
            "dentry->d_inode",
            "attr_name",
            "ops[i].am_flags"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attrmulti_attr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "498-507",
          "snippet": "int\nxfs_attrmulti_attr_remove(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\t__uint32_t\t\tflags)\n{\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\treturn xfs_attr_remove(XFS_I(inode), name, flags);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_attrmulti_attr_remove(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\t__uint32_t\t\tflags)\n{\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\treturn xfs_attr_remove(XFS_I(inode), name, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "parfilp"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attrmulti_attr_set",
          "args": [
            "dentry->d_inode",
            "attr_name",
            "ops[i].am_attrvalue",
            "ops[i].am_length",
            "ops[i].am_flags"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attrmulti_attr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "476-496",
          "snippet": "int\nxfs_attrmulti_attr_set(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tconst unsigned char\t__user *ubuf,\n\t__uint32_t\t\tlen,\n\t__uint32_t\t\tflags)\n{\n\tunsigned char\t\t*kbuf;\n\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (len > XATTR_SIZE_MAX)\n\t\treturn -EINVAL;\n\n\tkbuf = memdup_user(ubuf, len);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\treturn xfs_attr_set(XFS_I(inode), name, kbuf, len, flags);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_attrmulti_attr_set(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tconst unsigned char\t__user *ubuf,\n\t__uint32_t\t\tlen,\n\t__uint32_t\t\tflags)\n{\n\tunsigned char\t\t*kbuf;\n\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (len > XATTR_SIZE_MAX)\n\t\treturn -EINVAL;\n\n\tkbuf = memdup_user(ubuf, len);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\treturn xfs_attr_set(XFS_I(inode), name, kbuf, len, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attrmulti_attr_get",
          "args": [
            "dentry->d_inode",
            "attr_name",
            "ops[i].am_attrvalue",
            "&ops[i].am_length",
            "ops[i].am_flags"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attrmulti_attr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "447-474",
          "snippet": "int\nxfs_attrmulti_attr_get(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tunsigned char\t\t__user *ubuf,\n\t__uint32_t\t\t*len,\n\t__uint32_t\t\tflags)\n{\n\tunsigned char\t\t*kbuf;\n\tint\t\t\terror = -EFAULT;\n\n\tif (*len > XATTR_SIZE_MAX)\n\t\treturn -EINVAL;\n\tkbuf = kmem_zalloc_large(*len, KM_SLEEP);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\terror = xfs_attr_get(XFS_I(inode), name, kbuf, (int *)len, flags);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(ubuf, kbuf, *len))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_attrmulti_attr_get(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tunsigned char\t\t__user *ubuf,\n\t__uint32_t\t\t*len,\n\t__uint32_t\t\tflags)\n{\n\tunsigned char\t\t*kbuf;\n\tint\t\t\terror = -EFAULT;\n\n\tif (*len > XATTR_SIZE_MAX)\n\t\treturn -EINVAL;\n\tkbuf = kmem_zalloc_large(*len, KM_SLEEP);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\terror = xfs_attr_get(XFS_I(inode), name, kbuf, (int *)len, flags);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(ubuf, kbuf, *len))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "(char *)attr_name",
            "ops[i].am_attrname",
            "MAXNAMELEN"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "MAXNAMELEN",
            "GFP_KERNEL"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ops"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ops"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "am_hreq.ops",
            "size"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_handlereq_to_dentry",
          "args": [
            "parfilp",
            "&am_hreq.hreq"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_handlereq_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "184-190",
          "snippet": "dentry *\nxfs_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\ndentry *\nxfs_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&am_hreq",
            "arg",
            "sizeof(xfs_fsop_attrmulti_handlereq_t)"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_attrmulti_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror;\n\txfs_attr_multiop_t\t*ops;\n\txfs_fsop_attrmulti_handlereq_t am_hreq;\n\tstruct dentry\t\t*dentry;\n\tunsigned int\t\ti, size;\n\tunsigned char\t\t*attr_name;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&am_hreq, arg, sizeof(xfs_fsop_attrmulti_handlereq_t)))\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (am_hreq.opcount >= INT_MAX / sizeof(xfs_attr_multiop_t))\n\t\treturn -E2BIG;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &am_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terror = -E2BIG;\n\tsize = am_hreq.opcount * sizeof(xfs_attr_multiop_t);\n\tif (!size || size > 16 * PAGE_SIZE)\n\t\tgoto out_dput;\n\n\tops = memdup_user(am_hreq.ops, size);\n\tif (IS_ERR(ops)) {\n\t\terror = PTR_ERR(ops);\n\t\tgoto out_dput;\n\t}\n\n\terror = -ENOMEM;\n\tattr_name = kmalloc(MAXNAMELEN, GFP_KERNEL);\n\tif (!attr_name)\n\t\tgoto out_kfree_ops;\n\n\terror = 0;\n\tfor (i = 0; i < am_hreq.opcount; i++) {\n\t\tops[i].am_error = strncpy_from_user((char *)attr_name,\n\t\t\t\tops[i].am_attrname, MAXNAMELEN);\n\t\tif (ops[i].am_error == 0 || ops[i].am_error == MAXNAMELEN)\n\t\t\terror = -ERANGE;\n\t\tif (ops[i].am_error < 0)\n\t\t\tbreak;\n\n\t\tswitch (ops[i].am_opcode) {\n\t\tcase ATTR_OP_GET:\n\t\t\tops[i].am_error = xfs_attrmulti_attr_get(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tops[i].am_attrvalue, &ops[i].am_length,\n\t\t\t\t\tops[i].am_flags);\n\t\t\tbreak;\n\t\tcase ATTR_OP_SET:\n\t\t\tops[i].am_error = mnt_want_write_file(parfilp);\n\t\t\tif (ops[i].am_error)\n\t\t\t\tbreak;\n\t\t\tops[i].am_error = xfs_attrmulti_attr_set(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tops[i].am_attrvalue, ops[i].am_length,\n\t\t\t\t\tops[i].am_flags);\n\t\t\tmnt_drop_write_file(parfilp);\n\t\t\tbreak;\n\t\tcase ATTR_OP_REMOVE:\n\t\t\tops[i].am_error = mnt_want_write_file(parfilp);\n\t\t\tif (ops[i].am_error)\n\t\t\t\tbreak;\n\t\t\tops[i].am_error = xfs_attrmulti_attr_remove(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tops[i].am_flags);\n\t\t\tmnt_drop_write_file(parfilp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tops[i].am_error = -EINVAL;\n\t\t}\n\t}\n\n\tif (copy_to_user(am_hreq.ops, ops, size))\n\t\terror = -EFAULT;\n\n\tkfree(attr_name);\n out_kfree_ops:\n\tkfree(ops);\n out_dput:\n\tdput(dentry);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_attrmulti_attr_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "498-507",
    "snippet": "int\nxfs_attrmulti_attr_remove(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\t__uint32_t\t\tflags)\n{\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\treturn xfs_attr_remove(XFS_I(inode), name, flags);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_attr_remove",
          "args": [
            "XFS_I(inode)",
            "name",
            "flags"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "404-516",
          "snippet": "int\nxfs_attr_remove(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_bmap_free\tflist;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_attr_remove);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tif (!xfs_inode_hasattr(dp))\n\t\treturn -ENOATTR;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.firstblock = &firstblock;\n\targs.flist = &flist;\n\n\t/*\n\t * we have no control over the attribute names that userspace passes us\n\t * to remove, so we have to allow the name lookup prior to attribute\n\t * removal to fail.\n\t */\n\targs.op_flags = XFS_DA_OP_OKNOENT;\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\targs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_RM);\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\n\tif (flags & ATTR_ROOT)\n\t\targs.trans->t_flags |= XFS_TRANS_RESERVE;\n\n\terror = xfs_trans_reserve(args.trans, &M_RES(mp)->tr_attrrm,\n\t\t\t\t  XFS_ATTRRM_SPACE_RES(mp), 0);\n\tif (error) {\n\t\txfs_trans_cancel(args.trans, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\t/*\n\t * No need to make quota reservations here. We expect to release some\n\t * blocks not allocate in the common case.\n\t */\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\tif (!xfs_inode_hasattr(dp)) {\n\t\terror = -ENOATTR;\n\t} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\tASSERT(dp->i_afp->if_flags & XFS_IFINLINE);\n\t\terror = xfs_attr_shortform_remove(&args);\n\t} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\terror = xfs_attr_leaf_removename(&args);\n\t} else {\n\t\terror = xfs_attr_node_removename(&args);\n\t}\n\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans) {\n\t\txfs_trans_cancel(args.trans,\n\t\t\tXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nint\nxfs_attr_remove(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_bmap_free\tflist;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_attr_remove);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tif (!xfs_inode_hasattr(dp))\n\t\treturn -ENOATTR;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.firstblock = &firstblock;\n\targs.flist = &flist;\n\n\t/*\n\t * we have no control over the attribute names that userspace passes us\n\t * to remove, so we have to allow the name lookup prior to attribute\n\t * removal to fail.\n\t */\n\targs.op_flags = XFS_DA_OP_OKNOENT;\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\targs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_RM);\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\n\tif (flags & ATTR_ROOT)\n\t\targs.trans->t_flags |= XFS_TRANS_RESERVE;\n\n\terror = xfs_trans_reserve(args.trans, &M_RES(mp)->tr_attrrm,\n\t\t\t\t  XFS_ATTRRM_SPACE_RES(mp), 0);\n\tif (error) {\n\t\txfs_trans_cancel(args.trans, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\t/*\n\t * No need to make quota reservations here. We expect to release some\n\t * blocks not allocate in the common case.\n\t */\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\tif (!xfs_inode_hasattr(dp)) {\n\t\terror = -ENOATTR;\n\t} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\tASSERT(dp->i_afp->if_flags & XFS_IFINLINE);\n\t\terror = xfs_attr_shortform_remove(&args);\n\t} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\terror = xfs_attr_leaf_removename(&args);\n\t} else {\n\t\terror = xfs_attr_node_removename(&args);\n\t}\n\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans) {\n\t\txfs_trans_cancel(args.trans,\n\t\t\tXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_attrmulti_attr_remove(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\t__uint32_t\t\tflags)\n{\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\treturn xfs_attr_remove(XFS_I(inode), name, flags);\n}"
  },
  {
    "function_name": "xfs_attrmulti_attr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "476-496",
    "snippet": "int\nxfs_attrmulti_attr_set(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tconst unsigned char\t__user *ubuf,\n\t__uint32_t\t\tlen,\n\t__uint32_t\t\tflags)\n{\n\tunsigned char\t\t*kbuf;\n\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (len > XATTR_SIZE_MAX)\n\t\treturn -EINVAL;\n\n\tkbuf = memdup_user(ubuf, len);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\treturn xfs_attr_set(XFS_I(inode), name, kbuf, len, flags);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_attr_set",
          "args": [
            "XFS_I(inode)",
            "name",
            "kbuf",
            "len",
            "flags"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "194-398",
          "snippet": "int\nxfs_attr_set(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\tvaluelen,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_bmap_free\tflist;\n\tstruct xfs_trans_res\ttres;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\trsvd = (flags & ATTR_ROOT) != 0;\n\tint\t\t\terror, err2, committed, local;\n\n\tXFS_STATS_INC(xs_attr_set);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = valuelen;\n\targs.firstblock = &firstblock;\n\targs.flist = &flist;\n\targs.op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\targs.total = xfs_attr_calc_size(&args, &local);\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If the inode doesn't have an attribute fork, add one.\n\t * (inode must not be locked when we call this routine)\n\t */\n\tif (XFS_IFORK_Q(dp) == 0) {\n\t\tint sf_size = sizeof(xfs_attr_sf_hdr_t) +\n\t\t\tXFS_ATTR_SF_ENTSIZE_BYNAME(args.namelen, valuelen);\n\n\t\terror = xfs_bmap_add_attrfork(dp, sf_size, rsvd);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\targs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_SET);\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\n\tif (rsvd)\n\t\targs.trans->t_flags |= XFS_TRANS_RESERVE;\n\n\ttres.tr_logres = M_RES(mp)->tr_attrsetm.tr_logres +\n\t\t\t M_RES(mp)->tr_attrsetrt.tr_logres * args.total;\n\ttres.tr_logcount = XFS_ATTRSET_LOG_COUNT;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(args.trans, &tres, args.total, 0);\n\tif (error) {\n\t\txfs_trans_cancel(args.trans, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\n\terror = xfs_trans_reserve_quota_nblks(args.trans, dp, args.total, 0,\n\t\t\t\trsvd ? XFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\n\t\t\t\t       XFS_QMOPT_RES_REGBLKS);\n\tif (error) {\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\t\txfs_trans_cancel(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\t\treturn error;\n\t}\n\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t/*\n\t * If the attribute list is non-existent or a shortform list,\n\t * upgrade it to a single-leaf-block attribute list.\n\t */\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL ||\n\t    (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     dp->i_d.di_anextents == 0)) {\n\n\t\t/*\n\t\t * Build initial attribute list (if required).\n\t\t */\n\t\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS)\n\t\t\txfs_attr_shortform_create(&args);\n\n\t\t/*\n\t\t * Try to add the attr to the attribute list in\n\t\t * the inode.\n\t\t */\n\t\terror = xfs_attr_shortform_addname(&args);\n\t\tif (error != -ENOSPC) {\n\t\t\t/*\n\t\t\t * Commit the shortform mods, and we're done.\n\t\t\t * NOTE: this is also the error path (EEXIST, etc).\n\t\t\t */\n\t\t\tASSERT(args.trans != NULL);\n\n\t\t\t/*\n\t\t\t * If this is a synchronous mount, make sure that\n\t\t\t * the transaction goes to disk before returning\n\t\t\t * to the user.\n\t\t\t */\n\t\t\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\t\t\txfs_trans_set_sync(args.trans);\n\n\t\t\tif (!error && (flags & ATTR_KERNOTIME) == 0) {\n\t\t\t\txfs_trans_ichgtime(args.trans, dp,\n\t\t\t\t\t\t\tXFS_ICHGTIME_CHG);\n\t\t\t}\n\t\t\terr2 = xfs_trans_commit(args.trans,\n\t\t\t\t\t\t XFS_TRANS_RELEASE_LOG_RES);\n\t\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\t\t\treturn error ? error : err2;\n\t\t}\n\n\t\t/*\n\t\t * It won't fit in the shortform, transform to a leaf block.\n\t\t * GROT: another possible req'mt for a double-split btree op.\n\t\t */\n\t\txfs_bmap_init(args.flist, args.firstblock);\n\t\terror = xfs_attr_shortform_to_leaf(&args);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args.trans, args.flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs.trans = NULL;\n\t\t\txfs_bmap_cancel(&flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the leaf transformation.  We'll need another (linked)\n\t\t * transaction to add the new attribute to the leaf.\n\t\t */\n\n\t\terror = xfs_trans_roll(&args.trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t}\n\n\tif (xfs_bmap_one_block(dp, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_addname(&args);\n\telse\n\t\terror = xfs_attr_node_addname(&args);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans) {\n\t\txfs_trans_cancel(args.trans,\n\t\t\tXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nint\nxfs_attr_set(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\tvaluelen,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_bmap_free\tflist;\n\tstruct xfs_trans_res\ttres;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\trsvd = (flags & ATTR_ROOT) != 0;\n\tint\t\t\terror, err2, committed, local;\n\n\tXFS_STATS_INC(xs_attr_set);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = valuelen;\n\targs.firstblock = &firstblock;\n\targs.flist = &flist;\n\targs.op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\targs.total = xfs_attr_calc_size(&args, &local);\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If the inode doesn't have an attribute fork, add one.\n\t * (inode must not be locked when we call this routine)\n\t */\n\tif (XFS_IFORK_Q(dp) == 0) {\n\t\tint sf_size = sizeof(xfs_attr_sf_hdr_t) +\n\t\t\tXFS_ATTR_SF_ENTSIZE_BYNAME(args.namelen, valuelen);\n\n\t\terror = xfs_bmap_add_attrfork(dp, sf_size, rsvd);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\targs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_SET);\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\n\tif (rsvd)\n\t\targs.trans->t_flags |= XFS_TRANS_RESERVE;\n\n\ttres.tr_logres = M_RES(mp)->tr_attrsetm.tr_logres +\n\t\t\t M_RES(mp)->tr_attrsetrt.tr_logres * args.total;\n\ttres.tr_logcount = XFS_ATTRSET_LOG_COUNT;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(args.trans, &tres, args.total, 0);\n\tif (error) {\n\t\txfs_trans_cancel(args.trans, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\n\terror = xfs_trans_reserve_quota_nblks(args.trans, dp, args.total, 0,\n\t\t\t\trsvd ? XFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\n\t\t\t\t       XFS_QMOPT_RES_REGBLKS);\n\tif (error) {\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\t\txfs_trans_cancel(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\t\treturn error;\n\t}\n\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t/*\n\t * If the attribute list is non-existent or a shortform list,\n\t * upgrade it to a single-leaf-block attribute list.\n\t */\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL ||\n\t    (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     dp->i_d.di_anextents == 0)) {\n\n\t\t/*\n\t\t * Build initial attribute list (if required).\n\t\t */\n\t\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS)\n\t\t\txfs_attr_shortform_create(&args);\n\n\t\t/*\n\t\t * Try to add the attr to the attribute list in\n\t\t * the inode.\n\t\t */\n\t\terror = xfs_attr_shortform_addname(&args);\n\t\tif (error != -ENOSPC) {\n\t\t\t/*\n\t\t\t * Commit the shortform mods, and we're done.\n\t\t\t * NOTE: this is also the error path (EEXIST, etc).\n\t\t\t */\n\t\t\tASSERT(args.trans != NULL);\n\n\t\t\t/*\n\t\t\t * If this is a synchronous mount, make sure that\n\t\t\t * the transaction goes to disk before returning\n\t\t\t * to the user.\n\t\t\t */\n\t\t\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\t\t\txfs_trans_set_sync(args.trans);\n\n\t\t\tif (!error && (flags & ATTR_KERNOTIME) == 0) {\n\t\t\t\txfs_trans_ichgtime(args.trans, dp,\n\t\t\t\t\t\t\tXFS_ICHGTIME_CHG);\n\t\t\t}\n\t\t\terr2 = xfs_trans_commit(args.trans,\n\t\t\t\t\t\t XFS_TRANS_RELEASE_LOG_RES);\n\t\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\t\t\treturn error ? error : err2;\n\t\t}\n\n\t\t/*\n\t\t * It won't fit in the shortform, transform to a leaf block.\n\t\t * GROT: another possible req'mt for a double-split btree op.\n\t\t */\n\t\txfs_bmap_init(args.flist, args.firstblock);\n\t\terror = xfs_attr_shortform_to_leaf(&args);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args.trans, args.flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs.trans = NULL;\n\t\t\txfs_bmap_cancel(&flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the leaf transformation.  We'll need another (linked)\n\t\t * transaction to add the new attribute to the leaf.\n\t\t */\n\n\t\terror = xfs_trans_roll(&args.trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t}\n\n\tif (xfs_bmap_one_block(dp, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_addname(&args);\n\telse\n\t\terror = xfs_attr_node_addname(&args);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans) {\n\t\txfs_trans_cancel(args.trans,\n\t\t\tXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kbuf"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kbuf"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "ubuf",
            "len"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_attrmulti_attr_set(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tconst unsigned char\t__user *ubuf,\n\t__uint32_t\t\tlen,\n\t__uint32_t\t\tflags)\n{\n\tunsigned char\t\t*kbuf;\n\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (len > XATTR_SIZE_MAX)\n\t\treturn -EINVAL;\n\n\tkbuf = memdup_user(ubuf, len);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\treturn xfs_attr_set(XFS_I(inode), name, kbuf, len, flags);\n}"
  },
  {
    "function_name": "xfs_attrmulti_attr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "447-474",
    "snippet": "int\nxfs_attrmulti_attr_get(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tunsigned char\t\t__user *ubuf,\n\t__uint32_t\t\t*len,\n\t__uint32_t\t\tflags)\n{\n\tunsigned char\t\t*kbuf;\n\tint\t\t\terror = -EFAULT;\n\n\tif (*len > XATTR_SIZE_MAX)\n\t\treturn -EINVAL;\n\tkbuf = kmem_zalloc_large(*len, KM_SLEEP);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\terror = xfs_attr_get(XFS_I(inode), name, kbuf, (int *)len, flags);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(ubuf, kbuf, *len))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\n\treturn error;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "kbuf"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "ubuf",
            "kbuf",
            "*len"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_get",
          "args": [
            "XFS_I(inode)",
            "name",
            "kbuf",
            "(int *)len",
            "flags"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "116-156",
          "snippet": "int\nxfs_attr_get(\n\tstruct xfs_inode\t*ip,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\t*valuelenp,\n\tint\t\t\tflags)\n{\n\tstruct xfs_da_args\targs;\n\tuint\t\t\tlock_mode;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_attr_get);\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\n\tif (!xfs_inode_hasattr(ip))\n\t\treturn -ENOATTR;\n\n\terror = xfs_attr_args_init(&args, ip, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = *valuelenp;\n\n\tlock_mode = xfs_ilock_attr_map_shared(ip);\n\tif (!xfs_inode_hasattr(ip))\n\t\terror = -ENOATTR;\n\telse if (ip->i_d.di_aformat == XFS_DINODE_FMT_LOCAL)\n\t\terror = xfs_attr_shortform_getvalue(&args);\n\telse if (xfs_bmap_one_block(ip, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_get(&args);\n\telse\n\t\terror = xfs_attr_node_get(&args);\n\txfs_iunlock(ip, lock_mode);\n\n\t*valuelenp = args.valuelen;\n\treturn error == -EEXIST ? 0 : error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nint\nxfs_attr_get(\n\tstruct xfs_inode\t*ip,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\t*valuelenp,\n\tint\t\t\tflags)\n{\n\tstruct xfs_da_args\targs;\n\tuint\t\t\tlock_mode;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(xs_attr_get);\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\n\tif (!xfs_inode_hasattr(ip))\n\t\treturn -ENOATTR;\n\n\terror = xfs_attr_args_init(&args, ip, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = *valuelenp;\n\n\tlock_mode = xfs_ilock_attr_map_shared(ip);\n\tif (!xfs_inode_hasattr(ip))\n\t\terror = -ENOATTR;\n\telse if (ip->i_d.di_aformat == XFS_DINODE_FMT_LOCAL)\n\t\terror = xfs_attr_shortform_getvalue(&args);\n\telse if (xfs_bmap_one_block(ip, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_get(&args);\n\telse\n\t\terror = xfs_attr_node_get(&args);\n\txfs_iunlock(ip, lock_mode);\n\n\t*valuelenp = args.valuelen;\n\treturn error == -EEXIST ? 0 : error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zalloc_large",
          "args": [
            "*len",
            "KM_SLEEP"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_attrmulti_attr_get(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tunsigned char\t\t__user *ubuf,\n\t__uint32_t\t\t*len,\n\t__uint32_t\t\tflags)\n{\n\tunsigned char\t\t*kbuf;\n\tint\t\t\terror = -EFAULT;\n\n\tif (*len > XATTR_SIZE_MAX)\n\t\treturn -EINVAL;\n\tkbuf = kmem_zalloc_large(*len, KM_SLEEP);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\terror = xfs_attr_get(XFS_I(inode), name, kbuf, (int *)len, flags);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(ubuf, kbuf, *len))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_attrlist_by_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "398-445",
    "snippet": "STATIC int\nxfs_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror = -ENOMEM;\n\tattrlist_cursor_kern_t\t*cursor;\n\txfs_fsop_attrlist_handlereq_t al_hreq;\n\tstruct dentry\t\t*dentry;\n\tchar\t\t\t*kbuf;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&al_hreq, arg, sizeof(xfs_fsop_attrlist_handlereq_t)))\n\t\treturn -EFAULT;\n\tif (al_hreq.buflen < sizeof(struct attrlist) ||\n\t    al_hreq.buflen > XATTR_LIST_MAX)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Reject flags, only allow namespaces.\n\t */\n\tif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\n\t\treturn -EINVAL;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\n\tif (!kbuf)\n\t\tgoto out_dput;\n\n\tcursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\n\terror = xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,\n\t\t\t\t\tal_hreq.flags, cursor);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(al_hreq.buffer, kbuf, al_hreq.buflen))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\nout_dput:\n\tdput(dentry);\n\treturn error;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "kbuf"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "al_hreq.buffer",
            "kbuf",
            "al_hreq.buflen"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_list",
          "args": [
            "XFS_I(dentry->d_inode)",
            "kbuf",
            "al_hreq.buflen",
            "al_hreq.flags",
            "cursor"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_list.c",
          "lines": "600-650",
          "snippet": "int\nxfs_attr_list(\n\txfs_inode_t\t*dp,\n\tchar\t\t*buffer,\n\tint\t\tbufsize,\n\tint\t\tflags,\n\tattrlist_cursor_kern_t *cursor)\n{\n\txfs_attr_list_context_t context;\n\tstruct attrlist *alist;\n\tint error;\n\n\t/*\n\t * Validate the cursor.\n\t */\n\tif (cursor->pad1 || cursor->pad2)\n\t\treturn -EINVAL;\n\tif ((cursor->initted == 0) &&\n\t    (cursor->hashval || cursor->blkno || cursor->offset))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Check for a properly aligned buffer.\n\t */\n\tif (((long)buffer) & (sizeof(int)-1))\n\t\treturn -EFAULT;\n\tif (flags & ATTR_KERNOVAL)\n\t\tbufsize = 0;\n\n\t/*\n\t * Initialize the output buffer.\n\t */\n\tmemset(&context, 0, sizeof(context));\n\tcontext.dp = dp;\n\tcontext.cursor = cursor;\n\tcontext.resynch = 1;\n\tcontext.flags = flags;\n\tcontext.alist = buffer;\n\tcontext.bufsize = (bufsize & ~(sizeof(int)-1));  /* align */\n\tcontext.firstu = context.bufsize;\n\tcontext.put_listent = xfs_attr_put_listent;\n\n\talist = (struct attrlist *)context.alist;\n\talist->al_count = 0;\n\talist->al_more = 0;\n\talist->al_offset[0] = context.bufsize;\n\n\terror = xfs_attr_list_int(&context);\n\tASSERT(error <= 0);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_list(\n\txfs_inode_t\t*dp,\n\tchar\t\t*buffer,\n\tint\t\tbufsize,\n\tint\t\tflags,\n\tattrlist_cursor_kern_t *cursor)\n{\n\txfs_attr_list_context_t context;\n\tstruct attrlist *alist;\n\tint error;\n\n\t/*\n\t * Validate the cursor.\n\t */\n\tif (cursor->pad1 || cursor->pad2)\n\t\treturn -EINVAL;\n\tif ((cursor->initted == 0) &&\n\t    (cursor->hashval || cursor->blkno || cursor->offset))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Check for a properly aligned buffer.\n\t */\n\tif (((long)buffer) & (sizeof(int)-1))\n\t\treturn -EFAULT;\n\tif (flags & ATTR_KERNOVAL)\n\t\tbufsize = 0;\n\n\t/*\n\t * Initialize the output buffer.\n\t */\n\tmemset(&context, 0, sizeof(context));\n\tcontext.dp = dp;\n\tcontext.cursor = cursor;\n\tcontext.resynch = 1;\n\tcontext.flags = flags;\n\tcontext.alist = buffer;\n\tcontext.bufsize = (bufsize & ~(sizeof(int)-1));  /* align */\n\tcontext.firstu = context.bufsize;\n\tcontext.put_listent = xfs_attr_put_listent;\n\n\talist = (struct attrlist *)context.alist;\n\talist->al_count = 0;\n\talist->al_more = 0;\n\talist->al_offset[0] = context.bufsize;\n\n\terror = xfs_attr_list_int(&context);\n\tASSERT(error <= 0);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zalloc_large",
          "args": [
            "al_hreq.buflen",
            "KM_SLEEP"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_handlereq_to_dentry",
          "args": [
            "parfilp",
            "&al_hreq.hreq"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_handlereq_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "184-190",
          "snippet": "dentry *\nxfs_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\ndentry *\nxfs_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&al_hreq",
            "arg",
            "sizeof(xfs_fsop_attrlist_handlereq_t)"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror = -ENOMEM;\n\tattrlist_cursor_kern_t\t*cursor;\n\txfs_fsop_attrlist_handlereq_t al_hreq;\n\tstruct dentry\t\t*dentry;\n\tchar\t\t\t*kbuf;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&al_hreq, arg, sizeof(xfs_fsop_attrlist_handlereq_t)))\n\t\treturn -EFAULT;\n\tif (al_hreq.buflen < sizeof(struct attrlist) ||\n\t    al_hreq.buflen > XATTR_LIST_MAX)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Reject flags, only allow namespaces.\n\t */\n\tif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\n\t\treturn -EINVAL;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\n\tif (!kbuf)\n\t\tgoto out_dput;\n\n\tcursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\n\terror = xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,\n\t\t\t\t\tal_hreq.flags, cursor);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(al_hreq.buffer, kbuf, al_hreq.buflen))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\nout_dput:\n\tdput(dentry);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_fssetdm_by_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "354-396",
    "snippet": "STATIC int\nxfs_fssetdm_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror;\n\tstruct fsdmidata\tfsd;\n\txfs_fsop_setdm_handlereq_t dmhreq;\n\tstruct dentry\t\t*dentry;\n\n\tif (!capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\tif (copy_from_user(&dmhreq, arg, sizeof(xfs_fsop_setdm_handlereq_t)))\n\t\treturn -EFAULT;\n\n\terror = mnt_want_write_file(parfilp);\n\tif (error)\n\t\treturn error;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &dmhreq.hreq);\n\tif (IS_ERR(dentry)) {\n\t\tmnt_drop_write_file(parfilp);\n\t\treturn PTR_ERR(dentry);\n\t}\n\n\tif (IS_IMMUTABLE(dentry->d_inode) || IS_APPEND(dentry->d_inode)) {\n\t\terror = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(&fsd, dmhreq.data, sizeof(fsd))) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terror = xfs_set_dmattrs(XFS_I(dentry->d_inode), fsd.fsd_dmevmask,\n\t\t\t\t fsd.fsd_dmstate);\n\n out:\n\tmnt_drop_write_file(parfilp);\n\tdput(dentry);\n\treturn error;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "parfilp"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_set_dmattrs",
          "args": [
            "XFS_I(dentry->d_inode)",
            "fsd.fsd_dmevmask",
            "fsd.fsd_dmstate"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_set_dmattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "320-352",
          "snippet": "int\nxfs_set_dmattrs(\n\txfs_inode_t     *ip,\n\tu_int\t\tevmask,\n\tu_int16_t\tstate)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SET_DMATTRS);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\tip->i_d.di_dmevmask = evmask;\n\tip->i_d.di_dmstate  = state;\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(tp, 0);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_set_dmattrs(\n\txfs_inode_t     *ip,\n\tu_int\t\tevmask,\n\tu_int16_t\tstate)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SET_DMATTRS);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\tip->i_d.di_dmevmask = evmask;\n\tip->i_d.di_dmstate  = state;\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(tp, 0);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&fsd",
            "dmhreq.data",
            "sizeof(fsd)"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "dentry->d_inode"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "dentry->d_inode"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_handlereq_to_dentry",
          "args": [
            "parfilp",
            "&dmhreq.hreq"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_handlereq_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "184-190",
          "snippet": "dentry *\nxfs_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\ndentry *\nxfs_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "parfilp"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_MKNOD"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_fssetdm_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror;\n\tstruct fsdmidata\tfsd;\n\txfs_fsop_setdm_handlereq_t dmhreq;\n\tstruct dentry\t\t*dentry;\n\n\tif (!capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\tif (copy_from_user(&dmhreq, arg, sizeof(xfs_fsop_setdm_handlereq_t)))\n\t\treturn -EFAULT;\n\n\terror = mnt_want_write_file(parfilp);\n\tif (error)\n\t\treturn error;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, &dmhreq.hreq);\n\tif (IS_ERR(dentry)) {\n\t\tmnt_drop_write_file(parfilp);\n\t\treturn PTR_ERR(dentry);\n\t}\n\n\tif (IS_IMMUTABLE(dentry->d_inode) || IS_APPEND(dentry->d_inode)) {\n\t\terror = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(&fsd, dmhreq.data, sizeof(fsd))) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terror = xfs_set_dmattrs(XFS_I(dentry->d_inode), fsd.fsd_dmevmask,\n\t\t\t\t fsd.fsd_dmstate);\n\n out:\n\tmnt_drop_write_file(parfilp);\n\tdput(dentry);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_set_dmattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "320-352",
    "snippet": "int\nxfs_set_dmattrs(\n\txfs_inode_t     *ip,\n\tu_int\t\tevmask,\n\tu_int16_t\tstate)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SET_DMATTRS);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\tip->i_d.di_dmevmask = evmask;\n\tip->i_d.di_dmstate  = state;\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(tp, 0);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "0"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "XFS_ILOG_CORE"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "0"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_ichange",
            "0",
            "0"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_SET_DMATTRS"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_set_dmattrs(\n\txfs_inode_t     *ip,\n\tu_int\t\tevmask,\n\tu_int16_t\tstate)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SET_DMATTRS);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\tip->i_d.di_dmevmask = evmask;\n\tip->i_d.di_dmstate  = state;\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(tp, 0);\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_readlink_by_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "272-318",
    "snippet": "int\nxfs_readlink_by_handle(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tstruct dentry\t\t*dentry;\n\t__u32\t\t\tolen;\n\tvoid\t\t\t*link;\n\tint\t\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\t/* Restrict this handle operation to symlinks only. */\n\tif (!d_is_symlink(dentry)) {\n\t\terror = -EINVAL;\n\t\tgoto out_dput;\n\t}\n\n\tif (copy_from_user(&olen, hreq->ohandlen, sizeof(__u32))) {\n\t\terror = -EFAULT;\n\t\tgoto out_dput;\n\t}\n\n\tlink = kmalloc(MAXPATHLEN+1, GFP_KERNEL);\n\tif (!link) {\n\t\terror = -ENOMEM;\n\t\tgoto out_dput;\n\t}\n\n\terror = xfs_readlink(XFS_I(dentry->d_inode), link);\n\tif (error)\n\t\tgoto out_kfree;\n\terror = readlink_copy(hreq->ohandle, olen, link);\n\tif (error)\n\t\tgoto out_kfree;\n\n out_kfree:\n\tkfree(link);\n out_dput:\n\tdput(dentry);\n\treturn error;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readlink_copy",
          "args": [
            "hreq->ohandle",
            "olen",
            "link"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "readlink_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "4409-4422",
          "snippet": "int readlink_copy(char __user *buffer, int buflen, const char *link)\n{\n\tint len = PTR_ERR(link);\n\tif (IS_ERR(link))\n\t\tgoto out;\n\n\tlen = strlen(link);\n\tif (len > (unsigned) buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, link, len))\n\t\tlen = -EFAULT;\nout:\n\treturn len;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint readlink_copy(char __user *buffer, int buflen, const char *link)\n{\n\tint len = PTR_ERR(link);\n\tif (IS_ERR(link))\n\t\tgoto out;\n\n\tlen = strlen(link);\n\tif (len > (unsigned) buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, link, len))\n\t\tlen = -EFAULT;\nout:\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_readlink",
          "args": [
            "XFS_I(dentry->d_inode)",
            "link"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_readlink_by_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "272-318",
          "snippet": "int\nxfs_readlink_by_handle(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tstruct dentry\t\t*dentry;\n\t__u32\t\t\tolen;\n\tvoid\t\t\t*link;\n\tint\t\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\t/* Restrict this handle operation to symlinks only. */\n\tif (!d_is_symlink(dentry)) {\n\t\terror = -EINVAL;\n\t\tgoto out_dput;\n\t}\n\n\tif (copy_from_user(&olen, hreq->ohandlen, sizeof(__u32))) {\n\t\terror = -EFAULT;\n\t\tgoto out_dput;\n\t}\n\n\tlink = kmalloc(MAXPATHLEN+1, GFP_KERNEL);\n\tif (!link) {\n\t\terror = -ENOMEM;\n\t\tgoto out_dput;\n\t}\n\n\terror = xfs_readlink(XFS_I(dentry->d_inode), link);\n\tif (error)\n\t\tgoto out_kfree;\n\terror = readlink_copy(hreq->ohandle, olen, link);\n\tif (error)\n\t\tgoto out_kfree;\n\n out_kfree:\n\tkfree(link);\n out_dput:\n\tdput(dentry);\n\treturn error;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "MAXPATHLEN+1",
            "GFP_KERNEL"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&olen",
            "hreq->ohandlen",
            "sizeof(__u32)"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_is_symlink",
          "args": [
            "dentry"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_handlereq_to_dentry",
          "args": [
            "parfilp",
            "hreq"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_handlereq_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "184-190",
          "snippet": "dentry *\nxfs_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\ndentry *\nxfs_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_readlink_by_handle(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tstruct dentry\t\t*dentry;\n\t__u32\t\t\tolen;\n\tvoid\t\t\t*link;\n\tint\t\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\t/* Restrict this handle operation to symlinks only. */\n\tif (!d_is_symlink(dentry)) {\n\t\terror = -EINVAL;\n\t\tgoto out_dput;\n\t}\n\n\tif (copy_from_user(&olen, hreq->ohandlen, sizeof(__u32))) {\n\t\terror = -EFAULT;\n\t\tgoto out_dput;\n\t}\n\n\tlink = kmalloc(MAXPATHLEN+1, GFP_KERNEL);\n\tif (!link) {\n\t\terror = -ENOMEM;\n\t\tgoto out_dput;\n\t}\n\n\terror = xfs_readlink(XFS_I(dentry->d_inode), link);\n\tif (error)\n\t\tgoto out_kfree;\n\terror = readlink_copy(hreq->ohandle, olen, link);\n\tif (error)\n\t\tgoto out_kfree;\n\n out_kfree:\n\tkfree(link);\n out_dput:\n\tdput(dentry);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_open_by_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "192-270",
    "snippet": "int\nxfs_open_by_handle(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tconst struct cred\t*cred = current_cred();\n\tint\t\t\terror;\n\tint\t\t\tfd;\n\tint\t\t\tpermflag;\n\tstruct file\t\t*filp;\n\tstruct inode\t\t*inode;\n\tstruct dentry\t\t*dentry;\n\tfmode_t\t\t\tfmode;\n\tstruct path\t\tpath;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\tinode = dentry->d_inode;\n\n\t/* Restrict xfs_open_by_handle to directories & regular files. */\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))) {\n\t\terror = -EPERM;\n\t\tgoto out_dput;\n\t}\n\n#if BITS_PER_LONG != 32\n\threq->oflags |= O_LARGEFILE;\n#endif\n\n\tpermflag = hreq->oflags;\n\tfmode = OPEN_FMODE(permflag);\n\tif ((!(permflag & O_APPEND) || (permflag & O_TRUNC)) &&\n\t    (fmode & FMODE_WRITE) && IS_APPEND(inode)) {\n\t\terror = -EPERM;\n\t\tgoto out_dput;\n\t}\n\n\tif ((fmode & FMODE_WRITE) && IS_IMMUTABLE(inode)) {\n\t\terror = -EACCES;\n\t\tgoto out_dput;\n\t}\n\n\t/* Can't write directories. */\n\tif (S_ISDIR(inode->i_mode) && (fmode & FMODE_WRITE)) {\n\t\terror = -EISDIR;\n\t\tgoto out_dput;\n\t}\n\n\tfd = get_unused_fd_flags(0);\n\tif (fd < 0) {\n\t\terror = fd;\n\t\tgoto out_dput;\n\t}\n\n\tpath.mnt = parfilp->f_path.mnt;\n\tpath.dentry = dentry;\n\tfilp = dentry_open(&path, hreq->oflags, cred);\n\tdput(dentry);\n\tif (IS_ERR(filp)) {\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(filp);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tfilp->f_flags |= O_NOATIME;\n\t\tfilp->f_mode |= FMODE_NOCMTIME;\n\t}\n\n\tfd_install(fd, filp);\n\treturn fd;\n\n out_dput:\n\tdput(dentry);\n\treturn error;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fd_install",
          "args": [
            "fd",
            "filp"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "fd_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "563-566",
          "snippet": "void fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "filp"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unused_fd",
          "args": [
            "fd"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "522-528",
          "snippet": "void put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "filp"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_open",
          "args": [
            "&path",
            "hreq->oflags",
            "cred"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "821-849",
          "snippet": "struct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unused_fd_flags",
          "args": [
            "0"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "get_unused_fd_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "508-511",
          "snippet": "int get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPEN_FMODE",
          "args": [
            "permflag"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_handlereq_to_dentry",
          "args": [
            "parfilp",
            "hreq"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_handlereq_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "184-190",
          "snippet": "dentry *\nxfs_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\ndentry *\nxfs_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_open_by_handle(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tconst struct cred\t*cred = current_cred();\n\tint\t\t\terror;\n\tint\t\t\tfd;\n\tint\t\t\tpermflag;\n\tstruct file\t\t*filp;\n\tstruct inode\t\t*inode;\n\tstruct dentry\t\t*dentry;\n\tfmode_t\t\t\tfmode;\n\tstruct path\t\tpath;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\tinode = dentry->d_inode;\n\n\t/* Restrict xfs_open_by_handle to directories & regular files. */\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))) {\n\t\terror = -EPERM;\n\t\tgoto out_dput;\n\t}\n\n#if BITS_PER_LONG != 32\n\threq->oflags |= O_LARGEFILE;\n#endif\n\n\tpermflag = hreq->oflags;\n\tfmode = OPEN_FMODE(permflag);\n\tif ((!(permflag & O_APPEND) || (permflag & O_TRUNC)) &&\n\t    (fmode & FMODE_WRITE) && IS_APPEND(inode)) {\n\t\terror = -EPERM;\n\t\tgoto out_dput;\n\t}\n\n\tif ((fmode & FMODE_WRITE) && IS_IMMUTABLE(inode)) {\n\t\terror = -EACCES;\n\t\tgoto out_dput;\n\t}\n\n\t/* Can't write directories. */\n\tif (S_ISDIR(inode->i_mode) && (fmode & FMODE_WRITE)) {\n\t\terror = -EISDIR;\n\t\tgoto out_dput;\n\t}\n\n\tfd = get_unused_fd_flags(0);\n\tif (fd < 0) {\n\t\terror = fd;\n\t\tgoto out_dput;\n\t}\n\n\tpath.mnt = parfilp->f_path.mnt;\n\tpath.dentry = dentry;\n\tfilp = dentry_open(&path, hreq->oflags, cred);\n\tdput(dentry);\n\tif (IS_ERR(filp)) {\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(filp);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tfilp->f_flags |= O_NOATIME;\n\t\tfilp->f_mode |= FMODE_NOCMTIME;\n\t}\n\n\tfd_install(fd, filp);\n\treturn fd;\n\n out_dput:\n\tdput(dentry);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_handlereq_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "184-190",
    "snippet": "dentry *\nxfs_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_handle_to_dentry",
          "args": [
            "parfilp",
            "hreq->ihandle",
            "hreq->ihandlen"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_handle_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "152-182",
          "snippet": "struct dentry *\nxfs_handle_to_dentry(\n\tstruct file\t\t*parfilp,\n\tvoid __user\t\t*uhandle,\n\tu32\t\t\thlen)\n{\n\txfs_handle_t\t\thandle;\n\tstruct xfs_fid64\tfid;\n\n\t/*\n\t * Only allow handle opens under a directory.\n\t */\n\tif (!S_ISDIR(file_inode(parfilp)->i_mode))\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\tif (hlen != sizeof(xfs_handle_t))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (copy_from_user(&handle, uhandle, hlen))\n\t\treturn ERR_PTR(-EFAULT);\n\tif (handle.ha_fid.fid_len !=\n\t    sizeof(handle.ha_fid) - sizeof(handle.ha_fid.fid_len))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmemset(&fid, 0, sizeof(struct fid));\n\tfid.ino = handle.ha_fid.fid_ino;\n\tfid.gen = handle.ha_fid.fid_gen;\n\n\treturn exportfs_decode_fh(parfilp->f_path.mnt, (struct fid *)&fid, 3,\n\t\t\tFILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG,\n\t\t\txfs_handle_acceptable, NULL);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstruct dentry *\nxfs_handle_to_dentry(\n\tstruct file\t\t*parfilp,\n\tvoid __user\t\t*uhandle,\n\tu32\t\t\thlen)\n{\n\txfs_handle_t\t\thandle;\n\tstruct xfs_fid64\tfid;\n\n\t/*\n\t * Only allow handle opens under a directory.\n\t */\n\tif (!S_ISDIR(file_inode(parfilp)->i_mode))\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\tif (hlen != sizeof(xfs_handle_t))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (copy_from_user(&handle, uhandle, hlen))\n\t\treturn ERR_PTR(-EFAULT);\n\tif (handle.ha_fid.fid_len !=\n\t    sizeof(handle.ha_fid) - sizeof(handle.ha_fid.fid_len))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmemset(&fid, 0, sizeof(struct fid));\n\tfid.ino = handle.ha_fid.fid_ino;\n\tfid.gen = handle.ha_fid.fid_gen;\n\n\treturn exportfs_decode_fh(parfilp->f_path.mnt, (struct fid *)&fid, 3,\n\t\t\tFILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG,\n\t\t\txfs_handle_acceptable, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\ndentry *\nxfs_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);\n}"
  },
  {
    "function_name": "xfs_handle_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "152-182",
    "snippet": "struct dentry *\nxfs_handle_to_dentry(\n\tstruct file\t\t*parfilp,\n\tvoid __user\t\t*uhandle,\n\tu32\t\t\thlen)\n{\n\txfs_handle_t\t\thandle;\n\tstruct xfs_fid64\tfid;\n\n\t/*\n\t * Only allow handle opens under a directory.\n\t */\n\tif (!S_ISDIR(file_inode(parfilp)->i_mode))\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\tif (hlen != sizeof(xfs_handle_t))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (copy_from_user(&handle, uhandle, hlen))\n\t\treturn ERR_PTR(-EFAULT);\n\tif (handle.ha_fid.fid_len !=\n\t    sizeof(handle.ha_fid) - sizeof(handle.ha_fid.fid_len))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmemset(&fid, 0, sizeof(struct fid));\n\tfid.ino = handle.ha_fid.fid_ino;\n\tfid.gen = handle.ha_fid.fid_gen;\n\n\treturn exportfs_decode_fh(parfilp->f_path.mnt, (struct fid *)&fid, 3,\n\t\t\tFILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG,\n\t\t\txfs_handle_acceptable, NULL);\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exportfs_decode_fh",
          "args": [
            "parfilp->f_path.mnt",
            "(struct fid *)&fid",
            "3",
            "FILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG",
            "xfs_handle_acceptable",
            "NULL"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "exportfs_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
          "lines": "412-541",
          "snippet": "struct dentry *exportfs_decode_fh(struct vfsmount *mnt, struct fid *fid,\n\t\tint fh_len, int fileid_type,\n\t\tint (*acceptable)(void *, struct dentry *), void *context)\n{\n\tconst struct export_operations *nop = mnt->mnt_sb->s_export_op;\n\tstruct dentry *result, *alias;\n\tchar nbuf[NAME_MAX+1];\n\tint err;\n\n\t/*\n\t * Try to get any dentry for the given file handle from the filesystem.\n\t */\n\tif (!nop || !nop->fh_to_dentry)\n\t\treturn ERR_PTR(-ESTALE);\n\tresult = nop->fh_to_dentry(mnt->mnt_sb, fid, fh_len, fileid_type);\n\tif (!result)\n\t\tresult = ERR_PTR(-ESTALE);\n\tif (IS_ERR(result))\n\t\treturn result;\n\n\tif (d_is_dir(result)) {\n\t\t/*\n\t\t * This request is for a directory.\n\t\t *\n\t\t * On the positive side there is only one dentry for each\n\t\t * directory inode.  On the negative side this implies that we\n\t\t * to ensure our dentry is connected all the way up to the\n\t\t * filesystem root.\n\t\t */\n\t\tif (result->d_flags & DCACHE_DISCONNECTED) {\n\t\t\terr = reconnect_path(mnt, result, nbuf);\n\t\t\tif (err)\n\t\t\t\tgoto err_result;\n\t\t}\n\n\t\tif (!acceptable(context, result)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_result;\n\t\t}\n\n\t\treturn result;\n\t} else {\n\t\t/*\n\t\t * It's not a directory.  Life is a little more complicated.\n\t\t */\n\t\tstruct dentry *target_dir, *nresult;\n\n\t\t/*\n\t\t * See if either the dentry we just got from the filesystem\n\t\t * or any alias for it is acceptable.  This is always true\n\t\t * if this filesystem is exported without the subtreecheck\n\t\t * option.  If the filesystem is exported with the subtree\n\t\t * check option there's a fair chance we need to look at\n\t\t * the parent directory in the file handle and make sure\n\t\t * it's connected to the filesystem root.\n\t\t */\n\t\talias = find_acceptable_alias(result, acceptable, context);\n\t\tif (alias)\n\t\t\treturn alias;\n\n\t\t/*\n\t\t * Try to extract a dentry for the parent directory from the\n\t\t * file handle.  If this fails we'll have to give up.\n\t\t */\n\t\terr = -ESTALE;\n\t\tif (!nop->fh_to_parent)\n\t\t\tgoto err_result;\n\n\t\ttarget_dir = nop->fh_to_parent(mnt->mnt_sb, fid,\n\t\t\t\tfh_len, fileid_type);\n\t\tif (!target_dir)\n\t\t\tgoto err_result;\n\t\terr = PTR_ERR(target_dir);\n\t\tif (IS_ERR(target_dir))\n\t\t\tgoto err_result;\n\n\t\t/*\n\t\t * And as usual we need to make sure the parent directory is\n\t\t * connected to the filesystem root.  The VFS really doesn't\n\t\t * like disconnected directories..\n\t\t */\n\t\terr = reconnect_path(mnt, target_dir, nbuf);\n\t\tif (err) {\n\t\t\tdput(target_dir);\n\t\t\tgoto err_result;\n\t\t}\n\n\t\t/*\n\t\t * Now that we've got both a well-connected parent and a\n\t\t * dentry for the inode we're after, make sure that our\n\t\t * inode is actually connected to the parent.\n\t\t */\n\t\terr = exportfs_get_name(mnt, target_dir, nbuf, result);\n\t\tif (!err) {\n\t\t\tmutex_lock(&target_dir->d_inode->i_mutex);\n\t\t\tnresult = lookup_one_len(nbuf, target_dir,\n\t\t\t\t\t\t strlen(nbuf));\n\t\t\tmutex_unlock(&target_dir->d_inode->i_mutex);\n\t\t\tif (!IS_ERR(nresult)) {\n\t\t\t\tif (nresult->d_inode) {\n\t\t\t\t\tdput(result);\n\t\t\t\t\tresult = nresult;\n\t\t\t\t} else\n\t\t\t\t\tdput(nresult);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * At this point we are done with the parent, but it's pinned\n\t\t * by the child dentry anyway.\n\t\t */\n\t\tdput(target_dir);\n\n\t\t/*\n\t\t * And finally make sure the dentry is actually acceptable\n\t\t * to NFSD.\n\t\t */\n\t\talias = find_acceptable_alias(result, acceptable, context);\n\t\tif (!alias) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_result;\n\t\t}\n\n\t\treturn alias;\n\t}\n\n err_result:\n\tdput(result);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int get_name(const struct path *path, char *name, struct dentry *child);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic int get_name(const struct path *path, char *name, struct dentry *child);\n\nstruct dentry *exportfs_decode_fh(struct vfsmount *mnt, struct fid *fid,\n\t\tint fh_len, int fileid_type,\n\t\tint (*acceptable)(void *, struct dentry *), void *context)\n{\n\tconst struct export_operations *nop = mnt->mnt_sb->s_export_op;\n\tstruct dentry *result, *alias;\n\tchar nbuf[NAME_MAX+1];\n\tint err;\n\n\t/*\n\t * Try to get any dentry for the given file handle from the filesystem.\n\t */\n\tif (!nop || !nop->fh_to_dentry)\n\t\treturn ERR_PTR(-ESTALE);\n\tresult = nop->fh_to_dentry(mnt->mnt_sb, fid, fh_len, fileid_type);\n\tif (!result)\n\t\tresult = ERR_PTR(-ESTALE);\n\tif (IS_ERR(result))\n\t\treturn result;\n\n\tif (d_is_dir(result)) {\n\t\t/*\n\t\t * This request is for a directory.\n\t\t *\n\t\t * On the positive side there is only one dentry for each\n\t\t * directory inode.  On the negative side this implies that we\n\t\t * to ensure our dentry is connected all the way up to the\n\t\t * filesystem root.\n\t\t */\n\t\tif (result->d_flags & DCACHE_DISCONNECTED) {\n\t\t\terr = reconnect_path(mnt, result, nbuf);\n\t\t\tif (err)\n\t\t\t\tgoto err_result;\n\t\t}\n\n\t\tif (!acceptable(context, result)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_result;\n\t\t}\n\n\t\treturn result;\n\t} else {\n\t\t/*\n\t\t * It's not a directory.  Life is a little more complicated.\n\t\t */\n\t\tstruct dentry *target_dir, *nresult;\n\n\t\t/*\n\t\t * See if either the dentry we just got from the filesystem\n\t\t * or any alias for it is acceptable.  This is always true\n\t\t * if this filesystem is exported without the subtreecheck\n\t\t * option.  If the filesystem is exported with the subtree\n\t\t * check option there's a fair chance we need to look at\n\t\t * the parent directory in the file handle and make sure\n\t\t * it's connected to the filesystem root.\n\t\t */\n\t\talias = find_acceptable_alias(result, acceptable, context);\n\t\tif (alias)\n\t\t\treturn alias;\n\n\t\t/*\n\t\t * Try to extract a dentry for the parent directory from the\n\t\t * file handle.  If this fails we'll have to give up.\n\t\t */\n\t\terr = -ESTALE;\n\t\tif (!nop->fh_to_parent)\n\t\t\tgoto err_result;\n\n\t\ttarget_dir = nop->fh_to_parent(mnt->mnt_sb, fid,\n\t\t\t\tfh_len, fileid_type);\n\t\tif (!target_dir)\n\t\t\tgoto err_result;\n\t\terr = PTR_ERR(target_dir);\n\t\tif (IS_ERR(target_dir))\n\t\t\tgoto err_result;\n\n\t\t/*\n\t\t * And as usual we need to make sure the parent directory is\n\t\t * connected to the filesystem root.  The VFS really doesn't\n\t\t * like disconnected directories..\n\t\t */\n\t\terr = reconnect_path(mnt, target_dir, nbuf);\n\t\tif (err) {\n\t\t\tdput(target_dir);\n\t\t\tgoto err_result;\n\t\t}\n\n\t\t/*\n\t\t * Now that we've got both a well-connected parent and a\n\t\t * dentry for the inode we're after, make sure that our\n\t\t * inode is actually connected to the parent.\n\t\t */\n\t\terr = exportfs_get_name(mnt, target_dir, nbuf, result);\n\t\tif (!err) {\n\t\t\tmutex_lock(&target_dir->d_inode->i_mutex);\n\t\t\tnresult = lookup_one_len(nbuf, target_dir,\n\t\t\t\t\t\t strlen(nbuf));\n\t\t\tmutex_unlock(&target_dir->d_inode->i_mutex);\n\t\t\tif (!IS_ERR(nresult)) {\n\t\t\t\tif (nresult->d_inode) {\n\t\t\t\t\tdput(result);\n\t\t\t\t\tresult = nresult;\n\t\t\t\t} else\n\t\t\t\t\tdput(nresult);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * At this point we are done with the parent, but it's pinned\n\t\t * by the child dentry anyway.\n\t\t */\n\t\tdput(target_dir);\n\n\t\t/*\n\t\t * And finally make sure the dentry is actually acceptable\n\t\t * to NFSD.\n\t\t */\n\t\talias = find_acceptable_alias(result, acceptable, context);\n\t\tif (!alias) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_result;\n\t\t}\n\n\t\treturn alias;\n\t}\n\n err_result:\n\tdput(result);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fid",
            "0",
            "sizeof(struct fid)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&handle",
            "uhandle",
            "hlen"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOTDIR"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "file_inode(parfilp)->i_mode"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "parfilp"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstruct dentry *\nxfs_handle_to_dentry(\n\tstruct file\t\t*parfilp,\n\tvoid __user\t\t*uhandle,\n\tu32\t\t\thlen)\n{\n\txfs_handle_t\t\thandle;\n\tstruct xfs_fid64\tfid;\n\n\t/*\n\t * Only allow handle opens under a directory.\n\t */\n\tif (!S_ISDIR(file_inode(parfilp)->i_mode))\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\tif (hlen != sizeof(xfs_handle_t))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (copy_from_user(&handle, uhandle, hlen))\n\t\treturn ERR_PTR(-EFAULT);\n\tif (handle.ha_fid.fid_len !=\n\t    sizeof(handle.ha_fid) - sizeof(handle.ha_fid.fid_len))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmemset(&fid, 0, sizeof(struct fid));\n\tfid.ino = handle.ha_fid.fid_ino;\n\tfid.gen = handle.ha_fid.fid_gen;\n\n\treturn exportfs_decode_fh(parfilp->f_path.mnt, (struct fid *)&fid, 3,\n\t\t\tFILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG,\n\t\t\txfs_handle_acceptable, NULL);\n}"
  },
  {
    "function_name": "xfs_handle_acceptable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "141-147",
    "snippet": "STATIC int\nxfs_handle_acceptable(\n\tvoid\t\t\t*context,\n\tstruct dentry\t\t*dentry)\n{\n\treturn 1;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_handle_acceptable(\n\tvoid\t\t\t*context,\n\tstruct dentry\t\t*dentry)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "xfs_find_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
    "lines": "63-135",
    "snippet": "int\nxfs_find_handle(\n\tunsigned int\t\tcmd,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tint\t\t\thsize;\n\txfs_handle_t\t\thandle;\n\tstruct inode\t\t*inode;\n\tstruct fd\t\tf = {NULL};\n\tstruct path\t\tpath;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*ip;\n\n\tif (cmd == XFS_IOC_FD_TO_HANDLE) {\n\t\tf = fdget(hreq->fd);\n\t\tif (!f.file)\n\t\t\treturn -EBADF;\n\t\tinode = file_inode(f.file);\n\t} else {\n\t\terror = user_lpath((const char __user *)hreq->path, &path);\n\t\tif (error)\n\t\t\treturn error;\n\t\tinode = path.dentry->d_inode;\n\t}\n\tip = XFS_I(inode);\n\n\t/*\n\t * We can only generate handles for inodes residing on a XFS filesystem,\n\t * and only for regular files, directories or symbolic links.\n\t */\n\terror = -EINVAL;\n\tif (inode->i_sb->s_magic != XFS_SB_MAGIC)\n\t\tgoto out_put;\n\n\terror = -EBADF;\n\tif (!S_ISREG(inode->i_mode) &&\n\t    !S_ISDIR(inode->i_mode) &&\n\t    !S_ISLNK(inode->i_mode))\n\t\tgoto out_put;\n\n\n\tmemcpy(&handle.ha_fsid, ip->i_mount->m_fixedfsid, sizeof(xfs_fsid_t));\n\n\tif (cmd == XFS_IOC_PATH_TO_FSHANDLE) {\n\t\t/*\n\t\t * This handle only contains an fsid, zero the rest.\n\t\t */\n\t\tmemset(&handle.ha_fid, 0, sizeof(handle.ha_fid));\n\t\thsize = sizeof(xfs_fsid_t);\n\t} else {\n\t\thandle.ha_fid.fid_len = sizeof(xfs_fid_t) -\n\t\t\t\t\tsizeof(handle.ha_fid.fid_len);\n\t\thandle.ha_fid.fid_pad = 0;\n\t\thandle.ha_fid.fid_gen = ip->i_d.di_gen;\n\t\thandle.ha_fid.fid_ino = ip->i_ino;\n\n\t\thsize = XFS_HSIZE(handle);\n\t}\n\n\terror = -EFAULT;\n\tif (copy_to_user(hreq->ohandle, &handle, hsize) ||\n\t    copy_to_user(hreq->ohandlen, &hsize, sizeof(__s32)))\n\t\tgoto out_put;\n\n\terror = 0;\n\n out_put:\n\tif (cmd == XFS_IOC_FD_TO_HANDLE)\n\t\tfdput(f);\n\telse\n\t\tpath_put(&path);\n\treturn error;\n}",
    "includes": [
      "#include <linux/exportfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_export.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "fdput_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "273-278",
          "snippet": "static inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "hreq->ohandlen",
            "&hsize",
            "sizeof(__s32)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "hreq->ohandle",
            "&handle",
            "hsize"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_HSIZE",
          "args": [
            "handle"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&handle.ha_fid",
            "0",
            "sizeof(handle.ha_fid)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&handle.ha_fsid",
            "ip->i_mount->m_fixedfsid",
            "sizeof(xfs_fsid_t)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_lpath",
          "args": [
            "(const char __user *)hreq->path",
            "&path"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "f.file"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "hreq->fd"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "706-718",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_find_handle(\n\tunsigned int\t\tcmd,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tint\t\t\thsize;\n\txfs_handle_t\t\thandle;\n\tstruct inode\t\t*inode;\n\tstruct fd\t\tf = {NULL};\n\tstruct path\t\tpath;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*ip;\n\n\tif (cmd == XFS_IOC_FD_TO_HANDLE) {\n\t\tf = fdget(hreq->fd);\n\t\tif (!f.file)\n\t\t\treturn -EBADF;\n\t\tinode = file_inode(f.file);\n\t} else {\n\t\terror = user_lpath((const char __user *)hreq->path, &path);\n\t\tif (error)\n\t\t\treturn error;\n\t\tinode = path.dentry->d_inode;\n\t}\n\tip = XFS_I(inode);\n\n\t/*\n\t * We can only generate handles for inodes residing on a XFS filesystem,\n\t * and only for regular files, directories or symbolic links.\n\t */\n\terror = -EINVAL;\n\tif (inode->i_sb->s_magic != XFS_SB_MAGIC)\n\t\tgoto out_put;\n\n\terror = -EBADF;\n\tif (!S_ISREG(inode->i_mode) &&\n\t    !S_ISDIR(inode->i_mode) &&\n\t    !S_ISLNK(inode->i_mode))\n\t\tgoto out_put;\n\n\n\tmemcpy(&handle.ha_fsid, ip->i_mount->m_fixedfsid, sizeof(xfs_fsid_t));\n\n\tif (cmd == XFS_IOC_PATH_TO_FSHANDLE) {\n\t\t/*\n\t\t * This handle only contains an fsid, zero the rest.\n\t\t */\n\t\tmemset(&handle.ha_fid, 0, sizeof(handle.ha_fid));\n\t\thsize = sizeof(xfs_fsid_t);\n\t} else {\n\t\thandle.ha_fid.fid_len = sizeof(xfs_fid_t) -\n\t\t\t\t\tsizeof(handle.ha_fid.fid_len);\n\t\thandle.ha_fid.fid_pad = 0;\n\t\thandle.ha_fid.fid_gen = ip->i_d.di_gen;\n\t\thandle.ha_fid.fid_ino = ip->i_ino;\n\n\t\thsize = XFS_HSIZE(handle);\n\t}\n\n\terror = -EFAULT;\n\tif (copy_to_user(hreq->ohandle, &handle, hsize) ||\n\t    copy_to_user(hreq->ohandlen, &hsize, sizeof(__s32)))\n\t\tgoto out_put;\n\n\terror = 0;\n\n out_put:\n\tif (cmd == XFS_IOC_FD_TO_HANDLE)\n\t\tfdput(f);\n\telse\n\t\tpath_put(&path);\n\treturn error;\n}"
  }
]