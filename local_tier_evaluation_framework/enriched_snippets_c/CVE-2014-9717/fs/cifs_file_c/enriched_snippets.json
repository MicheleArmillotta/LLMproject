[
  {
    "function_name": "cifs_direct_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "3878-3887",
    "snippet": "static ssize_t\ncifs_direct_io(int rw, struct kiocb *iocb, struct iov_iter *iter,\n               loff_t pos)\n{\n        /*\n         * FIXME\n         * Eventually need to support direct IO for non forcedirectio mounts\n         */\n        return -EINVAL;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic ssize_t\ncifs_direct_io(int rw, struct kiocb *iocb, struct iov_iter *iter,\n               loff_t pos)\n{\n        /*\n         * FIXME\n         * Eventually need to support direct IO for non forcedirectio mounts\n         */\n        return -EINVAL;\n}"
  },
  {
    "function_name": "cifs_oplock_break",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "3814-3867",
    "snippet": "void cifs_oplock_break(struct work_struct *work)\n{\n\tstruct cifsFileInfo *cfile = container_of(work, struct cifsFileInfo,\n\t\t\t\t\t\t  oplock_break);\n\tstruct inode *inode = cfile->dentry->d_inode;\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tint rc = 0;\n\n\twait_on_bit(&cinode->flags, CIFS_INODE_PENDING_WRITERS,\n\t\t\tTASK_UNINTERRUPTIBLE);\n\n\tserver->ops->downgrade_oplock(server, cinode,\n\t\ttest_bit(CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2, &cinode->flags));\n\n\tif (!CIFS_CACHE_WRITE(cinode) && CIFS_CACHE_READ(cinode) &&\n\t\t\t\t\t\tcifs_has_mand_locks(cinode)) {\n\t\tcifs_dbg(FYI, \"Reset oplock to None for inode=%p due to mand locks\\n\",\n\t\t\t inode);\n\t\tcinode->oplock = 0;\n\t}\n\n\tif (inode && S_ISREG(inode->i_mode)) {\n\t\tif (CIFS_CACHE_READ(cinode))\n\t\t\tbreak_lease(inode, O_RDONLY);\n\t\telse\n\t\t\tbreak_lease(inode, O_WRONLY);\n\t\trc = filemap_fdatawrite(inode->i_mapping);\n\t\tif (!CIFS_CACHE_READ(cinode)) {\n\t\t\trc = filemap_fdatawait(inode->i_mapping);\n\t\t\tmapping_set_error(inode->i_mapping, rc);\n\t\t\tcifs_zap_mapping(inode);\n\t\t}\n\t\tcifs_dbg(FYI, \"Oplock flush inode %p rc %d\\n\", inode, rc);\n\t}\n\n\trc = cifs_push_locks(cfile);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Push locks rc = %d\\n\", rc);\n\n\t/*\n\t * releasing stale oplock after recent reconnect of smb session using\n\t * a now incorrect file handle is not a data integrity issue but do\n\t * not bother sending an oplock release if session to server still is\n\t * disconnected since oplock already released by the server\n\t */\n\tif (!cfile->oplock_break_cancelled) {\n\t\trc = tcon->ses->server->ops->oplock_response(tcon, &cfile->fid,\n\t\t\t\t\t\t\t     cinode);\n\t\tcifs_dbg(FYI, \"Oplock release rc = %d\\n\", rc);\n\t}\n\tcifs_done_oplock_break(cinode);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_done_oplock_break",
          "args": [
            "cinode"
          ],
          "line": 3866
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_done_oplock_break",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "592-596",
          "snippet": "void cifs_done_oplock_break(struct cifsInodeInfo *cinode)\n{\n\tclear_bit(CIFS_INODE_PENDING_OPLOCK_BREAK, &cinode->flags);\n\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_OPLOCK_BREAK);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid cifs_done_oplock_break(struct cifsInodeInfo *cinode)\n{\n\tclear_bit(CIFS_INODE_PENDING_OPLOCK_BREAK, &cinode->flags);\n\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_OPLOCK_BREAK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Oplock release rc = %d\\n\"",
            "rc"
          ],
          "line": 3864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->oplock_response",
          "args": [
            "tcon",
            "&cfile->fid",
            "cinode"
          ],
          "line": 3862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Push locks rc = %d\\n\"",
            "rc"
          ],
          "line": 3853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_push_locks",
          "args": [
            "cfile"
          ],
          "line": 3851
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_push_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1213-1238",
          "snippet": "static int\ncifs_push_locks(struct cifsFileInfo *cfile)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(cfile->dentry->d_sb);\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tint rc = 0;\n\n\t/* we are going to update can_cache_brlcks here - need a write access */\n\tdown_write(&cinode->lock_sem);\n\tif (!cinode->can_cache_brlcks) {\n\t\tup_write(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n\tif (cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability)) &&\n\t    ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0))\n\t\trc = cifs_push_posix_locks(cfile);\n\telse\n\t\trc = tcon->ses->server->ops->push_mand_locks(cfile);\n\n\tcinode->can_cache_brlcks = false;\n\tup_write(&cinode->lock_sem);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_push_locks(struct cifsFileInfo *cfile)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(cfile->dentry->d_sb);\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tint rc = 0;\n\n\t/* we are going to update can_cache_brlcks here - need a write access */\n\tdown_write(&cinode->lock_sem);\n\tif (!cinode->can_cache_brlcks) {\n\t\tup_write(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n\tif (cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability)) &&\n\t    ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0))\n\t\trc = cifs_push_posix_locks(cfile);\n\telse\n\t\trc = tcon->ses->server->ops->push_mand_locks(cfile);\n\n\tcinode->can_cache_brlcks = false;\n\tup_write(&cinode->lock_sem);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Oplock flush inode %p rc %d\\n\"",
            "inode",
            "rc"
          ],
          "line": 3848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_zap_mapping",
          "args": [
            "inode"
          ],
          "line": 3846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "inode->i_mapping",
            "rc"
          ],
          "line": 3845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait",
          "args": [
            "inode->i_mapping"
          ],
          "line": 3844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "cinode"
          ],
          "line": 3843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite",
          "args": [
            "inode->i_mapping"
          ],
          "line": 3842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "break_lease",
          "args": [
            "inode",
            "O_WRONLY"
          ],
          "line": 3841
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_open_break_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "661-669",
          "snippet": "static int nfsd_open_break_lease(struct inode *inode, int access)\n{\n\tunsigned int mode;\n\n\tif (access & NFSD_MAY_NOT_BREAK_LEASE)\n\t\treturn 0;\n\tmode = (access & NFSD_MAY_WRITE) ? O_WRONLY : O_RDONLY;\n\treturn break_lease(inode, mode | O_NONBLOCK);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int nfsd_open_break_lease(struct inode *inode, int access)\n{\n\tunsigned int mode;\n\n\tif (access & NFSD_MAY_NOT_BREAK_LEASE)\n\t\treturn 0;\n\tmode = (access & NFSD_MAY_WRITE) ? O_WRONLY : O_RDONLY;\n\treturn break_lease(inode, mode | O_NONBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "cinode"
          ],
          "line": 3838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 3837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Reset oplock to None for inode=%p due to mand locks\\n\"",
            "inode"
          ],
          "line": 3832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_has_mand_locks",
          "args": [
            "cinode"
          ],
          "line": 3831
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_has_mand_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "254-269",
          "snippet": "static bool\ncifs_has_mand_locks(struct cifsInodeInfo *cinode)\n{\n\tstruct cifs_fid_locks *cur;\n\tbool has_locks = false;\n\n\tdown_read(&cinode->lock_sem);\n\tlist_for_each_entry(cur, &cinode->llist, llist) {\n\t\tif (!list_empty(&cur->locks)) {\n\t\t\thas_locks = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&cinode->lock_sem);\n\treturn has_locks;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic bool\ncifs_has_mand_locks(struct cifsInodeInfo *cinode)\n{\n\tstruct cifs_fid_locks *cur;\n\tbool has_locks = false;\n\n\tdown_read(&cinode->lock_sem);\n\tlist_for_each_entry(cur, &cinode->llist, llist) {\n\t\tif (!list_empty(&cur->locks)) {\n\t\t\thas_locks = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&cinode->lock_sem);\n\treturn has_locks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "cinode"
          ],
          "line": 3830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_WRITE",
          "args": [
            "cinode"
          ],
          "line": 3830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->downgrade_oplock",
          "args": [
            "server",
            "cinode",
            "test_bit(CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2, &cinode->flags)"
          ],
          "line": 3827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2",
            "&cinode->flags"
          ],
          "line": 3828
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_bit",
          "args": [
            "&cinode->flags",
            "CIFS_INODE_PENDING_WRITERS",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 3824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 3820
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 3819
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structcifsFileInfo",
            "oplock_break"
          ],
          "line": 3816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nvoid cifs_oplock_break(struct work_struct *work)\n{\n\tstruct cifsFileInfo *cfile = container_of(work, struct cifsFileInfo,\n\t\t\t\t\t\t  oplock_break);\n\tstruct inode *inode = cfile->dentry->d_inode;\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tint rc = 0;\n\n\twait_on_bit(&cinode->flags, CIFS_INODE_PENDING_WRITERS,\n\t\t\tTASK_UNINTERRUPTIBLE);\n\n\tserver->ops->downgrade_oplock(server, cinode,\n\t\ttest_bit(CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2, &cinode->flags));\n\n\tif (!CIFS_CACHE_WRITE(cinode) && CIFS_CACHE_READ(cinode) &&\n\t\t\t\t\t\tcifs_has_mand_locks(cinode)) {\n\t\tcifs_dbg(FYI, \"Reset oplock to None for inode=%p due to mand locks\\n\",\n\t\t\t inode);\n\t\tcinode->oplock = 0;\n\t}\n\n\tif (inode && S_ISREG(inode->i_mode)) {\n\t\tif (CIFS_CACHE_READ(cinode))\n\t\t\tbreak_lease(inode, O_RDONLY);\n\t\telse\n\t\t\tbreak_lease(inode, O_WRONLY);\n\t\trc = filemap_fdatawrite(inode->i_mapping);\n\t\tif (!CIFS_CACHE_READ(cinode)) {\n\t\t\trc = filemap_fdatawait(inode->i_mapping);\n\t\t\tmapping_set_error(inode->i_mapping, rc);\n\t\t\tcifs_zap_mapping(inode);\n\t\t}\n\t\tcifs_dbg(FYI, \"Oplock flush inode %p rc %d\\n\", inode, rc);\n\t}\n\n\trc = cifs_push_locks(cfile);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Push locks rc = %d\\n\", rc);\n\n\t/*\n\t * releasing stale oplock after recent reconnect of smb session using\n\t * a now incorrect file handle is not a data integrity issue but do\n\t * not bother sending an oplock release if session to server still is\n\t * disconnected since oplock already released by the server\n\t */\n\tif (!cfile->oplock_break_cancelled) {\n\t\trc = tcon->ses->server->ops->oplock_response(tcon, &cfile->fid,\n\t\t\t\t\t\t\t     cinode);\n\t\tcifs_dbg(FYI, \"Oplock release rc = %d\\n\", rc);\n\t}\n\tcifs_done_oplock_break(cinode);\n}"
  },
  {
    "function_name": "cifs_launder_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "3793-3812",
    "snippet": "static int cifs_launder_page(struct page *page)\n{\n\tint rc = 0;\n\tloff_t range_start = page_offset(page);\n\tloff_t range_end = range_start + (loff_t)(PAGE_CACHE_SIZE - 1);\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = 0,\n\t\t.range_start = range_start,\n\t\t.range_end = range_end,\n\t};\n\n\tcifs_dbg(FYI, \"Launder page: %p\\n\", page);\n\n\tif (clear_page_dirty_for_io(page))\n\t\trc = cifs_writepage_locked(page, &wbc);\n\n\tcifs_fscache_invalidate_page(page, page->mapping->host);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_fscache_invalidate_page",
          "args": [
            "page",
            "page->mapping->host"
          ],
          "line": 3810
        },
        "resolved": true,
        "details": {
          "function_name": "__cifs_fscache_invalidate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
          "lines": "233-241",
          "snippet": "void __cifs_fscache_invalidate_page(struct page *page, struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct fscache_cookie *cookie = cifsi->fscache;\n\n\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\", __func__, page, cookie);\n\tfscache_wait_on_page_write(cookie, page);\n\tfscache_uncache_page(cookie, page);\n}",
          "includes": [
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid __cifs_fscache_invalidate_page(struct page *page, struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct fscache_cookie *cookie = cifsi->fscache;\n\n\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\", __func__, page, cookie);\n\tfscache_wait_on_page_write(cookie, page);\n\tfscache_uncache_page(cookie, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_writepage_locked",
          "args": [
            "page",
            "&wbc"
          ],
          "line": 3808
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_writepage_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "2149-2186",
          "snippet": "static int\ncifs_writepage_locked(struct page *page, struct writeback_control *wbc)\n{\n\tint rc;\n\tunsigned int xid;\n\n\txid = get_xid();\n/* BB add check for wbc flags */\n\tpage_cache_get(page);\n\tif (!PageUptodate(page))\n\t\tcifs_dbg(FYI, \"ppw - page not up to date\\n\");\n\n\t/*\n\t * Set the \"writeback\" flag, and clear \"dirty\" in the radix tree.\n\t *\n\t * A writepage() implementation always needs to do either this,\n\t * or re-dirty the page with \"redirty_page_for_writepage()\" in\n\t * the case of a failure.\n\t *\n\t * Just unlocking the page will cause the radix tree tag-bits\n\t * to fail to update with the state of the page correctly.\n\t */\n\tset_page_writeback(page);\nretry_write:\n\trc = cifs_partialpagewrite(page, 0, PAGE_CACHE_SIZE);\n\tif (rc == -EAGAIN && wbc->sync_mode == WB_SYNC_ALL)\n\t\tgoto retry_write;\n\telse if (rc == -EAGAIN)\n\t\tredirty_page_for_writepage(wbc, page);\n\telse if (rc != 0)\n\t\tSetPageError(page);\n\telse\n\t\tSetPageUptodate(page);\n\tend_page_writeback(page);\n\tpage_cache_release(page);\n\tfree_xid(xid);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_writepage_locked(struct page *page, struct writeback_control *wbc)\n{\n\tint rc;\n\tunsigned int xid;\n\n\txid = get_xid();\n/* BB add check for wbc flags */\n\tpage_cache_get(page);\n\tif (!PageUptodate(page))\n\t\tcifs_dbg(FYI, \"ppw - page not up to date\\n\");\n\n\t/*\n\t * Set the \"writeback\" flag, and clear \"dirty\" in the radix tree.\n\t *\n\t * A writepage() implementation always needs to do either this,\n\t * or re-dirty the page with \"redirty_page_for_writepage()\" in\n\t * the case of a failure.\n\t *\n\t * Just unlocking the page will cause the radix tree tag-bits\n\t * to fail to update with the state of the page correctly.\n\t */\n\tset_page_writeback(page);\nretry_write:\n\trc = cifs_partialpagewrite(page, 0, PAGE_CACHE_SIZE);\n\tif (rc == -EAGAIN && wbc->sync_mode == WB_SYNC_ALL)\n\t\tgoto retry_write;\n\telse if (rc == -EAGAIN)\n\t\tredirty_page_for_writepage(wbc, page);\n\telse if (rc != 0)\n\t\tSetPageError(page);\n\telse\n\t\tSetPageUptodate(page);\n\tend_page_writeback(page);\n\tpage_cache_release(page);\n\tfree_xid(xid);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 3807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Launder page: %p\\n\"",
            "page"
          ],
          "line": 3805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "PAGE_CACHE_SIZE - 1"
          ],
          "line": 3797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 3796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_launder_page(struct page *page)\n{\n\tint rc = 0;\n\tloff_t range_start = page_offset(page);\n\tloff_t range_end = range_start + (loff_t)(PAGE_CACHE_SIZE - 1);\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = 0,\n\t\t.range_start = range_start,\n\t\t.range_end = range_end,\n\t};\n\n\tcifs_dbg(FYI, \"Launder page: %p\\n\", page);\n\n\tif (clear_page_dirty_for_io(page))\n\t\trc = cifs_writepage_locked(page, &wbc);\n\n\tcifs_fscache_invalidate_page(page, page->mapping->host);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_invalidate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "3784-3791",
    "snippet": "static void cifs_invalidate_page(struct page *page, unsigned int offset,\n\t\t\t\t unsigned int length)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(page->mapping->host);\n\n\tif (offset == 0 && length == PAGE_CACHE_SIZE)\n\t\tcifs_fscache_invalidate_page(page, &cifsi->vfs_inode);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_fscache_invalidate_page",
          "args": [
            "page",
            "&cifsi->vfs_inode"
          ],
          "line": 3790
        },
        "resolved": true,
        "details": {
          "function_name": "__cifs_fscache_invalidate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
          "lines": "233-241",
          "snippet": "void __cifs_fscache_invalidate_page(struct page *page, struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct fscache_cookie *cookie = cifsi->fscache;\n\n\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\", __func__, page, cookie);\n\tfscache_wait_on_page_write(cookie, page);\n\tfscache_uncache_page(cookie, page);\n}",
          "includes": [
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid __cifs_fscache_invalidate_page(struct page *page, struct inode *inode)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct fscache_cookie *cookie = cifsi->fscache;\n\n\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\", __func__, page, cookie);\n\tfscache_wait_on_page_write(cookie, page);\n\tfscache_uncache_page(cookie, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "page->mapping->host"
          ],
          "line": 3787
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic void cifs_invalidate_page(struct page *page, unsigned int offset,\n\t\t\t\t unsigned int length)\n{\n\tstruct cifsInodeInfo *cifsi = CIFS_I(page->mapping->host);\n\n\tif (offset == 0 && length == PAGE_CACHE_SIZE)\n\t\tcifs_fscache_invalidate_page(page, &cifsi->vfs_inode);\n}"
  },
  {
    "function_name": "cifs_release_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "3776-3782",
    "snippet": "static int cifs_release_page(struct page *page, gfp_t gfp)\n{\n\tif (PagePrivate(page))\n\t\treturn 0;\n\n\treturn cifs_fscache_release_page(page, gfp);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_fscache_release_page",
          "args": [
            "page",
            "gfp"
          ],
          "line": 3781
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fscache_release_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
          "lines": "128-141",
          "snippet": "int cifs_fscache_release_page(struct page *page, gfp_t gfp)\n{\n\tif (PageFsCache(page)) {\n\t\tstruct inode *inode = page->mapping->host;\n\t\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\n\t\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\",\n\t\t\t __func__, page, cifsi->fscache);\n\t\tif (!fscache_maybe_release_page(cifsi->fscache, page, gfp))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nint cifs_fscache_release_page(struct page *page, gfp_t gfp)\n{\n\tif (PageFsCache(page)) {\n\t\tstruct inode *inode = page->mapping->host;\n\t\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\n\t\tcifs_dbg(FYI, \"%s: (0x%p/0x%p)\\n\",\n\t\t\t __func__, page, cifsi->fscache);\n\t\tif (!fscache_maybe_release_page(cifsi->fscache, page, gfp))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 3778
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_release_page(struct page *page, gfp_t gfp)\n{\n\tif (PagePrivate(page))\n\t\treturn 0;\n\n\treturn cifs_fscache_release_page(page, gfp);\n}"
  },
  {
    "function_name": "cifs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "3699-3774",
    "snippet": "static int cifs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint oncethru = 0;\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tloff_t offset = pos & (PAGE_CACHE_SIZE - 1);\n\tloff_t page_start = pos & PAGE_MASK;\n\tloff_t i_size;\n\tstruct page *page;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"write_begin from %lld len %d\\n\", (long long)pos, len);\n\nstart:\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\t/*\n\t * If we write a full page it will be up to date, no need to read from\n\t * the server. If the write is short, we'll end up doing a sync write\n\t * instead.\n\t */\n\tif (len == PAGE_CACHE_SIZE)\n\t\tgoto out;\n\n\t/*\n\t * optimize away the read when we have an oplock, and we're not\n\t * expecting to use any of the data we'd be reading in. That\n\t * is, when the page lies beyond the EOF, or straddles the EOF\n\t * and the write will cover all of the existing data.\n\t */\n\tif (CIFS_CACHE_READ(CIFS_I(mapping->host))) {\n\t\ti_size = i_size_read(mapping->host);\n\t\tif (page_start >= i_size ||\n\t\t    (offset == 0 && (pos + len) >= i_size)) {\n\t\t\tzero_user_segments(page, 0, offset,\n\t\t\t\t\t   offset + len,\n\t\t\t\t\t   PAGE_CACHE_SIZE);\n\t\t\t/*\n\t\t\t * PageChecked means that the parts of the page\n\t\t\t * to which we're not writing are considered up\n\t\t\t * to date. Once the data is copied to the\n\t\t\t * page, it can be set uptodate.\n\t\t\t */\n\t\t\tSetPageChecked(page);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif ((file->f_flags & O_ACCMODE) != O_WRONLY && !oncethru) {\n\t\t/*\n\t\t * might as well read a page, it is fast enough. If we get\n\t\t * an error, we don't need to return it. cifs_write_end will\n\t\t * do a sync write instead since PG_uptodate isn't set.\n\t\t */\n\t\tcifs_readpage_worker(file, page, &page_start);\n\t\tpage_cache_release(page);\n\t\toncethru = 1;\n\t\tgoto start;\n\t} else {\n\t\t/* we could try using another file handle if there is one -\n\t\t   but how would we lock it to prevent close of that handle\n\t\t   racing with this read? In any case\n\t\t   this will be written out by write_end so is fine */\n\t}\nout:\n\t*pagep = page;\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 3762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_readpage_worker",
          "args": [
            "file",
            "page",
            "&page_start"
          ],
          "line": 3761
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_readpage_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "3588-3629",
          "snippet": "static int cifs_readpage_worker(struct file *file, struct page *page,\n\tloff_t *poffset)\n{\n\tchar *read_data;\n\tint rc;\n\n\t/* Is the page cached? */\n\trc = cifs_readpage_from_fscache(file_inode(file), page);\n\tif (rc == 0)\n\t\tgoto read_complete;\n\n\tread_data = kmap(page);\n\t/* for reads over a certain size could initiate async read ahead */\n\n\trc = cifs_read(file, read_data, PAGE_CACHE_SIZE, poffset);\n\n\tif (rc < 0)\n\t\tgoto io_error;\n\telse\n\t\tcifs_dbg(FYI, \"Bytes read %d\\n\", rc);\n\n\tfile_inode(file)->i_atime =\n\t\tcurrent_fs_time(file_inode(file)->i_sb);\n\n\tif (PAGE_CACHE_SIZE > rc)\n\t\tmemset(read_data + rc, 0, PAGE_CACHE_SIZE - rc);\n\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\n\t/* send this page to the cache */\n\tcifs_readpage_to_fscache(file_inode(file), page);\n\n\trc = 0;\n\nio_error:\n\tkunmap(page);\n\tunlock_page(page);\n\nread_complete:\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_readpage_worker(struct file *file, struct page *page,\n\tloff_t *poffset)\n{\n\tchar *read_data;\n\tint rc;\n\n\t/* Is the page cached? */\n\trc = cifs_readpage_from_fscache(file_inode(file), page);\n\tif (rc == 0)\n\t\tgoto read_complete;\n\n\tread_data = kmap(page);\n\t/* for reads over a certain size could initiate async read ahead */\n\n\trc = cifs_read(file, read_data, PAGE_CACHE_SIZE, poffset);\n\n\tif (rc < 0)\n\t\tgoto io_error;\n\telse\n\t\tcifs_dbg(FYI, \"Bytes read %d\\n\", rc);\n\n\tfile_inode(file)->i_atime =\n\t\tcurrent_fs_time(file_inode(file)->i_sb);\n\n\tif (PAGE_CACHE_SIZE > rc)\n\t\tmemset(read_data + rc, 0, PAGE_CACHE_SIZE - rc);\n\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\n\t/* send this page to the cache */\n\tcifs_readpage_to_fscache(file_inode(file), page);\n\n\trc = 0;\n\nio_error:\n\tkunmap(page);\n\tunlock_page(page);\n\nread_complete:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageChecked",
          "args": [
            "page"
          ],
          "line": 3750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segments",
          "args": [
            "page",
            "0",
            "offset",
            "offset + len",
            "PAGE_CACHE_SIZE"
          ],
          "line": 3741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "mapping->host"
          ],
          "line": 3738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "CIFS_I(mapping->host)"
          ],
          "line": 3737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "mapping->host"
          ],
          "line": 3737
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 3720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 3714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"write_begin from %lld len %d\\n\"",
            "(long long)pos",
            "len"
          ],
          "line": 3711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint oncethru = 0;\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tloff_t offset = pos & (PAGE_CACHE_SIZE - 1);\n\tloff_t page_start = pos & PAGE_MASK;\n\tloff_t i_size;\n\tstruct page *page;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"write_begin from %lld len %d\\n\", (long long)pos, len);\n\nstart:\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\t/*\n\t * If we write a full page it will be up to date, no need to read from\n\t * the server. If the write is short, we'll end up doing a sync write\n\t * instead.\n\t */\n\tif (len == PAGE_CACHE_SIZE)\n\t\tgoto out;\n\n\t/*\n\t * optimize away the read when we have an oplock, and we're not\n\t * expecting to use any of the data we'd be reading in. That\n\t * is, when the page lies beyond the EOF, or straddles the EOF\n\t * and the write will cover all of the existing data.\n\t */\n\tif (CIFS_CACHE_READ(CIFS_I(mapping->host))) {\n\t\ti_size = i_size_read(mapping->host);\n\t\tif (page_start >= i_size ||\n\t\t    (offset == 0 && (pos + len) >= i_size)) {\n\t\t\tzero_user_segments(page, 0, offset,\n\t\t\t\t\t   offset + len,\n\t\t\t\t\t   PAGE_CACHE_SIZE);\n\t\t\t/*\n\t\t\t * PageChecked means that the parts of the page\n\t\t\t * to which we're not writing are considered up\n\t\t\t * to date. Once the data is copied to the\n\t\t\t * page, it can be set uptodate.\n\t\t\t */\n\t\t\tSetPageChecked(page);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif ((file->f_flags & O_ACCMODE) != O_WRONLY && !oncethru) {\n\t\t/*\n\t\t * might as well read a page, it is fast enough. If we get\n\t\t * an error, we don't need to return it. cifs_write_end will\n\t\t * do a sync write instead since PG_uptodate isn't set.\n\t\t */\n\t\tcifs_readpage_worker(file, page, &page_start);\n\t\tpage_cache_release(page);\n\t\toncethru = 1;\n\t\tgoto start;\n\t} else {\n\t\t/* we could try using another file handle if there is one -\n\t\t   but how would we lock it to prevent close of that handle\n\t\t   racing with this read? In any case\n\t\t   this will be written out by write_end so is fine */\n\t}\nout:\n\t*pagep = page;\n\treturn rc;\n}"
  },
  {
    "function_name": "is_size_safe_to_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "3675-3697",
    "snippet": "bool is_size_safe_to_change(struct cifsInodeInfo *cifsInode, __u64 end_of_file)\n{\n\tif (!cifsInode)\n\t\treturn true;\n\n\tif (is_inode_writable(cifsInode)) {\n\t\t/* This inode is open for write at least once */\n\t\tstruct cifs_sb_info *cifs_sb;\n\n\t\tcifs_sb = CIFS_SB(cifsInode->vfs_inode.i_sb);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO) {\n\t\t\t/* since no page cache to corrupt on directio\n\t\t\twe can change size safely */\n\t\t\treturn true;\n\t\t}\n\n\t\tif (i_size_read(&cifsInode->vfs_inode) < end_of_file)\n\t\t\treturn true;\n\n\t\treturn false;\n\t} else\n\t\treturn true;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "&cifsInode->vfs_inode"
          ],
          "line": 3691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "cifsInode->vfs_inode.i_sb"
          ],
          "line": 3684
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_inode_writable",
          "args": [
            "cifsInode"
          ],
          "line": 3680
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_writable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "3654-3667",
          "snippet": "static int is_inode_writable(struct cifsInodeInfo *cifs_inode)\n{\n\tstruct cifsFileInfo *open_file;\n\n\tspin_lock(&cifs_file_list_lock);\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_WRITE) {\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int is_inode_writable(struct cifsInodeInfo *cifs_inode)\n{\n\tstruct cifsFileInfo *open_file;\n\n\tspin_lock(&cifs_file_list_lock);\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_WRITE) {\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nbool is_size_safe_to_change(struct cifsInodeInfo *cifsInode, __u64 end_of_file)\n{\n\tif (!cifsInode)\n\t\treturn true;\n\n\tif (is_inode_writable(cifsInode)) {\n\t\t/* This inode is open for write at least once */\n\t\tstruct cifs_sb_info *cifs_sb;\n\n\t\tcifs_sb = CIFS_SB(cifsInode->vfs_inode.i_sb);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO) {\n\t\t\t/* since no page cache to corrupt on directio\n\t\t\twe can change size safely */\n\t\t\treturn true;\n\t\t}\n\n\t\tif (i_size_read(&cifsInode->vfs_inode) < end_of_file)\n\t\t\treturn true;\n\n\t\treturn false;\n\t} else\n\t\treturn true;\n}"
  },
  {
    "function_name": "is_inode_writable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "3654-3667",
    "snippet": "static int is_inode_writable(struct cifsInodeInfo *cifs_inode)\n{\n\tstruct cifsFileInfo *open_file;\n\n\tspin_lock(&cifs_file_list_lock);\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_WRITE) {\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 3665
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OPEN_FMODE",
          "args": [
            "open_file->f_flags"
          ],
          "line": 3660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "open_file",
            "&cifs_inode->openFileList",
            "flist"
          ],
          "line": 3659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 3658
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int is_inode_writable(struct cifsInodeInfo *cifs_inode)\n{\n\tstruct cifsFileInfo *open_file;\n\n\tspin_lock(&cifs_file_list_lock);\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_WRITE) {\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "3631-3652",
    "snippet": "static int cifs_readpage(struct file *file, struct page *page)\n{\n\tloff_t offset = (loff_t)page->index << PAGE_CACHE_SHIFT;\n\tint rc = -EACCES;\n\tunsigned int xid;\n\n\txid = get_xid();\n\n\tif (file->private_data == NULL) {\n\t\trc = -EBADF;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tcifs_dbg(FYI, \"readpage %p at offset %d 0x%x\\n\",\n\t\t page, (int)offset, (int)offset);\n\n\trc = cifs_readpage_worker(file, page, &offset);\n\n\tfree_xid(xid);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 3650
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_readpage_worker",
          "args": [
            "file",
            "page",
            "&offset"
          ],
          "line": 3648
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_readpage_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "3588-3629",
          "snippet": "static int cifs_readpage_worker(struct file *file, struct page *page,\n\tloff_t *poffset)\n{\n\tchar *read_data;\n\tint rc;\n\n\t/* Is the page cached? */\n\trc = cifs_readpage_from_fscache(file_inode(file), page);\n\tif (rc == 0)\n\t\tgoto read_complete;\n\n\tread_data = kmap(page);\n\t/* for reads over a certain size could initiate async read ahead */\n\n\trc = cifs_read(file, read_data, PAGE_CACHE_SIZE, poffset);\n\n\tif (rc < 0)\n\t\tgoto io_error;\n\telse\n\t\tcifs_dbg(FYI, \"Bytes read %d\\n\", rc);\n\n\tfile_inode(file)->i_atime =\n\t\tcurrent_fs_time(file_inode(file)->i_sb);\n\n\tif (PAGE_CACHE_SIZE > rc)\n\t\tmemset(read_data + rc, 0, PAGE_CACHE_SIZE - rc);\n\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\n\t/* send this page to the cache */\n\tcifs_readpage_to_fscache(file_inode(file), page);\n\n\trc = 0;\n\nio_error:\n\tkunmap(page);\n\tunlock_page(page);\n\nread_complete:\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_readpage_worker(struct file *file, struct page *page,\n\tloff_t *poffset)\n{\n\tchar *read_data;\n\tint rc;\n\n\t/* Is the page cached? */\n\trc = cifs_readpage_from_fscache(file_inode(file), page);\n\tif (rc == 0)\n\t\tgoto read_complete;\n\n\tread_data = kmap(page);\n\t/* for reads over a certain size could initiate async read ahead */\n\n\trc = cifs_read(file, read_data, PAGE_CACHE_SIZE, poffset);\n\n\tif (rc < 0)\n\t\tgoto io_error;\n\telse\n\t\tcifs_dbg(FYI, \"Bytes read %d\\n\", rc);\n\n\tfile_inode(file)->i_atime =\n\t\tcurrent_fs_time(file_inode(file)->i_sb);\n\n\tif (PAGE_CACHE_SIZE > rc)\n\t\tmemset(read_data + rc, 0, PAGE_CACHE_SIZE - rc);\n\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\n\t/* send this page to the cache */\n\tcifs_readpage_to_fscache(file_inode(file), page);\n\n\trc = 0;\n\nio_error:\n\tkunmap(page);\n\tunlock_page(page);\n\nread_complete:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"readpage %p at offset %d 0x%x\\n\"",
            "page",
            "(int)offset",
            "(int)offset"
          ],
          "line": 3645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 3637
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_readpage(struct file *file, struct page *page)\n{\n\tloff_t offset = (loff_t)page->index << PAGE_CACHE_SHIFT;\n\tint rc = -EACCES;\n\tunsigned int xid;\n\n\txid = get_xid();\n\n\tif (file->private_data == NULL) {\n\t\trc = -EBADF;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tcifs_dbg(FYI, \"readpage %p at offset %d 0x%x\\n\",\n\t\t page, (int)offset, (int)offset);\n\n\trc = cifs_readpage_worker(file, page, &offset);\n\n\tfree_xid(xid);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_readpage_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "3588-3629",
    "snippet": "static int cifs_readpage_worker(struct file *file, struct page *page,\n\tloff_t *poffset)\n{\n\tchar *read_data;\n\tint rc;\n\n\t/* Is the page cached? */\n\trc = cifs_readpage_from_fscache(file_inode(file), page);\n\tif (rc == 0)\n\t\tgoto read_complete;\n\n\tread_data = kmap(page);\n\t/* for reads over a certain size could initiate async read ahead */\n\n\trc = cifs_read(file, read_data, PAGE_CACHE_SIZE, poffset);\n\n\tif (rc < 0)\n\t\tgoto io_error;\n\telse\n\t\tcifs_dbg(FYI, \"Bytes read %d\\n\", rc);\n\n\tfile_inode(file)->i_atime =\n\t\tcurrent_fs_time(file_inode(file)->i_sb);\n\n\tif (PAGE_CACHE_SIZE > rc)\n\t\tmemset(read_data + rc, 0, PAGE_CACHE_SIZE - rc);\n\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\n\t/* send this page to the cache */\n\tcifs_readpage_to_fscache(file_inode(file), page);\n\n\trc = 0;\n\nio_error:\n\tkunmap(page);\n\tunlock_page(page);\n\nread_complete:\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 3625
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 3624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_readpage_to_fscache",
          "args": [
            "file_inode(file)",
            "page"
          ],
          "line": 3619
        },
        "resolved": true,
        "details": {
          "function_name": "__cifs_readpage_to_fscache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
          "lines": "215-224",
          "snippet": "void __cifs_readpage_to_fscache(struct inode *inode, struct page *page)\n{\n\tint ret;\n\n\tcifs_dbg(FYI, \"%s: (fsc: %p, p: %p, i: %p)\\n\",\n\t\t __func__, CIFS_I(inode)->fscache, page, inode);\n\tret = fscache_write_page(CIFS_I(inode)->fscache, page, GFP_KERNEL);\n\tif (ret != 0)\n\t\tfscache_uncache_page(CIFS_I(inode)->fscache, page);\n}",
          "includes": [
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid __cifs_readpage_to_fscache(struct inode *inode, struct page *page)\n{\n\tint ret;\n\n\tcifs_dbg(FYI, \"%s: (fsc: %p, p: %p, i: %p)\\n\",\n\t\t __func__, CIFS_I(inode)->fscache, page, inode);\n\tret = fscache_write_page(CIFS_I(inode)->fscache, page, GFP_KERNEL);\n\tif (ret != 0)\n\t\tfscache_uncache_page(CIFS_I(inode)->fscache, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 3619
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 3616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 3615
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "read_data + rc",
            "0",
            "PAGE_CACHE_SIZE - rc"
          ],
          "line": 3613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "file_inode(file)->i_sb"
          ],
          "line": 3610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Bytes read %d\\n\"",
            "rc"
          ],
          "line": 3607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_read",
          "args": [
            "file",
            "read_data",
            "PAGE_CACHE_SIZE",
            "poffset"
          ],
          "line": 3602
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "3456-3583",
          "snippet": "static int cifs_readpages(struct file *file, struct address_space *mapping,\n\tstruct list_head *page_list, unsigned num_pages)\n{\n\tint rc;\n\tstruct list_head tmplist;\n\tstruct cifsFileInfo *open_file = file->private_data;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct TCP_Server_Info *server;\n\tpid_t pid;\n\n\t/*\n\t * Reads as many pages as possible from fscache. Returns -ENOBUFS\n\t * immediately if the cookie is negative\n\t *\n\t * After this point, every page in the list might have PG_fscache set,\n\t * so we will need to clean that up off of every page we don't use.\n\t */\n\trc = cifs_readpages_from_fscache(mapping->host, mapping, page_list,\n\t\t\t\t\t &num_pages);\n\tif (rc == 0)\n\t\treturn rc;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\trc = 0;\n\tserver = tlink_tcon(open_file->tlink)->ses->server;\n\n\tcifs_dbg(FYI, \"%s: file=%p mapping=%p num_pages=%u\\n\",\n\t\t __func__, file, mapping, num_pages);\n\n\t/*\n\t * Start with the page at end of list and move it to private\n\t * list. Do the same with any following pages until we hit\n\t * the rsize limit, hit an index discontinuity, or run out of\n\t * pages. Issue the async read and then start the loop again\n\t * until the list is empty.\n\t *\n\t * Note that list order is important. The page_list is in\n\t * the order of declining indexes. When we put the pages in\n\t * the rdata->pages, then we want them in increasing order.\n\t */\n\twhile (!list_empty(page_list)) {\n\t\tunsigned int i, nr_pages, bytes, rsize;\n\t\tloff_t offset;\n\t\tstruct page *page, *tpage;\n\t\tstruct cifs_readdata *rdata;\n\t\tunsigned credits;\n\n\t\trc = server->ops->wait_mtu_credits(server, cifs_sb->rsize,\n\t\t\t\t\t\t   &rsize, &credits);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Give up immediately if rsize is too small to read an entire\n\t\t * page. The VFS will fall back to readpage. We should never\n\t\t * reach this point however since we set ra_pages to 0 when the\n\t\t * rsize is smaller than a cache page.\n\t\t */\n\t\tif (unlikely(rsize < PAGE_CACHE_SIZE)) {\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\treturn 0;\n\t\t}\n\n\t\trc = readpages_get_pages(mapping, page_list, rsize, &tmplist,\n\t\t\t\t\t &nr_pages, &offset, &bytes);\n\t\tif (rc) {\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\trdata = cifs_readdata_alloc(nr_pages, cifs_readv_complete);\n\t\tif (!rdata) {\n\t\t\t/* best to give up if we're out of mem */\n\t\t\tlist_for_each_entry_safe(page, tpage, &tmplist, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\tlru_cache_add_file(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t}\n\t\t\trc = -ENOMEM;\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\trdata->cfile = cifsFileInfo_get(open_file);\n\t\trdata->mapping = mapping;\n\t\trdata->offset = offset;\n\t\trdata->bytes = bytes;\n\t\trdata->pid = pid;\n\t\trdata->pagesz = PAGE_CACHE_SIZE;\n\t\trdata->read_into_pages = cifs_readpages_read_into_pages;\n\t\trdata->credits = credits;\n\n\t\tlist_for_each_entry_safe(page, tpage, &tmplist, lru) {\n\t\t\tlist_del(&page->lru);\n\t\t\trdata->pages[rdata->nr_pages++] = page;\n\t\t}\n\n\t\tif (!rdata->cfile->invalidHandle ||\n\t\t    !cifs_reopen_file(rdata->cfile, true))\n\t\t\trc = server->ops->async_readv(rdata);\n\t\tif (rc) {\n\t\t\tadd_credits_and_wake_if(server, rdata->credits, 0);\n\t\t\tfor (i = 0; i < rdata->nr_pages; i++) {\n\t\t\t\tpage = rdata->pages[i];\n\t\t\t\tlru_cache_add_file(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t}\n\t\t\t/* Fallback to the readpage in error/reconnect cases */\n\t\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\t\t\tbreak;\n\t\t}\n\n\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\t}\n\n\t/* Any pages that have been shown to fscache but didn't get added to\n\t * the pagecache must be uncached before they get returned to the\n\t * allocator.\n\t */\n\tcifs_fscache_readpages_cancel(mapping->host, page_list);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int cifs_readpages(struct file *file, struct address_space *mapping,\n\tstruct list_head *page_list, unsigned num_pages)\n{\n\tint rc;\n\tstruct list_head tmplist;\n\tstruct cifsFileInfo *open_file = file->private_data;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct TCP_Server_Info *server;\n\tpid_t pid;\n\n\t/*\n\t * Reads as many pages as possible from fscache. Returns -ENOBUFS\n\t * immediately if the cookie is negative\n\t *\n\t * After this point, every page in the list might have PG_fscache set,\n\t * so we will need to clean that up off of every page we don't use.\n\t */\n\trc = cifs_readpages_from_fscache(mapping->host, mapping, page_list,\n\t\t\t\t\t &num_pages);\n\tif (rc == 0)\n\t\treturn rc;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\trc = 0;\n\tserver = tlink_tcon(open_file->tlink)->ses->server;\n\n\tcifs_dbg(FYI, \"%s: file=%p mapping=%p num_pages=%u\\n\",\n\t\t __func__, file, mapping, num_pages);\n\n\t/*\n\t * Start with the page at end of list and move it to private\n\t * list. Do the same with any following pages until we hit\n\t * the rsize limit, hit an index discontinuity, or run out of\n\t * pages. Issue the async read and then start the loop again\n\t * until the list is empty.\n\t *\n\t * Note that list order is important. The page_list is in\n\t * the order of declining indexes. When we put the pages in\n\t * the rdata->pages, then we want them in increasing order.\n\t */\n\twhile (!list_empty(page_list)) {\n\t\tunsigned int i, nr_pages, bytes, rsize;\n\t\tloff_t offset;\n\t\tstruct page *page, *tpage;\n\t\tstruct cifs_readdata *rdata;\n\t\tunsigned credits;\n\n\t\trc = server->ops->wait_mtu_credits(server, cifs_sb->rsize,\n\t\t\t\t\t\t   &rsize, &credits);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Give up immediately if rsize is too small to read an entire\n\t\t * page. The VFS will fall back to readpage. We should never\n\t\t * reach this point however since we set ra_pages to 0 when the\n\t\t * rsize is smaller than a cache page.\n\t\t */\n\t\tif (unlikely(rsize < PAGE_CACHE_SIZE)) {\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\treturn 0;\n\t\t}\n\n\t\trc = readpages_get_pages(mapping, page_list, rsize, &tmplist,\n\t\t\t\t\t &nr_pages, &offset, &bytes);\n\t\tif (rc) {\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\trdata = cifs_readdata_alloc(nr_pages, cifs_readv_complete);\n\t\tif (!rdata) {\n\t\t\t/* best to give up if we're out of mem */\n\t\t\tlist_for_each_entry_safe(page, tpage, &tmplist, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\tlru_cache_add_file(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t}\n\t\t\trc = -ENOMEM;\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\trdata->cfile = cifsFileInfo_get(open_file);\n\t\trdata->mapping = mapping;\n\t\trdata->offset = offset;\n\t\trdata->bytes = bytes;\n\t\trdata->pid = pid;\n\t\trdata->pagesz = PAGE_CACHE_SIZE;\n\t\trdata->read_into_pages = cifs_readpages_read_into_pages;\n\t\trdata->credits = credits;\n\n\t\tlist_for_each_entry_safe(page, tpage, &tmplist, lru) {\n\t\t\tlist_del(&page->lru);\n\t\t\trdata->pages[rdata->nr_pages++] = page;\n\t\t}\n\n\t\tif (!rdata->cfile->invalidHandle ||\n\t\t    !cifs_reopen_file(rdata->cfile, true))\n\t\t\trc = server->ops->async_readv(rdata);\n\t\tif (rc) {\n\t\t\tadd_credits_and_wake_if(server, rdata->credits, 0);\n\t\t\tfor (i = 0; i < rdata->nr_pages; i++) {\n\t\t\t\tpage = rdata->pages[i];\n\t\t\t\tlru_cache_add_file(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t}\n\t\t\t/* Fallback to the readpage in error/reconnect cases */\n\t\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\t\t\tbreak;\n\t\t}\n\n\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\t}\n\n\t/* Any pages that have been shown to fscache but didn't get added to\n\t * the pagecache must be uncached before they get returned to the\n\t * allocator.\n\t */\n\tcifs_fscache_readpages_cancel(mapping->host, page_list);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 3599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_readpage_from_fscache",
          "args": [
            "file_inode(file)",
            "page"
          ],
          "line": 3595
        },
        "resolved": true,
        "details": {
          "function_name": "__cifs_readpage_from_fscache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
          "lines": "155-179",
          "snippet": "int __cifs_readpage_from_fscache(struct inode *inode, struct page *page)\n{\n\tint ret;\n\n\tcifs_dbg(FYI, \"%s: (fsc:%p, p:%p, i:0x%p\\n\",\n\t\t __func__, CIFS_I(inode)->fscache, page, inode);\n\tret = fscache_read_or_alloc_page(CIFS_I(inode)->fscache, page,\n\t\t\t\t\t cifs_readpage_from_fscache_complete,\n\t\t\t\t\t NULL,\n\t\t\t\t\t GFP_KERNEL);\n\tswitch (ret) {\n\n\tcase 0: /* page found in fscache, read submitted */\n\t\tcifs_dbg(FYI, \"%s: submitted\\n\", __func__);\n\t\treturn ret;\n\tcase -ENOBUFS:\t/* page won't be cached */\n\tcase -ENODATA:\t/* page not in cache */\n\t\tcifs_dbg(FYI, \"%s: %d\\n\", __func__, ret);\n\t\treturn 1;\n\n\tdefault:\n\t\tcifs_dbg(VFS, \"unknown error ret = %d\\n\", ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nint __cifs_readpage_from_fscache(struct inode *inode, struct page *page)\n{\n\tint ret;\n\n\tcifs_dbg(FYI, \"%s: (fsc:%p, p:%p, i:0x%p\\n\",\n\t\t __func__, CIFS_I(inode)->fscache, page, inode);\n\tret = fscache_read_or_alloc_page(CIFS_I(inode)->fscache, page,\n\t\t\t\t\t cifs_readpage_from_fscache_complete,\n\t\t\t\t\t NULL,\n\t\t\t\t\t GFP_KERNEL);\n\tswitch (ret) {\n\n\tcase 0: /* page found in fscache, read submitted */\n\t\tcifs_dbg(FYI, \"%s: submitted\\n\", __func__);\n\t\treturn ret;\n\tcase -ENOBUFS:\t/* page won't be cached */\n\tcase -ENODATA:\t/* page not in cache */\n\t\tcifs_dbg(FYI, \"%s: %d\\n\", __func__, ret);\n\t\treturn 1;\n\n\tdefault:\n\t\tcifs_dbg(VFS, \"unknown error ret = %d\\n\", ret);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_readpage_worker(struct file *file, struct page *page,\n\tloff_t *poffset)\n{\n\tchar *read_data;\n\tint rc;\n\n\t/* Is the page cached? */\n\trc = cifs_readpage_from_fscache(file_inode(file), page);\n\tif (rc == 0)\n\t\tgoto read_complete;\n\n\tread_data = kmap(page);\n\t/* for reads over a certain size could initiate async read ahead */\n\n\trc = cifs_read(file, read_data, PAGE_CACHE_SIZE, poffset);\n\n\tif (rc < 0)\n\t\tgoto io_error;\n\telse\n\t\tcifs_dbg(FYI, \"Bytes read %d\\n\", rc);\n\n\tfile_inode(file)->i_atime =\n\t\tcurrent_fs_time(file_inode(file)->i_sb);\n\n\tif (PAGE_CACHE_SIZE > rc)\n\t\tmemset(read_data + rc, 0, PAGE_CACHE_SIZE - rc);\n\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\n\t/* send this page to the cache */\n\tcifs_readpage_to_fscache(file_inode(file), page);\n\n\trc = 0;\n\nio_error:\n\tkunmap(page);\n\tunlock_page(page);\n\nread_complete:\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "3456-3583",
    "snippet": "static int cifs_readpages(struct file *file, struct address_space *mapping,\n\tstruct list_head *page_list, unsigned num_pages)\n{\n\tint rc;\n\tstruct list_head tmplist;\n\tstruct cifsFileInfo *open_file = file->private_data;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct TCP_Server_Info *server;\n\tpid_t pid;\n\n\t/*\n\t * Reads as many pages as possible from fscache. Returns -ENOBUFS\n\t * immediately if the cookie is negative\n\t *\n\t * After this point, every page in the list might have PG_fscache set,\n\t * so we will need to clean that up off of every page we don't use.\n\t */\n\trc = cifs_readpages_from_fscache(mapping->host, mapping, page_list,\n\t\t\t\t\t &num_pages);\n\tif (rc == 0)\n\t\treturn rc;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\trc = 0;\n\tserver = tlink_tcon(open_file->tlink)->ses->server;\n\n\tcifs_dbg(FYI, \"%s: file=%p mapping=%p num_pages=%u\\n\",\n\t\t __func__, file, mapping, num_pages);\n\n\t/*\n\t * Start with the page at end of list and move it to private\n\t * list. Do the same with any following pages until we hit\n\t * the rsize limit, hit an index discontinuity, or run out of\n\t * pages. Issue the async read and then start the loop again\n\t * until the list is empty.\n\t *\n\t * Note that list order is important. The page_list is in\n\t * the order of declining indexes. When we put the pages in\n\t * the rdata->pages, then we want them in increasing order.\n\t */\n\twhile (!list_empty(page_list)) {\n\t\tunsigned int i, nr_pages, bytes, rsize;\n\t\tloff_t offset;\n\t\tstruct page *page, *tpage;\n\t\tstruct cifs_readdata *rdata;\n\t\tunsigned credits;\n\n\t\trc = server->ops->wait_mtu_credits(server, cifs_sb->rsize,\n\t\t\t\t\t\t   &rsize, &credits);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Give up immediately if rsize is too small to read an entire\n\t\t * page. The VFS will fall back to readpage. We should never\n\t\t * reach this point however since we set ra_pages to 0 when the\n\t\t * rsize is smaller than a cache page.\n\t\t */\n\t\tif (unlikely(rsize < PAGE_CACHE_SIZE)) {\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\treturn 0;\n\t\t}\n\n\t\trc = readpages_get_pages(mapping, page_list, rsize, &tmplist,\n\t\t\t\t\t &nr_pages, &offset, &bytes);\n\t\tif (rc) {\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\trdata = cifs_readdata_alloc(nr_pages, cifs_readv_complete);\n\t\tif (!rdata) {\n\t\t\t/* best to give up if we're out of mem */\n\t\t\tlist_for_each_entry_safe(page, tpage, &tmplist, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\tlru_cache_add_file(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t}\n\t\t\trc = -ENOMEM;\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\trdata->cfile = cifsFileInfo_get(open_file);\n\t\trdata->mapping = mapping;\n\t\trdata->offset = offset;\n\t\trdata->bytes = bytes;\n\t\trdata->pid = pid;\n\t\trdata->pagesz = PAGE_CACHE_SIZE;\n\t\trdata->read_into_pages = cifs_readpages_read_into_pages;\n\t\trdata->credits = credits;\n\n\t\tlist_for_each_entry_safe(page, tpage, &tmplist, lru) {\n\t\t\tlist_del(&page->lru);\n\t\t\trdata->pages[rdata->nr_pages++] = page;\n\t\t}\n\n\t\tif (!rdata->cfile->invalidHandle ||\n\t\t    !cifs_reopen_file(rdata->cfile, true))\n\t\t\trc = server->ops->async_readv(rdata);\n\t\tif (rc) {\n\t\t\tadd_credits_and_wake_if(server, rdata->credits, 0);\n\t\t\tfor (i = 0; i < rdata->nr_pages; i++) {\n\t\t\t\tpage = rdata->pages[i];\n\t\t\t\tlru_cache_add_file(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t}\n\t\t\t/* Fallback to the readpage in error/reconnect cases */\n\t\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\t\t\tbreak;\n\t\t}\n\n\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\t}\n\n\t/* Any pages that have been shown to fscache but didn't get added to\n\t * the pagecache must be uncached before they get returned to the\n\t * allocator.\n\t */\n\tcifs_fscache_readpages_cancel(mapping->host, page_list);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_fscache_readpages_cancel",
          "args": [
            "mapping->host",
            "page_list"
          ],
          "line": 3581
        },
        "resolved": true,
        "details": {
          "function_name": "__cifs_fscache_readpages_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
          "lines": "226-231",
          "snippet": "void __cifs_fscache_readpages_cancel(struct inode *inode, struct list_head *pages)\n{\n\tcifs_dbg(FYI, \"%s: (fsc: %p, i: %p)\\n\",\n\t\t __func__, CIFS_I(inode)->fscache, inode);\n\tfscache_readpages_cancel(CIFS_I(inode)->fscache, pages);\n}",
          "includes": [
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid __cifs_fscache_readpages_cancel(struct inode *inode, struct list_head *pages)\n{\n\tcifs_dbg(FYI, \"%s: (fsc: %p, i: %p)\\n\",\n\t\t __func__, CIFS_I(inode)->fscache, inode);\n\tfscache_readpages_cancel(CIFS_I(inode)->fscache, pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&rdata->refcount",
            "cifs_readdata_release"
          ],
          "line": 3574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&rdata->refcount",
            "cifs_readdata_release"
          ],
          "line": 3570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 3567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 3566
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_cache_add_file",
          "args": [
            "page"
          ],
          "line": 3565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_credits_and_wake_if",
          "args": [
            "server",
            "rdata->credits",
            "0"
          ],
          "line": 3562
        },
        "resolved": true,
        "details": {
          "function_name": "add_credits_and_wake_if",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "648-656",
          "snippet": "static inline void\nadd_credits_and_wake_if(struct TCP_Server_Info *server, const unsigned int add,\n\t\t\tconst int optype)\n{\n\tif (add) {\n\t\tserver->ops->add_credits(server, add, optype);\n\t\twake_up(&server->request_q);\n\t}\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\nadd_credits_and_wake_if(struct TCP_Server_Info *server, const unsigned int add,\n\t\t\tconst int optype)\n{\n\tif (add) {\n\t\tserver->ops->add_credits(server, add, optype);\n\t\twake_up(&server->request_q);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->async_readv",
          "args": [
            "rdata"
          ],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_reopen_file",
          "args": [
            "rdata->cfile",
            "true"
          ],
          "line": 3559
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_reopen_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "597-744",
          "snippet": "static int\ncifs_reopen_file(struct cifsFileInfo *cfile, bool can_flush)\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\t__u32 oplock;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsInodeInfo *cinode;\n\tstruct inode *inode;\n\tchar *full_path = NULL;\n\tint desired_access;\n\tint disposition = FILE_OPEN;\n\tint create_options = CREATE_NOT_DIR;\n\tstruct cifs_open_parms oparms;\n\n\txid = get_xid();\n\tmutex_lock(&cfile->fh_mutex);\n\tif (!cfile->invalidHandle) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\trc = 0;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tinode = cfile->dentry->d_inode;\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttcon = tlink_tcon(cfile->tlink);\n\tserver = tcon->ses->server;\n\n\t/*\n\t * Can not grab rename sem here because various ops, including those\n\t * that already have the rename sem can end up causing writepage to get\n\t * called and if the server was down that means we end up here, and we\n\t * can never tell if the caller already has the rename_sem.\n\t */\n\tfull_path = build_path_from_dentry(cfile->dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tcifs_dbg(FYI, \"inode = 0x%p file flags 0x%x for %s\\n\",\n\t\t inode, cfile->f_flags, full_path);\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\t/*\n\t\t * O_CREAT, O_EXCL and O_TRUNC already had their effect on the\n\t\t * original open. Must mask them off for a reopen.\n\t\t */\n\t\tunsigned int oflags = cfile->f_flags &\n\t\t\t\t\t\t~(O_CREAT | O_EXCL | O_TRUNC);\n\n\t\trc = cifs_posix_open(full_path, NULL, inode->i_sb,\n\t\t\t\t     cifs_sb->mnt_file_mode /* ignored */,\n\t\t\t\t     oflags, &oplock, &cfile->fid.netfid, xid);\n\t\tif (rc == 0) {\n\t\t\tcifs_dbg(FYI, \"posix reopen succeeded\\n\");\n\t\t\toparms.reconnect = true;\n\t\t\tgoto reopen_success;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry open the old way on errors, especially\n\t\t * in the reconnect path it is important to retry hard\n\t\t */\n\t}\n\n\tdesired_access = cifs_convert_flags(cfile->f_flags);\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &cfile->fid);\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = &cfile->fid;\n\toparms.reconnect = true;\n\n\t/*\n\t * Can not refresh inode by passing in file_info buf to be returned by\n\t * ops->open and then calling get_inode_info with returned buf since\n\t * file might have write behind data that needs to be flushed and server\n\t * version of file size can be stale. If we knew for sure that inode was\n\t * not dirty locally we could do this.\n\t */\n\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\tif (rc == -ENOENT && oparms.reconnect == false) {\n\t\t/* durable handle timeout is expired - open the file again */\n\t\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\t\t/* indicate that we need to relock the file */\n\t\toparms.reconnect = true;\n\t}\n\n\tif (rc) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tcifs_dbg(FYI, \"cifs_reopen returned 0x%x\\n\", rc);\n\t\tcifs_dbg(FYI, \"oplock: %d\\n\", oplock);\n\t\tgoto reopen_error_exit;\n\t}\n\nreopen_success:\n\tcfile->invalidHandle = false;\n\tmutex_unlock(&cfile->fh_mutex);\n\tcinode = CIFS_I(inode);\n\n\tif (can_flush) {\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\t\tmapping_set_error(inode->i_mapping, rc);\n\n\t\tif (tcon->unix_ext)\n\t\t\trc = cifs_get_inode_info_unix(&inode, full_path,\n\t\t\t\t\t\t      inode->i_sb, xid);\n\t\telse\n\t\t\trc = cifs_get_inode_info(&inode, full_path, NULL,\n\t\t\t\t\t\t inode->i_sb, xid, NULL);\n\t}\n\t/*\n\t * Else we are writing out data to server already and could deadlock if\n\t * we tried to flush data, and since we do not know if we have data that\n\t * would invalidate the current end of file on the server we can not go\n\t * to the server to get the new inode info.\n\t */\n\n\tserver->ops->set_fid(cfile, &cfile->fid, oplock);\n\tif (oparms.reconnect)\n\t\tcifs_relock_file(cfile);\n\nreopen_error_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_reopen_file(struct cifsFileInfo *cfile, bool can_flush)\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\t__u32 oplock;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsInodeInfo *cinode;\n\tstruct inode *inode;\n\tchar *full_path = NULL;\n\tint desired_access;\n\tint disposition = FILE_OPEN;\n\tint create_options = CREATE_NOT_DIR;\n\tstruct cifs_open_parms oparms;\n\n\txid = get_xid();\n\tmutex_lock(&cfile->fh_mutex);\n\tif (!cfile->invalidHandle) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\trc = 0;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tinode = cfile->dentry->d_inode;\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttcon = tlink_tcon(cfile->tlink);\n\tserver = tcon->ses->server;\n\n\t/*\n\t * Can not grab rename sem here because various ops, including those\n\t * that already have the rename sem can end up causing writepage to get\n\t * called and if the server was down that means we end up here, and we\n\t * can never tell if the caller already has the rename_sem.\n\t */\n\tfull_path = build_path_from_dentry(cfile->dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tcifs_dbg(FYI, \"inode = 0x%p file flags 0x%x for %s\\n\",\n\t\t inode, cfile->f_flags, full_path);\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\t/*\n\t\t * O_CREAT, O_EXCL and O_TRUNC already had their effect on the\n\t\t * original open. Must mask them off for a reopen.\n\t\t */\n\t\tunsigned int oflags = cfile->f_flags &\n\t\t\t\t\t\t~(O_CREAT | O_EXCL | O_TRUNC);\n\n\t\trc = cifs_posix_open(full_path, NULL, inode->i_sb,\n\t\t\t\t     cifs_sb->mnt_file_mode /* ignored */,\n\t\t\t\t     oflags, &oplock, &cfile->fid.netfid, xid);\n\t\tif (rc == 0) {\n\t\t\tcifs_dbg(FYI, \"posix reopen succeeded\\n\");\n\t\t\toparms.reconnect = true;\n\t\t\tgoto reopen_success;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry open the old way on errors, especially\n\t\t * in the reconnect path it is important to retry hard\n\t\t */\n\t}\n\n\tdesired_access = cifs_convert_flags(cfile->f_flags);\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &cfile->fid);\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = &cfile->fid;\n\toparms.reconnect = true;\n\n\t/*\n\t * Can not refresh inode by passing in file_info buf to be returned by\n\t * ops->open and then calling get_inode_info with returned buf since\n\t * file might have write behind data that needs to be flushed and server\n\t * version of file size can be stale. If we knew for sure that inode was\n\t * not dirty locally we could do this.\n\t */\n\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\tif (rc == -ENOENT && oparms.reconnect == false) {\n\t\t/* durable handle timeout is expired - open the file again */\n\t\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\t\t/* indicate that we need to relock the file */\n\t\toparms.reconnect = true;\n\t}\n\n\tif (rc) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tcifs_dbg(FYI, \"cifs_reopen returned 0x%x\\n\", rc);\n\t\tcifs_dbg(FYI, \"oplock: %d\\n\", oplock);\n\t\tgoto reopen_error_exit;\n\t}\n\nreopen_success:\n\tcfile->invalidHandle = false;\n\tmutex_unlock(&cfile->fh_mutex);\n\tcinode = CIFS_I(inode);\n\n\tif (can_flush) {\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\t\tmapping_set_error(inode->i_mapping, rc);\n\n\t\tif (tcon->unix_ext)\n\t\t\trc = cifs_get_inode_info_unix(&inode, full_path,\n\t\t\t\t\t\t      inode->i_sb, xid);\n\t\telse\n\t\t\trc = cifs_get_inode_info(&inode, full_path, NULL,\n\t\t\t\t\t\t inode->i_sb, xid, NULL);\n\t}\n\t/*\n\t * Else we are writing out data to server already and could deadlock if\n\t * we tried to flush data, and since we do not know if we have data that\n\t * would invalidate the current end of file on the server we can not go\n\t * to the server to get the new inode info.\n\t */\n\n\tserver->ops->set_fid(cfile, &cfile->fid, oplock);\n\tif (oparms.reconnect)\n\t\tcifs_relock_file(cfile);\n\nreopen_error_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 3554
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "tpage",
            "&tmplist",
            "lru"
          ],
          "line": 3553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsFileInfo_get",
          "args": [
            "open_file"
          ],
          "line": 3544
        },
        "resolved": true,
        "details": {
          "function_name": "cifsFileInfo_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "344-351",
          "snippet": "struct cifsFileInfo *\ncifsFileInfo_get(struct cifsFileInfo *cifs_file)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tcifsFileInfo_get_locked(cifs_file);\n\tspin_unlock(&cifs_file_list_lock);\n\treturn cifs_file;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstruct cifsFileInfo *\ncifsFileInfo_get(struct cifsFileInfo *cifs_file)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tcifsFileInfo_get_locked(cifs_file);\n\tspin_unlock(&cifs_file_list_lock);\n\treturn cifs_file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 3537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_cache_add_file",
          "args": [
            "page"
          ],
          "line": 3535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "tpage",
            "&tmplist",
            "lru"
          ],
          "line": 3533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_readdata_alloc",
          "args": [
            "nr_pages",
            "cifs_readv_complete"
          ],
          "line": 3530
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_readdata_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "2769-2784",
          "snippet": "static struct cifs_readdata *\ncifs_readdata_alloc(unsigned int nr_pages, work_func_t complete)\n{\n\tstruct cifs_readdata *rdata;\n\n\trdata = kzalloc(sizeof(*rdata) + (sizeof(struct page *) * nr_pages),\n\t\t\tGFP_KERNEL);\n\tif (rdata != NULL) {\n\t\tkref_init(&rdata->refcount);\n\t\tINIT_LIST_HEAD(&rdata->list);\n\t\tinit_completion(&rdata->done);\n\t\tINIT_WORK(&rdata->work, complete);\n\t}\n\n\treturn rdata;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic struct cifs_readdata *\ncifs_readdata_alloc(unsigned int nr_pages, work_func_t complete)\n{\n\tstruct cifs_readdata *rdata;\n\n\trdata = kzalloc(sizeof(*rdata) + (sizeof(struct page *) * nr_pages),\n\t\t\tGFP_KERNEL);\n\tif (rdata != NULL) {\n\t\tkref_init(&rdata->refcount);\n\t\tINIT_LIST_HEAD(&rdata->list);\n\t\tinit_completion(&rdata->done);\n\t\tINIT_WORK(&rdata->work, complete);\n\t}\n\n\treturn rdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "readpages_get_pages",
          "args": [
            "mapping",
            "page_list",
            "rsize",
            "&tmplist",
            "&nr_pages",
            "&offset",
            "&bytes"
          ],
          "line": 3523
        },
        "resolved": true,
        "details": {
          "function_name": "readpages_get_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "3397-3454",
          "snippet": "static int\nreadpages_get_pages(struct address_space *mapping, struct list_head *page_list,\n\t\t    unsigned int rsize, struct list_head *tmplist,\n\t\t    unsigned int *nr_pages, loff_t *offset, unsigned int *bytes)\n{\n\tstruct page *page, *tpage;\n\tunsigned int expected_index;\n\tint rc;\n\n\tINIT_LIST_HEAD(tmplist);\n\n\tpage = list_entry(page_list->prev, struct page, lru);\n\n\t/*\n\t * Lock the page and put it in the cache. Since no one else\n\t * should have access to this page, we're safe to simply set\n\t * PG_locked without checking it first.\n\t */\n\t__set_page_locked(page);\n\trc = add_to_page_cache_locked(page, mapping,\n\t\t\t\t      page->index, GFP_KERNEL);\n\n\t/* give up if we can't stick it in the cache */\n\tif (rc) {\n\t\t__clear_page_locked(page);\n\t\treturn rc;\n\t}\n\n\t/* move first page to the tmplist */\n\t*offset = (loff_t)page->index << PAGE_CACHE_SHIFT;\n\t*bytes = PAGE_CACHE_SIZE;\n\t*nr_pages = 1;\n\tlist_move_tail(&page->lru, tmplist);\n\n\t/* now try and add more pages onto the request */\n\texpected_index = page->index + 1;\n\tlist_for_each_entry_safe_reverse(page, tpage, page_list, lru) {\n\t\t/* discontinuity ? */\n\t\tif (page->index != expected_index)\n\t\t\tbreak;\n\n\t\t/* would this page push the read over the rsize? */\n\t\tif (*bytes + PAGE_CACHE_SIZE > rsize)\n\t\t\tbreak;\n\n\t\t__set_page_locked(page);\n\t\tif (add_to_page_cache_locked(page, mapping, page->index,\n\t\t\t\t\t\t\t\tGFP_KERNEL)) {\n\t\t\t__clear_page_locked(page);\n\t\t\tbreak;\n\t\t}\n\t\tlist_move_tail(&page->lru, tmplist);\n\t\t(*bytes) += PAGE_CACHE_SIZE;\n\t\texpected_index++;\n\t\t(*nr_pages)++;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\nreadpages_get_pages(struct address_space *mapping, struct list_head *page_list,\n\t\t    unsigned int rsize, struct list_head *tmplist,\n\t\t    unsigned int *nr_pages, loff_t *offset, unsigned int *bytes)\n{\n\tstruct page *page, *tpage;\n\tunsigned int expected_index;\n\tint rc;\n\n\tINIT_LIST_HEAD(tmplist);\n\n\tpage = list_entry(page_list->prev, struct page, lru);\n\n\t/*\n\t * Lock the page and put it in the cache. Since no one else\n\t * should have access to this page, we're safe to simply set\n\t * PG_locked without checking it first.\n\t */\n\t__set_page_locked(page);\n\trc = add_to_page_cache_locked(page, mapping,\n\t\t\t\t      page->index, GFP_KERNEL);\n\n\t/* give up if we can't stick it in the cache */\n\tif (rc) {\n\t\t__clear_page_locked(page);\n\t\treturn rc;\n\t}\n\n\t/* move first page to the tmplist */\n\t*offset = (loff_t)page->index << PAGE_CACHE_SHIFT;\n\t*bytes = PAGE_CACHE_SIZE;\n\t*nr_pages = 1;\n\tlist_move_tail(&page->lru, tmplist);\n\n\t/* now try and add more pages onto the request */\n\texpected_index = page->index + 1;\n\tlist_for_each_entry_safe_reverse(page, tpage, page_list, lru) {\n\t\t/* discontinuity ? */\n\t\tif (page->index != expected_index)\n\t\t\tbreak;\n\n\t\t/* would this page push the read over the rsize? */\n\t\tif (*bytes + PAGE_CACHE_SIZE > rsize)\n\t\t\tbreak;\n\n\t\t__set_page_locked(page);\n\t\tif (add_to_page_cache_locked(page, mapping, page->index,\n\t\t\t\t\t\t\t\tGFP_KERNEL)) {\n\t\t\t__clear_page_locked(page);\n\t\t\tbreak;\n\t\t}\n\t\tlist_move_tail(&page->lru, tmplist);\n\t\t(*bytes) += PAGE_CACHE_SIZE;\n\t\texpected_index++;\n\t\t(*nr_pages)++;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rsize < PAGE_CACHE_SIZE"
          ],
          "line": 3518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->wait_mtu_credits",
          "args": [
            "server",
            "cifs_sb->rsize",
            "&rsize",
            "&credits"
          ],
          "line": 3507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "page_list"
          ],
          "line": 3500
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: file=%p mapping=%p num_pages=%u\\n\"",
            "__func__",
            "file",
            "mapping",
            "num_pages"
          ],
          "line": 3486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "open_file->tlink"
          ],
          "line": 3484
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_readpages_from_fscache",
          "args": [
            "mapping->host",
            "mapping",
            "page_list",
            "&num_pages"
          ],
          "line": 3473
        },
        "resolved": true,
        "details": {
          "function_name": "__cifs_readpages_from_fscache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
          "lines": "184-213",
          "snippet": "int __cifs_readpages_from_fscache(struct inode *inode,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tstruct list_head *pages,\n\t\t\t\tunsigned *nr_pages)\n{\n\tint ret;\n\n\tcifs_dbg(FYI, \"%s: (0x%p/%u/0x%p)\\n\",\n\t\t __func__, CIFS_I(inode)->fscache, *nr_pages, inode);\n\tret = fscache_read_or_alloc_pages(CIFS_I(inode)->fscache, mapping,\n\t\t\t\t\t  pages, nr_pages,\n\t\t\t\t\t  cifs_readpage_from_fscache_complete,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  mapping_gfp_mask(mapping));\n\tswitch (ret) {\n\tcase 0:\t/* read submitted to the cache for all pages */\n\t\tcifs_dbg(FYI, \"%s: submitted\\n\", __func__);\n\t\treturn ret;\n\n\tcase -ENOBUFS:\t/* some pages are not cached and can't be */\n\tcase -ENODATA:\t/* some pages are not cached */\n\t\tcifs_dbg(FYI, \"%s: no page\\n\", __func__);\n\t\treturn 1;\n\n\tdefault:\n\t\tcifs_dbg(FYI, \"unknown error ret = %d\\n\", ret);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nint __cifs_readpages_from_fscache(struct inode *inode,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tstruct list_head *pages,\n\t\t\t\tunsigned *nr_pages)\n{\n\tint ret;\n\n\tcifs_dbg(FYI, \"%s: (0x%p/%u/0x%p)\\n\",\n\t\t __func__, CIFS_I(inode)->fscache, *nr_pages, inode);\n\tret = fscache_read_or_alloc_pages(CIFS_I(inode)->fscache, mapping,\n\t\t\t\t\t  pages, nr_pages,\n\t\t\t\t\t  cifs_readpage_from_fscache_complete,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  mapping_gfp_mask(mapping));\n\tswitch (ret) {\n\tcase 0:\t/* read submitted to the cache for all pages */\n\t\tcifs_dbg(FYI, \"%s: submitted\\n\", __func__);\n\t\treturn ret;\n\n\tcase -ENOBUFS:\t/* some pages are not cached and can't be */\n\tcase -ENODATA:\t/* some pages are not cached */\n\t\tcifs_dbg(FYI, \"%s: no page\\n\", __func__);\n\t\treturn 1;\n\n\tdefault:\n\t\tcifs_dbg(FYI, \"unknown error ret = %d\\n\", ret);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_FILE_SB",
          "args": [
            "file"
          ],
          "line": 3462
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_FILE_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1171-1175",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_FILE_SB(struct file *file)\n{\n\treturn CIFS_SB(file_inode(file)->i_sb);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_FILE_SB(struct file *file)\n{\n\treturn CIFS_SB(file_inode(file)->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int cifs_readpages(struct file *file, struct address_space *mapping,\n\tstruct list_head *page_list, unsigned num_pages)\n{\n\tint rc;\n\tstruct list_head tmplist;\n\tstruct cifsFileInfo *open_file = file->private_data;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct TCP_Server_Info *server;\n\tpid_t pid;\n\n\t/*\n\t * Reads as many pages as possible from fscache. Returns -ENOBUFS\n\t * immediately if the cookie is negative\n\t *\n\t * After this point, every page in the list might have PG_fscache set,\n\t * so we will need to clean that up off of every page we don't use.\n\t */\n\trc = cifs_readpages_from_fscache(mapping->host, mapping, page_list,\n\t\t\t\t\t &num_pages);\n\tif (rc == 0)\n\t\treturn rc;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\trc = 0;\n\tserver = tlink_tcon(open_file->tlink)->ses->server;\n\n\tcifs_dbg(FYI, \"%s: file=%p mapping=%p num_pages=%u\\n\",\n\t\t __func__, file, mapping, num_pages);\n\n\t/*\n\t * Start with the page at end of list and move it to private\n\t * list. Do the same with any following pages until we hit\n\t * the rsize limit, hit an index discontinuity, or run out of\n\t * pages. Issue the async read and then start the loop again\n\t * until the list is empty.\n\t *\n\t * Note that list order is important. The page_list is in\n\t * the order of declining indexes. When we put the pages in\n\t * the rdata->pages, then we want them in increasing order.\n\t */\n\twhile (!list_empty(page_list)) {\n\t\tunsigned int i, nr_pages, bytes, rsize;\n\t\tloff_t offset;\n\t\tstruct page *page, *tpage;\n\t\tstruct cifs_readdata *rdata;\n\t\tunsigned credits;\n\n\t\trc = server->ops->wait_mtu_credits(server, cifs_sb->rsize,\n\t\t\t\t\t\t   &rsize, &credits);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Give up immediately if rsize is too small to read an entire\n\t\t * page. The VFS will fall back to readpage. We should never\n\t\t * reach this point however since we set ra_pages to 0 when the\n\t\t * rsize is smaller than a cache page.\n\t\t */\n\t\tif (unlikely(rsize < PAGE_CACHE_SIZE)) {\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\treturn 0;\n\t\t}\n\n\t\trc = readpages_get_pages(mapping, page_list, rsize, &tmplist,\n\t\t\t\t\t &nr_pages, &offset, &bytes);\n\t\tif (rc) {\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\trdata = cifs_readdata_alloc(nr_pages, cifs_readv_complete);\n\t\tif (!rdata) {\n\t\t\t/* best to give up if we're out of mem */\n\t\t\tlist_for_each_entry_safe(page, tpage, &tmplist, lru) {\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\tlru_cache_add_file(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t}\n\t\t\trc = -ENOMEM;\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\trdata->cfile = cifsFileInfo_get(open_file);\n\t\trdata->mapping = mapping;\n\t\trdata->offset = offset;\n\t\trdata->bytes = bytes;\n\t\trdata->pid = pid;\n\t\trdata->pagesz = PAGE_CACHE_SIZE;\n\t\trdata->read_into_pages = cifs_readpages_read_into_pages;\n\t\trdata->credits = credits;\n\n\t\tlist_for_each_entry_safe(page, tpage, &tmplist, lru) {\n\t\t\tlist_del(&page->lru);\n\t\t\trdata->pages[rdata->nr_pages++] = page;\n\t\t}\n\n\t\tif (!rdata->cfile->invalidHandle ||\n\t\t    !cifs_reopen_file(rdata->cfile, true))\n\t\t\trc = server->ops->async_readv(rdata);\n\t\tif (rc) {\n\t\t\tadd_credits_and_wake_if(server, rdata->credits, 0);\n\t\t\tfor (i = 0; i < rdata->nr_pages; i++) {\n\t\t\t\tpage = rdata->pages[i];\n\t\t\t\tlru_cache_add_file(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t}\n\t\t\t/* Fallback to the readpage in error/reconnect cases */\n\t\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\t\t\tbreak;\n\t\t}\n\n\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\t}\n\n\t/* Any pages that have been shown to fscache but didn't get added to\n\t * the pagecache must be uncached before they get returned to the\n\t * allocator.\n\t */\n\tcifs_fscache_readpages_cancel(mapping->host, page_list);\n\treturn rc;\n}"
  },
  {
    "function_name": "readpages_get_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "3397-3454",
    "snippet": "static int\nreadpages_get_pages(struct address_space *mapping, struct list_head *page_list,\n\t\t    unsigned int rsize, struct list_head *tmplist,\n\t\t    unsigned int *nr_pages, loff_t *offset, unsigned int *bytes)\n{\n\tstruct page *page, *tpage;\n\tunsigned int expected_index;\n\tint rc;\n\n\tINIT_LIST_HEAD(tmplist);\n\n\tpage = list_entry(page_list->prev, struct page, lru);\n\n\t/*\n\t * Lock the page and put it in the cache. Since no one else\n\t * should have access to this page, we're safe to simply set\n\t * PG_locked without checking it first.\n\t */\n\t__set_page_locked(page);\n\trc = add_to_page_cache_locked(page, mapping,\n\t\t\t\t      page->index, GFP_KERNEL);\n\n\t/* give up if we can't stick it in the cache */\n\tif (rc) {\n\t\t__clear_page_locked(page);\n\t\treturn rc;\n\t}\n\n\t/* move first page to the tmplist */\n\t*offset = (loff_t)page->index << PAGE_CACHE_SHIFT;\n\t*bytes = PAGE_CACHE_SIZE;\n\t*nr_pages = 1;\n\tlist_move_tail(&page->lru, tmplist);\n\n\t/* now try and add more pages onto the request */\n\texpected_index = page->index + 1;\n\tlist_for_each_entry_safe_reverse(page, tpage, page_list, lru) {\n\t\t/* discontinuity ? */\n\t\tif (page->index != expected_index)\n\t\t\tbreak;\n\n\t\t/* would this page push the read over the rsize? */\n\t\tif (*bytes + PAGE_CACHE_SIZE > rsize)\n\t\t\tbreak;\n\n\t\t__set_page_locked(page);\n\t\tif (add_to_page_cache_locked(page, mapping, page->index,\n\t\t\t\t\t\t\t\tGFP_KERNEL)) {\n\t\t\t__clear_page_locked(page);\n\t\t\tbreak;\n\t\t}\n\t\tlist_move_tail(&page->lru, tmplist);\n\t\t(*bytes) += PAGE_CACHE_SIZE;\n\t\texpected_index++;\n\t\t(*nr_pages)++;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&page->lru",
            "tmplist"
          ],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_page_locked",
          "args": [
            "page"
          ],
          "line": 3445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_locked",
          "args": [
            "page",
            "mapping",
            "page->index",
            "GFP_KERNEL"
          ],
          "line": 3443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_page_locked",
          "args": [
            "page"
          ],
          "line": 3442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_reverse",
          "args": [
            "page",
            "tpage",
            "page_list",
            "lru"
          ],
          "line": 3433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&page->lru",
            "tmplist"
          ],
          "line": 3429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_page_locked",
          "args": [
            "page"
          ],
          "line": 3421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_locked",
          "args": [
            "page",
            "mapping",
            "page->index",
            "GFP_KERNEL"
          ],
          "line": 3416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_page_locked",
          "args": [
            "page"
          ],
          "line": 3415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "page_list->prev",
            "structpage",
            "lru"
          ],
          "line": 3408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "tmplist"
          ],
          "line": 3406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\nreadpages_get_pages(struct address_space *mapping, struct list_head *page_list,\n\t\t    unsigned int rsize, struct list_head *tmplist,\n\t\t    unsigned int *nr_pages, loff_t *offset, unsigned int *bytes)\n{\n\tstruct page *page, *tpage;\n\tunsigned int expected_index;\n\tint rc;\n\n\tINIT_LIST_HEAD(tmplist);\n\n\tpage = list_entry(page_list->prev, struct page, lru);\n\n\t/*\n\t * Lock the page and put it in the cache. Since no one else\n\t * should have access to this page, we're safe to simply set\n\t * PG_locked without checking it first.\n\t */\n\t__set_page_locked(page);\n\trc = add_to_page_cache_locked(page, mapping,\n\t\t\t\t      page->index, GFP_KERNEL);\n\n\t/* give up if we can't stick it in the cache */\n\tif (rc) {\n\t\t__clear_page_locked(page);\n\t\treturn rc;\n\t}\n\n\t/* move first page to the tmplist */\n\t*offset = (loff_t)page->index << PAGE_CACHE_SHIFT;\n\t*bytes = PAGE_CACHE_SIZE;\n\t*nr_pages = 1;\n\tlist_move_tail(&page->lru, tmplist);\n\n\t/* now try and add more pages onto the request */\n\texpected_index = page->index + 1;\n\tlist_for_each_entry_safe_reverse(page, tpage, page_list, lru) {\n\t\t/* discontinuity ? */\n\t\tif (page->index != expected_index)\n\t\t\tbreak;\n\n\t\t/* would this page push the read over the rsize? */\n\t\tif (*bytes + PAGE_CACHE_SIZE > rsize)\n\t\t\tbreak;\n\n\t\t__set_page_locked(page);\n\t\tif (add_to_page_cache_locked(page, mapping, page->index,\n\t\t\t\t\t\t\t\tGFP_KERNEL)) {\n\t\t\t__clear_page_locked(page);\n\t\t\tbreak;\n\t\t}\n\t\tlist_move_tail(&page->lru, tmplist);\n\t\t(*bytes) += PAGE_CACHE_SIZE;\n\t\texpected_index++;\n\t\t(*nr_pages)++;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_readpages_read_into_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "3319-3395",
    "snippet": "static int\ncifs_readpages_read_into_pages(struct TCP_Server_Info *server,\n\t\t\tstruct cifs_readdata *rdata, unsigned int len)\n{\n\tint result = 0;\n\tunsigned int i;\n\tu64 eof;\n\tpgoff_t eof_index;\n\tunsigned int nr_pages = rdata->nr_pages;\n\tstruct kvec iov;\n\n\t/* determine the eof that the server (probably) has */\n\teof = CIFS_I(rdata->mapping->host)->server_eof;\n\teof_index = eof ? (eof - 1) >> PAGE_CACHE_SHIFT : 0;\n\tcifs_dbg(FYI, \"eof=%llu eof_index=%lu\\n\", eof, eof_index);\n\n\trdata->got_bytes = 0;\n\trdata->tailsz = PAGE_CACHE_SIZE;\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page = rdata->pages[i];\n\n\t\tif (len >= PAGE_CACHE_SIZE) {\n\t\t\t/* enough data to fill the page */\n\t\t\tiov.iov_base = kmap(page);\n\t\t\tiov.iov_len = PAGE_CACHE_SIZE;\n\t\t\tcifs_dbg(FYI, \"%u: idx=%lu iov_base=%p iov_len=%zu\\n\",\n\t\t\t\t i, page->index, iov.iov_base, iov.iov_len);\n\t\t\tlen -= PAGE_CACHE_SIZE;\n\t\t} else if (len > 0) {\n\t\t\t/* enough for partial page, fill and zero the rest */\n\t\t\tiov.iov_base = kmap(page);\n\t\t\tiov.iov_len = len;\n\t\t\tcifs_dbg(FYI, \"%u: idx=%lu iov_base=%p iov_len=%zu\\n\",\n\t\t\t\t i, page->index, iov.iov_base, iov.iov_len);\n\t\t\tmemset(iov.iov_base + len,\n\t\t\t\t'\\0', PAGE_CACHE_SIZE - len);\n\t\t\trdata->tailsz = len;\n\t\t\tlen = 0;\n\t\t} else if (page->index > eof_index) {\n\t\t\t/*\n\t\t\t * The VFS will not try to do readahead past the\n\t\t\t * i_size, but it's possible that we have outstanding\n\t\t\t * writes with gaps in the middle and the i_size hasn't\n\t\t\t * caught up yet. Populate those with zeroed out pages\n\t\t\t * to prevent the VFS from repeatedly attempting to\n\t\t\t * fill them until the writes are flushed.\n\t\t\t */\n\t\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\t\t\tlru_cache_add_file(page);\n\t\t\tflush_dcache_page(page);\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\trdata->pages[i] = NULL;\n\t\t\trdata->nr_pages--;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* no need to hold page hostage */\n\t\t\tlru_cache_add_file(page);\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\trdata->pages[i] = NULL;\n\t\t\trdata->nr_pages--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult = cifs_readv_from_socket(server, &iov, 1, iov.iov_len);\n\t\tkunmap(page);\n\t\tif (result < 0)\n\t\t\tbreak;\n\n\t\trdata->got_bytes += result;\n\t}\n\n\treturn rdata->got_bytes > 0 && result != -ECONNABORTED ?\n\t\t\t\t\t\trdata->got_bytes : result;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 3386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_readv_from_socket",
          "args": [
            "server",
            "&iov",
            "1",
            "iov.iov_len"
          ],
          "line": 3385
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_readv_from_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "542-599",
          "snippet": "int\ncifs_readv_from_socket(struct TCP_Server_Info *server, struct kvec *iov_orig,\n\t\t       unsigned int nr_segs, unsigned int to_read)\n{\n\tint length = 0;\n\tint total_read;\n\tunsigned int segs;\n\tstruct msghdr smb_msg;\n\tstruct kvec *iov;\n\n\tiov = get_server_iovec(server, nr_segs);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\tsmb_msg.msg_control = NULL;\n\tsmb_msg.msg_controllen = 0;\n\n\tfor (total_read = 0; to_read; total_read += length, to_read -= length) {\n\t\ttry_to_freeze();\n\n\t\tif (server_unresponsive(server)) {\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tsegs = kvec_array_init(iov, iov_orig, nr_segs, total_read);\n\n\t\tlength = kernel_recvmsg(server->ssocket, &smb_msg,\n\t\t\t\t\tiov, segs, to_read, 0);\n\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\ttotal_read = -ESHUTDOWN;\n\t\t\tbreak;\n\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t} else if (length == -ERESTARTSYS ||\n\t\t\t   length == -EAGAIN ||\n\t\t\t   length == -EINTR) {\n\t\t\t/*\n\t\t\t * Minimum sleep to prevent looping, allowing socket\n\t\t\t * to clear and app threads to set tcpStatus\n\t\t\t * CifsNeedReconnect if server hung.\n\t\t\t */\n\t\t\tusleep_range(1000, 2000);\n\t\t\tlength = 0;\n\t\t\tcontinue;\n\t\t} else if (length <= 0) {\n\t\t\tcifs_dbg(FYI, \"Received no data or error: expecting %d\\n\"\n\t\t\t\t \"got %d\", to_read, length);\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn total_read;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_readv_from_socket(struct TCP_Server_Info *server, struct kvec *iov_orig,\n\t\t       unsigned int nr_segs, unsigned int to_read)\n{\n\tint length = 0;\n\tint total_read;\n\tunsigned int segs;\n\tstruct msghdr smb_msg;\n\tstruct kvec *iov;\n\n\tiov = get_server_iovec(server, nr_segs);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\tsmb_msg.msg_control = NULL;\n\tsmb_msg.msg_controllen = 0;\n\n\tfor (total_read = 0; to_read; total_read += length, to_read -= length) {\n\t\ttry_to_freeze();\n\n\t\tif (server_unresponsive(server)) {\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tsegs = kvec_array_init(iov, iov_orig, nr_segs, total_read);\n\n\t\tlength = kernel_recvmsg(server->ssocket, &smb_msg,\n\t\t\t\t\tiov, segs, to_read, 0);\n\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\ttotal_read = -ESHUTDOWN;\n\t\t\tbreak;\n\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t} else if (length == -ERESTARTSYS ||\n\t\t\t   length == -EAGAIN ||\n\t\t\t   length == -EINTR) {\n\t\t\t/*\n\t\t\t * Minimum sleep to prevent looping, allowing socket\n\t\t\t * to clear and app threads to set tcpStatus\n\t\t\t * CifsNeedReconnect if server hung.\n\t\t\t */\n\t\t\tusleep_range(1000, 2000);\n\t\t\tlength = 0;\n\t\t\tcontinue;\n\t\t} else if (length <= 0) {\n\t\t\tcifs_dbg(FYI, \"Received no data or error: expecting %d\\n\"\n\t\t\t\t \"got %d\", to_read, length);\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn total_read;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 3379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 3378
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_cache_add_file",
          "args": [
            "page"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 3371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 3369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 3368
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_cache_add_file",
          "args": [
            "page"
          ],
          "line": 3367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 3366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "iov.iov_base + len",
            "'\\0'",
            "PAGE_CACHE_SIZE - len"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%u: idx=%lu iov_base=%p iov_len=%zu\\n\"",
            "i",
            "page->index",
            "iov.iov_base",
            "iov.iov_len"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 3349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%u: idx=%lu iov_base=%p iov_len=%zu\\n\"",
            "i",
            "page->index",
            "iov.iov_base",
            "iov.iov_len"
          ],
          "line": 3344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"eof=%llu eof_index=%lu\\n\"",
            "eof",
            "eof_index"
          ],
          "line": 3333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "rdata->mapping->host"
          ],
          "line": 3331
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_readpages_read_into_pages(struct TCP_Server_Info *server,\n\t\t\tstruct cifs_readdata *rdata, unsigned int len)\n{\n\tint result = 0;\n\tunsigned int i;\n\tu64 eof;\n\tpgoff_t eof_index;\n\tunsigned int nr_pages = rdata->nr_pages;\n\tstruct kvec iov;\n\n\t/* determine the eof that the server (probably) has */\n\teof = CIFS_I(rdata->mapping->host)->server_eof;\n\teof_index = eof ? (eof - 1) >> PAGE_CACHE_SHIFT : 0;\n\tcifs_dbg(FYI, \"eof=%llu eof_index=%lu\\n\", eof, eof_index);\n\n\trdata->got_bytes = 0;\n\trdata->tailsz = PAGE_CACHE_SIZE;\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page = rdata->pages[i];\n\n\t\tif (len >= PAGE_CACHE_SIZE) {\n\t\t\t/* enough data to fill the page */\n\t\t\tiov.iov_base = kmap(page);\n\t\t\tiov.iov_len = PAGE_CACHE_SIZE;\n\t\t\tcifs_dbg(FYI, \"%u: idx=%lu iov_base=%p iov_len=%zu\\n\",\n\t\t\t\t i, page->index, iov.iov_base, iov.iov_len);\n\t\t\tlen -= PAGE_CACHE_SIZE;\n\t\t} else if (len > 0) {\n\t\t\t/* enough for partial page, fill and zero the rest */\n\t\t\tiov.iov_base = kmap(page);\n\t\t\tiov.iov_len = len;\n\t\t\tcifs_dbg(FYI, \"%u: idx=%lu iov_base=%p iov_len=%zu\\n\",\n\t\t\t\t i, page->index, iov.iov_base, iov.iov_len);\n\t\t\tmemset(iov.iov_base + len,\n\t\t\t\t'\\0', PAGE_CACHE_SIZE - len);\n\t\t\trdata->tailsz = len;\n\t\t\tlen = 0;\n\t\t} else if (page->index > eof_index) {\n\t\t\t/*\n\t\t\t * The VFS will not try to do readahead past the\n\t\t\t * i_size, but it's possible that we have outstanding\n\t\t\t * writes with gaps in the middle and the i_size hasn't\n\t\t\t * caught up yet. Populate those with zeroed out pages\n\t\t\t * to prevent the VFS from repeatedly attempting to\n\t\t\t * fill them until the writes are flushed.\n\t\t\t */\n\t\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\t\t\tlru_cache_add_file(page);\n\t\t\tflush_dcache_page(page);\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\trdata->pages[i] = NULL;\n\t\t\trdata->nr_pages--;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* no need to hold page hostage */\n\t\t\tlru_cache_add_file(page);\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\trdata->pages[i] = NULL;\n\t\t\trdata->nr_pages--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult = cifs_readv_from_socket(server, &iov, 1, iov.iov_len);\n\t\tkunmap(page);\n\t\tif (result < 0)\n\t\t\tbreak;\n\n\t\trdata->got_bytes += result;\n\t}\n\n\treturn rdata->got_bytes > 0 && result != -ECONNABORTED ?\n\t\t\t\t\t\trdata->got_bytes : result;\n}"
  },
  {
    "function_name": "cifs_readv_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "3286-3317",
    "snippet": "static void\ncifs_readv_complete(struct work_struct *work)\n{\n\tunsigned int i, got_bytes;\n\tstruct cifs_readdata *rdata = container_of(work,\n\t\t\t\t\t\tstruct cifs_readdata, work);\n\n\tgot_bytes = rdata->got_bytes;\n\tfor (i = 0; i < rdata->nr_pages; i++) {\n\t\tstruct page *page = rdata->pages[i];\n\n\t\tlru_cache_add_file(page);\n\n\t\tif (rdata->result == 0 ||\n\t\t    (rdata->result == -EAGAIN && got_bytes)) {\n\t\t\tflush_dcache_page(page);\n\t\t\tSetPageUptodate(page);\n\t\t}\n\n\t\tunlock_page(page);\n\n\t\tif (rdata->result == 0 ||\n\t\t    (rdata->result == -EAGAIN && got_bytes))\n\t\t\tcifs_readpage_to_fscache(rdata->mapping->host, page);\n\n\t\tgot_bytes -= min_t(unsigned int, PAGE_CACHE_SIZE, got_bytes);\n\n\t\tpage_cache_release(page);\n\t\trdata->pages[i] = NULL;\n\t}\n\tkref_put(&rdata->refcount, cifs_readdata_release);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&rdata->refcount",
            "cifs_readdata_release"
          ],
          "line": 3316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 3313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "PAGE_CACHE_SIZE",
            "got_bytes"
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_readpage_to_fscache",
          "args": [
            "rdata->mapping->host",
            "page"
          ],
          "line": 3309
        },
        "resolved": true,
        "details": {
          "function_name": "__cifs_readpage_to_fscache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
          "lines": "215-224",
          "snippet": "void __cifs_readpage_to_fscache(struct inode *inode, struct page *page)\n{\n\tint ret;\n\n\tcifs_dbg(FYI, \"%s: (fsc: %p, p: %p, i: %p)\\n\",\n\t\t __func__, CIFS_I(inode)->fscache, page, inode);\n\tret = fscache_write_page(CIFS_I(inode)->fscache, page, GFP_KERNEL);\n\tif (ret != 0)\n\t\tfscache_uncache_page(CIFS_I(inode)->fscache, page);\n}",
          "includes": [
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid __cifs_readpage_to_fscache(struct inode *inode, struct page *page)\n{\n\tint ret;\n\n\tcifs_dbg(FYI, \"%s: (fsc: %p, p: %p, i: %p)\\n\",\n\t\t __func__, CIFS_I(inode)->fscache, page, inode);\n\tret = fscache_write_page(CIFS_I(inode)->fscache, page, GFP_KERNEL);\n\tif (ret != 0)\n\t\tfscache_uncache_page(CIFS_I(inode)->fscache, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 3305
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 3301
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_cache_add_file",
          "args": [
            "page"
          ],
          "line": 3297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structcifs_readdata",
            "work"
          ],
          "line": 3290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_readv_complete(struct work_struct *work)\n{\n\tunsigned int i, got_bytes;\n\tstruct cifs_readdata *rdata = container_of(work,\n\t\t\t\t\t\tstruct cifs_readdata, work);\n\n\tgot_bytes = rdata->got_bytes;\n\tfor (i = 0; i < rdata->nr_pages; i++) {\n\t\tstruct page *page = rdata->pages[i];\n\n\t\tlru_cache_add_file(page);\n\n\t\tif (rdata->result == 0 ||\n\t\t    (rdata->result == -EAGAIN && got_bytes)) {\n\t\t\tflush_dcache_page(page);\n\t\t\tSetPageUptodate(page);\n\t\t}\n\n\t\tunlock_page(page);\n\n\t\tif (rdata->result == 0 ||\n\t\t    (rdata->result == -EAGAIN && got_bytes))\n\t\t\tcifs_readpage_to_fscache(rdata->mapping->host, page);\n\n\t\tgot_bytes -= min_t(unsigned int, PAGE_CACHE_SIZE, got_bytes);\n\n\t\tpage_cache_release(page);\n\t\trdata->pages[i] = NULL;\n\t}\n\tkref_put(&rdata->refcount, cifs_readdata_release);\n}"
  },
  {
    "function_name": "cifs_file_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "3267-3284",
    "snippet": "int cifs_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tint rc, xid;\n\n\txid = get_xid();\n\trc = cifs_revalidate_file(file);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Validation prior to mmap failed, error=%d\\n\",\n\t\t\t rc);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\trc = generic_file_mmap(file, vma);\n\tif (rc == 0)\n\t\tvma->vm_ops = &cifs_file_vm_ops;\n\tfree_xid(xid);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vm_operations_struct cifs_file_vm_ops = {\n\t.fault = filemap_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = cifs_page_mkwrite,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 3282
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_file_mmap",
          "args": [
            "file",
            "vma"
          ],
          "line": 3279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Validation prior to mmap failed, error=%d\\n\"",
            "rc"
          ],
          "line": 3274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_revalidate_file",
          "args": [
            "file"
          ],
          "line": 3272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 3271
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic struct vm_operations_struct cifs_file_vm_ops = {\n\t.fault = filemap_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = cifs_page_mkwrite,\n};\n\nint cifs_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tint rc, xid;\n\n\txid = get_xid();\n\trc = cifs_revalidate_file(file);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Validation prior to mmap failed, error=%d\\n\",\n\t\t\t rc);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\trc = generic_file_mmap(file, vma);\n\tif (rc == 0)\n\t\tvma->vm_ops = &cifs_file_vm_ops;\n\tfree_xid(xid);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_file_strict_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "3247-3265",
    "snippet": "int cifs_file_strict_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tint rc, xid;\n\tstruct inode *inode = file_inode(file);\n\n\txid = get_xid();\n\n\tif (!CIFS_CACHE_READ(CIFS_I(inode))) {\n\t\trc = cifs_zap_mapping(inode);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = generic_file_mmap(file, vma);\n\tif (rc == 0)\n\t\tvma->vm_ops = &cifs_file_vm_ops;\n\tfree_xid(xid);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vm_operations_struct cifs_file_vm_ops = {\n\t.fault = filemap_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = cifs_page_mkwrite,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 3263
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_file_mmap",
          "args": [
            "file",
            "vma"
          ],
          "line": 3260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_zap_mapping",
          "args": [
            "inode"
          ],
          "line": 3255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "CIFS_I(inode)"
          ],
          "line": 3254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 3254
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 3252
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 3250
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic struct vm_operations_struct cifs_file_vm_ops = {\n\t.fault = filemap_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = cifs_page_mkwrite,\n};\n\nint cifs_file_strict_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tint rc, xid;\n\tstruct inode *inode = file_inode(file);\n\n\txid = get_xid();\n\n\tif (!CIFS_CACHE_READ(CIFS_I(inode))) {\n\t\trc = cifs_zap_mapping(inode);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = generic_file_mmap(file, vma);\n\tif (rc == 0)\n\t\tvma->vm_ops = &cifs_file_vm_ops;\n\tfree_xid(xid);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "3232-3239",
    "snippet": "static int\ncifs_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\n\tlock_page(page);\n\treturn VM_FAULT_LOCKED;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 3237
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\n\tlock_page(page);\n\treturn VM_FAULT_LOCKED;\n}"
  },
  {
    "function_name": "cifs_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "3137-3226",
    "snippet": "static ssize_t\ncifs_read(struct file *file, char *read_data, size_t read_size, loff_t *offset)\n{\n\tint rc = -EACCES;\n\tunsigned int bytes_read = 0;\n\tunsigned int total_read;\n\tunsigned int current_read_size;\n\tunsigned int rsize;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tunsigned int xid;\n\tchar *cur_offset;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifs_io_parms io_parms;\n\tint buf_type = CIFS_NO_BUFFER;\n\t__u32 pid;\n\n\txid = get_xid();\n\tcifs_sb = CIFS_FILE_SB(file);\n\n\t/* FIXME: set up handlers for larger reads and/or convert to async */\n\trsize = min_t(unsigned int, cifs_sb->rsize, CIFSMaxBufSize);\n\n\tif (file->private_data == NULL) {\n\t\trc = -EBADF;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\topen_file = file->private_data;\n\ttcon = tlink_tcon(open_file->tlink);\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->sync_read) {\n\t\tfree_xid(xid);\n\t\treturn -ENOSYS;\n\t}\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tif ((file->f_flags & O_ACCMODE) == O_WRONLY)\n\t\tcifs_dbg(FYI, \"attempting read on write only file instance\\n\");\n\n\tfor (total_read = 0, cur_offset = read_data; read_size > total_read;\n\t     total_read += bytes_read, cur_offset += bytes_read) {\n\t\tdo {\n\t\t\tcurrent_read_size = min_t(uint, read_size - total_read,\n\t\t\t\t\t\t  rsize);\n\t\t\t/*\n\t\t\t * For windows me and 9x we do not want to request more\n\t\t\t * than it negotiated since it will refuse the read\n\t\t\t * then.\n\t\t\t */\n\t\t\tif ((tcon->ses) && !(tcon->ses->capabilities &\n\t\t\t\ttcon->ses->server->vals->cap_large_files)) {\n\t\t\t\tcurrent_read_size = min_t(uint,\n\t\t\t\t\tcurrent_read_size, CIFSMaxBufSize);\n\t\t\t}\n\t\t\tif (open_file->invalidHandle) {\n\t\t\t\trc = cifs_reopen_file(open_file, true);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tio_parms.pid = pid;\n\t\t\tio_parms.tcon = tcon;\n\t\t\tio_parms.offset = *offset;\n\t\t\tio_parms.length = current_read_size;\n\t\t\trc = server->ops->sync_read(xid, &open_file->fid, &io_parms,\n\t\t\t\t\t\t    &bytes_read, &cur_offset,\n\t\t\t\t\t\t    &buf_type);\n\t\t} while (rc == -EAGAIN);\n\n\t\tif (rc || (bytes_read == 0)) {\n\t\t\tif (total_read) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\tcifs_stats_bytes_read(tcon, total_read);\n\t\t\t*offset += bytes_read;\n\t\t}\n\t}\n\tfree_xid(xid);\n\treturn total_read;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 3224
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_bytes_read",
          "args": [
            "tcon",
            "total_read"
          ],
          "line": 3220
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_bytes_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1213-1219",
          "snippet": "static inline void cifs_stats_bytes_read(struct cifs_tcon *tcon,\n\t\t\t\t\t unsigned int bytes)\n{\n\tspin_lock(&tcon->stat_lock);\n\ttcon->bytes_read += bytes;\n\tspin_unlock(&tcon->stat_lock);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_stats_bytes_read(struct cifs_tcon *tcon,\n\t\t\t\t\t unsigned int bytes)\n{\n\tspin_lock(&tcon->stat_lock);\n\ttcon->bytes_read += bytes;\n\tspin_unlock(&tcon->stat_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->sync_read",
          "args": [
            "xid",
            "&open_file->fid",
            "&io_parms",
            "&bytes_read",
            "&cur_offset",
            "&buf_type"
          ],
          "line": 3207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_reopen_file",
          "args": [
            "open_file",
            "true"
          ],
          "line": 3199
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_reopen_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "597-744",
          "snippet": "static int\ncifs_reopen_file(struct cifsFileInfo *cfile, bool can_flush)\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\t__u32 oplock;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsInodeInfo *cinode;\n\tstruct inode *inode;\n\tchar *full_path = NULL;\n\tint desired_access;\n\tint disposition = FILE_OPEN;\n\tint create_options = CREATE_NOT_DIR;\n\tstruct cifs_open_parms oparms;\n\n\txid = get_xid();\n\tmutex_lock(&cfile->fh_mutex);\n\tif (!cfile->invalidHandle) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\trc = 0;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tinode = cfile->dentry->d_inode;\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttcon = tlink_tcon(cfile->tlink);\n\tserver = tcon->ses->server;\n\n\t/*\n\t * Can not grab rename sem here because various ops, including those\n\t * that already have the rename sem can end up causing writepage to get\n\t * called and if the server was down that means we end up here, and we\n\t * can never tell if the caller already has the rename_sem.\n\t */\n\tfull_path = build_path_from_dentry(cfile->dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tcifs_dbg(FYI, \"inode = 0x%p file flags 0x%x for %s\\n\",\n\t\t inode, cfile->f_flags, full_path);\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\t/*\n\t\t * O_CREAT, O_EXCL and O_TRUNC already had their effect on the\n\t\t * original open. Must mask them off for a reopen.\n\t\t */\n\t\tunsigned int oflags = cfile->f_flags &\n\t\t\t\t\t\t~(O_CREAT | O_EXCL | O_TRUNC);\n\n\t\trc = cifs_posix_open(full_path, NULL, inode->i_sb,\n\t\t\t\t     cifs_sb->mnt_file_mode /* ignored */,\n\t\t\t\t     oflags, &oplock, &cfile->fid.netfid, xid);\n\t\tif (rc == 0) {\n\t\t\tcifs_dbg(FYI, \"posix reopen succeeded\\n\");\n\t\t\toparms.reconnect = true;\n\t\t\tgoto reopen_success;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry open the old way on errors, especially\n\t\t * in the reconnect path it is important to retry hard\n\t\t */\n\t}\n\n\tdesired_access = cifs_convert_flags(cfile->f_flags);\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &cfile->fid);\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = &cfile->fid;\n\toparms.reconnect = true;\n\n\t/*\n\t * Can not refresh inode by passing in file_info buf to be returned by\n\t * ops->open and then calling get_inode_info with returned buf since\n\t * file might have write behind data that needs to be flushed and server\n\t * version of file size can be stale. If we knew for sure that inode was\n\t * not dirty locally we could do this.\n\t */\n\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\tif (rc == -ENOENT && oparms.reconnect == false) {\n\t\t/* durable handle timeout is expired - open the file again */\n\t\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\t\t/* indicate that we need to relock the file */\n\t\toparms.reconnect = true;\n\t}\n\n\tif (rc) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tcifs_dbg(FYI, \"cifs_reopen returned 0x%x\\n\", rc);\n\t\tcifs_dbg(FYI, \"oplock: %d\\n\", oplock);\n\t\tgoto reopen_error_exit;\n\t}\n\nreopen_success:\n\tcfile->invalidHandle = false;\n\tmutex_unlock(&cfile->fh_mutex);\n\tcinode = CIFS_I(inode);\n\n\tif (can_flush) {\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\t\tmapping_set_error(inode->i_mapping, rc);\n\n\t\tif (tcon->unix_ext)\n\t\t\trc = cifs_get_inode_info_unix(&inode, full_path,\n\t\t\t\t\t\t      inode->i_sb, xid);\n\t\telse\n\t\t\trc = cifs_get_inode_info(&inode, full_path, NULL,\n\t\t\t\t\t\t inode->i_sb, xid, NULL);\n\t}\n\t/*\n\t * Else we are writing out data to server already and could deadlock if\n\t * we tried to flush data, and since we do not know if we have data that\n\t * would invalidate the current end of file on the server we can not go\n\t * to the server to get the new inode info.\n\t */\n\n\tserver->ops->set_fid(cfile, &cfile->fid, oplock);\n\tif (oparms.reconnect)\n\t\tcifs_relock_file(cfile);\n\nreopen_error_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_reopen_file(struct cifsFileInfo *cfile, bool can_flush)\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\t__u32 oplock;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsInodeInfo *cinode;\n\tstruct inode *inode;\n\tchar *full_path = NULL;\n\tint desired_access;\n\tint disposition = FILE_OPEN;\n\tint create_options = CREATE_NOT_DIR;\n\tstruct cifs_open_parms oparms;\n\n\txid = get_xid();\n\tmutex_lock(&cfile->fh_mutex);\n\tif (!cfile->invalidHandle) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\trc = 0;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tinode = cfile->dentry->d_inode;\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttcon = tlink_tcon(cfile->tlink);\n\tserver = tcon->ses->server;\n\n\t/*\n\t * Can not grab rename sem here because various ops, including those\n\t * that already have the rename sem can end up causing writepage to get\n\t * called and if the server was down that means we end up here, and we\n\t * can never tell if the caller already has the rename_sem.\n\t */\n\tfull_path = build_path_from_dentry(cfile->dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tcifs_dbg(FYI, \"inode = 0x%p file flags 0x%x for %s\\n\",\n\t\t inode, cfile->f_flags, full_path);\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\t/*\n\t\t * O_CREAT, O_EXCL and O_TRUNC already had their effect on the\n\t\t * original open. Must mask them off for a reopen.\n\t\t */\n\t\tunsigned int oflags = cfile->f_flags &\n\t\t\t\t\t\t~(O_CREAT | O_EXCL | O_TRUNC);\n\n\t\trc = cifs_posix_open(full_path, NULL, inode->i_sb,\n\t\t\t\t     cifs_sb->mnt_file_mode /* ignored */,\n\t\t\t\t     oflags, &oplock, &cfile->fid.netfid, xid);\n\t\tif (rc == 0) {\n\t\t\tcifs_dbg(FYI, \"posix reopen succeeded\\n\");\n\t\t\toparms.reconnect = true;\n\t\t\tgoto reopen_success;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry open the old way on errors, especially\n\t\t * in the reconnect path it is important to retry hard\n\t\t */\n\t}\n\n\tdesired_access = cifs_convert_flags(cfile->f_flags);\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &cfile->fid);\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = &cfile->fid;\n\toparms.reconnect = true;\n\n\t/*\n\t * Can not refresh inode by passing in file_info buf to be returned by\n\t * ops->open and then calling get_inode_info with returned buf since\n\t * file might have write behind data that needs to be flushed and server\n\t * version of file size can be stale. If we knew for sure that inode was\n\t * not dirty locally we could do this.\n\t */\n\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\tif (rc == -ENOENT && oparms.reconnect == false) {\n\t\t/* durable handle timeout is expired - open the file again */\n\t\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\t\t/* indicate that we need to relock the file */\n\t\toparms.reconnect = true;\n\t}\n\n\tif (rc) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tcifs_dbg(FYI, \"cifs_reopen returned 0x%x\\n\", rc);\n\t\tcifs_dbg(FYI, \"oplock: %d\\n\", oplock);\n\t\tgoto reopen_error_exit;\n\t}\n\nreopen_success:\n\tcfile->invalidHandle = false;\n\tmutex_unlock(&cfile->fh_mutex);\n\tcinode = CIFS_I(inode);\n\n\tif (can_flush) {\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\t\tmapping_set_error(inode->i_mapping, rc);\n\n\t\tif (tcon->unix_ext)\n\t\t\trc = cifs_get_inode_info_unix(&inode, full_path,\n\t\t\t\t\t\t      inode->i_sb, xid);\n\t\telse\n\t\t\trc = cifs_get_inode_info(&inode, full_path, NULL,\n\t\t\t\t\t\t inode->i_sb, xid, NULL);\n\t}\n\t/*\n\t * Else we are writing out data to server already and could deadlock if\n\t * we tried to flush data, and since we do not know if we have data that\n\t * would invalidate the current end of file on the server we can not go\n\t * to the server to get the new inode info.\n\t */\n\n\tserver->ops->set_fid(cfile, &cfile->fid, oplock);\n\tif (oparms.reconnect)\n\t\tcifs_relock_file(cfile);\n\nreopen_error_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "uint",
            "current_read_size",
            "CIFSMaxBufSize"
          ],
          "line": 3195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "uint",
            "read_size - total_read",
            "rsize"
          ],
          "line": 3186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"attempting read on write only file instance\\n\""
          ],
          "line": 3181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "open_file->tlink"
          ],
          "line": 3167
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "cifs_sb->rsize",
            "CIFSMaxBufSize"
          ],
          "line": 3159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_FILE_SB",
          "args": [
            "file"
          ],
          "line": 3156
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_FILE_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1171-1175",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_FILE_SB(struct file *file)\n{\n\treturn CIFS_SB(file_inode(file)->i_sb);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_FILE_SB(struct file *file)\n{\n\treturn CIFS_SB(file_inode(file)->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 3155
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic ssize_t\ncifs_read(struct file *file, char *read_data, size_t read_size, loff_t *offset)\n{\n\tint rc = -EACCES;\n\tunsigned int bytes_read = 0;\n\tunsigned int total_read;\n\tunsigned int current_read_size;\n\tunsigned int rsize;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tunsigned int xid;\n\tchar *cur_offset;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifs_io_parms io_parms;\n\tint buf_type = CIFS_NO_BUFFER;\n\t__u32 pid;\n\n\txid = get_xid();\n\tcifs_sb = CIFS_FILE_SB(file);\n\n\t/* FIXME: set up handlers for larger reads and/or convert to async */\n\trsize = min_t(unsigned int, cifs_sb->rsize, CIFSMaxBufSize);\n\n\tif (file->private_data == NULL) {\n\t\trc = -EBADF;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\topen_file = file->private_data;\n\ttcon = tlink_tcon(open_file->tlink);\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->sync_read) {\n\t\tfree_xid(xid);\n\t\treturn -ENOSYS;\n\t}\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tif ((file->f_flags & O_ACCMODE) == O_WRONLY)\n\t\tcifs_dbg(FYI, \"attempting read on write only file instance\\n\");\n\n\tfor (total_read = 0, cur_offset = read_data; read_size > total_read;\n\t     total_read += bytes_read, cur_offset += bytes_read) {\n\t\tdo {\n\t\t\tcurrent_read_size = min_t(uint, read_size - total_read,\n\t\t\t\t\t\t  rsize);\n\t\t\t/*\n\t\t\t * For windows me and 9x we do not want to request more\n\t\t\t * than it negotiated since it will refuse the read\n\t\t\t * then.\n\t\t\t */\n\t\t\tif ((tcon->ses) && !(tcon->ses->capabilities &\n\t\t\t\ttcon->ses->server->vals->cap_large_files)) {\n\t\t\t\tcurrent_read_size = min_t(uint,\n\t\t\t\t\tcurrent_read_size, CIFSMaxBufSize);\n\t\t\t}\n\t\t\tif (open_file->invalidHandle) {\n\t\t\t\trc = cifs_reopen_file(open_file, true);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tio_parms.pid = pid;\n\t\t\tio_parms.tcon = tcon;\n\t\t\tio_parms.offset = *offset;\n\t\t\tio_parms.length = current_read_size;\n\t\t\trc = server->ops->sync_read(xid, &open_file->fid, &io_parms,\n\t\t\t\t\t\t    &bytes_read, &cur_offset,\n\t\t\t\t\t\t    &buf_type);\n\t\t} while (rc == -EAGAIN);\n\n\t\tif (rc || (bytes_read == 0)) {\n\t\t\tif (total_read) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\tcifs_stats_bytes_read(tcon, total_read);\n\t\t\t*offset += bytes_read;\n\t\t}\n\t}\n\tfree_xid(xid);\n\treturn total_read;\n}"
  },
  {
    "function_name": "cifs_strict_readv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "3097-3135",
    "snippet": "ssize_t\ncifs_strict_readv(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)\n\t\t\t\t\t\tiocb->ki_filp->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tint rc = -EACCES;\n\n\t/*\n\t * In strict cache mode we need to read from the server all the time\n\t * if we don't have level II oplock because the server can delay mtime\n\t * change - so we can't make a decision about inode invalidating.\n\t * And we can also fail with pagereading if there are mandatory locks\n\t * on pages affected by this read but not on the region from pos to\n\t * pos+len-1.\n\t */\n\tif (!CIFS_CACHE_READ(cinode))\n\t\treturn cifs_user_readv(iocb, to);\n\n\tif (cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability)) &&\n\t    ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0))\n\t\treturn generic_file_read_iter(iocb, to);\n\n\t/*\n\t * We need to hold the sem to be sure nobody modifies lock list\n\t * with a brlock that prevents reading.\n\t */\n\tdown_read(&cinode->lock_sem);\n\tif (!cifs_find_lock_conflict(cfile, iocb->ki_pos, iov_iter_count(to),\n\t\t\t\t     tcon->ses->server->vals->shared_lock_type,\n\t\t\t\t     NULL, CIFS_READ_OP))\n\t\trc = generic_file_read_iter(iocb, to);\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CIFS_READ_OP\t1"
    ],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_file_read_iter",
          "args": [
            "iocb",
            "to"
          ],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_find_lock_conflict",
          "args": [
            "cfile",
            "iocb->ki_pos",
            "iov_iter_count(to)",
            "tcon->ses->server->vals->shared_lock_type",
            "NULL",
            "CIFS_READ_OP"
          ],
          "line": 3129
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_find_lock_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "870-887",
          "snippet": "bool\ncifs_find_lock_conflict(struct cifsFileInfo *cfile, __u64 offset, __u64 length,\n\t\t\t__u8 type, struct cifsLockInfo **conf_lock,\n\t\t\tint rw_check)\n{\n\tbool rc = false;\n\tstruct cifs_fid_locks *cur;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\n\tlist_for_each_entry(cur, &cinode->llist, llist) {\n\t\trc = cifs_find_fid_lock_conflict(cur, offset, length, type,\n\t\t\t\t\t\t cfile, conf_lock, rw_check);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nbool\ncifs_find_lock_conflict(struct cifsFileInfo *cfile, __u64 offset, __u64 length,\n\t\t\t__u8 type, struct cifsLockInfo **conf_lock,\n\t\t\tint rw_check)\n{\n\tbool rc = false;\n\tstruct cifs_fid_locks *cur;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\n\tlist_for_each_entry(cur, &cinode->llist, llist) {\n\t\trc = cifs_find_fid_lock_conflict(cur, offset, length, type,\n\t\t\t\t\t\t cfile, conf_lock, rw_check);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "to"
          ],
          "line": 3129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 3128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_file_read_iter",
          "args": [
            "iocb",
            "to"
          ],
          "line": 3122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "tcon->fsUnixInfo.Capability"
          ],
          "line": 3120
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_unix",
          "args": [
            "tcon->ses"
          ],
          "line": 3119
        },
        "resolved": true,
        "details": {
          "function_name": "cap_unix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "804-808",
          "snippet": "static inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_user_readv",
          "args": [
            "iocb",
            "to"
          ],
          "line": 3117
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_user_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "2993-3095",
          "snippet": "ssize_t cifs_user_readv(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tssize_t rc;\n\tsize_t len;\n\tssize_t total_read = 0;\n\tloff_t offset = iocb->ki_pos;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifs_readdata *rdata, *tmp;\n\tstruct list_head rdata_list;\n\n\tlen = iov_iter_count(to);\n\tif (!len)\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&rdata_list);\n\tcifs_sb = CIFS_FILE_SB(file);\n\topen_file = file->private_data;\n\ttcon = tlink_tcon(open_file->tlink);\n\n\tif (!tcon->ses->server->ops->async_readv)\n\t\treturn -ENOSYS;\n\n\tif ((file->f_flags & O_ACCMODE) == O_WRONLY)\n\t\tcifs_dbg(FYI, \"attempting read on write only file instance\\n\");\n\n\trc = cifs_send_async_read(offset, len, open_file, cifs_sb, &rdata_list);\n\n\t/* if at least one read request send succeeded, then reset rc */\n\tif (!list_empty(&rdata_list))\n\t\trc = 0;\n\n\tlen = iov_iter_count(to);\n\t/* the loop below should proceed in the order of increasing offsets */\nagain:\n\tlist_for_each_entry_safe(rdata, tmp, &rdata_list, list) {\n\t\tif (!rc) {\n\t\t\t/* FIXME: freezable sleep too? */\n\t\t\trc = wait_for_completion_killable(&rdata->done);\n\t\t\tif (rc)\n\t\t\t\trc = -EINTR;\n\t\t\telse if (rdata->result == -EAGAIN) {\n\t\t\t\t/* resend call if it's a retryable error */\n\t\t\t\tstruct list_head tmp_list;\n\t\t\t\tunsigned int got_bytes = rdata->got_bytes;\n\n\t\t\t\tlist_del_init(&rdata->list);\n\t\t\t\tINIT_LIST_HEAD(&tmp_list);\n\n\t\t\t\t/*\n\t\t\t\t * Got a part of data and then reconnect has\n\t\t\t\t * happened -- fill the buffer and continue\n\t\t\t\t * reading.\n\t\t\t\t */\n\t\t\t\tif (got_bytes && got_bytes < rdata->bytes) {\n\t\t\t\t\trc = cifs_readdata_to_iov(rdata, to);\n\t\t\t\t\tif (rc) {\n\t\t\t\t\t\tkref_put(&rdata->refcount,\n\t\t\t\t\t\tcifs_uncached_readdata_release);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trc = cifs_send_async_read(\n\t\t\t\t\t\trdata->offset + got_bytes,\n\t\t\t\t\t\trdata->bytes - got_bytes,\n\t\t\t\t\t\trdata->cfile, cifs_sb,\n\t\t\t\t\t\t&tmp_list);\n\n\t\t\t\tlist_splice(&tmp_list, &rdata_list);\n\n\t\t\t\tkref_put(&rdata->refcount,\n\t\t\t\t\t cifs_uncached_readdata_release);\n\t\t\t\tgoto again;\n\t\t\t} else if (rdata->result)\n\t\t\t\trc = rdata->result;\n\t\t\telse\n\t\t\t\trc = cifs_readdata_to_iov(rdata, to);\n\n\t\t\t/* if there was a short read -- discard anything left */\n\t\t\tif (rdata->got_bytes && rdata->got_bytes < rdata->bytes)\n\t\t\t\trc = -ENODATA;\n\t\t}\n\t\tlist_del_init(&rdata->list);\n\t\tkref_put(&rdata->refcount, cifs_uncached_readdata_release);\n\t}\n\n\ttotal_read = len - iov_iter_count(to);\n\n\tcifs_stats_bytes_read(tcon, total_read);\n\n\t/* mask nodata case */\n\tif (rc == -ENODATA)\n\t\trc = 0;\n\n\tif (total_read) {\n\t\tiocb->ki_pos += total_read;\n\t\treturn total_read;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nssize_t cifs_user_readv(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tssize_t rc;\n\tsize_t len;\n\tssize_t total_read = 0;\n\tloff_t offset = iocb->ki_pos;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifs_readdata *rdata, *tmp;\n\tstruct list_head rdata_list;\n\n\tlen = iov_iter_count(to);\n\tif (!len)\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&rdata_list);\n\tcifs_sb = CIFS_FILE_SB(file);\n\topen_file = file->private_data;\n\ttcon = tlink_tcon(open_file->tlink);\n\n\tif (!tcon->ses->server->ops->async_readv)\n\t\treturn -ENOSYS;\n\n\tif ((file->f_flags & O_ACCMODE) == O_WRONLY)\n\t\tcifs_dbg(FYI, \"attempting read on write only file instance\\n\");\n\n\trc = cifs_send_async_read(offset, len, open_file, cifs_sb, &rdata_list);\n\n\t/* if at least one read request send succeeded, then reset rc */\n\tif (!list_empty(&rdata_list))\n\t\trc = 0;\n\n\tlen = iov_iter_count(to);\n\t/* the loop below should proceed in the order of increasing offsets */\nagain:\n\tlist_for_each_entry_safe(rdata, tmp, &rdata_list, list) {\n\t\tif (!rc) {\n\t\t\t/* FIXME: freezable sleep too? */\n\t\t\trc = wait_for_completion_killable(&rdata->done);\n\t\t\tif (rc)\n\t\t\t\trc = -EINTR;\n\t\t\telse if (rdata->result == -EAGAIN) {\n\t\t\t\t/* resend call if it's a retryable error */\n\t\t\t\tstruct list_head tmp_list;\n\t\t\t\tunsigned int got_bytes = rdata->got_bytes;\n\n\t\t\t\tlist_del_init(&rdata->list);\n\t\t\t\tINIT_LIST_HEAD(&tmp_list);\n\n\t\t\t\t/*\n\t\t\t\t * Got a part of data and then reconnect has\n\t\t\t\t * happened -- fill the buffer and continue\n\t\t\t\t * reading.\n\t\t\t\t */\n\t\t\t\tif (got_bytes && got_bytes < rdata->bytes) {\n\t\t\t\t\trc = cifs_readdata_to_iov(rdata, to);\n\t\t\t\t\tif (rc) {\n\t\t\t\t\t\tkref_put(&rdata->refcount,\n\t\t\t\t\t\tcifs_uncached_readdata_release);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trc = cifs_send_async_read(\n\t\t\t\t\t\trdata->offset + got_bytes,\n\t\t\t\t\t\trdata->bytes - got_bytes,\n\t\t\t\t\t\trdata->cfile, cifs_sb,\n\t\t\t\t\t\t&tmp_list);\n\n\t\t\t\tlist_splice(&tmp_list, &rdata_list);\n\n\t\t\t\tkref_put(&rdata->refcount,\n\t\t\t\t\t cifs_uncached_readdata_release);\n\t\t\t\tgoto again;\n\t\t\t} else if (rdata->result)\n\t\t\t\trc = rdata->result;\n\t\t\telse\n\t\t\t\trc = cifs_readdata_to_iov(rdata, to);\n\n\t\t\t/* if there was a short read -- discard anything left */\n\t\t\tif (rdata->got_bytes && rdata->got_bytes < rdata->bytes)\n\t\t\t\trc = -ENODATA;\n\t\t}\n\t\tlist_del_init(&rdata->list);\n\t\tkref_put(&rdata->refcount, cifs_uncached_readdata_release);\n\t}\n\n\ttotal_read = len - iov_iter_count(to);\n\n\tcifs_stats_bytes_read(tcon, total_read);\n\n\t/* mask nodata case */\n\tif (rc == -ENODATA)\n\t\trc = 0;\n\n\tif (total_read) {\n\t\tiocb->ki_pos += total_read;\n\t\treturn total_read;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "cinode"
          ],
          "line": 3116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 3105
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3102
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 3101
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "iocb->ki_filp"
          ],
          "line": 3100
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\n#define CIFS_READ_OP\t1\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nssize_t\ncifs_strict_readv(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)\n\t\t\t\t\t\tiocb->ki_filp->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tint rc = -EACCES;\n\n\t/*\n\t * In strict cache mode we need to read from the server all the time\n\t * if we don't have level II oplock because the server can delay mtime\n\t * change - so we can't make a decision about inode invalidating.\n\t * And we can also fail with pagereading if there are mandatory locks\n\t * on pages affected by this read but not on the region from pos to\n\t * pos+len-1.\n\t */\n\tif (!CIFS_CACHE_READ(cinode))\n\t\treturn cifs_user_readv(iocb, to);\n\n\tif (cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability)) &&\n\t    ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0))\n\t\treturn generic_file_read_iter(iocb, to);\n\n\t/*\n\t * We need to hold the sem to be sure nobody modifies lock list\n\t * with a brlock that prevents reading.\n\t */\n\tdown_read(&cinode->lock_sem);\n\tif (!cifs_find_lock_conflict(cfile, iocb->ki_pos, iov_iter_count(to),\n\t\t\t\t     tcon->ses->server->vals->shared_lock_type,\n\t\t\t\t     NULL, CIFS_READ_OP))\n\t\trc = generic_file_read_iter(iocb, to);\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_user_readv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2993-3095",
    "snippet": "ssize_t cifs_user_readv(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tssize_t rc;\n\tsize_t len;\n\tssize_t total_read = 0;\n\tloff_t offset = iocb->ki_pos;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifs_readdata *rdata, *tmp;\n\tstruct list_head rdata_list;\n\n\tlen = iov_iter_count(to);\n\tif (!len)\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&rdata_list);\n\tcifs_sb = CIFS_FILE_SB(file);\n\topen_file = file->private_data;\n\ttcon = tlink_tcon(open_file->tlink);\n\n\tif (!tcon->ses->server->ops->async_readv)\n\t\treturn -ENOSYS;\n\n\tif ((file->f_flags & O_ACCMODE) == O_WRONLY)\n\t\tcifs_dbg(FYI, \"attempting read on write only file instance\\n\");\n\n\trc = cifs_send_async_read(offset, len, open_file, cifs_sb, &rdata_list);\n\n\t/* if at least one read request send succeeded, then reset rc */\n\tif (!list_empty(&rdata_list))\n\t\trc = 0;\n\n\tlen = iov_iter_count(to);\n\t/* the loop below should proceed in the order of increasing offsets */\nagain:\n\tlist_for_each_entry_safe(rdata, tmp, &rdata_list, list) {\n\t\tif (!rc) {\n\t\t\t/* FIXME: freezable sleep too? */\n\t\t\trc = wait_for_completion_killable(&rdata->done);\n\t\t\tif (rc)\n\t\t\t\trc = -EINTR;\n\t\t\telse if (rdata->result == -EAGAIN) {\n\t\t\t\t/* resend call if it's a retryable error */\n\t\t\t\tstruct list_head tmp_list;\n\t\t\t\tunsigned int got_bytes = rdata->got_bytes;\n\n\t\t\t\tlist_del_init(&rdata->list);\n\t\t\t\tINIT_LIST_HEAD(&tmp_list);\n\n\t\t\t\t/*\n\t\t\t\t * Got a part of data and then reconnect has\n\t\t\t\t * happened -- fill the buffer and continue\n\t\t\t\t * reading.\n\t\t\t\t */\n\t\t\t\tif (got_bytes && got_bytes < rdata->bytes) {\n\t\t\t\t\trc = cifs_readdata_to_iov(rdata, to);\n\t\t\t\t\tif (rc) {\n\t\t\t\t\t\tkref_put(&rdata->refcount,\n\t\t\t\t\t\tcifs_uncached_readdata_release);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trc = cifs_send_async_read(\n\t\t\t\t\t\trdata->offset + got_bytes,\n\t\t\t\t\t\trdata->bytes - got_bytes,\n\t\t\t\t\t\trdata->cfile, cifs_sb,\n\t\t\t\t\t\t&tmp_list);\n\n\t\t\t\tlist_splice(&tmp_list, &rdata_list);\n\n\t\t\t\tkref_put(&rdata->refcount,\n\t\t\t\t\t cifs_uncached_readdata_release);\n\t\t\t\tgoto again;\n\t\t\t} else if (rdata->result)\n\t\t\t\trc = rdata->result;\n\t\t\telse\n\t\t\t\trc = cifs_readdata_to_iov(rdata, to);\n\n\t\t\t/* if there was a short read -- discard anything left */\n\t\t\tif (rdata->got_bytes && rdata->got_bytes < rdata->bytes)\n\t\t\t\trc = -ENODATA;\n\t\t}\n\t\tlist_del_init(&rdata->list);\n\t\tkref_put(&rdata->refcount, cifs_uncached_readdata_release);\n\t}\n\n\ttotal_read = len - iov_iter_count(to);\n\n\tcifs_stats_bytes_read(tcon, total_read);\n\n\t/* mask nodata case */\n\tif (rc == -ENODATA)\n\t\trc = 0;\n\n\tif (total_read) {\n\t\tiocb->ki_pos += total_read;\n\t\treturn total_read;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_stats_bytes_read",
          "args": [
            "tcon",
            "total_read"
          ],
          "line": 3084
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_bytes_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1213-1219",
          "snippet": "static inline void cifs_stats_bytes_read(struct cifs_tcon *tcon,\n\t\t\t\t\t unsigned int bytes)\n{\n\tspin_lock(&tcon->stat_lock);\n\ttcon->bytes_read += bytes;\n\tspin_unlock(&tcon->stat_lock);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_stats_bytes_read(struct cifs_tcon *tcon,\n\t\t\t\t\t unsigned int bytes)\n{\n\tspin_lock(&tcon->stat_lock);\n\ttcon->bytes_read += bytes;\n\tspin_unlock(&tcon->stat_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "to"
          ],
          "line": 3082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&rdata->refcount",
            "cifs_uncached_readdata_release"
          ],
          "line": 3079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&rdata->list"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_readdata_to_iov",
          "args": [
            "rdata",
            "to"
          ],
          "line": 3072
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_readdata_to_iov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "2846-2861",
          "snippet": "static int\ncifs_readdata_to_iov(struct cifs_readdata *rdata, struct iov_iter *iter)\n{\n\tsize_t remaining = rdata->got_bytes;\n\tunsigned int i;\n\n\tfor (i = 0; i < rdata->nr_pages; i++) {\n\t\tstruct page *page = rdata->pages[i];\n\t\tsize_t copy = min_t(size_t, remaining, PAGE_SIZE);\n\t\tsize_t written = copy_page_to_iter(page, 0, copy, iter);\n\t\tremaining -= written;\n\t\tif (written < copy && iov_iter_count(iter) > 0)\n\t\t\tbreak;\n\t}\n\treturn remaining ? -EFAULT : 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_readdata_to_iov(struct cifs_readdata *rdata, struct iov_iter *iter)\n{\n\tsize_t remaining = rdata->got_bytes;\n\tunsigned int i;\n\n\tfor (i = 0; i < rdata->nr_pages; i++) {\n\t\tstruct page *page = rdata->pages[i];\n\t\tsize_t copy = min_t(size_t, remaining, PAGE_SIZE);\n\t\tsize_t written = copy_page_to_iter(page, 0, copy, iter);\n\t\tremaining -= written;\n\t\tif (written < copy && iov_iter_count(iter) > 0)\n\t\t\tbreak;\n\t}\n\treturn remaining ? -EFAULT : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&rdata->refcount",
            "cifs_uncached_readdata_release"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&tmp_list",
            "&rdata_list"
          ],
          "line": 3064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_send_async_read",
          "args": [
            "rdata->offset + got_bytes",
            "rdata->bytes - got_bytes",
            "rdata->cfile",
            "cifs_sb",
            "&tmp_list"
          ],
          "line": 3058
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_send_async_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "2923-2991",
          "snippet": "static int\ncifs_send_async_read(loff_t offset, size_t len, struct cifsFileInfo *open_file,\n\t\t     struct cifs_sb_info *cifs_sb, struct list_head *rdata_list)\n{\n\tstruct cifs_readdata *rdata;\n\tunsigned int npages, rsize, credits;\n\tsize_t cur_len;\n\tint rc;\n\tpid_t pid;\n\tstruct TCP_Server_Info *server;\n\n\tserver = tlink_tcon(open_file->tlink)->ses->server;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tdo {\n\t\trc = server->ops->wait_mtu_credits(server, cifs_sb->rsize,\n\t\t\t\t\t\t   &rsize, &credits);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tcur_len = min_t(const size_t, len, rsize);\n\t\tnpages = DIV_ROUND_UP(cur_len, PAGE_SIZE);\n\n\t\t/* allocate a readdata struct */\n\t\trdata = cifs_readdata_alloc(npages,\n\t\t\t\t\t    cifs_uncached_readv_complete);\n\t\tif (!rdata) {\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\trc = cifs_read_allocate_pages(rdata, npages);\n\t\tif (rc)\n\t\t\tgoto error;\n\n\t\trdata->cfile = cifsFileInfo_get(open_file);\n\t\trdata->nr_pages = npages;\n\t\trdata->offset = offset;\n\t\trdata->bytes = cur_len;\n\t\trdata->pid = pid;\n\t\trdata->pagesz = PAGE_SIZE;\n\t\trdata->read_into_pages = cifs_uncached_read_into_pages;\n\t\trdata->credits = credits;\n\n\t\tif (!rdata->cfile->invalidHandle ||\n\t\t    !cifs_reopen_file(rdata->cfile, true))\n\t\t\trc = server->ops->async_readv(rdata);\nerror:\n\t\tif (rc) {\n\t\t\tadd_credits_and_wake_if(server, rdata->credits, 0);\n\t\t\tkref_put(&rdata->refcount,\n\t\t\t\t cifs_uncached_readdata_release);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&rdata->list, rdata_list);\n\t\toffset += cur_len;\n\t\tlen -= cur_len;\n\t} while (len > 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_send_async_read(loff_t offset, size_t len, struct cifsFileInfo *open_file,\n\t\t     struct cifs_sb_info *cifs_sb, struct list_head *rdata_list)\n{\n\tstruct cifs_readdata *rdata;\n\tunsigned int npages, rsize, credits;\n\tsize_t cur_len;\n\tint rc;\n\tpid_t pid;\n\tstruct TCP_Server_Info *server;\n\n\tserver = tlink_tcon(open_file->tlink)->ses->server;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tdo {\n\t\trc = server->ops->wait_mtu_credits(server, cifs_sb->rsize,\n\t\t\t\t\t\t   &rsize, &credits);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tcur_len = min_t(const size_t, len, rsize);\n\t\tnpages = DIV_ROUND_UP(cur_len, PAGE_SIZE);\n\n\t\t/* allocate a readdata struct */\n\t\trdata = cifs_readdata_alloc(npages,\n\t\t\t\t\t    cifs_uncached_readv_complete);\n\t\tif (!rdata) {\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\trc = cifs_read_allocate_pages(rdata, npages);\n\t\tif (rc)\n\t\t\tgoto error;\n\n\t\trdata->cfile = cifsFileInfo_get(open_file);\n\t\trdata->nr_pages = npages;\n\t\trdata->offset = offset;\n\t\trdata->bytes = cur_len;\n\t\trdata->pid = pid;\n\t\trdata->pagesz = PAGE_SIZE;\n\t\trdata->read_into_pages = cifs_uncached_read_into_pages;\n\t\trdata->credits = credits;\n\n\t\tif (!rdata->cfile->invalidHandle ||\n\t\t    !cifs_reopen_file(rdata->cfile, true))\n\t\t\trc = server->ops->async_readv(rdata);\nerror:\n\t\tif (rc) {\n\t\t\tadd_credits_and_wake_if(server, rdata->credits, 0);\n\t\t\tkref_put(&rdata->refcount,\n\t\t\t\t cifs_uncached_readdata_release);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&rdata->list, rdata_list);\n\t\toffset += cur_len;\n\t\tlen -= cur_len;\n\t} while (len > 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&rdata->refcount",
            "cifs_uncached_readdata_release"
          ],
          "line": 3052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tmp_list"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&rdata->list"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion_killable",
          "args": [
            "&rdata->done"
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "rdata",
            "tmp",
            "&rdata_list",
            "list"
          ],
          "line": 3030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "to"
          ],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&rdata_list"
          ],
          "line": 3024
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"attempting read on write only file instance\\n\""
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "open_file->tlink"
          ],
          "line": 3013
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_FILE_SB",
          "args": [
            "file"
          ],
          "line": 3011
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_FILE_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1171-1175",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_FILE_SB(struct file *file)\n{\n\treturn CIFS_SB(file_inode(file)->i_sb);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_FILE_SB(struct file *file)\n{\n\treturn CIFS_SB(file_inode(file)->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rdata_list"
          ],
          "line": 3010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "to"
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nssize_t cifs_user_readv(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tssize_t rc;\n\tsize_t len;\n\tssize_t total_read = 0;\n\tloff_t offset = iocb->ki_pos;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifs_readdata *rdata, *tmp;\n\tstruct list_head rdata_list;\n\n\tlen = iov_iter_count(to);\n\tif (!len)\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&rdata_list);\n\tcifs_sb = CIFS_FILE_SB(file);\n\topen_file = file->private_data;\n\ttcon = tlink_tcon(open_file->tlink);\n\n\tif (!tcon->ses->server->ops->async_readv)\n\t\treturn -ENOSYS;\n\n\tif ((file->f_flags & O_ACCMODE) == O_WRONLY)\n\t\tcifs_dbg(FYI, \"attempting read on write only file instance\\n\");\n\n\trc = cifs_send_async_read(offset, len, open_file, cifs_sb, &rdata_list);\n\n\t/* if at least one read request send succeeded, then reset rc */\n\tif (!list_empty(&rdata_list))\n\t\trc = 0;\n\n\tlen = iov_iter_count(to);\n\t/* the loop below should proceed in the order of increasing offsets */\nagain:\n\tlist_for_each_entry_safe(rdata, tmp, &rdata_list, list) {\n\t\tif (!rc) {\n\t\t\t/* FIXME: freezable sleep too? */\n\t\t\trc = wait_for_completion_killable(&rdata->done);\n\t\t\tif (rc)\n\t\t\t\trc = -EINTR;\n\t\t\telse if (rdata->result == -EAGAIN) {\n\t\t\t\t/* resend call if it's a retryable error */\n\t\t\t\tstruct list_head tmp_list;\n\t\t\t\tunsigned int got_bytes = rdata->got_bytes;\n\n\t\t\t\tlist_del_init(&rdata->list);\n\t\t\t\tINIT_LIST_HEAD(&tmp_list);\n\n\t\t\t\t/*\n\t\t\t\t * Got a part of data and then reconnect has\n\t\t\t\t * happened -- fill the buffer and continue\n\t\t\t\t * reading.\n\t\t\t\t */\n\t\t\t\tif (got_bytes && got_bytes < rdata->bytes) {\n\t\t\t\t\trc = cifs_readdata_to_iov(rdata, to);\n\t\t\t\t\tif (rc) {\n\t\t\t\t\t\tkref_put(&rdata->refcount,\n\t\t\t\t\t\tcifs_uncached_readdata_release);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trc = cifs_send_async_read(\n\t\t\t\t\t\trdata->offset + got_bytes,\n\t\t\t\t\t\trdata->bytes - got_bytes,\n\t\t\t\t\t\trdata->cfile, cifs_sb,\n\t\t\t\t\t\t&tmp_list);\n\n\t\t\t\tlist_splice(&tmp_list, &rdata_list);\n\n\t\t\t\tkref_put(&rdata->refcount,\n\t\t\t\t\t cifs_uncached_readdata_release);\n\t\t\t\tgoto again;\n\t\t\t} else if (rdata->result)\n\t\t\t\trc = rdata->result;\n\t\t\telse\n\t\t\t\trc = cifs_readdata_to_iov(rdata, to);\n\n\t\t\t/* if there was a short read -- discard anything left */\n\t\t\tif (rdata->got_bytes && rdata->got_bytes < rdata->bytes)\n\t\t\t\trc = -ENODATA;\n\t\t}\n\t\tlist_del_init(&rdata->list);\n\t\tkref_put(&rdata->refcount, cifs_uncached_readdata_release);\n\t}\n\n\ttotal_read = len - iov_iter_count(to);\n\n\tcifs_stats_bytes_read(tcon, total_read);\n\n\t/* mask nodata case */\n\tif (rc == -ENODATA)\n\t\trc = 0;\n\n\tif (total_read) {\n\t\tiocb->ki_pos += total_read;\n\t\treturn total_read;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_send_async_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2923-2991",
    "snippet": "static int\ncifs_send_async_read(loff_t offset, size_t len, struct cifsFileInfo *open_file,\n\t\t     struct cifs_sb_info *cifs_sb, struct list_head *rdata_list)\n{\n\tstruct cifs_readdata *rdata;\n\tunsigned int npages, rsize, credits;\n\tsize_t cur_len;\n\tint rc;\n\tpid_t pid;\n\tstruct TCP_Server_Info *server;\n\n\tserver = tlink_tcon(open_file->tlink)->ses->server;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tdo {\n\t\trc = server->ops->wait_mtu_credits(server, cifs_sb->rsize,\n\t\t\t\t\t\t   &rsize, &credits);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tcur_len = min_t(const size_t, len, rsize);\n\t\tnpages = DIV_ROUND_UP(cur_len, PAGE_SIZE);\n\n\t\t/* allocate a readdata struct */\n\t\trdata = cifs_readdata_alloc(npages,\n\t\t\t\t\t    cifs_uncached_readv_complete);\n\t\tif (!rdata) {\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\trc = cifs_read_allocate_pages(rdata, npages);\n\t\tif (rc)\n\t\t\tgoto error;\n\n\t\trdata->cfile = cifsFileInfo_get(open_file);\n\t\trdata->nr_pages = npages;\n\t\trdata->offset = offset;\n\t\trdata->bytes = cur_len;\n\t\trdata->pid = pid;\n\t\trdata->pagesz = PAGE_SIZE;\n\t\trdata->read_into_pages = cifs_uncached_read_into_pages;\n\t\trdata->credits = credits;\n\n\t\tif (!rdata->cfile->invalidHandle ||\n\t\t    !cifs_reopen_file(rdata->cfile, true))\n\t\t\trc = server->ops->async_readv(rdata);\nerror:\n\t\tif (rc) {\n\t\t\tadd_credits_and_wake_if(server, rdata->credits, 0);\n\t\t\tkref_put(&rdata->refcount,\n\t\t\t\t cifs_uncached_readdata_release);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&rdata->list, rdata_list);\n\t\toffset += cur_len;\n\t\tlen -= cur_len;\n\t} while (len > 0);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&rdata->list",
            "rdata_list"
          ],
          "line": 2985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&rdata->refcount",
            "cifs_uncached_readdata_release"
          ],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_credits_and_wake_if",
          "args": [
            "server",
            "rdata->credits",
            "0"
          ],
          "line": 2977
        },
        "resolved": true,
        "details": {
          "function_name": "add_credits_and_wake_if",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "648-656",
          "snippet": "static inline void\nadd_credits_and_wake_if(struct TCP_Server_Info *server, const unsigned int add,\n\t\t\tconst int optype)\n{\n\tif (add) {\n\t\tserver->ops->add_credits(server, add, optype);\n\t\twake_up(&server->request_q);\n\t}\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\nadd_credits_and_wake_if(struct TCP_Server_Info *server, const unsigned int add,\n\t\t\tconst int optype)\n{\n\tif (add) {\n\t\tserver->ops->add_credits(server, add, optype);\n\t\twake_up(&server->request_q);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->async_readv",
          "args": [
            "rdata"
          ],
          "line": 2974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_reopen_file",
          "args": [
            "rdata->cfile",
            "true"
          ],
          "line": 2973
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_reopen_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "597-744",
          "snippet": "static int\ncifs_reopen_file(struct cifsFileInfo *cfile, bool can_flush)\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\t__u32 oplock;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsInodeInfo *cinode;\n\tstruct inode *inode;\n\tchar *full_path = NULL;\n\tint desired_access;\n\tint disposition = FILE_OPEN;\n\tint create_options = CREATE_NOT_DIR;\n\tstruct cifs_open_parms oparms;\n\n\txid = get_xid();\n\tmutex_lock(&cfile->fh_mutex);\n\tif (!cfile->invalidHandle) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\trc = 0;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tinode = cfile->dentry->d_inode;\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttcon = tlink_tcon(cfile->tlink);\n\tserver = tcon->ses->server;\n\n\t/*\n\t * Can not grab rename sem here because various ops, including those\n\t * that already have the rename sem can end up causing writepage to get\n\t * called and if the server was down that means we end up here, and we\n\t * can never tell if the caller already has the rename_sem.\n\t */\n\tfull_path = build_path_from_dentry(cfile->dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tcifs_dbg(FYI, \"inode = 0x%p file flags 0x%x for %s\\n\",\n\t\t inode, cfile->f_flags, full_path);\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\t/*\n\t\t * O_CREAT, O_EXCL and O_TRUNC already had their effect on the\n\t\t * original open. Must mask them off for a reopen.\n\t\t */\n\t\tunsigned int oflags = cfile->f_flags &\n\t\t\t\t\t\t~(O_CREAT | O_EXCL | O_TRUNC);\n\n\t\trc = cifs_posix_open(full_path, NULL, inode->i_sb,\n\t\t\t\t     cifs_sb->mnt_file_mode /* ignored */,\n\t\t\t\t     oflags, &oplock, &cfile->fid.netfid, xid);\n\t\tif (rc == 0) {\n\t\t\tcifs_dbg(FYI, \"posix reopen succeeded\\n\");\n\t\t\toparms.reconnect = true;\n\t\t\tgoto reopen_success;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry open the old way on errors, especially\n\t\t * in the reconnect path it is important to retry hard\n\t\t */\n\t}\n\n\tdesired_access = cifs_convert_flags(cfile->f_flags);\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &cfile->fid);\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = &cfile->fid;\n\toparms.reconnect = true;\n\n\t/*\n\t * Can not refresh inode by passing in file_info buf to be returned by\n\t * ops->open and then calling get_inode_info with returned buf since\n\t * file might have write behind data that needs to be flushed and server\n\t * version of file size can be stale. If we knew for sure that inode was\n\t * not dirty locally we could do this.\n\t */\n\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\tif (rc == -ENOENT && oparms.reconnect == false) {\n\t\t/* durable handle timeout is expired - open the file again */\n\t\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\t\t/* indicate that we need to relock the file */\n\t\toparms.reconnect = true;\n\t}\n\n\tif (rc) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tcifs_dbg(FYI, \"cifs_reopen returned 0x%x\\n\", rc);\n\t\tcifs_dbg(FYI, \"oplock: %d\\n\", oplock);\n\t\tgoto reopen_error_exit;\n\t}\n\nreopen_success:\n\tcfile->invalidHandle = false;\n\tmutex_unlock(&cfile->fh_mutex);\n\tcinode = CIFS_I(inode);\n\n\tif (can_flush) {\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\t\tmapping_set_error(inode->i_mapping, rc);\n\n\t\tif (tcon->unix_ext)\n\t\t\trc = cifs_get_inode_info_unix(&inode, full_path,\n\t\t\t\t\t\t      inode->i_sb, xid);\n\t\telse\n\t\t\trc = cifs_get_inode_info(&inode, full_path, NULL,\n\t\t\t\t\t\t inode->i_sb, xid, NULL);\n\t}\n\t/*\n\t * Else we are writing out data to server already and could deadlock if\n\t * we tried to flush data, and since we do not know if we have data that\n\t * would invalidate the current end of file on the server we can not go\n\t * to the server to get the new inode info.\n\t */\n\n\tserver->ops->set_fid(cfile, &cfile->fid, oplock);\n\tif (oparms.reconnect)\n\t\tcifs_relock_file(cfile);\n\nreopen_error_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_reopen_file(struct cifsFileInfo *cfile, bool can_flush)\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\t__u32 oplock;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsInodeInfo *cinode;\n\tstruct inode *inode;\n\tchar *full_path = NULL;\n\tint desired_access;\n\tint disposition = FILE_OPEN;\n\tint create_options = CREATE_NOT_DIR;\n\tstruct cifs_open_parms oparms;\n\n\txid = get_xid();\n\tmutex_lock(&cfile->fh_mutex);\n\tif (!cfile->invalidHandle) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\trc = 0;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tinode = cfile->dentry->d_inode;\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttcon = tlink_tcon(cfile->tlink);\n\tserver = tcon->ses->server;\n\n\t/*\n\t * Can not grab rename sem here because various ops, including those\n\t * that already have the rename sem can end up causing writepage to get\n\t * called and if the server was down that means we end up here, and we\n\t * can never tell if the caller already has the rename_sem.\n\t */\n\tfull_path = build_path_from_dentry(cfile->dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tcifs_dbg(FYI, \"inode = 0x%p file flags 0x%x for %s\\n\",\n\t\t inode, cfile->f_flags, full_path);\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\t/*\n\t\t * O_CREAT, O_EXCL and O_TRUNC already had their effect on the\n\t\t * original open. Must mask them off for a reopen.\n\t\t */\n\t\tunsigned int oflags = cfile->f_flags &\n\t\t\t\t\t\t~(O_CREAT | O_EXCL | O_TRUNC);\n\n\t\trc = cifs_posix_open(full_path, NULL, inode->i_sb,\n\t\t\t\t     cifs_sb->mnt_file_mode /* ignored */,\n\t\t\t\t     oflags, &oplock, &cfile->fid.netfid, xid);\n\t\tif (rc == 0) {\n\t\t\tcifs_dbg(FYI, \"posix reopen succeeded\\n\");\n\t\t\toparms.reconnect = true;\n\t\t\tgoto reopen_success;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry open the old way on errors, especially\n\t\t * in the reconnect path it is important to retry hard\n\t\t */\n\t}\n\n\tdesired_access = cifs_convert_flags(cfile->f_flags);\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &cfile->fid);\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = &cfile->fid;\n\toparms.reconnect = true;\n\n\t/*\n\t * Can not refresh inode by passing in file_info buf to be returned by\n\t * ops->open and then calling get_inode_info with returned buf since\n\t * file might have write behind data that needs to be flushed and server\n\t * version of file size can be stale. If we knew for sure that inode was\n\t * not dirty locally we could do this.\n\t */\n\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\tif (rc == -ENOENT && oparms.reconnect == false) {\n\t\t/* durable handle timeout is expired - open the file again */\n\t\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\t\t/* indicate that we need to relock the file */\n\t\toparms.reconnect = true;\n\t}\n\n\tif (rc) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tcifs_dbg(FYI, \"cifs_reopen returned 0x%x\\n\", rc);\n\t\tcifs_dbg(FYI, \"oplock: %d\\n\", oplock);\n\t\tgoto reopen_error_exit;\n\t}\n\nreopen_success:\n\tcfile->invalidHandle = false;\n\tmutex_unlock(&cfile->fh_mutex);\n\tcinode = CIFS_I(inode);\n\n\tif (can_flush) {\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\t\tmapping_set_error(inode->i_mapping, rc);\n\n\t\tif (tcon->unix_ext)\n\t\t\trc = cifs_get_inode_info_unix(&inode, full_path,\n\t\t\t\t\t\t      inode->i_sb, xid);\n\t\telse\n\t\t\trc = cifs_get_inode_info(&inode, full_path, NULL,\n\t\t\t\t\t\t inode->i_sb, xid, NULL);\n\t}\n\t/*\n\t * Else we are writing out data to server already and could deadlock if\n\t * we tried to flush data, and since we do not know if we have data that\n\t * would invalidate the current end of file on the server we can not go\n\t * to the server to get the new inode info.\n\t */\n\n\tserver->ops->set_fid(cfile, &cfile->fid, oplock);\n\tif (oparms.reconnect)\n\t\tcifs_relock_file(cfile);\n\nreopen_error_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifsFileInfo_get",
          "args": [
            "open_file"
          ],
          "line": 2963
        },
        "resolved": true,
        "details": {
          "function_name": "cifsFileInfo_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "344-351",
          "snippet": "struct cifsFileInfo *\ncifsFileInfo_get(struct cifsFileInfo *cifs_file)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tcifsFileInfo_get_locked(cifs_file);\n\tspin_unlock(&cifs_file_list_lock);\n\treturn cifs_file;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstruct cifsFileInfo *\ncifsFileInfo_get(struct cifsFileInfo *cifs_file)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tcifsFileInfo_get_locked(cifs_file);\n\tspin_unlock(&cifs_file_list_lock);\n\treturn cifs_file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_read_allocate_pages",
          "args": [
            "rdata",
            "npages"
          ],
          "line": 2959
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_read_allocate_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "2798-2821",
          "snippet": "static int\ncifs_read_allocate_pages(struct cifs_readdata *rdata, unsigned int nr_pages)\n{\n\tint rc = 0;\n\tstruct page *page;\n\tunsigned int i;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpage = alloc_page(GFP_KERNEL|__GFP_HIGHMEM);\n\t\tif (!page) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\trdata->pages[i] = page;\n\t}\n\n\tif (rc) {\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tput_page(rdata->pages[i]);\n\t\t\trdata->pages[i] = NULL;\n\t\t}\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_read_allocate_pages(struct cifs_readdata *rdata, unsigned int nr_pages)\n{\n\tint rc = 0;\n\tstruct page *page;\n\tunsigned int i;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpage = alloc_page(GFP_KERNEL|__GFP_HIGHMEM);\n\t\tif (!page) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\trdata->pages[i] = page;\n\t}\n\n\tif (rc) {\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tput_page(rdata->pages[i]);\n\t\t\trdata->pages[i] = NULL;\n\t\t}\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_readdata_alloc",
          "args": [
            "npages",
            "cifs_uncached_readv_complete"
          ],
          "line": 2951
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_readdata_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "2769-2784",
          "snippet": "static struct cifs_readdata *\ncifs_readdata_alloc(unsigned int nr_pages, work_func_t complete)\n{\n\tstruct cifs_readdata *rdata;\n\n\trdata = kzalloc(sizeof(*rdata) + (sizeof(struct page *) * nr_pages),\n\t\t\tGFP_KERNEL);\n\tif (rdata != NULL) {\n\t\tkref_init(&rdata->refcount);\n\t\tINIT_LIST_HEAD(&rdata->list);\n\t\tinit_completion(&rdata->done);\n\t\tINIT_WORK(&rdata->work, complete);\n\t}\n\n\treturn rdata;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic struct cifs_readdata *\ncifs_readdata_alloc(unsigned int nr_pages, work_func_t complete)\n{\n\tstruct cifs_readdata *rdata;\n\n\trdata = kzalloc(sizeof(*rdata) + (sizeof(struct page *) * nr_pages),\n\t\t\tGFP_KERNEL);\n\tif (rdata != NULL) {\n\t\tkref_init(&rdata->refcount);\n\t\tINIT_LIST_HEAD(&rdata->list);\n\t\tinit_completion(&rdata->done);\n\t\tINIT_WORK(&rdata->work, complete);\n\t}\n\n\treturn rdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "cur_len",
            "PAGE_SIZE"
          ],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "constsize_t",
            "len",
            "rsize"
          ],
          "line": 2947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->wait_mtu_credits",
          "args": [
            "server",
            "cifs_sb->rsize",
            "&rsize",
            "&credits"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "open_file->tlink"
          ],
          "line": 2934
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_send_async_read(loff_t offset, size_t len, struct cifsFileInfo *open_file,\n\t\t     struct cifs_sb_info *cifs_sb, struct list_head *rdata_list)\n{\n\tstruct cifs_readdata *rdata;\n\tunsigned int npages, rsize, credits;\n\tsize_t cur_len;\n\tint rc;\n\tpid_t pid;\n\tstruct TCP_Server_Info *server;\n\n\tserver = tlink_tcon(open_file->tlink)->ses->server;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tdo {\n\t\trc = server->ops->wait_mtu_credits(server, cifs_sb->rsize,\n\t\t\t\t\t\t   &rsize, &credits);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tcur_len = min_t(const size_t, len, rsize);\n\t\tnpages = DIV_ROUND_UP(cur_len, PAGE_SIZE);\n\n\t\t/* allocate a readdata struct */\n\t\trdata = cifs_readdata_alloc(npages,\n\t\t\t\t\t    cifs_uncached_readv_complete);\n\t\tif (!rdata) {\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\trc = cifs_read_allocate_pages(rdata, npages);\n\t\tif (rc)\n\t\t\tgoto error;\n\n\t\trdata->cfile = cifsFileInfo_get(open_file);\n\t\trdata->nr_pages = npages;\n\t\trdata->offset = offset;\n\t\trdata->bytes = cur_len;\n\t\trdata->pid = pid;\n\t\trdata->pagesz = PAGE_SIZE;\n\t\trdata->read_into_pages = cifs_uncached_read_into_pages;\n\t\trdata->credits = credits;\n\n\t\tif (!rdata->cfile->invalidHandle ||\n\t\t    !cifs_reopen_file(rdata->cfile, true))\n\t\t\trc = server->ops->async_readv(rdata);\nerror:\n\t\tif (rc) {\n\t\t\tadd_credits_and_wake_if(server, rdata->credits, 0);\n\t\t\tkref_put(&rdata->refcount,\n\t\t\t\t cifs_uncached_readdata_release);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&rdata->list, rdata_list);\n\t\toffset += cur_len;\n\t\tlen -= cur_len;\n\t} while (len > 0);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_uncached_read_into_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2873-2921",
    "snippet": "static int\ncifs_uncached_read_into_pages(struct TCP_Server_Info *server,\n\t\t\tstruct cifs_readdata *rdata, unsigned int len)\n{\n\tint result = 0;\n\tunsigned int i;\n\tunsigned int nr_pages = rdata->nr_pages;\n\tstruct kvec iov;\n\n\trdata->got_bytes = 0;\n\trdata->tailsz = PAGE_SIZE;\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page = rdata->pages[i];\n\n\t\tif (len >= PAGE_SIZE) {\n\t\t\t/* enough data to fill the page */\n\t\t\tiov.iov_base = kmap(page);\n\t\t\tiov.iov_len = PAGE_SIZE;\n\t\t\tcifs_dbg(FYI, \"%u: iov_base=%p iov_len=%zu\\n\",\n\t\t\t\t i, iov.iov_base, iov.iov_len);\n\t\t\tlen -= PAGE_SIZE;\n\t\t} else if (len > 0) {\n\t\t\t/* enough for partial page, fill and zero the rest */\n\t\t\tiov.iov_base = kmap(page);\n\t\t\tiov.iov_len = len;\n\t\t\tcifs_dbg(FYI, \"%u: iov_base=%p iov_len=%zu\\n\",\n\t\t\t\t i, iov.iov_base, iov.iov_len);\n\t\t\tmemset(iov.iov_base + len, '\\0', PAGE_SIZE - len);\n\t\t\trdata->tailsz = len;\n\t\t\tlen = 0;\n\t\t} else {\n\t\t\t/* no need to hold page hostage */\n\t\t\trdata->pages[i] = NULL;\n\t\t\trdata->nr_pages--;\n\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult = cifs_readv_from_socket(server, &iov, 1, iov.iov_len);\n\t\tkunmap(page);\n\t\tif (result < 0)\n\t\t\tbreak;\n\n\t\trdata->got_bytes += result;\n\t}\n\n\treturn rdata->got_bytes > 0 && result != -ECONNABORTED ?\n\t\t\t\t\t\trdata->got_bytes : result;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_readv_from_socket",
          "args": [
            "server",
            "&iov",
            "1",
            "iov.iov_len"
          ],
          "line": 2911
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_readv_from_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "542-599",
          "snippet": "int\ncifs_readv_from_socket(struct TCP_Server_Info *server, struct kvec *iov_orig,\n\t\t       unsigned int nr_segs, unsigned int to_read)\n{\n\tint length = 0;\n\tint total_read;\n\tunsigned int segs;\n\tstruct msghdr smb_msg;\n\tstruct kvec *iov;\n\n\tiov = get_server_iovec(server, nr_segs);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\tsmb_msg.msg_control = NULL;\n\tsmb_msg.msg_controllen = 0;\n\n\tfor (total_read = 0; to_read; total_read += length, to_read -= length) {\n\t\ttry_to_freeze();\n\n\t\tif (server_unresponsive(server)) {\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tsegs = kvec_array_init(iov, iov_orig, nr_segs, total_read);\n\n\t\tlength = kernel_recvmsg(server->ssocket, &smb_msg,\n\t\t\t\t\tiov, segs, to_read, 0);\n\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\ttotal_read = -ESHUTDOWN;\n\t\t\tbreak;\n\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t} else if (length == -ERESTARTSYS ||\n\t\t\t   length == -EAGAIN ||\n\t\t\t   length == -EINTR) {\n\t\t\t/*\n\t\t\t * Minimum sleep to prevent looping, allowing socket\n\t\t\t * to clear and app threads to set tcpStatus\n\t\t\t * CifsNeedReconnect if server hung.\n\t\t\t */\n\t\t\tusleep_range(1000, 2000);\n\t\t\tlength = 0;\n\t\t\tcontinue;\n\t\t} else if (length <= 0) {\n\t\t\tcifs_dbg(FYI, \"Received no data or error: expecting %d\\n\"\n\t\t\t\t \"got %d\", to_read, length);\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn total_read;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_readv_from_socket(struct TCP_Server_Info *server, struct kvec *iov_orig,\n\t\t       unsigned int nr_segs, unsigned int to_read)\n{\n\tint length = 0;\n\tint total_read;\n\tunsigned int segs;\n\tstruct msghdr smb_msg;\n\tstruct kvec *iov;\n\n\tiov = get_server_iovec(server, nr_segs);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\tsmb_msg.msg_control = NULL;\n\tsmb_msg.msg_controllen = 0;\n\n\tfor (total_read = 0; to_read; total_read += length, to_read -= length) {\n\t\ttry_to_freeze();\n\n\t\tif (server_unresponsive(server)) {\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tsegs = kvec_array_init(iov, iov_orig, nr_segs, total_read);\n\n\t\tlength = kernel_recvmsg(server->ssocket, &smb_msg,\n\t\t\t\t\tiov, segs, to_read, 0);\n\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\ttotal_read = -ESHUTDOWN;\n\t\t\tbreak;\n\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t} else if (length == -ERESTARTSYS ||\n\t\t\t   length == -EAGAIN ||\n\t\t\t   length == -EINTR) {\n\t\t\t/*\n\t\t\t * Minimum sleep to prevent looping, allowing socket\n\t\t\t * to clear and app threads to set tcpStatus\n\t\t\t * CifsNeedReconnect if server hung.\n\t\t\t */\n\t\t\tusleep_range(1000, 2000);\n\t\t\tlength = 0;\n\t\t\tcontinue;\n\t\t} else if (length <= 0) {\n\t\t\tcifs_dbg(FYI, \"Received no data or error: expecting %d\\n\"\n\t\t\t\t \"got %d\", to_read, length);\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -ECONNABORTED;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn total_read;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "iov.iov_base + len",
            "'\\0'",
            "PAGE_SIZE - len"
          ],
          "line": 2900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%u: iov_base=%p iov_len=%zu\\n\"",
            "i",
            "iov.iov_base",
            "iov.iov_len"
          ],
          "line": 2898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%u: iov_base=%p iov_len=%zu\\n\"",
            "i",
            "iov.iov_base",
            "iov.iov_len"
          ],
          "line": 2891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_uncached_read_into_pages(struct TCP_Server_Info *server,\n\t\t\tstruct cifs_readdata *rdata, unsigned int len)\n{\n\tint result = 0;\n\tunsigned int i;\n\tunsigned int nr_pages = rdata->nr_pages;\n\tstruct kvec iov;\n\n\trdata->got_bytes = 0;\n\trdata->tailsz = PAGE_SIZE;\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page = rdata->pages[i];\n\n\t\tif (len >= PAGE_SIZE) {\n\t\t\t/* enough data to fill the page */\n\t\t\tiov.iov_base = kmap(page);\n\t\t\tiov.iov_len = PAGE_SIZE;\n\t\t\tcifs_dbg(FYI, \"%u: iov_base=%p iov_len=%zu\\n\",\n\t\t\t\t i, iov.iov_base, iov.iov_len);\n\t\t\tlen -= PAGE_SIZE;\n\t\t} else if (len > 0) {\n\t\t\t/* enough for partial page, fill and zero the rest */\n\t\t\tiov.iov_base = kmap(page);\n\t\t\tiov.iov_len = len;\n\t\t\tcifs_dbg(FYI, \"%u: iov_base=%p iov_len=%zu\\n\",\n\t\t\t\t i, iov.iov_base, iov.iov_len);\n\t\t\tmemset(iov.iov_base + len, '\\0', PAGE_SIZE - len);\n\t\t\trdata->tailsz = len;\n\t\t\tlen = 0;\n\t\t} else {\n\t\t\t/* no need to hold page hostage */\n\t\t\trdata->pages[i] = NULL;\n\t\t\trdata->nr_pages--;\n\t\t\tput_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult = cifs_readv_from_socket(server, &iov, 1, iov.iov_len);\n\t\tkunmap(page);\n\t\tif (result < 0)\n\t\t\tbreak;\n\n\t\trdata->got_bytes += result;\n\t}\n\n\treturn rdata->got_bytes > 0 && result != -ECONNABORTED ?\n\t\t\t\t\t\trdata->got_bytes : result;\n}"
  },
  {
    "function_name": "cifs_uncached_readv_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2863-2871",
    "snippet": "static void\ncifs_uncached_readv_complete(struct work_struct *work)\n{\n\tstruct cifs_readdata *rdata = container_of(work,\n\t\t\t\t\t\tstruct cifs_readdata, work);\n\n\tcomplete(&rdata->done);\n\tkref_put(&rdata->refcount, cifs_uncached_readdata_release);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&rdata->refcount",
            "cifs_uncached_readdata_release"
          ],
          "line": 2870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&rdata->done"
          ],
          "line": 2869
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_readv_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "3286-3317",
          "snippet": "static void\ncifs_readv_complete(struct work_struct *work)\n{\n\tunsigned int i, got_bytes;\n\tstruct cifs_readdata *rdata = container_of(work,\n\t\t\t\t\t\tstruct cifs_readdata, work);\n\n\tgot_bytes = rdata->got_bytes;\n\tfor (i = 0; i < rdata->nr_pages; i++) {\n\t\tstruct page *page = rdata->pages[i];\n\n\t\tlru_cache_add_file(page);\n\n\t\tif (rdata->result == 0 ||\n\t\t    (rdata->result == -EAGAIN && got_bytes)) {\n\t\t\tflush_dcache_page(page);\n\t\t\tSetPageUptodate(page);\n\t\t}\n\n\t\tunlock_page(page);\n\n\t\tif (rdata->result == 0 ||\n\t\t    (rdata->result == -EAGAIN && got_bytes))\n\t\t\tcifs_readpage_to_fscache(rdata->mapping->host, page);\n\n\t\tgot_bytes -= min_t(unsigned int, PAGE_CACHE_SIZE, got_bytes);\n\n\t\tpage_cache_release(page);\n\t\trdata->pages[i] = NULL;\n\t}\n\tkref_put(&rdata->refcount, cifs_readdata_release);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_readv_complete(struct work_struct *work)\n{\n\tunsigned int i, got_bytes;\n\tstruct cifs_readdata *rdata = container_of(work,\n\t\t\t\t\t\tstruct cifs_readdata, work);\n\n\tgot_bytes = rdata->got_bytes;\n\tfor (i = 0; i < rdata->nr_pages; i++) {\n\t\tstruct page *page = rdata->pages[i];\n\n\t\tlru_cache_add_file(page);\n\n\t\tif (rdata->result == 0 ||\n\t\t    (rdata->result == -EAGAIN && got_bytes)) {\n\t\t\tflush_dcache_page(page);\n\t\t\tSetPageUptodate(page);\n\t\t}\n\n\t\tunlock_page(page);\n\n\t\tif (rdata->result == 0 ||\n\t\t    (rdata->result == -EAGAIN && got_bytes))\n\t\t\tcifs_readpage_to_fscache(rdata->mapping->host, page);\n\n\t\tgot_bytes -= min_t(unsigned int, PAGE_CACHE_SIZE, got_bytes);\n\n\t\tpage_cache_release(page);\n\t\trdata->pages[i] = NULL;\n\t}\n\tkref_put(&rdata->refcount, cifs_readdata_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structcifs_readdata",
            "work"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_uncached_readv_complete(struct work_struct *work)\n{\n\tstruct cifs_readdata *rdata = container_of(work,\n\t\t\t\t\t\tstruct cifs_readdata, work);\n\n\tcomplete(&rdata->done);\n\tkref_put(&rdata->refcount, cifs_uncached_readdata_release);\n}"
  },
  {
    "function_name": "cifs_readdata_to_iov",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2846-2861",
    "snippet": "static int\ncifs_readdata_to_iov(struct cifs_readdata *rdata, struct iov_iter *iter)\n{\n\tsize_t remaining = rdata->got_bytes;\n\tunsigned int i;\n\n\tfor (i = 0; i < rdata->nr_pages; i++) {\n\t\tstruct page *page = rdata->pages[i];\n\t\tsize_t copy = min_t(size_t, remaining, PAGE_SIZE);\n\t\tsize_t written = copy_page_to_iter(page, 0, copy, iter);\n\t\tremaining -= written;\n\t\tif (written < copy && iov_iter_count(iter) > 0)\n\t\t\tbreak;\n\t}\n\treturn remaining ? -EFAULT : 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 2857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_page_to_iter",
          "args": [
            "page",
            "0",
            "copy",
            "iter"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "remaining",
            "PAGE_SIZE"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_readdata_to_iov(struct cifs_readdata *rdata, struct iov_iter *iter)\n{\n\tsize_t remaining = rdata->got_bytes;\n\tunsigned int i;\n\n\tfor (i = 0; i < rdata->nr_pages; i++) {\n\t\tstruct page *page = rdata->pages[i];\n\t\tsize_t copy = min_t(size_t, remaining, PAGE_SIZE);\n\t\tsize_t written = copy_page_to_iter(page, 0, copy, iter);\n\t\tremaining -= written;\n\t\tif (written < copy && iov_iter_count(iter) > 0)\n\t\t\tbreak;\n\t}\n\treturn remaining ? -EFAULT : 0;\n}"
  },
  {
    "function_name": "cifs_uncached_readdata_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2823-2835",
    "snippet": "static void\ncifs_uncached_readdata_release(struct kref *refcount)\n{\n\tstruct cifs_readdata *rdata = container_of(refcount,\n\t\t\t\t\tstruct cifs_readdata, refcount);\n\tunsigned int i;\n\n\tfor (i = 0; i < rdata->nr_pages; i++) {\n\t\tput_page(rdata->pages[i]);\n\t\trdata->pages[i] = NULL;\n\t}\n\tcifs_readdata_release(refcount);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_readdata_release",
          "args": [
            "refcount"
          ],
          "line": 2834
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_readdata_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "2786-2796",
          "snippet": "void\ncifs_readdata_release(struct kref *refcount)\n{\n\tstruct cifs_readdata *rdata = container_of(refcount,\n\t\t\t\t\tstruct cifs_readdata, refcount);\n\n\tif (rdata->cfile)\n\t\tcifsFileInfo_put(rdata->cfile);\n\n\tkfree(rdata);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nvoid\ncifs_readdata_release(struct kref *refcount)\n{\n\tstruct cifs_readdata *rdata = container_of(refcount,\n\t\t\t\t\tstruct cifs_readdata, refcount);\n\n\tif (rdata->cfile)\n\t\tcifsFileInfo_put(rdata->cfile);\n\n\tkfree(rdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "rdata->pages[i]"
          ],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "refcount",
            "structcifs_readdata",
            "refcount"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_uncached_readdata_release(struct kref *refcount)\n{\n\tstruct cifs_readdata *rdata = container_of(refcount,\n\t\t\t\t\tstruct cifs_readdata, refcount);\n\tunsigned int i;\n\n\tfor (i = 0; i < rdata->nr_pages; i++) {\n\t\tput_page(rdata->pages[i]);\n\t\trdata->pages[i] = NULL;\n\t}\n\tcifs_readdata_release(refcount);\n}"
  },
  {
    "function_name": "cifs_read_allocate_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2798-2821",
    "snippet": "static int\ncifs_read_allocate_pages(struct cifs_readdata *rdata, unsigned int nr_pages)\n{\n\tint rc = 0;\n\tstruct page *page;\n\tunsigned int i;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpage = alloc_page(GFP_KERNEL|__GFP_HIGHMEM);\n\t\tif (!page) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\trdata->pages[i] = page;\n\t}\n\n\tif (rc) {\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tput_page(rdata->pages[i]);\n\t\t\trdata->pages[i] = NULL;\n\t\t}\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "rdata->pages[i]"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL|__GFP_HIGHMEM"
          ],
          "line": 2806
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_read_allocate_pages(struct cifs_readdata *rdata, unsigned int nr_pages)\n{\n\tint rc = 0;\n\tstruct page *page;\n\tunsigned int i;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpage = alloc_page(GFP_KERNEL|__GFP_HIGHMEM);\n\t\tif (!page) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\trdata->pages[i] = page;\n\t}\n\n\tif (rc) {\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tput_page(rdata->pages[i]);\n\t\t\trdata->pages[i] = NULL;\n\t\t}\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_readdata_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2786-2796",
    "snippet": "void\ncifs_readdata_release(struct kref *refcount)\n{\n\tstruct cifs_readdata *rdata = container_of(refcount,\n\t\t\t\t\tstruct cifs_readdata, refcount);\n\n\tif (rdata->cfile)\n\t\tcifsFileInfo_put(rdata->cfile);\n\n\tkfree(rdata);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rdata"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsFileInfo_put",
          "args": [
            "rdata->cfile"
          ],
          "line": 2793
        },
        "resolved": true,
        "details": {
          "function_name": "cifsFileInfo_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "358-436",
          "snippet": "void cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "refcount",
            "structcifs_readdata",
            "refcount"
          ],
          "line": 2789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nvoid\ncifs_readdata_release(struct kref *refcount)\n{\n\tstruct cifs_readdata *rdata = container_of(refcount,\n\t\t\t\t\tstruct cifs_readdata, refcount);\n\n\tif (rdata->cfile)\n\t\tcifsFileInfo_put(rdata->cfile);\n\n\tkfree(rdata);\n}"
  },
  {
    "function_name": "cifs_readdata_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2769-2784",
    "snippet": "static struct cifs_readdata *\ncifs_readdata_alloc(unsigned int nr_pages, work_func_t complete)\n{\n\tstruct cifs_readdata *rdata;\n\n\trdata = kzalloc(sizeof(*rdata) + (sizeof(struct page *) * nr_pages),\n\t\t\tGFP_KERNEL);\n\tif (rdata != NULL) {\n\t\tkref_init(&rdata->refcount);\n\t\tINIT_LIST_HEAD(&rdata->list);\n\t\tinit_completion(&rdata->done);\n\t\tINIT_WORK(&rdata->work, complete);\n\t}\n\n\treturn rdata;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&rdata->work",
            "complete"
          ],
          "line": 2780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&rdata->done"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rdata->list"
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&rdata->refcount"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*rdata) + (sizeof(struct page *) * nr_pages)",
            "GFP_KERNEL"
          ],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic struct cifs_readdata *\ncifs_readdata_alloc(unsigned int nr_pages, work_func_t complete)\n{\n\tstruct cifs_readdata *rdata;\n\n\trdata = kzalloc(sizeof(*rdata) + (sizeof(struct page *) * nr_pages),\n\t\t\tGFP_KERNEL);\n\tif (rdata != NULL) {\n\t\tkref_init(&rdata->refcount);\n\t\tINIT_LIST_HEAD(&rdata->list);\n\t\tinit_completion(&rdata->done);\n\t\tINIT_WORK(&rdata->work, complete);\n\t}\n\n\treturn rdata;\n}"
  },
  {
    "function_name": "cifs_strict_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2721-2767",
    "snippet": "ssize_t\ncifs_strict_writev(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)\n\t\t\t\t\t\tiocb->ki_filp->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tssize_t written;\n\n\twritten = cifs_get_writer(cinode);\n\tif (written)\n\t\treturn written;\n\n\tif (CIFS_CACHE_WRITE(cinode)) {\n\t\tif (cap_unix(tcon->ses) &&\n\t\t(CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability))\n\t\t  && ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0)) {\n\t\t\twritten = generic_file_write_iter(iocb, from);\n\t\t\tgoto out;\n\t\t}\n\t\twritten = cifs_writev(iocb, from);\n\t\tgoto out;\n\t}\n\t/*\n\t * For non-oplocked files in strict cache mode we need to write the data\n\t * to the server exactly from the pos to pos+len-1 rather than flush all\n\t * affected pages because it may cause a error with mandatory locks on\n\t * these pages but not on the region from pos to ppos+len-1.\n\t */\n\twritten = cifs_user_writev(iocb, from);\n\tif (written > 0 && CIFS_CACHE_READ(cinode)) {\n\t\t/*\n\t\t * Windows 7 server can delay breaking level2 oplock if a write\n\t\t * request comes - break it on the client to prevent reading\n\t\t * an old data.\n\t\t */\n\t\tcifs_zap_mapping(inode);\n\t\tcifs_dbg(FYI, \"Set no oplock for inode=%p after a write operation\\n\",\n\t\t\t inode);\n\t\tcinode->oplock = 0;\n\t}\nout:\n\tcifs_put_writer(cinode);\n\treturn written;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_put_writer",
          "args": [
            "cinode"
          ],
          "line": 2765
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "581-590",
          "snippet": "void cifs_put_writer(struct cifsInodeInfo *cinode)\n{\n\tspin_lock(&cinode->writers_lock);\n\tcinode->writers--;\n\tif (cinode->writers == 0) {\n\t\tclear_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\t\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_WRITERS);\n\t}\n\tspin_unlock(&cinode->writers_lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid cifs_put_writer(struct cifsInodeInfo *cinode)\n{\n\tspin_lock(&cinode->writers_lock);\n\tcinode->writers--;\n\tif (cinode->writers == 0) {\n\t\tclear_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\t\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_WRITERS);\n\t}\n\tspin_unlock(&cinode->writers_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Set no oplock for inode=%p after a write operation\\n\"",
            "inode"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_zap_mapping",
          "args": [
            "inode"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "cinode"
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_user_writev",
          "args": [
            "iocb",
            "from"
          ],
          "line": 2752
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_user_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "2659-2680",
          "snippet": "ssize_t cifs_user_writev(struct kiocb *iocb, struct iov_iter *from)\n{\n\tssize_t written;\n\tstruct inode *inode;\n\tloff_t pos = iocb->ki_pos;\n\n\tinode = file_inode(iocb->ki_filp);\n\n\t/*\n\t * BB - optimize the way when signing is disabled. We can drop this\n\t * extra memory-to-memory copying and use iovec buffers for constructing\n\t * write request.\n\t */\n\n\twritten = cifs_iovec_write(iocb->ki_filp, from, &pos);\n\tif (written > 0) {\n\t\tset_bit(CIFS_INO_INVALID_MAPPING, &CIFS_I(inode)->flags);\n\t\tiocb->ki_pos = pos;\n\t}\n\n\treturn written;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nssize_t cifs_user_writev(struct kiocb *iocb, struct iov_iter *from)\n{\n\tssize_t written;\n\tstruct inode *inode;\n\tloff_t pos = iocb->ki_pos;\n\n\tinode = file_inode(iocb->ki_filp);\n\n\t/*\n\t * BB - optimize the way when signing is disabled. We can drop this\n\t * extra memory-to-memory copying and use iovec buffers for constructing\n\t * write request.\n\t */\n\n\twritten = cifs_iovec_write(iocb->ki_filp, from, &pos);\n\tif (written > 0) {\n\t\tset_bit(CIFS_INO_INVALID_MAPPING, &CIFS_I(inode)->flags);\n\t\tiocb->ki_pos = pos;\n\t}\n\n\treturn written;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_writev",
          "args": [
            "iocb",
            "from"
          ],
          "line": 2743
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "2682-2719",
          "snippet": "static ssize_t\ncifs_writev(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)file->private_data;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;\n\tssize_t rc = -EACCES;\n\tloff_t lock_pos = iocb->ki_pos;\n\n\t/*\n\t * We need to hold the sem to be sure nobody modifies lock list\n\t * with a brlock that prevents writing.\n\t */\n\tdown_read(&cinode->lock_sem);\n\tmutex_lock(&inode->i_mutex);\n\tif (file->f_flags & O_APPEND)\n\t\tlock_pos = i_size_read(inode);\n\tif (!cifs_find_lock_conflict(cfile, lock_pos, iov_iter_count(from),\n\t\t\t\t     server->vals->exclusive_lock_type, NULL,\n\t\t\t\t     CIFS_WRITE_OP)) {\n\t\trc = __generic_file_write_iter(iocb, from);\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tif (rc > 0) {\n\t\t\tssize_t err;\n\n\t\t\terr = generic_write_sync(file, iocb->ki_pos - rc, rc);\n\t\t\tif (err < 0)\n\t\t\t\trc = err;\n\t\t}\n\t} else {\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define CIFS_WRITE_OP\t2"
          ],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\n#define CIFS_WRITE_OP\t2\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic ssize_t\ncifs_writev(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)file->private_data;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;\n\tssize_t rc = -EACCES;\n\tloff_t lock_pos = iocb->ki_pos;\n\n\t/*\n\t * We need to hold the sem to be sure nobody modifies lock list\n\t * with a brlock that prevents writing.\n\t */\n\tdown_read(&cinode->lock_sem);\n\tmutex_lock(&inode->i_mutex);\n\tif (file->f_flags & O_APPEND)\n\t\tlock_pos = i_size_read(inode);\n\tif (!cifs_find_lock_conflict(cfile, lock_pos, iov_iter_count(from),\n\t\t\t\t     server->vals->exclusive_lock_type, NULL,\n\t\t\t\t     CIFS_WRITE_OP)) {\n\t\trc = __generic_file_write_iter(iocb, from);\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tif (rc > 0) {\n\t\t\tssize_t err;\n\n\t\t\terr = generic_write_sync(file, iocb->ki_pos - rc, rc);\n\t\t\tif (err < 0)\n\t\t\t\trc = err;\n\t\t}\n\t} else {\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_file_write_iter",
          "args": [
            "iocb",
            "from"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "tcon->fsUnixInfo.Capability"
          ],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_unix",
          "args": [
            "tcon->ses"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "cap_unix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "804-808",
          "snippet": "static inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_WRITE",
          "args": [
            "cinode"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_writer",
          "args": [
            "cinode"
          ],
          "line": 2732
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "553-579",
          "snippet": "int cifs_get_writer(struct cifsInodeInfo *cinode)\n{\n\tint rc;\n\nstart:\n\trc = wait_on_bit(&cinode->flags, CIFS_INODE_PENDING_OPLOCK_BREAK,\n\t\t\t TASK_KILLABLE);\n\tif (rc)\n\t\treturn rc;\n\n\tspin_lock(&cinode->writers_lock);\n\tif (!cinode->writers)\n\t\tset_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\tcinode->writers++;\n\t/* Check to see if we have started servicing an oplock break */\n\tif (test_bit(CIFS_INODE_PENDING_OPLOCK_BREAK, &cinode->flags)) {\n\t\tcinode->writers--;\n\t\tif (cinode->writers == 0) {\n\t\t\tclear_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\t\t\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_WRITERS);\n\t\t}\n\t\tspin_unlock(&cinode->writers_lock);\n\t\tgoto start;\n\t}\n\tspin_unlock(&cinode->writers_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nint cifs_get_writer(struct cifsInodeInfo *cinode)\n{\n\tint rc;\n\nstart:\n\trc = wait_on_bit(&cinode->flags, CIFS_INODE_PENDING_OPLOCK_BREAK,\n\t\t\t TASK_KILLABLE);\n\tif (rc)\n\t\treturn rc;\n\n\tspin_lock(&cinode->writers_lock);\n\tif (!cinode->writers)\n\t\tset_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\tcinode->writers++;\n\t/* Check to see if we have started servicing an oplock break */\n\tif (test_bit(CIFS_INODE_PENDING_OPLOCK_BREAK, &cinode->flags)) {\n\t\tcinode->writers--;\n\t\tif (cinode->writers == 0) {\n\t\t\tclear_bit(CIFS_INODE_PENDING_WRITERS, &cinode->flags);\n\t\t\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_WRITERS);\n\t\t}\n\t\tspin_unlock(&cinode->writers_lock);\n\t\tgoto start;\n\t}\n\tspin_unlock(&cinode->writers_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 2729
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2726
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 2725
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "iocb->ki_filp"
          ],
          "line": 2724
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nssize_t\ncifs_strict_writev(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)\n\t\t\t\t\t\tiocb->ki_filp->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tssize_t written;\n\n\twritten = cifs_get_writer(cinode);\n\tif (written)\n\t\treturn written;\n\n\tif (CIFS_CACHE_WRITE(cinode)) {\n\t\tif (cap_unix(tcon->ses) &&\n\t\t(CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability))\n\t\t  && ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0)) {\n\t\t\twritten = generic_file_write_iter(iocb, from);\n\t\t\tgoto out;\n\t\t}\n\t\twritten = cifs_writev(iocb, from);\n\t\tgoto out;\n\t}\n\t/*\n\t * For non-oplocked files in strict cache mode we need to write the data\n\t * to the server exactly from the pos to pos+len-1 rather than flush all\n\t * affected pages because it may cause a error with mandatory locks on\n\t * these pages but not on the region from pos to ppos+len-1.\n\t */\n\twritten = cifs_user_writev(iocb, from);\n\tif (written > 0 && CIFS_CACHE_READ(cinode)) {\n\t\t/*\n\t\t * Windows 7 server can delay breaking level2 oplock if a write\n\t\t * request comes - break it on the client to prevent reading\n\t\t * an old data.\n\t\t */\n\t\tcifs_zap_mapping(inode);\n\t\tcifs_dbg(FYI, \"Set no oplock for inode=%p after a write operation\\n\",\n\t\t\t inode);\n\t\tcinode->oplock = 0;\n\t}\nout:\n\tcifs_put_writer(cinode);\n\treturn written;\n}"
  },
  {
    "function_name": "cifs_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2682-2719",
    "snippet": "static ssize_t\ncifs_writev(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)file->private_data;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;\n\tssize_t rc = -EACCES;\n\tloff_t lock_pos = iocb->ki_pos;\n\n\t/*\n\t * We need to hold the sem to be sure nobody modifies lock list\n\t * with a brlock that prevents writing.\n\t */\n\tdown_read(&cinode->lock_sem);\n\tmutex_lock(&inode->i_mutex);\n\tif (file->f_flags & O_APPEND)\n\t\tlock_pos = i_size_read(inode);\n\tif (!cifs_find_lock_conflict(cfile, lock_pos, iov_iter_count(from),\n\t\t\t\t     server->vals->exclusive_lock_type, NULL,\n\t\t\t\t     CIFS_WRITE_OP)) {\n\t\trc = __generic_file_write_iter(iocb, from);\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tif (rc > 0) {\n\t\t\tssize_t err;\n\n\t\t\terr = generic_write_sync(file, iocb->ki_pos - rc, rc);\n\t\t\tif (err < 0)\n\t\t\t\trc = err;\n\t\t}\n\t} else {\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CIFS_WRITE_OP\t2"
    ],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_write_sync",
          "args": [
            "file",
            "iocb->ki_pos - rc",
            "rc"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__generic_file_write_iter",
          "args": [
            "iocb",
            "from"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_find_lock_conflict",
          "args": [
            "cfile",
            "lock_pos",
            "iov_iter_count(from)",
            "server->vals->exclusive_lock_type",
            "NULL",
            "CIFS_WRITE_OP"
          ],
          "line": 2701
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_find_lock_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "870-887",
          "snippet": "bool\ncifs_find_lock_conflict(struct cifsFileInfo *cfile, __u64 offset, __u64 length,\n\t\t\t__u8 type, struct cifsLockInfo **conf_lock,\n\t\t\tint rw_check)\n{\n\tbool rc = false;\n\tstruct cifs_fid_locks *cur;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\n\tlist_for_each_entry(cur, &cinode->llist, llist) {\n\t\trc = cifs_find_fid_lock_conflict(cur, offset, length, type,\n\t\t\t\t\t\t cfile, conf_lock, rw_check);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nbool\ncifs_find_lock_conflict(struct cifsFileInfo *cfile, __u64 offset, __u64 length,\n\t\t\t__u8 type, struct cifsLockInfo **conf_lock,\n\t\t\tint rw_check)\n{\n\tbool rc = false;\n\tstruct cifs_fid_locks *cur;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\n\tlist_for_each_entry(cur, &cinode->llist, llist) {\n\t\trc = cifs_find_fid_lock_conflict(cur, offset, length, type,\n\t\t\t\t\t\t cfile, conf_lock, rw_check);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 2697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 2689
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 2688
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\n#define CIFS_WRITE_OP\t2\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic ssize_t\ncifs_writev(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)file->private_data;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;\n\tssize_t rc = -EACCES;\n\tloff_t lock_pos = iocb->ki_pos;\n\n\t/*\n\t * We need to hold the sem to be sure nobody modifies lock list\n\t * with a brlock that prevents writing.\n\t */\n\tdown_read(&cinode->lock_sem);\n\tmutex_lock(&inode->i_mutex);\n\tif (file->f_flags & O_APPEND)\n\t\tlock_pos = i_size_read(inode);\n\tif (!cifs_find_lock_conflict(cfile, lock_pos, iov_iter_count(from),\n\t\t\t\t     server->vals->exclusive_lock_type, NULL,\n\t\t\t\t     CIFS_WRITE_OP)) {\n\t\trc = __generic_file_write_iter(iocb, from);\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tif (rc > 0) {\n\t\t\tssize_t err;\n\n\t\t\terr = generic_write_sync(file, iocb->ki_pos - rc, rc);\n\t\t\tif (err < 0)\n\t\t\t\trc = err;\n\t\t}\n\t} else {\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_user_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2659-2680",
    "snippet": "ssize_t cifs_user_writev(struct kiocb *iocb, struct iov_iter *from)\n{\n\tssize_t written;\n\tstruct inode *inode;\n\tloff_t pos = iocb->ki_pos;\n\n\tinode = file_inode(iocb->ki_filp);\n\n\t/*\n\t * BB - optimize the way when signing is disabled. We can drop this\n\t * extra memory-to-memory copying and use iovec buffers for constructing\n\t * write request.\n\t */\n\n\twritten = cifs_iovec_write(iocb->ki_filp, from, &pos);\n\tif (written > 0) {\n\t\tset_bit(CIFS_INO_INVALID_MAPPING, &CIFS_I(inode)->flags);\n\t\tiocb->ki_pos = pos;\n\t}\n\n\treturn written;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CIFS_INO_INVALID_MAPPING",
            "&CIFS_I(inode)->flags"
          ],
          "line": 2675
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 2675
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_iovec_write",
          "args": [
            "iocb->ki_filp",
            "from",
            "&pos"
          ],
          "line": 2673
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_iovec_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "2562-2657",
          "snippet": "static ssize_t\ncifs_iovec_write(struct file *file, struct iov_iter *from, loff_t *poffset)\n{\n\tsize_t len;\n\tssize_t total_written = 0;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_writedata *wdata, *tmp;\n\tstruct list_head wdata_list;\n\tstruct iov_iter saved_from;\n\tint rc;\n\n\tlen = iov_iter_count(from);\n\trc = generic_write_checks(file, poffset, &len, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!len)\n\t\treturn 0;\n\n\tiov_iter_truncate(from, len);\n\n\tINIT_LIST_HEAD(&wdata_list);\n\tcifs_sb = CIFS_FILE_SB(file);\n\topen_file = file->private_data;\n\ttcon = tlink_tcon(open_file->tlink);\n\n\tif (!tcon->ses->server->ops->async_writev)\n\t\treturn -ENOSYS;\n\n\tmemcpy(&saved_from, from, sizeof(struct iov_iter));\n\n\trc = cifs_write_from_iter(*poffset, len, from, open_file, cifs_sb,\n\t\t\t\t  &wdata_list);\n\n\t/*\n\t * If at least one write was successfully sent, then discard any rc\n\t * value from the later writes. If the other write succeeds, then\n\t * we'll end up returning whatever was written. If it fails, then\n\t * we'll get a new rc value from that.\n\t */\n\tif (!list_empty(&wdata_list))\n\t\trc = 0;\n\n\t/*\n\t * Wait for and collect replies for any successful sends in order of\n\t * increasing offset. Once an error is hit or we get a fatal signal\n\t * while waiting, then return without waiting for any more replies.\n\t */\nrestart_loop:\n\tlist_for_each_entry_safe(wdata, tmp, &wdata_list, list) {\n\t\tif (!rc) {\n\t\t\t/* FIXME: freezable too? */\n\t\t\trc = wait_for_completion_killable(&wdata->done);\n\t\t\tif (rc)\n\t\t\t\trc = -EINTR;\n\t\t\telse if (wdata->result)\n\t\t\t\trc = wdata->result;\n\t\t\telse\n\t\t\t\ttotal_written += wdata->bytes;\n\n\t\t\t/* resend call if it's a retryable error */\n\t\t\tif (rc == -EAGAIN) {\n\t\t\t\tstruct list_head tmp_list;\n\t\t\t\tstruct iov_iter tmp_from;\n\n\t\t\t\tINIT_LIST_HEAD(&tmp_list);\n\t\t\t\tlist_del_init(&wdata->list);\n\n\t\t\t\tmemcpy(&tmp_from, &saved_from,\n\t\t\t\t       sizeof(struct iov_iter));\n\t\t\t\tiov_iter_advance(&tmp_from,\n\t\t\t\t\t\t wdata->offset - *poffset);\n\n\t\t\t\trc = cifs_write_from_iter(wdata->offset,\n\t\t\t\t\t\twdata->bytes, &tmp_from,\n\t\t\t\t\t\topen_file, cifs_sb, &tmp_list);\n\n\t\t\t\tlist_splice(&tmp_list, &wdata_list);\n\n\t\t\t\tkref_put(&wdata->refcount,\n\t\t\t\t\t cifs_uncached_writedata_release);\n\t\t\t\tgoto restart_loop;\n\t\t\t}\n\t\t}\n\t\tlist_del_init(&wdata->list);\n\t\tkref_put(&wdata->refcount, cifs_uncached_writedata_release);\n\t}\n\n\tif (total_written > 0)\n\t\t*poffset += total_written;\n\n\tcifs_stats_bytes_written(tcon, total_written);\n\treturn total_written ? total_written : (ssize_t)rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic ssize_t\ncifs_iovec_write(struct file *file, struct iov_iter *from, loff_t *poffset)\n{\n\tsize_t len;\n\tssize_t total_written = 0;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_writedata *wdata, *tmp;\n\tstruct list_head wdata_list;\n\tstruct iov_iter saved_from;\n\tint rc;\n\n\tlen = iov_iter_count(from);\n\trc = generic_write_checks(file, poffset, &len, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!len)\n\t\treturn 0;\n\n\tiov_iter_truncate(from, len);\n\n\tINIT_LIST_HEAD(&wdata_list);\n\tcifs_sb = CIFS_FILE_SB(file);\n\topen_file = file->private_data;\n\ttcon = tlink_tcon(open_file->tlink);\n\n\tif (!tcon->ses->server->ops->async_writev)\n\t\treturn -ENOSYS;\n\n\tmemcpy(&saved_from, from, sizeof(struct iov_iter));\n\n\trc = cifs_write_from_iter(*poffset, len, from, open_file, cifs_sb,\n\t\t\t\t  &wdata_list);\n\n\t/*\n\t * If at least one write was successfully sent, then discard any rc\n\t * value from the later writes. If the other write succeeds, then\n\t * we'll end up returning whatever was written. If it fails, then\n\t * we'll get a new rc value from that.\n\t */\n\tif (!list_empty(&wdata_list))\n\t\trc = 0;\n\n\t/*\n\t * Wait for and collect replies for any successful sends in order of\n\t * increasing offset. Once an error is hit or we get a fatal signal\n\t * while waiting, then return without waiting for any more replies.\n\t */\nrestart_loop:\n\tlist_for_each_entry_safe(wdata, tmp, &wdata_list, list) {\n\t\tif (!rc) {\n\t\t\t/* FIXME: freezable too? */\n\t\t\trc = wait_for_completion_killable(&wdata->done);\n\t\t\tif (rc)\n\t\t\t\trc = -EINTR;\n\t\t\telse if (wdata->result)\n\t\t\t\trc = wdata->result;\n\t\t\telse\n\t\t\t\ttotal_written += wdata->bytes;\n\n\t\t\t/* resend call if it's a retryable error */\n\t\t\tif (rc == -EAGAIN) {\n\t\t\t\tstruct list_head tmp_list;\n\t\t\t\tstruct iov_iter tmp_from;\n\n\t\t\t\tINIT_LIST_HEAD(&tmp_list);\n\t\t\t\tlist_del_init(&wdata->list);\n\n\t\t\t\tmemcpy(&tmp_from, &saved_from,\n\t\t\t\t       sizeof(struct iov_iter));\n\t\t\t\tiov_iter_advance(&tmp_from,\n\t\t\t\t\t\t wdata->offset - *poffset);\n\n\t\t\t\trc = cifs_write_from_iter(wdata->offset,\n\t\t\t\t\t\twdata->bytes, &tmp_from,\n\t\t\t\t\t\topen_file, cifs_sb, &tmp_list);\n\n\t\t\t\tlist_splice(&tmp_list, &wdata_list);\n\n\t\t\t\tkref_put(&wdata->refcount,\n\t\t\t\t\t cifs_uncached_writedata_release);\n\t\t\t\tgoto restart_loop;\n\t\t\t}\n\t\t}\n\t\tlist_del_init(&wdata->list);\n\t\tkref_put(&wdata->refcount, cifs_uncached_writedata_release);\n\t}\n\n\tif (total_written > 0)\n\t\t*poffset += total_written;\n\n\tcifs_stats_bytes_written(tcon, total_written);\n\treturn total_written ? total_written : (ssize_t)rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "iocb->ki_filp"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nssize_t cifs_user_writev(struct kiocb *iocb, struct iov_iter *from)\n{\n\tssize_t written;\n\tstruct inode *inode;\n\tloff_t pos = iocb->ki_pos;\n\n\tinode = file_inode(iocb->ki_filp);\n\n\t/*\n\t * BB - optimize the way when signing is disabled. We can drop this\n\t * extra memory-to-memory copying and use iovec buffers for constructing\n\t * write request.\n\t */\n\n\twritten = cifs_iovec_write(iocb->ki_filp, from, &pos);\n\tif (written > 0) {\n\t\tset_bit(CIFS_INO_INVALID_MAPPING, &CIFS_I(inode)->flags);\n\t\tiocb->ki_pos = pos;\n\t}\n\n\treturn written;\n}"
  },
  {
    "function_name": "cifs_iovec_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2562-2657",
    "snippet": "static ssize_t\ncifs_iovec_write(struct file *file, struct iov_iter *from, loff_t *poffset)\n{\n\tsize_t len;\n\tssize_t total_written = 0;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_writedata *wdata, *tmp;\n\tstruct list_head wdata_list;\n\tstruct iov_iter saved_from;\n\tint rc;\n\n\tlen = iov_iter_count(from);\n\trc = generic_write_checks(file, poffset, &len, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!len)\n\t\treturn 0;\n\n\tiov_iter_truncate(from, len);\n\n\tINIT_LIST_HEAD(&wdata_list);\n\tcifs_sb = CIFS_FILE_SB(file);\n\topen_file = file->private_data;\n\ttcon = tlink_tcon(open_file->tlink);\n\n\tif (!tcon->ses->server->ops->async_writev)\n\t\treturn -ENOSYS;\n\n\tmemcpy(&saved_from, from, sizeof(struct iov_iter));\n\n\trc = cifs_write_from_iter(*poffset, len, from, open_file, cifs_sb,\n\t\t\t\t  &wdata_list);\n\n\t/*\n\t * If at least one write was successfully sent, then discard any rc\n\t * value from the later writes. If the other write succeeds, then\n\t * we'll end up returning whatever was written. If it fails, then\n\t * we'll get a new rc value from that.\n\t */\n\tif (!list_empty(&wdata_list))\n\t\trc = 0;\n\n\t/*\n\t * Wait for and collect replies for any successful sends in order of\n\t * increasing offset. Once an error is hit or we get a fatal signal\n\t * while waiting, then return without waiting for any more replies.\n\t */\nrestart_loop:\n\tlist_for_each_entry_safe(wdata, tmp, &wdata_list, list) {\n\t\tif (!rc) {\n\t\t\t/* FIXME: freezable too? */\n\t\t\trc = wait_for_completion_killable(&wdata->done);\n\t\t\tif (rc)\n\t\t\t\trc = -EINTR;\n\t\t\telse if (wdata->result)\n\t\t\t\trc = wdata->result;\n\t\t\telse\n\t\t\t\ttotal_written += wdata->bytes;\n\n\t\t\t/* resend call if it's a retryable error */\n\t\t\tif (rc == -EAGAIN) {\n\t\t\t\tstruct list_head tmp_list;\n\t\t\t\tstruct iov_iter tmp_from;\n\n\t\t\t\tINIT_LIST_HEAD(&tmp_list);\n\t\t\t\tlist_del_init(&wdata->list);\n\n\t\t\t\tmemcpy(&tmp_from, &saved_from,\n\t\t\t\t       sizeof(struct iov_iter));\n\t\t\t\tiov_iter_advance(&tmp_from,\n\t\t\t\t\t\t wdata->offset - *poffset);\n\n\t\t\t\trc = cifs_write_from_iter(wdata->offset,\n\t\t\t\t\t\twdata->bytes, &tmp_from,\n\t\t\t\t\t\topen_file, cifs_sb, &tmp_list);\n\n\t\t\t\tlist_splice(&tmp_list, &wdata_list);\n\n\t\t\t\tkref_put(&wdata->refcount,\n\t\t\t\t\t cifs_uncached_writedata_release);\n\t\t\t\tgoto restart_loop;\n\t\t\t}\n\t\t}\n\t\tlist_del_init(&wdata->list);\n\t\tkref_put(&wdata->refcount, cifs_uncached_writedata_release);\n\t}\n\n\tif (total_written > 0)\n\t\t*poffset += total_written;\n\n\tcifs_stats_bytes_written(tcon, total_written);\n\treturn total_written ? total_written : (ssize_t)rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_stats_bytes_written",
          "args": [
            "tcon",
            "total_written"
          ],
          "line": 2655
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_bytes_written",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1203-1211",
          "snippet": "static inline void cifs_stats_bytes_written(struct cifs_tcon *tcon,\n\t\t\t\t\t    unsigned int bytes)\n{\n\tif (bytes) {\n\t\tspin_lock(&tcon->stat_lock);\n\t\ttcon->bytes_written += bytes;\n\t\tspin_unlock(&tcon->stat_lock);\n\t}\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_stats_bytes_written(struct cifs_tcon *tcon,\n\t\t\t\t\t    unsigned int bytes)\n{\n\tif (bytes) {\n\t\tspin_lock(&tcon->stat_lock);\n\t\ttcon->bytes_written += bytes;\n\t\tspin_unlock(&tcon->stat_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&wdata->refcount",
            "cifs_uncached_writedata_release"
          ],
          "line": 2649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&wdata->list"
          ],
          "line": 2648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&wdata->refcount",
            "cifs_uncached_writedata_release"
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&tmp_list",
            "&wdata_list"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_write_from_iter",
          "args": [
            "wdata->offset",
            "wdata->bytes",
            "&tmp_from",
            "open_file",
            "cifs_sb",
            "&tmp_list"
          ],
          "line": 2637
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_write_from_iter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "2464-2560",
          "snippet": "static int\ncifs_write_from_iter(loff_t offset, size_t len, struct iov_iter *from,\n\t\t     struct cifsFileInfo *open_file,\n\t\t     struct cifs_sb_info *cifs_sb, struct list_head *wdata_list)\n{\n\tint rc = 0;\n\tsize_t cur_len;\n\tunsigned long nr_pages, num_pages, i;\n\tstruct cifs_writedata *wdata;\n\tstruct iov_iter saved_from;\n\tloff_t saved_offset = offset;\n\tpid_t pid;\n\tstruct TCP_Server_Info *server;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tserver = tlink_tcon(open_file->tlink)->ses->server;\n\tmemcpy(&saved_from, from, sizeof(struct iov_iter));\n\n\tdo {\n\t\tunsigned int wsize, credits;\n\n\t\trc = server->ops->wait_mtu_credits(server, cifs_sb->wsize,\n\t\t\t\t\t\t   &wsize, &credits);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tnr_pages = get_numpages(wsize, len, &cur_len);\n\t\twdata = cifs_writedata_alloc(nr_pages,\n\t\t\t\t\t     cifs_uncached_writev_complete);\n\t\tif (!wdata) {\n\t\t\trc = -ENOMEM;\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = cifs_write_allocate_pages(wdata->pages, nr_pages);\n\t\tif (rc) {\n\t\t\tkfree(wdata);\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_pages = nr_pages;\n\t\trc = wdata_fill_from_iovec(wdata, from, &cur_len, &num_pages);\n\t\tif (rc) {\n\t\t\tfor (i = 0; i < nr_pages; i++)\n\t\t\t\tput_page(wdata->pages[i]);\n\t\t\tkfree(wdata);\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Bring nr_pages down to the number of pages we actually used,\n\t\t * and free any pages that we didn't use.\n\t\t */\n\t\tfor ( ; nr_pages > num_pages; nr_pages--)\n\t\t\tput_page(wdata->pages[nr_pages - 1]);\n\n\t\twdata->sync_mode = WB_SYNC_ALL;\n\t\twdata->nr_pages = nr_pages;\n\t\twdata->offset = (__u64)offset;\n\t\twdata->cfile = cifsFileInfo_get(open_file);\n\t\twdata->pid = pid;\n\t\twdata->bytes = cur_len;\n\t\twdata->pagesz = PAGE_SIZE;\n\t\twdata->tailsz = cur_len - ((nr_pages - 1) * PAGE_SIZE);\n\t\twdata->credits = credits;\n\n\t\tif (!wdata->cfile->invalidHandle ||\n\t\t    !cifs_reopen_file(wdata->cfile, false))\n\t\t\trc = server->ops->async_writev(wdata,\n\t\t\t\t\tcifs_uncached_writedata_release);\n\t\tif (rc) {\n\t\t\tadd_credits_and_wake_if(server, wdata->credits, 0);\n\t\t\tkref_put(&wdata->refcount,\n\t\t\t\t cifs_uncached_writedata_release);\n\t\t\tif (rc == -EAGAIN) {\n\t\t\t\tmemcpy(from, &saved_from,\n\t\t\t\t       sizeof(struct iov_iter));\n\t\t\t\tiov_iter_advance(from, offset - saved_offset);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&wdata->list, wdata_list);\n\t\toffset += cur_len;\n\t\tlen -= cur_len;\n\t} while (len > 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_write_from_iter(loff_t offset, size_t len, struct iov_iter *from,\n\t\t     struct cifsFileInfo *open_file,\n\t\t     struct cifs_sb_info *cifs_sb, struct list_head *wdata_list)\n{\n\tint rc = 0;\n\tsize_t cur_len;\n\tunsigned long nr_pages, num_pages, i;\n\tstruct cifs_writedata *wdata;\n\tstruct iov_iter saved_from;\n\tloff_t saved_offset = offset;\n\tpid_t pid;\n\tstruct TCP_Server_Info *server;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tserver = tlink_tcon(open_file->tlink)->ses->server;\n\tmemcpy(&saved_from, from, sizeof(struct iov_iter));\n\n\tdo {\n\t\tunsigned int wsize, credits;\n\n\t\trc = server->ops->wait_mtu_credits(server, cifs_sb->wsize,\n\t\t\t\t\t\t   &wsize, &credits);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tnr_pages = get_numpages(wsize, len, &cur_len);\n\t\twdata = cifs_writedata_alloc(nr_pages,\n\t\t\t\t\t     cifs_uncached_writev_complete);\n\t\tif (!wdata) {\n\t\t\trc = -ENOMEM;\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = cifs_write_allocate_pages(wdata->pages, nr_pages);\n\t\tif (rc) {\n\t\t\tkfree(wdata);\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_pages = nr_pages;\n\t\trc = wdata_fill_from_iovec(wdata, from, &cur_len, &num_pages);\n\t\tif (rc) {\n\t\t\tfor (i = 0; i < nr_pages; i++)\n\t\t\t\tput_page(wdata->pages[i]);\n\t\t\tkfree(wdata);\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Bring nr_pages down to the number of pages we actually used,\n\t\t * and free any pages that we didn't use.\n\t\t */\n\t\tfor ( ; nr_pages > num_pages; nr_pages--)\n\t\t\tput_page(wdata->pages[nr_pages - 1]);\n\n\t\twdata->sync_mode = WB_SYNC_ALL;\n\t\twdata->nr_pages = nr_pages;\n\t\twdata->offset = (__u64)offset;\n\t\twdata->cfile = cifsFileInfo_get(open_file);\n\t\twdata->pid = pid;\n\t\twdata->bytes = cur_len;\n\t\twdata->pagesz = PAGE_SIZE;\n\t\twdata->tailsz = cur_len - ((nr_pages - 1) * PAGE_SIZE);\n\t\twdata->credits = credits;\n\n\t\tif (!wdata->cfile->invalidHandle ||\n\t\t    !cifs_reopen_file(wdata->cfile, false))\n\t\t\trc = server->ops->async_writev(wdata,\n\t\t\t\t\tcifs_uncached_writedata_release);\n\t\tif (rc) {\n\t\t\tadd_credits_and_wake_if(server, wdata->credits, 0);\n\t\t\tkref_put(&wdata->refcount,\n\t\t\t\t cifs_uncached_writedata_release);\n\t\t\tif (rc == -EAGAIN) {\n\t\t\t\tmemcpy(from, &saved_from,\n\t\t\t\t       sizeof(struct iov_iter));\n\t\t\t\tiov_iter_advance(from, offset - saved_offset);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&wdata->list, wdata_list);\n\t\toffset += cur_len;\n\t\tlen -= cur_len;\n\t} while (len > 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_advance",
          "args": [
            "&tmp_from",
            "wdata->offset - *poffset"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tmp_from",
            "&saved_from",
            "sizeof(struct iov_iter)"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&wdata->list"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tmp_list"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion_killable",
          "args": [
            "&wdata->done"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "wdata",
            "tmp",
            "&wdata_list",
            "list"
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wdata_list"
          ],
          "line": 2604
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&saved_from",
            "from",
            "sizeof(struct iov_iter)"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "open_file->tlink"
          ],
          "line": 2588
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_FILE_SB",
          "args": [
            "file"
          ],
          "line": 2586
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_FILE_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1171-1175",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_FILE_SB(struct file *file)\n{\n\treturn CIFS_SB(file_inode(file)->i_sb);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_FILE_SB(struct file *file)\n{\n\treturn CIFS_SB(file_inode(file)->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&wdata_list"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_truncate",
          "args": [
            "from",
            "len"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_write_checks",
          "args": [
            "file",
            "poffset",
            "&len",
            "0"
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic ssize_t\ncifs_iovec_write(struct file *file, struct iov_iter *from, loff_t *poffset)\n{\n\tsize_t len;\n\tssize_t total_written = 0;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_writedata *wdata, *tmp;\n\tstruct list_head wdata_list;\n\tstruct iov_iter saved_from;\n\tint rc;\n\n\tlen = iov_iter_count(from);\n\trc = generic_write_checks(file, poffset, &len, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!len)\n\t\treturn 0;\n\n\tiov_iter_truncate(from, len);\n\n\tINIT_LIST_HEAD(&wdata_list);\n\tcifs_sb = CIFS_FILE_SB(file);\n\topen_file = file->private_data;\n\ttcon = tlink_tcon(open_file->tlink);\n\n\tif (!tcon->ses->server->ops->async_writev)\n\t\treturn -ENOSYS;\n\n\tmemcpy(&saved_from, from, sizeof(struct iov_iter));\n\n\trc = cifs_write_from_iter(*poffset, len, from, open_file, cifs_sb,\n\t\t\t\t  &wdata_list);\n\n\t/*\n\t * If at least one write was successfully sent, then discard any rc\n\t * value from the later writes. If the other write succeeds, then\n\t * we'll end up returning whatever was written. If it fails, then\n\t * we'll get a new rc value from that.\n\t */\n\tif (!list_empty(&wdata_list))\n\t\trc = 0;\n\n\t/*\n\t * Wait for and collect replies for any successful sends in order of\n\t * increasing offset. Once an error is hit or we get a fatal signal\n\t * while waiting, then return without waiting for any more replies.\n\t */\nrestart_loop:\n\tlist_for_each_entry_safe(wdata, tmp, &wdata_list, list) {\n\t\tif (!rc) {\n\t\t\t/* FIXME: freezable too? */\n\t\t\trc = wait_for_completion_killable(&wdata->done);\n\t\t\tif (rc)\n\t\t\t\trc = -EINTR;\n\t\t\telse if (wdata->result)\n\t\t\t\trc = wdata->result;\n\t\t\telse\n\t\t\t\ttotal_written += wdata->bytes;\n\n\t\t\t/* resend call if it's a retryable error */\n\t\t\tif (rc == -EAGAIN) {\n\t\t\t\tstruct list_head tmp_list;\n\t\t\t\tstruct iov_iter tmp_from;\n\n\t\t\t\tINIT_LIST_HEAD(&tmp_list);\n\t\t\t\tlist_del_init(&wdata->list);\n\n\t\t\t\tmemcpy(&tmp_from, &saved_from,\n\t\t\t\t       sizeof(struct iov_iter));\n\t\t\t\tiov_iter_advance(&tmp_from,\n\t\t\t\t\t\t wdata->offset - *poffset);\n\n\t\t\t\trc = cifs_write_from_iter(wdata->offset,\n\t\t\t\t\t\twdata->bytes, &tmp_from,\n\t\t\t\t\t\topen_file, cifs_sb, &tmp_list);\n\n\t\t\t\tlist_splice(&tmp_list, &wdata_list);\n\n\t\t\t\tkref_put(&wdata->refcount,\n\t\t\t\t\t cifs_uncached_writedata_release);\n\t\t\t\tgoto restart_loop;\n\t\t\t}\n\t\t}\n\t\tlist_del_init(&wdata->list);\n\t\tkref_put(&wdata->refcount, cifs_uncached_writedata_release);\n\t}\n\n\tif (total_written > 0)\n\t\t*poffset += total_written;\n\n\tcifs_stats_bytes_written(tcon, total_written);\n\treturn total_written ? total_written : (ssize_t)rc;\n}"
  },
  {
    "function_name": "cifs_write_from_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2464-2560",
    "snippet": "static int\ncifs_write_from_iter(loff_t offset, size_t len, struct iov_iter *from,\n\t\t     struct cifsFileInfo *open_file,\n\t\t     struct cifs_sb_info *cifs_sb, struct list_head *wdata_list)\n{\n\tint rc = 0;\n\tsize_t cur_len;\n\tunsigned long nr_pages, num_pages, i;\n\tstruct cifs_writedata *wdata;\n\tstruct iov_iter saved_from;\n\tloff_t saved_offset = offset;\n\tpid_t pid;\n\tstruct TCP_Server_Info *server;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tserver = tlink_tcon(open_file->tlink)->ses->server;\n\tmemcpy(&saved_from, from, sizeof(struct iov_iter));\n\n\tdo {\n\t\tunsigned int wsize, credits;\n\n\t\trc = server->ops->wait_mtu_credits(server, cifs_sb->wsize,\n\t\t\t\t\t\t   &wsize, &credits);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tnr_pages = get_numpages(wsize, len, &cur_len);\n\t\twdata = cifs_writedata_alloc(nr_pages,\n\t\t\t\t\t     cifs_uncached_writev_complete);\n\t\tif (!wdata) {\n\t\t\trc = -ENOMEM;\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = cifs_write_allocate_pages(wdata->pages, nr_pages);\n\t\tif (rc) {\n\t\t\tkfree(wdata);\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_pages = nr_pages;\n\t\trc = wdata_fill_from_iovec(wdata, from, &cur_len, &num_pages);\n\t\tif (rc) {\n\t\t\tfor (i = 0; i < nr_pages; i++)\n\t\t\t\tput_page(wdata->pages[i]);\n\t\t\tkfree(wdata);\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Bring nr_pages down to the number of pages we actually used,\n\t\t * and free any pages that we didn't use.\n\t\t */\n\t\tfor ( ; nr_pages > num_pages; nr_pages--)\n\t\t\tput_page(wdata->pages[nr_pages - 1]);\n\n\t\twdata->sync_mode = WB_SYNC_ALL;\n\t\twdata->nr_pages = nr_pages;\n\t\twdata->offset = (__u64)offset;\n\t\twdata->cfile = cifsFileInfo_get(open_file);\n\t\twdata->pid = pid;\n\t\twdata->bytes = cur_len;\n\t\twdata->pagesz = PAGE_SIZE;\n\t\twdata->tailsz = cur_len - ((nr_pages - 1) * PAGE_SIZE);\n\t\twdata->credits = credits;\n\n\t\tif (!wdata->cfile->invalidHandle ||\n\t\t    !cifs_reopen_file(wdata->cfile, false))\n\t\t\trc = server->ops->async_writev(wdata,\n\t\t\t\t\tcifs_uncached_writedata_release);\n\t\tif (rc) {\n\t\t\tadd_credits_and_wake_if(server, wdata->credits, 0);\n\t\t\tkref_put(&wdata->refcount,\n\t\t\t\t cifs_uncached_writedata_release);\n\t\t\tif (rc == -EAGAIN) {\n\t\t\t\tmemcpy(from, &saved_from,\n\t\t\t\t       sizeof(struct iov_iter));\n\t\t\t\tiov_iter_advance(from, offset - saved_offset);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&wdata->list, wdata_list);\n\t\toffset += cur_len;\n\t\tlen -= cur_len;\n\t} while (len > 0);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&wdata->list",
            "wdata_list"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_advance",
          "args": [
            "from",
            "offset - saved_offset"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "from",
            "&saved_from",
            "sizeof(struct iov_iter)"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&wdata->refcount",
            "cifs_uncached_writedata_release"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_credits_and_wake_if",
          "args": [
            "server",
            "wdata->credits",
            "0"
          ],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "add_credits_and_wake_if",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "648-656",
          "snippet": "static inline void\nadd_credits_and_wake_if(struct TCP_Server_Info *server, const unsigned int add,\n\t\t\tconst int optype)\n{\n\tif (add) {\n\t\tserver->ops->add_credits(server, add, optype);\n\t\twake_up(&server->request_q);\n\t}\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\nadd_credits_and_wake_if(struct TCP_Server_Info *server, const unsigned int add,\n\t\t\tconst int optype)\n{\n\tif (add) {\n\t\tserver->ops->add_credits(server, add, optype);\n\t\twake_up(&server->request_q);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->async_writev",
          "args": [
            "wdata",
            "cifs_uncached_writedata_release"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_reopen_file",
          "args": [
            "wdata->cfile",
            "false"
          ],
          "line": 2538
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_reopen_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "597-744",
          "snippet": "static int\ncifs_reopen_file(struct cifsFileInfo *cfile, bool can_flush)\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\t__u32 oplock;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsInodeInfo *cinode;\n\tstruct inode *inode;\n\tchar *full_path = NULL;\n\tint desired_access;\n\tint disposition = FILE_OPEN;\n\tint create_options = CREATE_NOT_DIR;\n\tstruct cifs_open_parms oparms;\n\n\txid = get_xid();\n\tmutex_lock(&cfile->fh_mutex);\n\tif (!cfile->invalidHandle) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\trc = 0;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tinode = cfile->dentry->d_inode;\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttcon = tlink_tcon(cfile->tlink);\n\tserver = tcon->ses->server;\n\n\t/*\n\t * Can not grab rename sem here because various ops, including those\n\t * that already have the rename sem can end up causing writepage to get\n\t * called and if the server was down that means we end up here, and we\n\t * can never tell if the caller already has the rename_sem.\n\t */\n\tfull_path = build_path_from_dentry(cfile->dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tcifs_dbg(FYI, \"inode = 0x%p file flags 0x%x for %s\\n\",\n\t\t inode, cfile->f_flags, full_path);\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\t/*\n\t\t * O_CREAT, O_EXCL and O_TRUNC already had their effect on the\n\t\t * original open. Must mask them off for a reopen.\n\t\t */\n\t\tunsigned int oflags = cfile->f_flags &\n\t\t\t\t\t\t~(O_CREAT | O_EXCL | O_TRUNC);\n\n\t\trc = cifs_posix_open(full_path, NULL, inode->i_sb,\n\t\t\t\t     cifs_sb->mnt_file_mode /* ignored */,\n\t\t\t\t     oflags, &oplock, &cfile->fid.netfid, xid);\n\t\tif (rc == 0) {\n\t\t\tcifs_dbg(FYI, \"posix reopen succeeded\\n\");\n\t\t\toparms.reconnect = true;\n\t\t\tgoto reopen_success;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry open the old way on errors, especially\n\t\t * in the reconnect path it is important to retry hard\n\t\t */\n\t}\n\n\tdesired_access = cifs_convert_flags(cfile->f_flags);\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &cfile->fid);\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = &cfile->fid;\n\toparms.reconnect = true;\n\n\t/*\n\t * Can not refresh inode by passing in file_info buf to be returned by\n\t * ops->open and then calling get_inode_info with returned buf since\n\t * file might have write behind data that needs to be flushed and server\n\t * version of file size can be stale. If we knew for sure that inode was\n\t * not dirty locally we could do this.\n\t */\n\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\tif (rc == -ENOENT && oparms.reconnect == false) {\n\t\t/* durable handle timeout is expired - open the file again */\n\t\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\t\t/* indicate that we need to relock the file */\n\t\toparms.reconnect = true;\n\t}\n\n\tif (rc) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tcifs_dbg(FYI, \"cifs_reopen returned 0x%x\\n\", rc);\n\t\tcifs_dbg(FYI, \"oplock: %d\\n\", oplock);\n\t\tgoto reopen_error_exit;\n\t}\n\nreopen_success:\n\tcfile->invalidHandle = false;\n\tmutex_unlock(&cfile->fh_mutex);\n\tcinode = CIFS_I(inode);\n\n\tif (can_flush) {\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\t\tmapping_set_error(inode->i_mapping, rc);\n\n\t\tif (tcon->unix_ext)\n\t\t\trc = cifs_get_inode_info_unix(&inode, full_path,\n\t\t\t\t\t\t      inode->i_sb, xid);\n\t\telse\n\t\t\trc = cifs_get_inode_info(&inode, full_path, NULL,\n\t\t\t\t\t\t inode->i_sb, xid, NULL);\n\t}\n\t/*\n\t * Else we are writing out data to server already and could deadlock if\n\t * we tried to flush data, and since we do not know if we have data that\n\t * would invalidate the current end of file on the server we can not go\n\t * to the server to get the new inode info.\n\t */\n\n\tserver->ops->set_fid(cfile, &cfile->fid, oplock);\n\tif (oparms.reconnect)\n\t\tcifs_relock_file(cfile);\n\nreopen_error_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_reopen_file(struct cifsFileInfo *cfile, bool can_flush)\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\t__u32 oplock;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsInodeInfo *cinode;\n\tstruct inode *inode;\n\tchar *full_path = NULL;\n\tint desired_access;\n\tint disposition = FILE_OPEN;\n\tint create_options = CREATE_NOT_DIR;\n\tstruct cifs_open_parms oparms;\n\n\txid = get_xid();\n\tmutex_lock(&cfile->fh_mutex);\n\tif (!cfile->invalidHandle) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\trc = 0;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tinode = cfile->dentry->d_inode;\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttcon = tlink_tcon(cfile->tlink);\n\tserver = tcon->ses->server;\n\n\t/*\n\t * Can not grab rename sem here because various ops, including those\n\t * that already have the rename sem can end up causing writepage to get\n\t * called and if the server was down that means we end up here, and we\n\t * can never tell if the caller already has the rename_sem.\n\t */\n\tfull_path = build_path_from_dentry(cfile->dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tcifs_dbg(FYI, \"inode = 0x%p file flags 0x%x for %s\\n\",\n\t\t inode, cfile->f_flags, full_path);\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\t/*\n\t\t * O_CREAT, O_EXCL and O_TRUNC already had their effect on the\n\t\t * original open. Must mask them off for a reopen.\n\t\t */\n\t\tunsigned int oflags = cfile->f_flags &\n\t\t\t\t\t\t~(O_CREAT | O_EXCL | O_TRUNC);\n\n\t\trc = cifs_posix_open(full_path, NULL, inode->i_sb,\n\t\t\t\t     cifs_sb->mnt_file_mode /* ignored */,\n\t\t\t\t     oflags, &oplock, &cfile->fid.netfid, xid);\n\t\tif (rc == 0) {\n\t\t\tcifs_dbg(FYI, \"posix reopen succeeded\\n\");\n\t\t\toparms.reconnect = true;\n\t\t\tgoto reopen_success;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry open the old way on errors, especially\n\t\t * in the reconnect path it is important to retry hard\n\t\t */\n\t}\n\n\tdesired_access = cifs_convert_flags(cfile->f_flags);\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &cfile->fid);\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = &cfile->fid;\n\toparms.reconnect = true;\n\n\t/*\n\t * Can not refresh inode by passing in file_info buf to be returned by\n\t * ops->open and then calling get_inode_info with returned buf since\n\t * file might have write behind data that needs to be flushed and server\n\t * version of file size can be stale. If we knew for sure that inode was\n\t * not dirty locally we could do this.\n\t */\n\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\tif (rc == -ENOENT && oparms.reconnect == false) {\n\t\t/* durable handle timeout is expired - open the file again */\n\t\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\t\t/* indicate that we need to relock the file */\n\t\toparms.reconnect = true;\n\t}\n\n\tif (rc) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tcifs_dbg(FYI, \"cifs_reopen returned 0x%x\\n\", rc);\n\t\tcifs_dbg(FYI, \"oplock: %d\\n\", oplock);\n\t\tgoto reopen_error_exit;\n\t}\n\nreopen_success:\n\tcfile->invalidHandle = false;\n\tmutex_unlock(&cfile->fh_mutex);\n\tcinode = CIFS_I(inode);\n\n\tif (can_flush) {\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\t\tmapping_set_error(inode->i_mapping, rc);\n\n\t\tif (tcon->unix_ext)\n\t\t\trc = cifs_get_inode_info_unix(&inode, full_path,\n\t\t\t\t\t\t      inode->i_sb, xid);\n\t\telse\n\t\t\trc = cifs_get_inode_info(&inode, full_path, NULL,\n\t\t\t\t\t\t inode->i_sb, xid, NULL);\n\t}\n\t/*\n\t * Else we are writing out data to server already and could deadlock if\n\t * we tried to flush data, and since we do not know if we have data that\n\t * would invalidate the current end of file on the server we can not go\n\t * to the server to get the new inode info.\n\t */\n\n\tserver->ops->set_fid(cfile, &cfile->fid, oplock);\n\tif (oparms.reconnect)\n\t\tcifs_relock_file(cfile);\n\nreopen_error_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifsFileInfo_get",
          "args": [
            "open_file"
          ],
          "line": 2530
        },
        "resolved": true,
        "details": {
          "function_name": "cifsFileInfo_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "344-351",
          "snippet": "struct cifsFileInfo *\ncifsFileInfo_get(struct cifsFileInfo *cifs_file)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tcifsFileInfo_get_locked(cifs_file);\n\tspin_unlock(&cifs_file_list_lock);\n\treturn cifs_file;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstruct cifsFileInfo *\ncifsFileInfo_get(struct cifsFileInfo *cifs_file)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tcifsFileInfo_get_locked(cifs_file);\n\tspin_unlock(&cifs_file_list_lock);\n\treturn cifs_file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "wdata->pages[nr_pages - 1]"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wdata"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdata_fill_from_iovec",
          "args": [
            "wdata",
            "from",
            "&cur_len",
            "&num_pages"
          ],
          "line": 2511
        },
        "resolved": true,
        "details": {
          "function_name": "wdata_fill_from_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "2422-2462",
          "snippet": "static int\nwdata_fill_from_iovec(struct cifs_writedata *wdata, struct iov_iter *from,\n\t\t      size_t *len, unsigned long *num_pages)\n{\n\tsize_t save_len, copied, bytes, cur_len = *len;\n\tunsigned long i, nr_pages = *num_pages;\n\n\tsave_len = cur_len;\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tbytes = min_t(const size_t, cur_len, PAGE_SIZE);\n\t\tcopied = copy_page_from_iter(wdata->pages[i], 0, bytes, from);\n\t\tcur_len -= copied;\n\t\t/*\n\t\t * If we didn't copy as much as we expected, then that\n\t\t * may mean we trod into an unmapped area. Stop copying\n\t\t * at that point. On the next pass through the big\n\t\t * loop, we'll likely end up getting a zero-length\n\t\t * write and bailing out of it.\n\t\t */\n\t\tif (copied < bytes)\n\t\t\tbreak;\n\t}\n\tcur_len = save_len - cur_len;\n\t*len = cur_len;\n\n\t/*\n\t * If we have no data to send, then that probably means that\n\t * the copy above failed altogether. That's most likely because\n\t * the address in the iovec was bogus. Return -EFAULT and let\n\t * the caller free anything we allocated and bail out.\n\t */\n\tif (!cur_len)\n\t\treturn -EFAULT;\n\n\t/*\n\t * i + 1 now represents the number of pages we actually used in\n\t * the copy phase above.\n\t */\n\t*num_pages = i + 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\nwdata_fill_from_iovec(struct cifs_writedata *wdata, struct iov_iter *from,\n\t\t      size_t *len, unsigned long *num_pages)\n{\n\tsize_t save_len, copied, bytes, cur_len = *len;\n\tunsigned long i, nr_pages = *num_pages;\n\n\tsave_len = cur_len;\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tbytes = min_t(const size_t, cur_len, PAGE_SIZE);\n\t\tcopied = copy_page_from_iter(wdata->pages[i], 0, bytes, from);\n\t\tcur_len -= copied;\n\t\t/*\n\t\t * If we didn't copy as much as we expected, then that\n\t\t * may mean we trod into an unmapped area. Stop copying\n\t\t * at that point. On the next pass through the big\n\t\t * loop, we'll likely end up getting a zero-length\n\t\t * write and bailing out of it.\n\t\t */\n\t\tif (copied < bytes)\n\t\t\tbreak;\n\t}\n\tcur_len = save_len - cur_len;\n\t*len = cur_len;\n\n\t/*\n\t * If we have no data to send, then that probably means that\n\t * the copy above failed altogether. That's most likely because\n\t * the address in the iovec was bogus. Return -EFAULT and let\n\t * the caller free anything we allocated and bail out.\n\t */\n\tif (!cur_len)\n\t\treturn -EFAULT;\n\n\t/*\n\t * i + 1 now represents the number of pages we actually used in\n\t * the copy phase above.\n\t */\n\t*num_pages = i + 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wdata"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_write_allocate_pages",
          "args": [
            "wdata->pages",
            "nr_pages"
          ],
          "line": 2503
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_write_allocate_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "2350-2374",
          "snippet": "static int\ncifs_write_allocate_pages(struct page **pages, unsigned long num_pages)\n{\n\tint rc = 0;\n\tunsigned long i;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL|__GFP_HIGHMEM);\n\t\tif (!pages[i]) {\n\t\t\t/*\n\t\t\t * save number of pages we have already allocated and\n\t\t\t * return with ENOMEM error\n\t\t\t */\n\t\t\tnum_pages = i;\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rc) {\n\t\tfor (i = 0; i < num_pages; i++)\n\t\t\tput_page(pages[i]);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_write_allocate_pages(struct page **pages, unsigned long num_pages)\n{\n\tint rc = 0;\n\tunsigned long i;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL|__GFP_HIGHMEM);\n\t\tif (!pages[i]) {\n\t\t\t/*\n\t\t\t * save number of pages we have already allocated and\n\t\t\t * return with ENOMEM error\n\t\t\t */\n\t\t\tnum_pages = i;\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rc) {\n\t\tfor (i = 0; i < num_pages; i++)\n\t\t\tput_page(pages[i]);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_writedata_alloc",
          "args": [
            "nr_pages",
            "cifs_uncached_writev_complete"
          ],
          "line": 2495
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_writedata_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2010-2025",
          "snippet": "struct cifs_writedata *\ncifs_writedata_alloc(unsigned int nr_pages, work_func_t complete)\n{\n\tstruct cifs_writedata *wdata;\n\n\t/* writedata + number of page pointers */\n\twdata = kzalloc(sizeof(*wdata) +\n\t\t\tsizeof(struct page *) * nr_pages, GFP_NOFS);\n\tif (wdata != NULL) {\n\t\tkref_init(&wdata->refcount);\n\t\tINIT_LIST_HEAD(&wdata->list);\n\t\tinit_completion(&wdata->done);\n\t\tINIT_WORK(&wdata->work, complete);\n\t}\n\treturn wdata;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstruct cifs_writedata *\ncifs_writedata_alloc(unsigned int nr_pages, work_func_t complete)\n{\n\tstruct cifs_writedata *wdata;\n\n\t/* writedata + number of page pointers */\n\twdata = kzalloc(sizeof(*wdata) +\n\t\t\tsizeof(struct page *) * nr_pages, GFP_NOFS);\n\tif (wdata != NULL) {\n\t\tkref_init(&wdata->refcount);\n\t\tINIT_LIST_HEAD(&wdata->list);\n\t\tinit_completion(&wdata->done);\n\t\tINIT_WORK(&wdata->work, complete);\n\t}\n\treturn wdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_numpages",
          "args": [
            "wsize",
            "len",
            "&cur_len"
          ],
          "line": 2494
        },
        "resolved": true,
        "details": {
          "function_name": "get_numpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "2376-2389",
          "snippet": "static inline\nsize_t get_numpages(const size_t wsize, const size_t len, size_t *cur_len)\n{\n\tsize_t num_pages;\n\tsize_t clen;\n\n\tclen = min_t(const size_t, len, wsize);\n\tnum_pages = DIV_ROUND_UP(clen, PAGE_SIZE);\n\n\tif (cur_len)\n\t\t*cur_len = clen;\n\n\treturn num_pages;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic inline\nsize_t get_numpages(const size_t wsize, const size_t len, size_t *cur_len)\n{\n\tsize_t num_pages;\n\tsize_t clen;\n\n\tclen = min_t(const size_t, len, wsize);\n\tnum_pages = DIV_ROUND_UP(clen, PAGE_SIZE);\n\n\tif (cur_len)\n\t\t*cur_len = clen;\n\n\treturn num_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->wait_mtu_credits",
          "args": [
            "server",
            "cifs_sb->wsize",
            "&wsize",
            "&credits"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&saved_from",
            "from",
            "sizeof(struct iov_iter)"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "open_file->tlink"
          ],
          "line": 2483
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_write_from_iter(loff_t offset, size_t len, struct iov_iter *from,\n\t\t     struct cifsFileInfo *open_file,\n\t\t     struct cifs_sb_info *cifs_sb, struct list_head *wdata_list)\n{\n\tint rc = 0;\n\tsize_t cur_len;\n\tunsigned long nr_pages, num_pages, i;\n\tstruct cifs_writedata *wdata;\n\tstruct iov_iter saved_from;\n\tloff_t saved_offset = offset;\n\tpid_t pid;\n\tstruct TCP_Server_Info *server;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = open_file->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tserver = tlink_tcon(open_file->tlink)->ses->server;\n\tmemcpy(&saved_from, from, sizeof(struct iov_iter));\n\n\tdo {\n\t\tunsigned int wsize, credits;\n\n\t\trc = server->ops->wait_mtu_credits(server, cifs_sb->wsize,\n\t\t\t\t\t\t   &wsize, &credits);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tnr_pages = get_numpages(wsize, len, &cur_len);\n\t\twdata = cifs_writedata_alloc(nr_pages,\n\t\t\t\t\t     cifs_uncached_writev_complete);\n\t\tif (!wdata) {\n\t\t\trc = -ENOMEM;\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = cifs_write_allocate_pages(wdata->pages, nr_pages);\n\t\tif (rc) {\n\t\t\tkfree(wdata);\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_pages = nr_pages;\n\t\trc = wdata_fill_from_iovec(wdata, from, &cur_len, &num_pages);\n\t\tif (rc) {\n\t\t\tfor (i = 0; i < nr_pages; i++)\n\t\t\t\tput_page(wdata->pages[i]);\n\t\t\tkfree(wdata);\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Bring nr_pages down to the number of pages we actually used,\n\t\t * and free any pages that we didn't use.\n\t\t */\n\t\tfor ( ; nr_pages > num_pages; nr_pages--)\n\t\t\tput_page(wdata->pages[nr_pages - 1]);\n\n\t\twdata->sync_mode = WB_SYNC_ALL;\n\t\twdata->nr_pages = nr_pages;\n\t\twdata->offset = (__u64)offset;\n\t\twdata->cfile = cifsFileInfo_get(open_file);\n\t\twdata->pid = pid;\n\t\twdata->bytes = cur_len;\n\t\twdata->pagesz = PAGE_SIZE;\n\t\twdata->tailsz = cur_len - ((nr_pages - 1) * PAGE_SIZE);\n\t\twdata->credits = credits;\n\n\t\tif (!wdata->cfile->invalidHandle ||\n\t\t    !cifs_reopen_file(wdata->cfile, false))\n\t\t\trc = server->ops->async_writev(wdata,\n\t\t\t\t\tcifs_uncached_writedata_release);\n\t\tif (rc) {\n\t\t\tadd_credits_and_wake_if(server, wdata->credits, 0);\n\t\t\tkref_put(&wdata->refcount,\n\t\t\t\t cifs_uncached_writedata_release);\n\t\t\tif (rc == -EAGAIN) {\n\t\t\t\tmemcpy(from, &saved_from,\n\t\t\t\t       sizeof(struct iov_iter));\n\t\t\t\tiov_iter_advance(from, offset - saved_offset);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&wdata->list, wdata_list);\n\t\toffset += cur_len;\n\t\tlen -= cur_len;\n\t} while (len > 0);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "wdata_fill_from_iovec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2422-2462",
    "snippet": "static int\nwdata_fill_from_iovec(struct cifs_writedata *wdata, struct iov_iter *from,\n\t\t      size_t *len, unsigned long *num_pages)\n{\n\tsize_t save_len, copied, bytes, cur_len = *len;\n\tunsigned long i, nr_pages = *num_pages;\n\n\tsave_len = cur_len;\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tbytes = min_t(const size_t, cur_len, PAGE_SIZE);\n\t\tcopied = copy_page_from_iter(wdata->pages[i], 0, bytes, from);\n\t\tcur_len -= copied;\n\t\t/*\n\t\t * If we didn't copy as much as we expected, then that\n\t\t * may mean we trod into an unmapped area. Stop copying\n\t\t * at that point. On the next pass through the big\n\t\t * loop, we'll likely end up getting a zero-length\n\t\t * write and bailing out of it.\n\t\t */\n\t\tif (copied < bytes)\n\t\t\tbreak;\n\t}\n\tcur_len = save_len - cur_len;\n\t*len = cur_len;\n\n\t/*\n\t * If we have no data to send, then that probably means that\n\t * the copy above failed altogether. That's most likely because\n\t * the address in the iovec was bogus. Return -EFAULT and let\n\t * the caller free anything we allocated and bail out.\n\t */\n\tif (!cur_len)\n\t\treturn -EFAULT;\n\n\t/*\n\t * i + 1 now represents the number of pages we actually used in\n\t * the copy phase above.\n\t */\n\t*num_pages = i + 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_page_from_iter",
          "args": [
            "wdata->pages[i]",
            "0",
            "bytes",
            "from"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "constsize_t",
            "cur_len",
            "PAGE_SIZE"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\nwdata_fill_from_iovec(struct cifs_writedata *wdata, struct iov_iter *from,\n\t\t      size_t *len, unsigned long *num_pages)\n{\n\tsize_t save_len, copied, bytes, cur_len = *len;\n\tunsigned long i, nr_pages = *num_pages;\n\n\tsave_len = cur_len;\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tbytes = min_t(const size_t, cur_len, PAGE_SIZE);\n\t\tcopied = copy_page_from_iter(wdata->pages[i], 0, bytes, from);\n\t\tcur_len -= copied;\n\t\t/*\n\t\t * If we didn't copy as much as we expected, then that\n\t\t * may mean we trod into an unmapped area. Stop copying\n\t\t * at that point. On the next pass through the big\n\t\t * loop, we'll likely end up getting a zero-length\n\t\t * write and bailing out of it.\n\t\t */\n\t\tif (copied < bytes)\n\t\t\tbreak;\n\t}\n\tcur_len = save_len - cur_len;\n\t*len = cur_len;\n\n\t/*\n\t * If we have no data to send, then that probably means that\n\t * the copy above failed altogether. That's most likely because\n\t * the address in the iovec was bogus. Return -EFAULT and let\n\t * the caller free anything we allocated and bail out.\n\t */\n\tif (!cur_len)\n\t\treturn -EFAULT;\n\n\t/*\n\t * i + 1 now represents the number of pages we actually used in\n\t * the copy phase above.\n\t */\n\t*num_pages = i + 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_uncached_writev_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2403-2420",
    "snippet": "static void\ncifs_uncached_writev_complete(struct work_struct *work)\n{\n\tstruct cifs_writedata *wdata = container_of(work,\n\t\t\t\t\tstruct cifs_writedata, work);\n\tstruct inode *inode = wdata->cfile->dentry->d_inode;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\tcifs_update_eof(cifsi, wdata->offset, wdata->bytes);\n\tif (cifsi->server_eof > inode->i_size)\n\t\ti_size_write(inode, cifsi->server_eof);\n\tspin_unlock(&inode->i_lock);\n\n\tcomplete(&wdata->done);\n\n\tkref_put(&wdata->refcount, cifs_uncached_writedata_release);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&wdata->refcount",
            "cifs_uncached_writedata_release"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&wdata->done"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_readv_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "3286-3317",
          "snippet": "static void\ncifs_readv_complete(struct work_struct *work)\n{\n\tunsigned int i, got_bytes;\n\tstruct cifs_readdata *rdata = container_of(work,\n\t\t\t\t\t\tstruct cifs_readdata, work);\n\n\tgot_bytes = rdata->got_bytes;\n\tfor (i = 0; i < rdata->nr_pages; i++) {\n\t\tstruct page *page = rdata->pages[i];\n\n\t\tlru_cache_add_file(page);\n\n\t\tif (rdata->result == 0 ||\n\t\t    (rdata->result == -EAGAIN && got_bytes)) {\n\t\t\tflush_dcache_page(page);\n\t\t\tSetPageUptodate(page);\n\t\t}\n\n\t\tunlock_page(page);\n\n\t\tif (rdata->result == 0 ||\n\t\t    (rdata->result == -EAGAIN && got_bytes))\n\t\t\tcifs_readpage_to_fscache(rdata->mapping->host, page);\n\n\t\tgot_bytes -= min_t(unsigned int, PAGE_CACHE_SIZE, got_bytes);\n\n\t\tpage_cache_release(page);\n\t\trdata->pages[i] = NULL;\n\t}\n\tkref_put(&rdata->refcount, cifs_readdata_release);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_readv_complete(struct work_struct *work)\n{\n\tunsigned int i, got_bytes;\n\tstruct cifs_readdata *rdata = container_of(work,\n\t\t\t\t\t\tstruct cifs_readdata, work);\n\n\tgot_bytes = rdata->got_bytes;\n\tfor (i = 0; i < rdata->nr_pages; i++) {\n\t\tstruct page *page = rdata->pages[i];\n\n\t\tlru_cache_add_file(page);\n\n\t\tif (rdata->result == 0 ||\n\t\t    (rdata->result == -EAGAIN && got_bytes)) {\n\t\t\tflush_dcache_page(page);\n\t\t\tSetPageUptodate(page);\n\t\t}\n\n\t\tunlock_page(page);\n\n\t\tif (rdata->result == 0 ||\n\t\t    (rdata->result == -EAGAIN && got_bytes))\n\t\t\tcifs_readpage_to_fscache(rdata->mapping->host, page);\n\n\t\tgot_bytes -= min_t(unsigned int, PAGE_CACHE_SIZE, got_bytes);\n\n\t\tpage_cache_release(page);\n\t\trdata->pages[i] = NULL;\n\t}\n\tkref_put(&rdata->refcount, cifs_readdata_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "cifsi->server_eof"
          ],
          "line": 2414
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_update_eof",
          "args": [
            "cifsi",
            "wdata->offset",
            "wdata->bytes"
          ],
          "line": 2412
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_update_eof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1624-1632",
          "snippet": "void\ncifs_update_eof(struct cifsInodeInfo *cifsi, loff_t offset,\n\t\t      unsigned int bytes_written)\n{\n\tloff_t end_of_write = offset + bytes_written;\n\n\tif (end_of_write > cifsi->server_eof)\n\t\tcifsi->server_eof = end_of_write;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid\ncifs_update_eof(struct cifsInodeInfo *cifsi, loff_t offset,\n\t\t      unsigned int bytes_written)\n{\n\tloff_t end_of_write = offset + bytes_written;\n\n\tif (end_of_write > cifsi->server_eof)\n\t\tcifsi->server_eof = end_of_write;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2411
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structcifs_writedata",
            "work"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic void\ncifs_uncached_writev_complete(struct work_struct *work)\n{\n\tstruct cifs_writedata *wdata = container_of(work,\n\t\t\t\t\tstruct cifs_writedata, work);\n\tstruct inode *inode = wdata->cfile->dentry->d_inode;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\tcifs_update_eof(cifsi, wdata->offset, wdata->bytes);\n\tif (cifsi->server_eof > inode->i_size)\n\t\ti_size_write(inode, cifsi->server_eof);\n\tspin_unlock(&inode->i_lock);\n\n\tcomplete(&wdata->done);\n\n\tkref_put(&wdata->refcount, cifs_uncached_writedata_release);\n}"
  },
  {
    "function_name": "cifs_uncached_writedata_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2391-2401",
    "snippet": "static void\ncifs_uncached_writedata_release(struct kref *refcount)\n{\n\tint i;\n\tstruct cifs_writedata *wdata = container_of(refcount,\n\t\t\t\t\tstruct cifs_writedata, refcount);\n\n\tfor (i = 0; i < wdata->nr_pages; i++)\n\t\tput_page(wdata->pages[i]);\n\tcifs_writedata_release(refcount);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_writedata_release",
          "args": [
            "refcount"
          ],
          "line": 2400
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_writedata_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1881-1891",
          "snippet": "void\ncifs_writedata_release(struct kref *refcount)\n{\n\tstruct cifs_writedata *wdata = container_of(refcount,\n\t\t\t\t\tstruct cifs_writedata, refcount);\n\n\tif (wdata->cfile)\n\t\tcifsFileInfo_put(wdata->cfile);\n\n\tkfree(wdata);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nvoid\ncifs_writedata_release(struct kref *refcount)\n{\n\tstruct cifs_writedata *wdata = container_of(refcount,\n\t\t\t\t\tstruct cifs_writedata, refcount);\n\n\tif (wdata->cfile)\n\t\tcifsFileInfo_put(wdata->cfile);\n\n\tkfree(wdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "wdata->pages[i]"
          ],
          "line": 2399
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "refcount",
            "structcifs_writedata",
            "refcount"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_uncached_writedata_release(struct kref *refcount)\n{\n\tint i;\n\tstruct cifs_writedata *wdata = container_of(refcount,\n\t\t\t\t\tstruct cifs_writedata, refcount);\n\n\tfor (i = 0; i < wdata->nr_pages; i++)\n\t\tput_page(wdata->pages[i]);\n\tcifs_writedata_release(refcount);\n}"
  },
  {
    "function_name": "get_numpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2376-2389",
    "snippet": "static inline\nsize_t get_numpages(const size_t wsize, const size_t len, size_t *cur_len)\n{\n\tsize_t num_pages;\n\tsize_t clen;\n\n\tclen = min_t(const size_t, len, wsize);\n\tnum_pages = DIV_ROUND_UP(clen, PAGE_SIZE);\n\n\tif (cur_len)\n\t\t*cur_len = clen;\n\n\treturn num_pages;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "clen",
            "PAGE_SIZE"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "constsize_t",
            "len",
            "wsize"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic inline\nsize_t get_numpages(const size_t wsize, const size_t len, size_t *cur_len)\n{\n\tsize_t num_pages;\n\tsize_t clen;\n\n\tclen = min_t(const size_t, len, wsize);\n\tnum_pages = DIV_ROUND_UP(clen, PAGE_SIZE);\n\n\tif (cur_len)\n\t\t*cur_len = clen;\n\n\treturn num_pages;\n}"
  },
  {
    "function_name": "cifs_write_allocate_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2350-2374",
    "snippet": "static int\ncifs_write_allocate_pages(struct page **pages, unsigned long num_pages)\n{\n\tint rc = 0;\n\tunsigned long i;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL|__GFP_HIGHMEM);\n\t\tif (!pages[i]) {\n\t\t\t/*\n\t\t\t * save number of pages we have already allocated and\n\t\t\t * return with ENOMEM error\n\t\t\t */\n\t\t\tnum_pages = i;\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rc) {\n\t\tfor (i = 0; i < num_pages; i++)\n\t\t\tput_page(pages[i]);\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "pages[i]"
          ],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL|__GFP_HIGHMEM"
          ],
          "line": 2357
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_write_allocate_pages(struct page **pages, unsigned long num_pages)\n{\n\tint rc = 0;\n\tunsigned long i;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL|__GFP_HIGHMEM);\n\t\tif (!pages[i]) {\n\t\t\t/*\n\t\t\t * save number of pages we have already allocated and\n\t\t\t * return with ENOMEM error\n\t\t\t */\n\t\t\tnum_pages = i;\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rc) {\n\t\tfor (i = 0; i < num_pages; i++)\n\t\t\tput_page(pages[i]);\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2337-2348",
    "snippet": "int cifs_flush(struct file *file, fl_owner_t id)\n{\n\tstruct inode *inode = file_inode(file);\n\tint rc = 0;\n\n\tif (file->f_mode & FMODE_WRITE)\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\n\tcifs_dbg(FYI, \"Flush inode %p file %p rc %d\\n\", inode, file, rc);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Flush inode %p file %p rc %d\\n\"",
            "inode",
            "file",
            "rc"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "inode->i_mapping"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2339
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nint cifs_flush(struct file *file, fl_owner_t id)\n{\n\tstruct inode *inode = file_inode(file);\n\tint rc = 0;\n\n\tif (file->f_mode & FMODE_WRITE)\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\n\tcifs_dbg(FYI, \"Flush inode %p file %p rc %d\\n\", inode, file, rc);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2299-2331",
    "snippet": "int cifs_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tunsigned int xid;\n\tint rc = 0;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsFileInfo *smbfile = file->private_data;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct inode *inode = file->f_mapping->host;\n\n\trc = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (rc)\n\t\treturn rc;\n\tmutex_lock(&inode->i_mutex);\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"Sync file - name: %pD datasync: 0x%x\\n\",\n\t\t file, datasync);\n\n\ttcon = tlink_tcon(smbfile->tlink);\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOSSYNC)) {\n\t\tserver = tcon->ses->server;\n\t\tif (server->ops->flush)\n\t\t\trc = server->ops->flush(xid, tcon, &smbfile->fid);\n\t\telse\n\t\t\trc = -ENOSYS;\n\t}\n\n\tfree_xid(xid);\n\tmutex_unlock(&inode->i_mutex);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->flush",
          "args": [
            "xid",
            "tcon",
            "&smbfile->fid"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "smbfile->tlink"
          ],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Sync file - name: %pD datasync: 0x%x\\n\"",
            "file",
            "datasync"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_FILE_SB",
          "args": [
            "file"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_FILE_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1171-1175",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_FILE_SB(struct file *file)\n{\n\treturn CIFS_SB(file_inode(file)->i_sb);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_FILE_SB(struct file *file)\n{\n\treturn CIFS_SB(file_inode(file)->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nint cifs_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tunsigned int xid;\n\tint rc = 0;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsFileInfo *smbfile = file->private_data;\n\tstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\n\tstruct inode *inode = file->f_mapping->host;\n\n\trc = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (rc)\n\t\treturn rc;\n\tmutex_lock(&inode->i_mutex);\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"Sync file - name: %pD datasync: 0x%x\\n\",\n\t\t file, datasync);\n\n\ttcon = tlink_tcon(smbfile->tlink);\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOSSYNC)) {\n\t\tserver = tcon->ses->server;\n\t\tif (server->ops->flush)\n\t\t\trc = server->ops->flush(xid, tcon, &smbfile->fid);\n\t\telse\n\t\t\trc = -ENOSYS;\n\t}\n\n\tfree_xid(xid);\n\tmutex_unlock(&inode->i_mutex);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_strict_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2256-2297",
    "snippet": "int cifs_strict_fsync(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync)\n{\n\tunsigned int xid;\n\tint rc = 0;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsFileInfo *smbfile = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\n\trc = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (rc)\n\t\treturn rc;\n\tmutex_lock(&inode->i_mutex);\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"Sync file - name: %pD datasync: 0x%x\\n\",\n\t\t file, datasync);\n\n\tif (!CIFS_CACHE_READ(CIFS_I(inode))) {\n\t\trc = cifs_zap_mapping(inode);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"rc: %d during invalidate phase\\n\", rc);\n\t\t\trc = 0; /* don't care about it in fsync */\n\t\t}\n\t}\n\n\ttcon = tlink_tcon(smbfile->tlink);\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOSSYNC)) {\n\t\tserver = tcon->ses->server;\n\t\tif (server->ops->flush)\n\t\t\trc = server->ops->flush(xid, tcon, &smbfile->fid);\n\t\telse\n\t\t\trc = -ENOSYS;\n\t}\n\n\tfree_xid(xid);\n\tmutex_unlock(&inode->i_mutex);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->flush",
          "args": [
            "xid",
            "tcon",
            "&smbfile->fid"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "smbfile->tlink"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"rc: %d during invalidate phase\\n\"",
            "rc"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_zap_mapping",
          "args": [
            "inode"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "CIFS_I(inode)"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Sync file - name: %pD datasync: 0x%x\\n\"",
            "file",
            "datasync"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nint cifs_strict_fsync(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync)\n{\n\tunsigned int xid;\n\tint rc = 0;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsFileInfo *smbfile = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\n\trc = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (rc)\n\t\treturn rc;\n\tmutex_lock(&inode->i_mutex);\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"Sync file - name: %pD datasync: 0x%x\\n\",\n\t\t file, datasync);\n\n\tif (!CIFS_CACHE_READ(CIFS_I(inode))) {\n\t\trc = cifs_zap_mapping(inode);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"rc: %d during invalidate phase\\n\", rc);\n\t\t\trc = 0; /* don't care about it in fsync */\n\t\t}\n\t}\n\n\ttcon = tlink_tcon(smbfile->tlink);\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOSSYNC)) {\n\t\tserver = tcon->ses->server;\n\t\tif (server->ops->flush)\n\t\t\trc = server->ops->flush(xid, tcon, &smbfile->fid);\n\t\telse\n\t\t\trc = -ENOSYS;\n\t}\n\n\tfree_xid(xid);\n\tmutex_unlock(&inode->i_mutex);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2195-2254",
    "snippet": "static int cifs_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tint rc;\n\tstruct inode *inode = mapping->host;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(cfile->dentry->d_sb);\n\t__u32 pid;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = cfile->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tcifs_dbg(FYI, \"write_end for page %p from pos %lld with %d bytes\\n\",\n\t\t page, pos, copied);\n\n\tif (PageChecked(page)) {\n\t\tif (copied == len)\n\t\t\tSetPageUptodate(page);\n\t\tClearPageChecked(page);\n\t} else if (!PageUptodate(page) && copied == PAGE_CACHE_SIZE)\n\t\tSetPageUptodate(page);\n\n\tif (!PageUptodate(page)) {\n\t\tchar *page_data;\n\t\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\t/* this is probably better than directly calling\n\t\t   partialpage_write since in this function the file handle is\n\t\t   known which we might as well\tleverage */\n\t\t/* BB check if anything else missing out of ppw\n\t\t   such as updating last write time */\n\t\tpage_data = kmap(page);\n\t\trc = cifs_write(cfile, pid, page_data + offset, copied, &pos);\n\t\t/* if (rc < 0) should we set writebehind rc? */\n\t\tkunmap(page);\n\n\t\tfree_xid(xid);\n\t} else {\n\t\trc = copied;\n\t\tpos += copied;\n\t\tset_page_dirty(page);\n\t}\n\n\tif (rc > 0) {\n\t\tspin_lock(&inode->i_lock);\n\t\tif (pos > inode->i_size)\n\t\t\ti_size_write(inode, pos);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "pos"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_write",
          "args": [
            "cfile",
            "pid",
            "page_data + offset",
            "copied",
            "&pos"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1634-1717",
          "snippet": "static ssize_t\ncifs_write(struct cifsFileInfo *open_file, __u32 pid, const char *write_data,\n\t   size_t write_size, loff_t *offset)\n{\n\tint rc = 0;\n\tunsigned int bytes_written = 0;\n\tunsigned int total_written;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tunsigned int xid;\n\tstruct dentry *dentry = open_file->dentry;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(dentry->d_inode);\n\tstruct cifs_io_parms io_parms;\n\n\tcifs_sb = CIFS_SB(dentry->d_sb);\n\n\tcifs_dbg(FYI, \"write %zd bytes to offset %lld of %pd\\n\",\n\t\t write_size, *offset, dentry);\n\n\ttcon = tlink_tcon(open_file->tlink);\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->sync_write)\n\t\treturn -ENOSYS;\n\n\txid = get_xid();\n\n\tfor (total_written = 0; write_size > total_written;\n\t     total_written += bytes_written) {\n\t\trc = -EAGAIN;\n\t\twhile (rc == -EAGAIN) {\n\t\t\tstruct kvec iov[2];\n\t\t\tunsigned int len;\n\n\t\t\tif (open_file->invalidHandle) {\n\t\t\t\t/* we could deadlock if we called\n\t\t\t\t   filemap_fdatawait from here so tell\n\t\t\t\t   reopen_file not to flush data to\n\t\t\t\t   server now */\n\t\t\t\trc = cifs_reopen_file(open_file, false);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlen = min(server->ops->wp_retry_size(dentry->d_inode),\n\t\t\t\t  (unsigned int)write_size - total_written);\n\t\t\t/* iov[0] is reserved for smb header */\n\t\t\tiov[1].iov_base = (char *)write_data + total_written;\n\t\t\tiov[1].iov_len = len;\n\t\t\tio_parms.pid = pid;\n\t\t\tio_parms.tcon = tcon;\n\t\t\tio_parms.offset = *offset;\n\t\t\tio_parms.length = len;\n\t\t\trc = server->ops->sync_write(xid, &open_file->fid,\n\t\t\t\t\t&io_parms, &bytes_written, iov, 1);\n\t\t}\n\t\tif (rc || (bytes_written == 0)) {\n\t\t\tif (total_written)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\tspin_lock(&dentry->d_inode->i_lock);\n\t\t\tcifs_update_eof(cifsi, *offset, bytes_written);\n\t\t\tspin_unlock(&dentry->d_inode->i_lock);\n\t\t\t*offset += bytes_written;\n\t\t}\n\t}\n\n\tcifs_stats_bytes_written(tcon, total_written);\n\n\tif (total_written > 0) {\n\t\tspin_lock(&dentry->d_inode->i_lock);\n\t\tif (*offset > dentry->d_inode->i_size)\n\t\t\ti_size_write(dentry->d_inode, *offset);\n\t\tspin_unlock(&dentry->d_inode->i_lock);\n\t}\n\tmark_inode_dirty_sync(dentry->d_inode);\n\tfree_xid(xid);\n\treturn total_written;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic ssize_t\ncifs_write(struct cifsFileInfo *open_file, __u32 pid, const char *write_data,\n\t   size_t write_size, loff_t *offset)\n{\n\tint rc = 0;\n\tunsigned int bytes_written = 0;\n\tunsigned int total_written;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tunsigned int xid;\n\tstruct dentry *dentry = open_file->dentry;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(dentry->d_inode);\n\tstruct cifs_io_parms io_parms;\n\n\tcifs_sb = CIFS_SB(dentry->d_sb);\n\n\tcifs_dbg(FYI, \"write %zd bytes to offset %lld of %pd\\n\",\n\t\t write_size, *offset, dentry);\n\n\ttcon = tlink_tcon(open_file->tlink);\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->sync_write)\n\t\treturn -ENOSYS;\n\n\txid = get_xid();\n\n\tfor (total_written = 0; write_size > total_written;\n\t     total_written += bytes_written) {\n\t\trc = -EAGAIN;\n\t\twhile (rc == -EAGAIN) {\n\t\t\tstruct kvec iov[2];\n\t\t\tunsigned int len;\n\n\t\t\tif (open_file->invalidHandle) {\n\t\t\t\t/* we could deadlock if we called\n\t\t\t\t   filemap_fdatawait from here so tell\n\t\t\t\t   reopen_file not to flush data to\n\t\t\t\t   server now */\n\t\t\t\trc = cifs_reopen_file(open_file, false);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlen = min(server->ops->wp_retry_size(dentry->d_inode),\n\t\t\t\t  (unsigned int)write_size - total_written);\n\t\t\t/* iov[0] is reserved for smb header */\n\t\t\tiov[1].iov_base = (char *)write_data + total_written;\n\t\t\tiov[1].iov_len = len;\n\t\t\tio_parms.pid = pid;\n\t\t\tio_parms.tcon = tcon;\n\t\t\tio_parms.offset = *offset;\n\t\t\tio_parms.length = len;\n\t\t\trc = server->ops->sync_write(xid, &open_file->fid,\n\t\t\t\t\t&io_parms, &bytes_written, iov, 1);\n\t\t}\n\t\tif (rc || (bytes_written == 0)) {\n\t\t\tif (total_written)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\tspin_lock(&dentry->d_inode->i_lock);\n\t\t\tcifs_update_eof(cifsi, *offset, bytes_written);\n\t\t\tspin_unlock(&dentry->d_inode->i_lock);\n\t\t\t*offset += bytes_written;\n\t\t}\n\t}\n\n\tcifs_stats_bytes_written(tcon, total_written);\n\n\tif (total_written > 0) {\n\t\tspin_lock(&dentry->d_inode->i_lock);\n\t\tif (*offset > dentry->d_inode->i_size)\n\t\t\ti_size_write(dentry->d_inode, *offset);\n\t\tspin_unlock(&dentry->d_inode->i_lock);\n\t}\n\tmark_inode_dirty_sync(dentry->d_inode);\n\tfree_xid(xid);\n\treturn total_written;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageChecked",
          "args": [
            "page"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageChecked",
          "args": [
            "page"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"write_end for page %p from pos %lld with %d bytes\\n\"",
            "page",
            "pos",
            "copied"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "cfile->dentry->d_sb"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int cifs_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tint rc;\n\tstruct inode *inode = mapping->host;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(cfile->dentry->d_sb);\n\t__u32 pid;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\n\t\tpid = cfile->pid;\n\telse\n\t\tpid = current->tgid;\n\n\tcifs_dbg(FYI, \"write_end for page %p from pos %lld with %d bytes\\n\",\n\t\t page, pos, copied);\n\n\tif (PageChecked(page)) {\n\t\tif (copied == len)\n\t\t\tSetPageUptodate(page);\n\t\tClearPageChecked(page);\n\t} else if (!PageUptodate(page) && copied == PAGE_CACHE_SIZE)\n\t\tSetPageUptodate(page);\n\n\tif (!PageUptodate(page)) {\n\t\tchar *page_data;\n\t\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\t/* this is probably better than directly calling\n\t\t   partialpage_write since in this function the file handle is\n\t\t   known which we might as well\tleverage */\n\t\t/* BB check if anything else missing out of ppw\n\t\t   such as updating last write time */\n\t\tpage_data = kmap(page);\n\t\trc = cifs_write(cfile, pid, page_data + offset, copied, &pos);\n\t\t/* if (rc < 0) should we set writebehind rc? */\n\t\tkunmap(page);\n\n\t\tfree_xid(xid);\n\t} else {\n\t\trc = copied;\n\t\tpos += copied;\n\t\tset_page_dirty(page);\n\t}\n\n\tif (rc > 0) {\n\t\tspin_lock(&inode->i_lock);\n\t\tif (pos > inode->i_size)\n\t\t\ti_size_write(inode, pos);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2188-2193",
    "snippet": "static int cifs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint rc = cifs_writepage_locked(page, wbc);\n\tunlock_page(page);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2191
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_writepage_locked",
          "args": [
            "page",
            "wbc"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_writepage_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "2149-2186",
          "snippet": "static int\ncifs_writepage_locked(struct page *page, struct writeback_control *wbc)\n{\n\tint rc;\n\tunsigned int xid;\n\n\txid = get_xid();\n/* BB add check for wbc flags */\n\tpage_cache_get(page);\n\tif (!PageUptodate(page))\n\t\tcifs_dbg(FYI, \"ppw - page not up to date\\n\");\n\n\t/*\n\t * Set the \"writeback\" flag, and clear \"dirty\" in the radix tree.\n\t *\n\t * A writepage() implementation always needs to do either this,\n\t * or re-dirty the page with \"redirty_page_for_writepage()\" in\n\t * the case of a failure.\n\t *\n\t * Just unlocking the page will cause the radix tree tag-bits\n\t * to fail to update with the state of the page correctly.\n\t */\n\tset_page_writeback(page);\nretry_write:\n\trc = cifs_partialpagewrite(page, 0, PAGE_CACHE_SIZE);\n\tif (rc == -EAGAIN && wbc->sync_mode == WB_SYNC_ALL)\n\t\tgoto retry_write;\n\telse if (rc == -EAGAIN)\n\t\tredirty_page_for_writepage(wbc, page);\n\telse if (rc != 0)\n\t\tSetPageError(page);\n\telse\n\t\tSetPageUptodate(page);\n\tend_page_writeback(page);\n\tpage_cache_release(page);\n\tfree_xid(xid);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_writepage_locked(struct page *page, struct writeback_control *wbc)\n{\n\tint rc;\n\tunsigned int xid;\n\n\txid = get_xid();\n/* BB add check for wbc flags */\n\tpage_cache_get(page);\n\tif (!PageUptodate(page))\n\t\tcifs_dbg(FYI, \"ppw - page not up to date\\n\");\n\n\t/*\n\t * Set the \"writeback\" flag, and clear \"dirty\" in the radix tree.\n\t *\n\t * A writepage() implementation always needs to do either this,\n\t * or re-dirty the page with \"redirty_page_for_writepage()\" in\n\t * the case of a failure.\n\t *\n\t * Just unlocking the page will cause the radix tree tag-bits\n\t * to fail to update with the state of the page correctly.\n\t */\n\tset_page_writeback(page);\nretry_write:\n\trc = cifs_partialpagewrite(page, 0, PAGE_CACHE_SIZE);\n\tif (rc == -EAGAIN && wbc->sync_mode == WB_SYNC_ALL)\n\t\tgoto retry_write;\n\telse if (rc == -EAGAIN)\n\t\tredirty_page_for_writepage(wbc, page);\n\telse if (rc != 0)\n\t\tSetPageError(page);\n\telse\n\t\tSetPageUptodate(page);\n\tend_page_writeback(page);\n\tpage_cache_release(page);\n\tfree_xid(xid);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint rc = cifs_writepage_locked(page, wbc);\n\tunlock_page(page);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_writepage_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2149-2186",
    "snippet": "static int\ncifs_writepage_locked(struct page *page, struct writeback_control *wbc)\n{\n\tint rc;\n\tunsigned int xid;\n\n\txid = get_xid();\n/* BB add check for wbc flags */\n\tpage_cache_get(page);\n\tif (!PageUptodate(page))\n\t\tcifs_dbg(FYI, \"ppw - page not up to date\\n\");\n\n\t/*\n\t * Set the \"writeback\" flag, and clear \"dirty\" in the radix tree.\n\t *\n\t * A writepage() implementation always needs to do either this,\n\t * or re-dirty the page with \"redirty_page_for_writepage()\" in\n\t * the case of a failure.\n\t *\n\t * Just unlocking the page will cause the radix tree tag-bits\n\t * to fail to update with the state of the page correctly.\n\t */\n\tset_page_writeback(page);\nretry_write:\n\trc = cifs_partialpagewrite(page, 0, PAGE_CACHE_SIZE);\n\tif (rc == -EAGAIN && wbc->sync_mode == WB_SYNC_ALL)\n\t\tgoto retry_write;\n\telse if (rc == -EAGAIN)\n\t\tredirty_page_for_writepage(wbc, page);\n\telse if (rc != 0)\n\t\tSetPageError(page);\n\telse\n\t\tSetPageUptodate(page);\n\tend_page_writeback(page);\n\tpage_cache_release(page);\n\tfree_xid(xid);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_partialpagewrite",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 2173
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_partialpagewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1833-1885",
          "snippet": "static int cifs_partialpagewrite(struct page *page, unsigned from, unsigned to)\n{\n\tstruct address_space *mapping = page->mapping;\n\tloff_t offset = (loff_t)page->index << PAGE_CACHE_SHIFT;\n\tchar *write_data;\n\tint rc = -EFAULT;\n\tint bytes_written = 0;\n\tstruct inode *inode;\n\tstruct cifsFileInfo *open_file;\n\n\tif (!mapping || !mapping->host)\n\t\treturn -EFAULT;\n\n\tinode = page->mapping->host;\n\n\toffset += (loff_t)from;\n\twrite_data = kmap(page);\n\twrite_data += from;\n\n\tif ((to > PAGE_CACHE_SIZE) || (from > to)) {\n\t\tkunmap(page);\n\t\treturn -EIO;\n\t}\n\n\t/* racing with truncate? */\n\tif (offset > mapping->host->i_size) {\n\t\tkunmap(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/* check to make sure that we are not extending the file */\n\tif (mapping->host->i_size - offset < (loff_t)to)\n\t\tto = (unsigned)(mapping->host->i_size - offset);\n\n\topen_file = find_writable_file(CIFS_I(mapping->host), false);\n\tif (open_file) {\n\t\tbytes_written = cifs_write(open_file, open_file->pid,\n\t\t\t\t\t   write_data, to - from, &offset);\n\t\tcifsFileInfo_put(open_file);\n\t\t/* Does mm or vfs already set times? */\n\t\tinode->i_atime = inode->i_mtime = current_fs_time(inode->i_sb);\n\t\tif ((bytes_written > 0) && (offset))\n\t\t\trc = 0;\n\t\telse if (bytes_written < 0)\n\t\t\trc = bytes_written;\n\t} else {\n\t\tcifs_dbg(FYI, \"No writeable filehandles for inode\\n\");\n\t\trc = -EIO;\n\t}\n\n\tkunmap(page);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_partialpagewrite(struct page *page, unsigned from, unsigned to)\n{\n\tstruct address_space *mapping = page->mapping;\n\tloff_t offset = (loff_t)page->index << PAGE_CACHE_SHIFT;\n\tchar *write_data;\n\tint rc = -EFAULT;\n\tint bytes_written = 0;\n\tstruct inode *inode;\n\tstruct cifsFileInfo *open_file;\n\n\tif (!mapping || !mapping->host)\n\t\treturn -EFAULT;\n\n\tinode = page->mapping->host;\n\n\toffset += (loff_t)from;\n\twrite_data = kmap(page);\n\twrite_data += from;\n\n\tif ((to > PAGE_CACHE_SIZE) || (from > to)) {\n\t\tkunmap(page);\n\t\treturn -EIO;\n\t}\n\n\t/* racing with truncate? */\n\tif (offset > mapping->host->i_size) {\n\t\tkunmap(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/* check to make sure that we are not extending the file */\n\tif (mapping->host->i_size - offset < (loff_t)to)\n\t\tto = (unsigned)(mapping->host->i_size - offset);\n\n\topen_file = find_writable_file(CIFS_I(mapping->host), false);\n\tif (open_file) {\n\t\tbytes_written = cifs_write(open_file, open_file->pid,\n\t\t\t\t\t   write_data, to - from, &offset);\n\t\tcifsFileInfo_put(open_file);\n\t\t/* Does mm or vfs already set times? */\n\t\tinode->i_atime = inode->i_mtime = current_fs_time(inode->i_sb);\n\t\tif ((bytes_written > 0) && (offset))\n\t\t\trc = 0;\n\t\telse if (bytes_written < 0)\n\t\t\trc = bytes_written;\n\t} else {\n\t\tcifs_dbg(FYI, \"No writeable filehandles for inode\\n\");\n\t\trc = -EIO;\n\t}\n\n\tkunmap(page);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"ppw - page not up to date\\n\""
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "page"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_writepage_locked(struct page *page, struct writeback_control *wbc)\n{\n\tint rc;\n\tunsigned int xid;\n\n\txid = get_xid();\n/* BB add check for wbc flags */\n\tpage_cache_get(page);\n\tif (!PageUptodate(page))\n\t\tcifs_dbg(FYI, \"ppw - page not up to date\\n\");\n\n\t/*\n\t * Set the \"writeback\" flag, and clear \"dirty\" in the radix tree.\n\t *\n\t * A writepage() implementation always needs to do either this,\n\t * or re-dirty the page with \"redirty_page_for_writepage()\" in\n\t * the case of a failure.\n\t *\n\t * Just unlocking the page will cause the radix tree tag-bits\n\t * to fail to update with the state of the page correctly.\n\t */\n\tset_page_writeback(page);\nretry_write:\n\trc = cifs_partialpagewrite(page, 0, PAGE_CACHE_SIZE);\n\tif (rc == -EAGAIN && wbc->sync_mode == WB_SYNC_ALL)\n\t\tgoto retry_write;\n\telse if (rc == -EAGAIN)\n\t\tredirty_page_for_writepage(wbc, page);\n\telse if (rc != 0)\n\t\tSetPageError(page);\n\telse\n\t\tSetPageUptodate(page);\n\tend_page_writeback(page);\n\tpage_cache_release(page);\n\tfree_xid(xid);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2036-2147",
    "snippet": "static int cifs_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(mapping->host->i_sb);\n\tstruct TCP_Server_Info *server;\n\tbool done = false, scanned = false, range_whole = false;\n\tpgoff_t end, index;\n\tstruct cifs_writedata *wdata;\n\tint rc = 0;\n\n\t/*\n\t * If wsize is smaller than the page cache size, default to writing\n\t * one page at a time via cifs_writepage\n\t */\n\tif (cifs_sb->wsize < PAGE_CACHE_SIZE)\n\t\treturn generic_writepages(mapping, wbc);\n\n\tif (wbc->range_cyclic) {\n\t\tindex = mapping->writeback_index; /* Start from prev offset */\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\t\trange_whole = true;\n\t\tscanned = true;\n\t}\n\tserver = cifs_sb_master_tcon(cifs_sb)->ses->server;\nretry:\n\twhile (!done && index <= end) {\n\t\tunsigned int i, nr_pages, found_pages, wsize, credits;\n\t\tpgoff_t next = 0, tofind, saved_index = index;\n\n\t\trc = server->ops->wait_mtu_credits(server, cifs_sb->wsize,\n\t\t\t\t\t\t   &wsize, &credits);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\ttofind = min((wsize / PAGE_CACHE_SIZE) - 1, end - index) + 1;\n\n\t\twdata = wdata_alloc_and_fillpages(tofind, mapping, end, &index,\n\t\t\t\t\t\t  &found_pages);\n\t\tif (!wdata) {\n\t\t\trc = -ENOMEM;\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (found_pages == 0) {\n\t\t\tkref_put(&wdata->refcount, cifs_writedata_release);\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tnr_pages = wdata_prepare_pages(wdata, found_pages, mapping, wbc,\n\t\t\t\t\t       end, &index, &next, &done);\n\n\t\t/* nothing to write? */\n\t\tif (nr_pages == 0) {\n\t\t\tkref_put(&wdata->refcount, cifs_writedata_release);\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\twdata->credits = credits;\n\n\t\trc = wdata_send_pages(wdata, nr_pages, mapping, wbc);\n\n\t\t/* send failure -- clean up the mess */\n\t\tif (rc != 0) {\n\t\t\tadd_credits_and_wake_if(server, wdata->credits, 0);\n\t\t\tfor (i = 0; i < nr_pages; ++i) {\n\t\t\t\tif (rc == -EAGAIN)\n\t\t\t\t\tredirty_page_for_writepage(wbc,\n\t\t\t\t\t\t\t   wdata->pages[i]);\n\t\t\t\telse\n\t\t\t\t\tSetPageError(wdata->pages[i]);\n\t\t\t\tend_page_writeback(wdata->pages[i]);\n\t\t\t\tpage_cache_release(wdata->pages[i]);\n\t\t\t}\n\t\t\tif (rc != -EAGAIN)\n\t\t\t\tmapping_set_error(mapping, rc);\n\t\t}\n\t\tkref_put(&wdata->refcount, cifs_writedata_release);\n\n\t\tif (wbc->sync_mode == WB_SYNC_ALL && rc == -EAGAIN) {\n\t\t\tindex = saved_index;\n\t\t\tcontinue;\n\t\t}\n\n\t\twbc->nr_to_write -= nr_pages;\n\t\tif (wbc->nr_to_write <= 0)\n\t\t\tdone = true;\n\n\t\tindex = next;\n\t}\n\n\tif (!scanned && !done) {\n\t\t/*\n\t\t * We hit the last page and there is more work to be done: wrap\n\t\t * back to the start of the file\n\t\t */\n\t\tscanned = true;\n\t\tindex = 0;\n\t\tgoto retry;\n\t}\n\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\tmapping->writeback_index = index;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&wdata->refcount",
            "cifs_writedata_release"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "mapping",
            "rc"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "wdata->pages[i]"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "wdata->pages[i]"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "wdata->pages[i]"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "wdata->pages[i]"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_credits_and_wake_if",
          "args": [
            "server",
            "wdata->credits",
            "0"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "add_credits_and_wake_if",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "648-656",
          "snippet": "static inline void\nadd_credits_and_wake_if(struct TCP_Server_Info *server, const unsigned int add,\n\t\t\tconst int optype)\n{\n\tif (add) {\n\t\tserver->ops->add_credits(server, add, optype);\n\t\twake_up(&server->request_q);\n\t}\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\nadd_credits_and_wake_if(struct TCP_Server_Info *server, const unsigned int add,\n\t\t\tconst int optype)\n{\n\tif (add) {\n\t\tserver->ops->add_credits(server, add, optype);\n\t\twake_up(&server->request_q);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdata_send_pages",
          "args": [
            "wdata",
            "nr_pages",
            "mapping",
            "wbc"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "wdata_send_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "2001-2034",
          "snippet": "static int\nwdata_send_pages(struct cifs_writedata *wdata, unsigned int nr_pages,\n\t\t struct address_space *mapping, struct writeback_control *wbc)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server;\n\tunsigned int i;\n\n\twdata->sync_mode = wbc->sync_mode;\n\twdata->nr_pages = nr_pages;\n\twdata->offset = page_offset(wdata->pages[0]);\n\twdata->pagesz = PAGE_CACHE_SIZE;\n\twdata->tailsz = min(i_size_read(mapping->host) -\n\t\t\tpage_offset(wdata->pages[nr_pages - 1]),\n\t\t\t(loff_t)PAGE_CACHE_SIZE);\n\twdata->bytes = ((nr_pages - 1) * PAGE_CACHE_SIZE) + wdata->tailsz;\n\n\tif (wdata->cfile != NULL)\n\t\tcifsFileInfo_put(wdata->cfile);\n\twdata->cfile = find_writable_file(CIFS_I(mapping->host), false);\n\tif (!wdata->cfile) {\n\t\tcifs_dbg(VFS, \"No writable handles for inode\\n\");\n\t\trc = -EBADF;\n\t} else {\n\t\twdata->pid = wdata->cfile->pid;\n\t\tserver = tlink_tcon(wdata->cfile->tlink)->ses->server;\n\t\trc = server->ops->async_writev(wdata, cifs_writedata_release);\n\t}\n\n\tfor (i = 0; i < nr_pages; ++i)\n\t\tunlock_page(wdata->pages[i]);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\nwdata_send_pages(struct cifs_writedata *wdata, unsigned int nr_pages,\n\t\t struct address_space *mapping, struct writeback_control *wbc)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server;\n\tunsigned int i;\n\n\twdata->sync_mode = wbc->sync_mode;\n\twdata->nr_pages = nr_pages;\n\twdata->offset = page_offset(wdata->pages[0]);\n\twdata->pagesz = PAGE_CACHE_SIZE;\n\twdata->tailsz = min(i_size_read(mapping->host) -\n\t\t\tpage_offset(wdata->pages[nr_pages - 1]),\n\t\t\t(loff_t)PAGE_CACHE_SIZE);\n\twdata->bytes = ((nr_pages - 1) * PAGE_CACHE_SIZE) + wdata->tailsz;\n\n\tif (wdata->cfile != NULL)\n\t\tcifsFileInfo_put(wdata->cfile);\n\twdata->cfile = find_writable_file(CIFS_I(mapping->host), false);\n\tif (!wdata->cfile) {\n\t\tcifs_dbg(VFS, \"No writable handles for inode\\n\");\n\t\trc = -EBADF;\n\t} else {\n\t\twdata->pid = wdata->cfile->pid;\n\t\tserver = tlink_tcon(wdata->cfile->tlink)->ses->server;\n\t\trc = server->ops->async_writev(wdata, cifs_writedata_release);\n\t}\n\n\tfor (i = 0; i < nr_pages; ++i)\n\t\tunlock_page(wdata->pages[i]);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&wdata->refcount",
            "cifs_writedata_release"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdata_prepare_pages",
          "args": [
            "wdata",
            "found_pages",
            "mapping",
            "wbc",
            "end",
            "&index",
            "&next",
            "&done"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "wdata_prepare_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1921-1999",
          "snippet": "static unsigned int\nwdata_prepare_pages(struct cifs_writedata *wdata, unsigned int found_pages,\n\t\t    struct address_space *mapping,\n\t\t    struct writeback_control *wbc,\n\t\t    pgoff_t end, pgoff_t *index, pgoff_t *next, bool *done)\n{\n\tunsigned int nr_pages = 0, i;\n\tstruct page *page;\n\n\tfor (i = 0; i < found_pages; i++) {\n\t\tpage = wdata->pages[i];\n\t\t/*\n\t\t * At this point we hold neither mapping->tree_lock nor\n\t\t * lock on the page itself: the page may be truncated or\n\t\t * invalidated (changing page->mapping to NULL), or even\n\t\t * swizzled back from swapper_space to tmpfs file\n\t\t * mapping\n\t\t */\n\n\t\tif (nr_pages == 0)\n\t\t\tlock_page(page);\n\t\telse if (!trylock_page(page))\n\t\t\tbreak;\n\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!wbc->range_cyclic && page->index > end) {\n\t\t\t*done = true;\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*next && (page->index != *next)) {\n\t\t\t/* Not next consecutive page */\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\t\twait_on_page_writeback(page);\n\n\t\tif (PageWriteback(page) ||\n\t\t\t\t!clear_page_dirty_for_io(page)) {\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * This actually clears the dirty bit in the radix tree.\n\t\t * See cifs_writepage() for more commentary.\n\t\t */\n\t\tset_page_writeback(page);\n\t\tif (page_offset(page) >= i_size_read(mapping->host)) {\n\t\t\t*done = true;\n\t\t\tunlock_page(page);\n\t\t\tend_page_writeback(page);\n\t\t\tbreak;\n\t\t}\n\n\t\twdata->pages[i] = page;\n\t\t*next = page->index + 1;\n\t\t++nr_pages;\n\t}\n\n\t/* reset index to refind any pages skipped */\n\tif (nr_pages == 0)\n\t\t*index = wdata->pages[0]->index + 1;\n\n\t/* put any pages we aren't going to use */\n\tfor (i = nr_pages; i < found_pages; i++) {\n\t\tpage_cache_release(wdata->pages[i]);\n\t\twdata->pages[i] = NULL;\n\t}\n\n\treturn nr_pages;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic unsigned int\nwdata_prepare_pages(struct cifs_writedata *wdata, unsigned int found_pages,\n\t\t    struct address_space *mapping,\n\t\t    struct writeback_control *wbc,\n\t\t    pgoff_t end, pgoff_t *index, pgoff_t *next, bool *done)\n{\n\tunsigned int nr_pages = 0, i;\n\tstruct page *page;\n\n\tfor (i = 0; i < found_pages; i++) {\n\t\tpage = wdata->pages[i];\n\t\t/*\n\t\t * At this point we hold neither mapping->tree_lock nor\n\t\t * lock on the page itself: the page may be truncated or\n\t\t * invalidated (changing page->mapping to NULL), or even\n\t\t * swizzled back from swapper_space to tmpfs file\n\t\t * mapping\n\t\t */\n\n\t\tif (nr_pages == 0)\n\t\t\tlock_page(page);\n\t\telse if (!trylock_page(page))\n\t\t\tbreak;\n\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!wbc->range_cyclic && page->index > end) {\n\t\t\t*done = true;\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*next && (page->index != *next)) {\n\t\t\t/* Not next consecutive page */\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\t\twait_on_page_writeback(page);\n\n\t\tif (PageWriteback(page) ||\n\t\t\t\t!clear_page_dirty_for_io(page)) {\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * This actually clears the dirty bit in the radix tree.\n\t\t * See cifs_writepage() for more commentary.\n\t\t */\n\t\tset_page_writeback(page);\n\t\tif (page_offset(page) >= i_size_read(mapping->host)) {\n\t\t\t*done = true;\n\t\t\tunlock_page(page);\n\t\t\tend_page_writeback(page);\n\t\t\tbreak;\n\t\t}\n\n\t\twdata->pages[i] = page;\n\t\t*next = page->index + 1;\n\t\t++nr_pages;\n\t}\n\n\t/* reset index to refind any pages skipped */\n\tif (nr_pages == 0)\n\t\t*index = wdata->pages[0]->index + 1;\n\n\t/* put any pages we aren't going to use */\n\tfor (i = nr_pages; i < found_pages; i++) {\n\t\tpage_cache_release(wdata->pages[i]);\n\t\twdata->pages[i] = NULL;\n\t}\n\n\treturn nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&wdata->refcount",
            "cifs_writedata_release"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdata_alloc_and_fillpages",
          "args": [
            "tofind",
            "mapping",
            "end",
            "&index",
            "&found_pages"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "wdata_alloc_and_fillpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1887-1919",
          "snippet": "static struct cifs_writedata *\nwdata_alloc_and_fillpages(pgoff_t tofind, struct address_space *mapping,\n\t\t\t  pgoff_t end, pgoff_t *index,\n\t\t\t  unsigned int *found_pages)\n{\n\tunsigned int nr_pages;\n\tstruct page **pages;\n\tstruct cifs_writedata *wdata;\n\n\twdata = cifs_writedata_alloc((unsigned int)tofind,\n\t\t\t\t     cifs_writev_complete);\n\tif (!wdata)\n\t\treturn NULL;\n\n\t/*\n\t * find_get_pages_tag seems to return a max of 256 on each\n\t * iteration, so we must call it several times in order to\n\t * fill the array or the wsize is effectively limited to\n\t * 256 * PAGE_CACHE_SIZE.\n\t */\n\t*found_pages = 0;\n\tpages = wdata->pages;\n\tdo {\n\t\tnr_pages = find_get_pages_tag(mapping, index,\n\t\t\t\t\t      PAGECACHE_TAG_DIRTY, tofind,\n\t\t\t\t\t      pages);\n\t\t*found_pages += nr_pages;\n\t\ttofind -= nr_pages;\n\t\tpages += nr_pages;\n\t} while (nr_pages && tofind && *index <= end);\n\n\treturn wdata;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic struct cifs_writedata *\nwdata_alloc_and_fillpages(pgoff_t tofind, struct address_space *mapping,\n\t\t\t  pgoff_t end, pgoff_t *index,\n\t\t\t  unsigned int *found_pages)\n{\n\tunsigned int nr_pages;\n\tstruct page **pages;\n\tstruct cifs_writedata *wdata;\n\n\twdata = cifs_writedata_alloc((unsigned int)tofind,\n\t\t\t\t     cifs_writev_complete);\n\tif (!wdata)\n\t\treturn NULL;\n\n\t/*\n\t * find_get_pages_tag seems to return a max of 256 on each\n\t * iteration, so we must call it several times in order to\n\t * fill the array or the wsize is effectively limited to\n\t * 256 * PAGE_CACHE_SIZE.\n\t */\n\t*found_pages = 0;\n\tpages = wdata->pages;\n\tdo {\n\t\tnr_pages = find_get_pages_tag(mapping, index,\n\t\t\t\t\t      PAGECACHE_TAG_DIRTY, tofind,\n\t\t\t\t\t      pages);\n\t\t*found_pages += nr_pages;\n\t\ttofind -= nr_pages;\n\t\tpages += nr_pages;\n\t} while (nr_pages && tofind && *index <= end);\n\n\treturn wdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(wsize / PAGE_CACHE_SIZE) - 1",
            "end - index"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "minix_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/file.c",
          "lines": "26-48",
          "snippet": "static int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->wait_mtu_credits",
          "args": [
            "server",
            "cifs_sb->wsize",
            "&wsize",
            "&credits"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_master_tcon",
          "args": [
            "cifs_sb"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_master_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3948-3952",
          "snippet": "struct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_writepages",
          "args": [
            "mapping",
            "wbc"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "mapping->host->i_sb"
          ],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(mapping->host->i_sb);\n\tstruct TCP_Server_Info *server;\n\tbool done = false, scanned = false, range_whole = false;\n\tpgoff_t end, index;\n\tstruct cifs_writedata *wdata;\n\tint rc = 0;\n\n\t/*\n\t * If wsize is smaller than the page cache size, default to writing\n\t * one page at a time via cifs_writepage\n\t */\n\tif (cifs_sb->wsize < PAGE_CACHE_SIZE)\n\t\treturn generic_writepages(mapping, wbc);\n\n\tif (wbc->range_cyclic) {\n\t\tindex = mapping->writeback_index; /* Start from prev offset */\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\t\trange_whole = true;\n\t\tscanned = true;\n\t}\n\tserver = cifs_sb_master_tcon(cifs_sb)->ses->server;\nretry:\n\twhile (!done && index <= end) {\n\t\tunsigned int i, nr_pages, found_pages, wsize, credits;\n\t\tpgoff_t next = 0, tofind, saved_index = index;\n\n\t\trc = server->ops->wait_mtu_credits(server, cifs_sb->wsize,\n\t\t\t\t\t\t   &wsize, &credits);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\ttofind = min((wsize / PAGE_CACHE_SIZE) - 1, end - index) + 1;\n\n\t\twdata = wdata_alloc_and_fillpages(tofind, mapping, end, &index,\n\t\t\t\t\t\t  &found_pages);\n\t\tif (!wdata) {\n\t\t\trc = -ENOMEM;\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (found_pages == 0) {\n\t\t\tkref_put(&wdata->refcount, cifs_writedata_release);\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tnr_pages = wdata_prepare_pages(wdata, found_pages, mapping, wbc,\n\t\t\t\t\t       end, &index, &next, &done);\n\n\t\t/* nothing to write? */\n\t\tif (nr_pages == 0) {\n\t\t\tkref_put(&wdata->refcount, cifs_writedata_release);\n\t\t\tadd_credits_and_wake_if(server, credits, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\twdata->credits = credits;\n\n\t\trc = wdata_send_pages(wdata, nr_pages, mapping, wbc);\n\n\t\t/* send failure -- clean up the mess */\n\t\tif (rc != 0) {\n\t\t\tadd_credits_and_wake_if(server, wdata->credits, 0);\n\t\t\tfor (i = 0; i < nr_pages; ++i) {\n\t\t\t\tif (rc == -EAGAIN)\n\t\t\t\t\tredirty_page_for_writepage(wbc,\n\t\t\t\t\t\t\t   wdata->pages[i]);\n\t\t\t\telse\n\t\t\t\t\tSetPageError(wdata->pages[i]);\n\t\t\t\tend_page_writeback(wdata->pages[i]);\n\t\t\t\tpage_cache_release(wdata->pages[i]);\n\t\t\t}\n\t\t\tif (rc != -EAGAIN)\n\t\t\t\tmapping_set_error(mapping, rc);\n\t\t}\n\t\tkref_put(&wdata->refcount, cifs_writedata_release);\n\n\t\tif (wbc->sync_mode == WB_SYNC_ALL && rc == -EAGAIN) {\n\t\t\tindex = saved_index;\n\t\t\tcontinue;\n\t\t}\n\n\t\twbc->nr_to_write -= nr_pages;\n\t\tif (wbc->nr_to_write <= 0)\n\t\t\tdone = true;\n\n\t\tindex = next;\n\t}\n\n\tif (!scanned && !done) {\n\t\t/*\n\t\t * We hit the last page and there is more work to be done: wrap\n\t\t * back to the start of the file\n\t\t */\n\t\tscanned = true;\n\t\tindex = 0;\n\t\tgoto retry;\n\t}\n\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\tmapping->writeback_index = index;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "wdata_send_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "2001-2034",
    "snippet": "static int\nwdata_send_pages(struct cifs_writedata *wdata, unsigned int nr_pages,\n\t\t struct address_space *mapping, struct writeback_control *wbc)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server;\n\tunsigned int i;\n\n\twdata->sync_mode = wbc->sync_mode;\n\twdata->nr_pages = nr_pages;\n\twdata->offset = page_offset(wdata->pages[0]);\n\twdata->pagesz = PAGE_CACHE_SIZE;\n\twdata->tailsz = min(i_size_read(mapping->host) -\n\t\t\tpage_offset(wdata->pages[nr_pages - 1]),\n\t\t\t(loff_t)PAGE_CACHE_SIZE);\n\twdata->bytes = ((nr_pages - 1) * PAGE_CACHE_SIZE) + wdata->tailsz;\n\n\tif (wdata->cfile != NULL)\n\t\tcifsFileInfo_put(wdata->cfile);\n\twdata->cfile = find_writable_file(CIFS_I(mapping->host), false);\n\tif (!wdata->cfile) {\n\t\tcifs_dbg(VFS, \"No writable handles for inode\\n\");\n\t\trc = -EBADF;\n\t} else {\n\t\twdata->pid = wdata->cfile->pid;\n\t\tserver = tlink_tcon(wdata->cfile->tlink)->ses->server;\n\t\trc = server->ops->async_writev(wdata, cifs_writedata_release);\n\t}\n\n\tfor (i = 0; i < nr_pages; ++i)\n\t\tunlock_page(wdata->pages[i]);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "wdata->pages[i]"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->async_writev",
          "args": [
            "wdata",
            "cifs_writedata_release"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "wdata->cfile->tlink"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"No writable handles for inode\\n\""
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_writable_file",
          "args": [
            "CIFS_I(mapping->host)",
            "false"
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "find_writable_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1753-1831",
          "snippet": "struct cifsFileInfo *find_writable_file(struct cifsInodeInfo *cifs_inode,\n\t\t\t\t\tbool fsuid_only)\n{\n\tstruct cifsFileInfo *open_file, *inv_file = NULL;\n\tstruct cifs_sb_info *cifs_sb;\n\tbool any_available = false;\n\tint rc;\n\tunsigned int refind = 0;\n\n\t/* Having a null inode here (because mapping->host was set to zero by\n\tthe VFS or MM) should not happen but we had reports of on oops (due to\n\tit being zero) during stress testcases so we need to check for it */\n\n\tif (cifs_inode == NULL) {\n\t\tcifs_dbg(VFS, \"Null inode passed to cifs_writeable_file\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tcifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);\n\n\t/* only filter by fsuid on multiuser mounts */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\tfsuid_only = false;\n\n\tspin_lock(&cifs_file_list_lock);\nrefind_writable:\n\tif (refind > MAX_REOPEN_ATT) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn NULL;\n\t}\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (!any_available && open_file->pid != current->tgid)\n\t\t\tcontinue;\n\t\tif (fsuid_only && !uid_eq(open_file->uid, current_fsuid()))\n\t\t\tcontinue;\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_WRITE) {\n\t\t\tif (!open_file->invalidHandle) {\n\t\t\t\t/* found a good writable file */\n\t\t\t\tcifsFileInfo_get_locked(open_file);\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\treturn open_file;\n\t\t\t} else {\n\t\t\t\tif (!inv_file)\n\t\t\t\t\tinv_file = open_file;\n\t\t\t}\n\t\t}\n\t}\n\t/* couldn't find useable FH with same pid, try any available */\n\tif (!any_available) {\n\t\tany_available = true;\n\t\tgoto refind_writable;\n\t}\n\n\tif (inv_file) {\n\t\tany_available = false;\n\t\tcifsFileInfo_get_locked(inv_file);\n\t}\n\n\tspin_unlock(&cifs_file_list_lock);\n\n\tif (inv_file) {\n\t\trc = cifs_reopen_file(inv_file, false);\n\t\tif (!rc)\n\t\t\treturn inv_file;\n\t\telse {\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_move_tail(&inv_file->flist,\n\t\t\t\t\t&cifs_inode->openFileList);\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tcifsFileInfo_put(inv_file);\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\t++refind;\n\t\t\tgoto refind_writable;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstruct cifsFileInfo *find_writable_file(struct cifsInodeInfo *cifs_inode,\n\t\t\t\t\tbool fsuid_only)\n{\n\tstruct cifsFileInfo *open_file, *inv_file = NULL;\n\tstruct cifs_sb_info *cifs_sb;\n\tbool any_available = false;\n\tint rc;\n\tunsigned int refind = 0;\n\n\t/* Having a null inode here (because mapping->host was set to zero by\n\tthe VFS or MM) should not happen but we had reports of on oops (due to\n\tit being zero) during stress testcases so we need to check for it */\n\n\tif (cifs_inode == NULL) {\n\t\tcifs_dbg(VFS, \"Null inode passed to cifs_writeable_file\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tcifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);\n\n\t/* only filter by fsuid on multiuser mounts */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\tfsuid_only = false;\n\n\tspin_lock(&cifs_file_list_lock);\nrefind_writable:\n\tif (refind > MAX_REOPEN_ATT) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn NULL;\n\t}\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (!any_available && open_file->pid != current->tgid)\n\t\t\tcontinue;\n\t\tif (fsuid_only && !uid_eq(open_file->uid, current_fsuid()))\n\t\t\tcontinue;\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_WRITE) {\n\t\t\tif (!open_file->invalidHandle) {\n\t\t\t\t/* found a good writable file */\n\t\t\t\tcifsFileInfo_get_locked(open_file);\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\treturn open_file;\n\t\t\t} else {\n\t\t\t\tif (!inv_file)\n\t\t\t\t\tinv_file = open_file;\n\t\t\t}\n\t\t}\n\t}\n\t/* couldn't find useable FH with same pid, try any available */\n\tif (!any_available) {\n\t\tany_available = true;\n\t\tgoto refind_writable;\n\t}\n\n\tif (inv_file) {\n\t\tany_available = false;\n\t\tcifsFileInfo_get_locked(inv_file);\n\t}\n\n\tspin_unlock(&cifs_file_list_lock);\n\n\tif (inv_file) {\n\t\trc = cifs_reopen_file(inv_file, false);\n\t\tif (!rc)\n\t\t\treturn inv_file;\n\t\telse {\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_move_tail(&inv_file->flist,\n\t\t\t\t\t&cifs_inode->openFileList);\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tcifsFileInfo_put(inv_file);\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\t++refind;\n\t\t\tgoto refind_writable;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "mapping->host"
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifsFileInfo_put",
          "args": [
            "wdata->cfile"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "cifsFileInfo_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "358-436",
          "snippet": "void cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "i_size_read(mapping->host) -\n\t\t\tpage_offset(wdata->pages[nr_pages - 1])",
            "(loff_t)PAGE_CACHE_SIZE"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "minix_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/file.c",
          "lines": "26-48",
          "snippet": "static int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "wdata->pages[nr_pages - 1]"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "mapping->host"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "wdata->pages[0]"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\nwdata_send_pages(struct cifs_writedata *wdata, unsigned int nr_pages,\n\t\t struct address_space *mapping, struct writeback_control *wbc)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server;\n\tunsigned int i;\n\n\twdata->sync_mode = wbc->sync_mode;\n\twdata->nr_pages = nr_pages;\n\twdata->offset = page_offset(wdata->pages[0]);\n\twdata->pagesz = PAGE_CACHE_SIZE;\n\twdata->tailsz = min(i_size_read(mapping->host) -\n\t\t\tpage_offset(wdata->pages[nr_pages - 1]),\n\t\t\t(loff_t)PAGE_CACHE_SIZE);\n\twdata->bytes = ((nr_pages - 1) * PAGE_CACHE_SIZE) + wdata->tailsz;\n\n\tif (wdata->cfile != NULL)\n\t\tcifsFileInfo_put(wdata->cfile);\n\twdata->cfile = find_writable_file(CIFS_I(mapping->host), false);\n\tif (!wdata->cfile) {\n\t\tcifs_dbg(VFS, \"No writable handles for inode\\n\");\n\t\trc = -EBADF;\n\t} else {\n\t\twdata->pid = wdata->cfile->pid;\n\t\tserver = tlink_tcon(wdata->cfile->tlink)->ses->server;\n\t\trc = server->ops->async_writev(wdata, cifs_writedata_release);\n\t}\n\n\tfor (i = 0; i < nr_pages; ++i)\n\t\tunlock_page(wdata->pages[i]);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "wdata_prepare_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "1921-1999",
    "snippet": "static unsigned int\nwdata_prepare_pages(struct cifs_writedata *wdata, unsigned int found_pages,\n\t\t    struct address_space *mapping,\n\t\t    struct writeback_control *wbc,\n\t\t    pgoff_t end, pgoff_t *index, pgoff_t *next, bool *done)\n{\n\tunsigned int nr_pages = 0, i;\n\tstruct page *page;\n\n\tfor (i = 0; i < found_pages; i++) {\n\t\tpage = wdata->pages[i];\n\t\t/*\n\t\t * At this point we hold neither mapping->tree_lock nor\n\t\t * lock on the page itself: the page may be truncated or\n\t\t * invalidated (changing page->mapping to NULL), or even\n\t\t * swizzled back from swapper_space to tmpfs file\n\t\t * mapping\n\t\t */\n\n\t\tif (nr_pages == 0)\n\t\t\tlock_page(page);\n\t\telse if (!trylock_page(page))\n\t\t\tbreak;\n\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!wbc->range_cyclic && page->index > end) {\n\t\t\t*done = true;\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*next && (page->index != *next)) {\n\t\t\t/* Not next consecutive page */\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\t\twait_on_page_writeback(page);\n\n\t\tif (PageWriteback(page) ||\n\t\t\t\t!clear_page_dirty_for_io(page)) {\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * This actually clears the dirty bit in the radix tree.\n\t\t * See cifs_writepage() for more commentary.\n\t\t */\n\t\tset_page_writeback(page);\n\t\tif (page_offset(page) >= i_size_read(mapping->host)) {\n\t\t\t*done = true;\n\t\t\tunlock_page(page);\n\t\t\tend_page_writeback(page);\n\t\t\tbreak;\n\t\t}\n\n\t\twdata->pages[i] = page;\n\t\t*next = page->index + 1;\n\t\t++nr_pages;\n\t}\n\n\t/* reset index to refind any pages skipped */\n\tif (nr_pages == 0)\n\t\t*index = wdata->pages[0]->index + 1;\n\n\t/* put any pages we aren't going to use */\n\tfor (i = nr_pages; i < found_pages; i++) {\n\t\tpage_cache_release(wdata->pages[i]);\n\t\twdata->pages[i] = NULL;\n\t}\n\n\treturn nr_pages;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "wdata->pages[i]"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "mapping->host"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != mapping"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic unsigned int\nwdata_prepare_pages(struct cifs_writedata *wdata, unsigned int found_pages,\n\t\t    struct address_space *mapping,\n\t\t    struct writeback_control *wbc,\n\t\t    pgoff_t end, pgoff_t *index, pgoff_t *next, bool *done)\n{\n\tunsigned int nr_pages = 0, i;\n\tstruct page *page;\n\n\tfor (i = 0; i < found_pages; i++) {\n\t\tpage = wdata->pages[i];\n\t\t/*\n\t\t * At this point we hold neither mapping->tree_lock nor\n\t\t * lock on the page itself: the page may be truncated or\n\t\t * invalidated (changing page->mapping to NULL), or even\n\t\t * swizzled back from swapper_space to tmpfs file\n\t\t * mapping\n\t\t */\n\n\t\tif (nr_pages == 0)\n\t\t\tlock_page(page);\n\t\telse if (!trylock_page(page))\n\t\t\tbreak;\n\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!wbc->range_cyclic && page->index > end) {\n\t\t\t*done = true;\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*next && (page->index != *next)) {\n\t\t\t/* Not next consecutive page */\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\t\twait_on_page_writeback(page);\n\n\t\tif (PageWriteback(page) ||\n\t\t\t\t!clear_page_dirty_for_io(page)) {\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * This actually clears the dirty bit in the radix tree.\n\t\t * See cifs_writepage() for more commentary.\n\t\t */\n\t\tset_page_writeback(page);\n\t\tif (page_offset(page) >= i_size_read(mapping->host)) {\n\t\t\t*done = true;\n\t\t\tunlock_page(page);\n\t\t\tend_page_writeback(page);\n\t\t\tbreak;\n\t\t}\n\n\t\twdata->pages[i] = page;\n\t\t*next = page->index + 1;\n\t\t++nr_pages;\n\t}\n\n\t/* reset index to refind any pages skipped */\n\tif (nr_pages == 0)\n\t\t*index = wdata->pages[0]->index + 1;\n\n\t/* put any pages we aren't going to use */\n\tfor (i = nr_pages; i < found_pages; i++) {\n\t\tpage_cache_release(wdata->pages[i]);\n\t\twdata->pages[i] = NULL;\n\t}\n\n\treturn nr_pages;\n}"
  },
  {
    "function_name": "wdata_alloc_and_fillpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "1887-1919",
    "snippet": "static struct cifs_writedata *\nwdata_alloc_and_fillpages(pgoff_t tofind, struct address_space *mapping,\n\t\t\t  pgoff_t end, pgoff_t *index,\n\t\t\t  unsigned int *found_pages)\n{\n\tunsigned int nr_pages;\n\tstruct page **pages;\n\tstruct cifs_writedata *wdata;\n\n\twdata = cifs_writedata_alloc((unsigned int)tofind,\n\t\t\t\t     cifs_writev_complete);\n\tif (!wdata)\n\t\treturn NULL;\n\n\t/*\n\t * find_get_pages_tag seems to return a max of 256 on each\n\t * iteration, so we must call it several times in order to\n\t * fill the array or the wsize is effectively limited to\n\t * 256 * PAGE_CACHE_SIZE.\n\t */\n\t*found_pages = 0;\n\tpages = wdata->pages;\n\tdo {\n\t\tnr_pages = find_get_pages_tag(mapping, index,\n\t\t\t\t\t      PAGECACHE_TAG_DIRTY, tofind,\n\t\t\t\t\t      pages);\n\t\t*found_pages += nr_pages;\n\t\ttofind -= nr_pages;\n\t\tpages += nr_pages;\n\t} while (nr_pages && tofind && *index <= end);\n\n\treturn wdata;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_get_pages_tag",
          "args": [
            "mapping",
            "index",
            "PAGECACHE_TAG_DIRTY",
            "tofind",
            "pages"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_writedata_alloc",
          "args": [
            "(unsigned int)tofind",
            "cifs_writev_complete"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_writedata_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2010-2025",
          "snippet": "struct cifs_writedata *\ncifs_writedata_alloc(unsigned int nr_pages, work_func_t complete)\n{\n\tstruct cifs_writedata *wdata;\n\n\t/* writedata + number of page pointers */\n\twdata = kzalloc(sizeof(*wdata) +\n\t\t\tsizeof(struct page *) * nr_pages, GFP_NOFS);\n\tif (wdata != NULL) {\n\t\tkref_init(&wdata->refcount);\n\t\tINIT_LIST_HEAD(&wdata->list);\n\t\tinit_completion(&wdata->done);\n\t\tINIT_WORK(&wdata->work, complete);\n\t}\n\treturn wdata;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstruct cifs_writedata *\ncifs_writedata_alloc(unsigned int nr_pages, work_func_t complete)\n{\n\tstruct cifs_writedata *wdata;\n\n\t/* writedata + number of page pointers */\n\twdata = kzalloc(sizeof(*wdata) +\n\t\t\tsizeof(struct page *) * nr_pages, GFP_NOFS);\n\tif (wdata != NULL) {\n\t\tkref_init(&wdata->refcount);\n\t\tINIT_LIST_HEAD(&wdata->list);\n\t\tinit_completion(&wdata->done);\n\t\tINIT_WORK(&wdata->work, complete);\n\t}\n\treturn wdata;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic struct cifs_writedata *\nwdata_alloc_and_fillpages(pgoff_t tofind, struct address_space *mapping,\n\t\t\t  pgoff_t end, pgoff_t *index,\n\t\t\t  unsigned int *found_pages)\n{\n\tunsigned int nr_pages;\n\tstruct page **pages;\n\tstruct cifs_writedata *wdata;\n\n\twdata = cifs_writedata_alloc((unsigned int)tofind,\n\t\t\t\t     cifs_writev_complete);\n\tif (!wdata)\n\t\treturn NULL;\n\n\t/*\n\t * find_get_pages_tag seems to return a max of 256 on each\n\t * iteration, so we must call it several times in order to\n\t * fill the array or the wsize is effectively limited to\n\t * 256 * PAGE_CACHE_SIZE.\n\t */\n\t*found_pages = 0;\n\tpages = wdata->pages;\n\tdo {\n\t\tnr_pages = find_get_pages_tag(mapping, index,\n\t\t\t\t\t      PAGECACHE_TAG_DIRTY, tofind,\n\t\t\t\t\t      pages);\n\t\t*found_pages += nr_pages;\n\t\ttofind -= nr_pages;\n\t\tpages += nr_pages;\n\t} while (nr_pages && tofind && *index <= end);\n\n\treturn wdata;\n}"
  },
  {
    "function_name": "cifs_partialpagewrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "1833-1885",
    "snippet": "static int cifs_partialpagewrite(struct page *page, unsigned from, unsigned to)\n{\n\tstruct address_space *mapping = page->mapping;\n\tloff_t offset = (loff_t)page->index << PAGE_CACHE_SHIFT;\n\tchar *write_data;\n\tint rc = -EFAULT;\n\tint bytes_written = 0;\n\tstruct inode *inode;\n\tstruct cifsFileInfo *open_file;\n\n\tif (!mapping || !mapping->host)\n\t\treturn -EFAULT;\n\n\tinode = page->mapping->host;\n\n\toffset += (loff_t)from;\n\twrite_data = kmap(page);\n\twrite_data += from;\n\n\tif ((to > PAGE_CACHE_SIZE) || (from > to)) {\n\t\tkunmap(page);\n\t\treturn -EIO;\n\t}\n\n\t/* racing with truncate? */\n\tif (offset > mapping->host->i_size) {\n\t\tkunmap(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/* check to make sure that we are not extending the file */\n\tif (mapping->host->i_size - offset < (loff_t)to)\n\t\tto = (unsigned)(mapping->host->i_size - offset);\n\n\topen_file = find_writable_file(CIFS_I(mapping->host), false);\n\tif (open_file) {\n\t\tbytes_written = cifs_write(open_file, open_file->pid,\n\t\t\t\t\t   write_data, to - from, &offset);\n\t\tcifsFileInfo_put(open_file);\n\t\t/* Does mm or vfs already set times? */\n\t\tinode->i_atime = inode->i_mtime = current_fs_time(inode->i_sb);\n\t\tif ((bytes_written > 0) && (offset))\n\t\t\trc = 0;\n\t\telse if (bytes_written < 0)\n\t\t\trc = bytes_written;\n\t} else {\n\t\tcifs_dbg(FYI, \"No writeable filehandles for inode\\n\");\n\t\trc = -EIO;\n\t}\n\n\tkunmap(page);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"No writeable filehandles for inode\\n\""
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "inode->i_sb"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifsFileInfo_put",
          "args": [
            "open_file"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "cifsFileInfo_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "358-436",
          "snippet": "void cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_write",
          "args": [
            "open_file",
            "open_file->pid",
            "write_data",
            "to - from",
            "&offset"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1634-1717",
          "snippet": "static ssize_t\ncifs_write(struct cifsFileInfo *open_file, __u32 pid, const char *write_data,\n\t   size_t write_size, loff_t *offset)\n{\n\tint rc = 0;\n\tunsigned int bytes_written = 0;\n\tunsigned int total_written;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tunsigned int xid;\n\tstruct dentry *dentry = open_file->dentry;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(dentry->d_inode);\n\tstruct cifs_io_parms io_parms;\n\n\tcifs_sb = CIFS_SB(dentry->d_sb);\n\n\tcifs_dbg(FYI, \"write %zd bytes to offset %lld of %pd\\n\",\n\t\t write_size, *offset, dentry);\n\n\ttcon = tlink_tcon(open_file->tlink);\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->sync_write)\n\t\treturn -ENOSYS;\n\n\txid = get_xid();\n\n\tfor (total_written = 0; write_size > total_written;\n\t     total_written += bytes_written) {\n\t\trc = -EAGAIN;\n\t\twhile (rc == -EAGAIN) {\n\t\t\tstruct kvec iov[2];\n\t\t\tunsigned int len;\n\n\t\t\tif (open_file->invalidHandle) {\n\t\t\t\t/* we could deadlock if we called\n\t\t\t\t   filemap_fdatawait from here so tell\n\t\t\t\t   reopen_file not to flush data to\n\t\t\t\t   server now */\n\t\t\t\trc = cifs_reopen_file(open_file, false);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlen = min(server->ops->wp_retry_size(dentry->d_inode),\n\t\t\t\t  (unsigned int)write_size - total_written);\n\t\t\t/* iov[0] is reserved for smb header */\n\t\t\tiov[1].iov_base = (char *)write_data + total_written;\n\t\t\tiov[1].iov_len = len;\n\t\t\tio_parms.pid = pid;\n\t\t\tio_parms.tcon = tcon;\n\t\t\tio_parms.offset = *offset;\n\t\t\tio_parms.length = len;\n\t\t\trc = server->ops->sync_write(xid, &open_file->fid,\n\t\t\t\t\t&io_parms, &bytes_written, iov, 1);\n\t\t}\n\t\tif (rc || (bytes_written == 0)) {\n\t\t\tif (total_written)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\tspin_lock(&dentry->d_inode->i_lock);\n\t\t\tcifs_update_eof(cifsi, *offset, bytes_written);\n\t\t\tspin_unlock(&dentry->d_inode->i_lock);\n\t\t\t*offset += bytes_written;\n\t\t}\n\t}\n\n\tcifs_stats_bytes_written(tcon, total_written);\n\n\tif (total_written > 0) {\n\t\tspin_lock(&dentry->d_inode->i_lock);\n\t\tif (*offset > dentry->d_inode->i_size)\n\t\t\ti_size_write(dentry->d_inode, *offset);\n\t\tspin_unlock(&dentry->d_inode->i_lock);\n\t}\n\tmark_inode_dirty_sync(dentry->d_inode);\n\tfree_xid(xid);\n\treturn total_written;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic ssize_t\ncifs_write(struct cifsFileInfo *open_file, __u32 pid, const char *write_data,\n\t   size_t write_size, loff_t *offset)\n{\n\tint rc = 0;\n\tunsigned int bytes_written = 0;\n\tunsigned int total_written;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tunsigned int xid;\n\tstruct dentry *dentry = open_file->dentry;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(dentry->d_inode);\n\tstruct cifs_io_parms io_parms;\n\n\tcifs_sb = CIFS_SB(dentry->d_sb);\n\n\tcifs_dbg(FYI, \"write %zd bytes to offset %lld of %pd\\n\",\n\t\t write_size, *offset, dentry);\n\n\ttcon = tlink_tcon(open_file->tlink);\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->sync_write)\n\t\treturn -ENOSYS;\n\n\txid = get_xid();\n\n\tfor (total_written = 0; write_size > total_written;\n\t     total_written += bytes_written) {\n\t\trc = -EAGAIN;\n\t\twhile (rc == -EAGAIN) {\n\t\t\tstruct kvec iov[2];\n\t\t\tunsigned int len;\n\n\t\t\tif (open_file->invalidHandle) {\n\t\t\t\t/* we could deadlock if we called\n\t\t\t\t   filemap_fdatawait from here so tell\n\t\t\t\t   reopen_file not to flush data to\n\t\t\t\t   server now */\n\t\t\t\trc = cifs_reopen_file(open_file, false);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlen = min(server->ops->wp_retry_size(dentry->d_inode),\n\t\t\t\t  (unsigned int)write_size - total_written);\n\t\t\t/* iov[0] is reserved for smb header */\n\t\t\tiov[1].iov_base = (char *)write_data + total_written;\n\t\t\tiov[1].iov_len = len;\n\t\t\tio_parms.pid = pid;\n\t\t\tio_parms.tcon = tcon;\n\t\t\tio_parms.offset = *offset;\n\t\t\tio_parms.length = len;\n\t\t\trc = server->ops->sync_write(xid, &open_file->fid,\n\t\t\t\t\t&io_parms, &bytes_written, iov, 1);\n\t\t}\n\t\tif (rc || (bytes_written == 0)) {\n\t\t\tif (total_written)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\tspin_lock(&dentry->d_inode->i_lock);\n\t\t\tcifs_update_eof(cifsi, *offset, bytes_written);\n\t\t\tspin_unlock(&dentry->d_inode->i_lock);\n\t\t\t*offset += bytes_written;\n\t\t}\n\t}\n\n\tcifs_stats_bytes_written(tcon, total_written);\n\n\tif (total_written > 0) {\n\t\tspin_lock(&dentry->d_inode->i_lock);\n\t\tif (*offset > dentry->d_inode->i_size)\n\t\t\ti_size_write(dentry->d_inode, *offset);\n\t\tspin_unlock(&dentry->d_inode->i_lock);\n\t}\n\tmark_inode_dirty_sync(dentry->d_inode);\n\tfree_xid(xid);\n\treturn total_written;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_writable_file",
          "args": [
            "CIFS_I(mapping->host)",
            "false"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "find_writable_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1753-1831",
          "snippet": "struct cifsFileInfo *find_writable_file(struct cifsInodeInfo *cifs_inode,\n\t\t\t\t\tbool fsuid_only)\n{\n\tstruct cifsFileInfo *open_file, *inv_file = NULL;\n\tstruct cifs_sb_info *cifs_sb;\n\tbool any_available = false;\n\tint rc;\n\tunsigned int refind = 0;\n\n\t/* Having a null inode here (because mapping->host was set to zero by\n\tthe VFS or MM) should not happen but we had reports of on oops (due to\n\tit being zero) during stress testcases so we need to check for it */\n\n\tif (cifs_inode == NULL) {\n\t\tcifs_dbg(VFS, \"Null inode passed to cifs_writeable_file\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tcifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);\n\n\t/* only filter by fsuid on multiuser mounts */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\tfsuid_only = false;\n\n\tspin_lock(&cifs_file_list_lock);\nrefind_writable:\n\tif (refind > MAX_REOPEN_ATT) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn NULL;\n\t}\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (!any_available && open_file->pid != current->tgid)\n\t\t\tcontinue;\n\t\tif (fsuid_only && !uid_eq(open_file->uid, current_fsuid()))\n\t\t\tcontinue;\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_WRITE) {\n\t\t\tif (!open_file->invalidHandle) {\n\t\t\t\t/* found a good writable file */\n\t\t\t\tcifsFileInfo_get_locked(open_file);\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\treturn open_file;\n\t\t\t} else {\n\t\t\t\tif (!inv_file)\n\t\t\t\t\tinv_file = open_file;\n\t\t\t}\n\t\t}\n\t}\n\t/* couldn't find useable FH with same pid, try any available */\n\tif (!any_available) {\n\t\tany_available = true;\n\t\tgoto refind_writable;\n\t}\n\n\tif (inv_file) {\n\t\tany_available = false;\n\t\tcifsFileInfo_get_locked(inv_file);\n\t}\n\n\tspin_unlock(&cifs_file_list_lock);\n\n\tif (inv_file) {\n\t\trc = cifs_reopen_file(inv_file, false);\n\t\tif (!rc)\n\t\t\treturn inv_file;\n\t\telse {\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_move_tail(&inv_file->flist,\n\t\t\t\t\t&cifs_inode->openFileList);\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tcifsFileInfo_put(inv_file);\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\t++refind;\n\t\t\tgoto refind_writable;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstruct cifsFileInfo *find_writable_file(struct cifsInodeInfo *cifs_inode,\n\t\t\t\t\tbool fsuid_only)\n{\n\tstruct cifsFileInfo *open_file, *inv_file = NULL;\n\tstruct cifs_sb_info *cifs_sb;\n\tbool any_available = false;\n\tint rc;\n\tunsigned int refind = 0;\n\n\t/* Having a null inode here (because mapping->host was set to zero by\n\tthe VFS or MM) should not happen but we had reports of on oops (due to\n\tit being zero) during stress testcases so we need to check for it */\n\n\tif (cifs_inode == NULL) {\n\t\tcifs_dbg(VFS, \"Null inode passed to cifs_writeable_file\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tcifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);\n\n\t/* only filter by fsuid on multiuser mounts */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\tfsuid_only = false;\n\n\tspin_lock(&cifs_file_list_lock);\nrefind_writable:\n\tif (refind > MAX_REOPEN_ATT) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn NULL;\n\t}\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (!any_available && open_file->pid != current->tgid)\n\t\t\tcontinue;\n\t\tif (fsuid_only && !uid_eq(open_file->uid, current_fsuid()))\n\t\t\tcontinue;\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_WRITE) {\n\t\t\tif (!open_file->invalidHandle) {\n\t\t\t\t/* found a good writable file */\n\t\t\t\tcifsFileInfo_get_locked(open_file);\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\treturn open_file;\n\t\t\t} else {\n\t\t\t\tif (!inv_file)\n\t\t\t\t\tinv_file = open_file;\n\t\t\t}\n\t\t}\n\t}\n\t/* couldn't find useable FH with same pid, try any available */\n\tif (!any_available) {\n\t\tany_available = true;\n\t\tgoto refind_writable;\n\t}\n\n\tif (inv_file) {\n\t\tany_available = false;\n\t\tcifsFileInfo_get_locked(inv_file);\n\t}\n\n\tspin_unlock(&cifs_file_list_lock);\n\n\tif (inv_file) {\n\t\trc = cifs_reopen_file(inv_file, false);\n\t\tif (!rc)\n\t\t\treturn inv_file;\n\t\telse {\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_move_tail(&inv_file->flist,\n\t\t\t\t\t&cifs_inode->openFileList);\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tcifsFileInfo_put(inv_file);\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\t++refind;\n\t\t\tgoto refind_writable;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "mapping->host"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_partialpagewrite(struct page *page, unsigned from, unsigned to)\n{\n\tstruct address_space *mapping = page->mapping;\n\tloff_t offset = (loff_t)page->index << PAGE_CACHE_SHIFT;\n\tchar *write_data;\n\tint rc = -EFAULT;\n\tint bytes_written = 0;\n\tstruct inode *inode;\n\tstruct cifsFileInfo *open_file;\n\n\tif (!mapping || !mapping->host)\n\t\treturn -EFAULT;\n\n\tinode = page->mapping->host;\n\n\toffset += (loff_t)from;\n\twrite_data = kmap(page);\n\twrite_data += from;\n\n\tif ((to > PAGE_CACHE_SIZE) || (from > to)) {\n\t\tkunmap(page);\n\t\treturn -EIO;\n\t}\n\n\t/* racing with truncate? */\n\tif (offset > mapping->host->i_size) {\n\t\tkunmap(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/* check to make sure that we are not extending the file */\n\tif (mapping->host->i_size - offset < (loff_t)to)\n\t\tto = (unsigned)(mapping->host->i_size - offset);\n\n\topen_file = find_writable_file(CIFS_I(mapping->host), false);\n\tif (open_file) {\n\t\tbytes_written = cifs_write(open_file, open_file->pid,\n\t\t\t\t\t   write_data, to - from, &offset);\n\t\tcifsFileInfo_put(open_file);\n\t\t/* Does mm or vfs already set times? */\n\t\tinode->i_atime = inode->i_mtime = current_fs_time(inode->i_sb);\n\t\tif ((bytes_written > 0) && (offset))\n\t\t\trc = 0;\n\t\telse if (bytes_written < 0)\n\t\t\trc = bytes_written;\n\t} else {\n\t\tcifs_dbg(FYI, \"No writeable filehandles for inode\\n\");\n\t\trc = -EIO;\n\t}\n\n\tkunmap(page);\n\treturn rc;\n}"
  },
  {
    "function_name": "find_writable_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "1753-1831",
    "snippet": "struct cifsFileInfo *find_writable_file(struct cifsInodeInfo *cifs_inode,\n\t\t\t\t\tbool fsuid_only)\n{\n\tstruct cifsFileInfo *open_file, *inv_file = NULL;\n\tstruct cifs_sb_info *cifs_sb;\n\tbool any_available = false;\n\tint rc;\n\tunsigned int refind = 0;\n\n\t/* Having a null inode here (because mapping->host was set to zero by\n\tthe VFS or MM) should not happen but we had reports of on oops (due to\n\tit being zero) during stress testcases so we need to check for it */\n\n\tif (cifs_inode == NULL) {\n\t\tcifs_dbg(VFS, \"Null inode passed to cifs_writeable_file\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tcifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);\n\n\t/* only filter by fsuid on multiuser mounts */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\tfsuid_only = false;\n\n\tspin_lock(&cifs_file_list_lock);\nrefind_writable:\n\tif (refind > MAX_REOPEN_ATT) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn NULL;\n\t}\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (!any_available && open_file->pid != current->tgid)\n\t\t\tcontinue;\n\t\tif (fsuid_only && !uid_eq(open_file->uid, current_fsuid()))\n\t\t\tcontinue;\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_WRITE) {\n\t\t\tif (!open_file->invalidHandle) {\n\t\t\t\t/* found a good writable file */\n\t\t\t\tcifsFileInfo_get_locked(open_file);\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\treturn open_file;\n\t\t\t} else {\n\t\t\t\tif (!inv_file)\n\t\t\t\t\tinv_file = open_file;\n\t\t\t}\n\t\t}\n\t}\n\t/* couldn't find useable FH with same pid, try any available */\n\tif (!any_available) {\n\t\tany_available = true;\n\t\tgoto refind_writable;\n\t}\n\n\tif (inv_file) {\n\t\tany_available = false;\n\t\tcifsFileInfo_get_locked(inv_file);\n\t}\n\n\tspin_unlock(&cifs_file_list_lock);\n\n\tif (inv_file) {\n\t\trc = cifs_reopen_file(inv_file, false);\n\t\tif (!rc)\n\t\t\treturn inv_file;\n\t\telse {\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_move_tail(&inv_file->flist,\n\t\t\t\t\t&cifs_inode->openFileList);\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tcifsFileInfo_put(inv_file);\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\t++refind;\n\t\t\tgoto refind_writable;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifsFileInfo_put",
          "args": [
            "inv_file"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "cifsFileInfo_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "358-436",
          "snippet": "void cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&inv_file->flist",
            "&cifs_inode->openFileList"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_reopen_file",
          "args": [
            "inv_file",
            "false"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_reopen_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "597-744",
          "snippet": "static int\ncifs_reopen_file(struct cifsFileInfo *cfile, bool can_flush)\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\t__u32 oplock;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsInodeInfo *cinode;\n\tstruct inode *inode;\n\tchar *full_path = NULL;\n\tint desired_access;\n\tint disposition = FILE_OPEN;\n\tint create_options = CREATE_NOT_DIR;\n\tstruct cifs_open_parms oparms;\n\n\txid = get_xid();\n\tmutex_lock(&cfile->fh_mutex);\n\tif (!cfile->invalidHandle) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\trc = 0;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tinode = cfile->dentry->d_inode;\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttcon = tlink_tcon(cfile->tlink);\n\tserver = tcon->ses->server;\n\n\t/*\n\t * Can not grab rename sem here because various ops, including those\n\t * that already have the rename sem can end up causing writepage to get\n\t * called and if the server was down that means we end up here, and we\n\t * can never tell if the caller already has the rename_sem.\n\t */\n\tfull_path = build_path_from_dentry(cfile->dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tcifs_dbg(FYI, \"inode = 0x%p file flags 0x%x for %s\\n\",\n\t\t inode, cfile->f_flags, full_path);\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\t/*\n\t\t * O_CREAT, O_EXCL and O_TRUNC already had their effect on the\n\t\t * original open. Must mask them off for a reopen.\n\t\t */\n\t\tunsigned int oflags = cfile->f_flags &\n\t\t\t\t\t\t~(O_CREAT | O_EXCL | O_TRUNC);\n\n\t\trc = cifs_posix_open(full_path, NULL, inode->i_sb,\n\t\t\t\t     cifs_sb->mnt_file_mode /* ignored */,\n\t\t\t\t     oflags, &oplock, &cfile->fid.netfid, xid);\n\t\tif (rc == 0) {\n\t\t\tcifs_dbg(FYI, \"posix reopen succeeded\\n\");\n\t\t\toparms.reconnect = true;\n\t\t\tgoto reopen_success;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry open the old way on errors, especially\n\t\t * in the reconnect path it is important to retry hard\n\t\t */\n\t}\n\n\tdesired_access = cifs_convert_flags(cfile->f_flags);\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &cfile->fid);\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = &cfile->fid;\n\toparms.reconnect = true;\n\n\t/*\n\t * Can not refresh inode by passing in file_info buf to be returned by\n\t * ops->open and then calling get_inode_info with returned buf since\n\t * file might have write behind data that needs to be flushed and server\n\t * version of file size can be stale. If we knew for sure that inode was\n\t * not dirty locally we could do this.\n\t */\n\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\tif (rc == -ENOENT && oparms.reconnect == false) {\n\t\t/* durable handle timeout is expired - open the file again */\n\t\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\t\t/* indicate that we need to relock the file */\n\t\toparms.reconnect = true;\n\t}\n\n\tif (rc) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tcifs_dbg(FYI, \"cifs_reopen returned 0x%x\\n\", rc);\n\t\tcifs_dbg(FYI, \"oplock: %d\\n\", oplock);\n\t\tgoto reopen_error_exit;\n\t}\n\nreopen_success:\n\tcfile->invalidHandle = false;\n\tmutex_unlock(&cfile->fh_mutex);\n\tcinode = CIFS_I(inode);\n\n\tif (can_flush) {\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\t\tmapping_set_error(inode->i_mapping, rc);\n\n\t\tif (tcon->unix_ext)\n\t\t\trc = cifs_get_inode_info_unix(&inode, full_path,\n\t\t\t\t\t\t      inode->i_sb, xid);\n\t\telse\n\t\t\trc = cifs_get_inode_info(&inode, full_path, NULL,\n\t\t\t\t\t\t inode->i_sb, xid, NULL);\n\t}\n\t/*\n\t * Else we are writing out data to server already and could deadlock if\n\t * we tried to flush data, and since we do not know if we have data that\n\t * would invalidate the current end of file on the server we can not go\n\t * to the server to get the new inode info.\n\t */\n\n\tserver->ops->set_fid(cfile, &cfile->fid, oplock);\n\tif (oparms.reconnect)\n\t\tcifs_relock_file(cfile);\n\nreopen_error_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_reopen_file(struct cifsFileInfo *cfile, bool can_flush)\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\t__u32 oplock;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsInodeInfo *cinode;\n\tstruct inode *inode;\n\tchar *full_path = NULL;\n\tint desired_access;\n\tint disposition = FILE_OPEN;\n\tint create_options = CREATE_NOT_DIR;\n\tstruct cifs_open_parms oparms;\n\n\txid = get_xid();\n\tmutex_lock(&cfile->fh_mutex);\n\tif (!cfile->invalidHandle) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\trc = 0;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tinode = cfile->dentry->d_inode;\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttcon = tlink_tcon(cfile->tlink);\n\tserver = tcon->ses->server;\n\n\t/*\n\t * Can not grab rename sem here because various ops, including those\n\t * that already have the rename sem can end up causing writepage to get\n\t * called and if the server was down that means we end up here, and we\n\t * can never tell if the caller already has the rename_sem.\n\t */\n\tfull_path = build_path_from_dentry(cfile->dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tcifs_dbg(FYI, \"inode = 0x%p file flags 0x%x for %s\\n\",\n\t\t inode, cfile->f_flags, full_path);\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\t/*\n\t\t * O_CREAT, O_EXCL and O_TRUNC already had their effect on the\n\t\t * original open. Must mask them off for a reopen.\n\t\t */\n\t\tunsigned int oflags = cfile->f_flags &\n\t\t\t\t\t\t~(O_CREAT | O_EXCL | O_TRUNC);\n\n\t\trc = cifs_posix_open(full_path, NULL, inode->i_sb,\n\t\t\t\t     cifs_sb->mnt_file_mode /* ignored */,\n\t\t\t\t     oflags, &oplock, &cfile->fid.netfid, xid);\n\t\tif (rc == 0) {\n\t\t\tcifs_dbg(FYI, \"posix reopen succeeded\\n\");\n\t\t\toparms.reconnect = true;\n\t\t\tgoto reopen_success;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry open the old way on errors, especially\n\t\t * in the reconnect path it is important to retry hard\n\t\t */\n\t}\n\n\tdesired_access = cifs_convert_flags(cfile->f_flags);\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &cfile->fid);\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = &cfile->fid;\n\toparms.reconnect = true;\n\n\t/*\n\t * Can not refresh inode by passing in file_info buf to be returned by\n\t * ops->open and then calling get_inode_info with returned buf since\n\t * file might have write behind data that needs to be flushed and server\n\t * version of file size can be stale. If we knew for sure that inode was\n\t * not dirty locally we could do this.\n\t */\n\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\tif (rc == -ENOENT && oparms.reconnect == false) {\n\t\t/* durable handle timeout is expired - open the file again */\n\t\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\t\t/* indicate that we need to relock the file */\n\t\toparms.reconnect = true;\n\t}\n\n\tif (rc) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tcifs_dbg(FYI, \"cifs_reopen returned 0x%x\\n\", rc);\n\t\tcifs_dbg(FYI, \"oplock: %d\\n\", oplock);\n\t\tgoto reopen_error_exit;\n\t}\n\nreopen_success:\n\tcfile->invalidHandle = false;\n\tmutex_unlock(&cfile->fh_mutex);\n\tcinode = CIFS_I(inode);\n\n\tif (can_flush) {\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\t\tmapping_set_error(inode->i_mapping, rc);\n\n\t\tif (tcon->unix_ext)\n\t\t\trc = cifs_get_inode_info_unix(&inode, full_path,\n\t\t\t\t\t\t      inode->i_sb, xid);\n\t\telse\n\t\t\trc = cifs_get_inode_info(&inode, full_path, NULL,\n\t\t\t\t\t\t inode->i_sb, xid, NULL);\n\t}\n\t/*\n\t * Else we are writing out data to server already and could deadlock if\n\t * we tried to flush data, and since we do not know if we have data that\n\t * would invalidate the current end of file on the server we can not go\n\t * to the server to get the new inode info.\n\t */\n\n\tserver->ops->set_fid(cfile, &cfile->fid, oplock);\n\tif (oparms.reconnect)\n\t\tcifs_relock_file(cfile);\n\nreopen_error_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifsFileInfo_get_locked",
          "args": [
            "inv_file"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "cifsFileInfo_get_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1104-1108",
          "snippet": "static inline void\ncifsFileInfo_get_locked(struct cifsFileInfo *cifs_file)\n{\n\t++cifs_file->count;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ncifsFileInfo_get_locked(struct cifsFileInfo *cifs_file)\n{\n\t++cifs_file->count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OPEN_FMODE",
          "args": [
            "open_file->f_flags"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "open_file->uid",
            "current_fsuid()"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "open_file",
            "&cifs_inode->openFileList",
            "flist"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "cifs_inode->vfs_inode.i_sb"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Null inode passed to cifs_writeable_file\\n\""
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstruct cifsFileInfo *find_writable_file(struct cifsInodeInfo *cifs_inode,\n\t\t\t\t\tbool fsuid_only)\n{\n\tstruct cifsFileInfo *open_file, *inv_file = NULL;\n\tstruct cifs_sb_info *cifs_sb;\n\tbool any_available = false;\n\tint rc;\n\tunsigned int refind = 0;\n\n\t/* Having a null inode here (because mapping->host was set to zero by\n\tthe VFS or MM) should not happen but we had reports of on oops (due to\n\tit being zero) during stress testcases so we need to check for it */\n\n\tif (cifs_inode == NULL) {\n\t\tcifs_dbg(VFS, \"Null inode passed to cifs_writeable_file\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tcifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);\n\n\t/* only filter by fsuid on multiuser mounts */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\tfsuid_only = false;\n\n\tspin_lock(&cifs_file_list_lock);\nrefind_writable:\n\tif (refind > MAX_REOPEN_ATT) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn NULL;\n\t}\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (!any_available && open_file->pid != current->tgid)\n\t\t\tcontinue;\n\t\tif (fsuid_only && !uid_eq(open_file->uid, current_fsuid()))\n\t\t\tcontinue;\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_WRITE) {\n\t\t\tif (!open_file->invalidHandle) {\n\t\t\t\t/* found a good writable file */\n\t\t\t\tcifsFileInfo_get_locked(open_file);\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\treturn open_file;\n\t\t\t} else {\n\t\t\t\tif (!inv_file)\n\t\t\t\t\tinv_file = open_file;\n\t\t\t}\n\t\t}\n\t}\n\t/* couldn't find useable FH with same pid, try any available */\n\tif (!any_available) {\n\t\tany_available = true;\n\t\tgoto refind_writable;\n\t}\n\n\tif (inv_file) {\n\t\tany_available = false;\n\t\tcifsFileInfo_get_locked(inv_file);\n\t}\n\n\tspin_unlock(&cifs_file_list_lock);\n\n\tif (inv_file) {\n\t\trc = cifs_reopen_file(inv_file, false);\n\t\tif (!rc)\n\t\t\treturn inv_file;\n\t\telse {\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_move_tail(&inv_file->flist,\n\t\t\t\t\t&cifs_inode->openFileList);\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tcifsFileInfo_put(inv_file);\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\t++refind;\n\t\t\tgoto refind_writable;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "find_readable_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "1719-1751",
    "snippet": "struct cifsFileInfo *find_readable_file(struct cifsInodeInfo *cifs_inode,\n\t\t\t\t\tbool fsuid_only)\n{\n\tstruct cifsFileInfo *open_file = NULL;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);\n\n\t/* only filter by fsuid on multiuser mounts */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\tfsuid_only = false;\n\n\tspin_lock(&cifs_file_list_lock);\n\t/* we could simply get the first_list_entry since write-only entries\n\t   are always at the end of the list but since the first entry might\n\t   have a close pending, we go through the whole list */\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (fsuid_only && !uid_eq(open_file->uid, current_fsuid()))\n\t\t\tcontinue;\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_READ) {\n\t\t\tif (!open_file->invalidHandle) {\n\t\t\t\t/* found a good file */\n\t\t\t\t/* lock it so it will not be closed on us */\n\t\t\t\tcifsFileInfo_get_locked(open_file);\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\treturn open_file;\n\t\t\t} /* else might as well continue, and look for\n\t\t\t     another, or simply have the caller reopen it\n\t\t\t     again rather than trying to fix this handle */\n\t\t} else /* write only file */\n\t\t\tbreak; /* write only files are last so must be done */\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\treturn NULL;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifsFileInfo_get_locked",
          "args": [
            "open_file"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "cifsFileInfo_get_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1104-1108",
          "snippet": "static inline void\ncifsFileInfo_get_locked(struct cifsFileInfo *cifs_file)\n{\n\t++cifs_file->count;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ncifsFileInfo_get_locked(struct cifsFileInfo *cifs_file)\n{\n\t++cifs_file->count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OPEN_FMODE",
          "args": [
            "open_file->f_flags"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "open_file->uid",
            "current_fsuid()"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "open_file",
            "&cifs_inode->openFileList",
            "flist"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "cifs_inode->vfs_inode.i_sb"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstruct cifsFileInfo *find_readable_file(struct cifsInodeInfo *cifs_inode,\n\t\t\t\t\tbool fsuid_only)\n{\n\tstruct cifsFileInfo *open_file = NULL;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);\n\n\t/* only filter by fsuid on multiuser mounts */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\tfsuid_only = false;\n\n\tspin_lock(&cifs_file_list_lock);\n\t/* we could simply get the first_list_entry since write-only entries\n\t   are always at the end of the list but since the first entry might\n\t   have a close pending, we go through the whole list */\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (fsuid_only && !uid_eq(open_file->uid, current_fsuid()))\n\t\t\tcontinue;\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_READ) {\n\t\t\tif (!open_file->invalidHandle) {\n\t\t\t\t/* found a good file */\n\t\t\t\t/* lock it so it will not be closed on us */\n\t\t\t\tcifsFileInfo_get_locked(open_file);\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\treturn open_file;\n\t\t\t} /* else might as well continue, and look for\n\t\t\t     another, or simply have the caller reopen it\n\t\t\t     again rather than trying to fix this handle */\n\t\t} else /* write only file */\n\t\t\tbreak; /* write only files are last so must be done */\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "cifs_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "1634-1717",
    "snippet": "static ssize_t\ncifs_write(struct cifsFileInfo *open_file, __u32 pid, const char *write_data,\n\t   size_t write_size, loff_t *offset)\n{\n\tint rc = 0;\n\tunsigned int bytes_written = 0;\n\tunsigned int total_written;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tunsigned int xid;\n\tstruct dentry *dentry = open_file->dentry;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(dentry->d_inode);\n\tstruct cifs_io_parms io_parms;\n\n\tcifs_sb = CIFS_SB(dentry->d_sb);\n\n\tcifs_dbg(FYI, \"write %zd bytes to offset %lld of %pd\\n\",\n\t\t write_size, *offset, dentry);\n\n\ttcon = tlink_tcon(open_file->tlink);\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->sync_write)\n\t\treturn -ENOSYS;\n\n\txid = get_xid();\n\n\tfor (total_written = 0; write_size > total_written;\n\t     total_written += bytes_written) {\n\t\trc = -EAGAIN;\n\t\twhile (rc == -EAGAIN) {\n\t\t\tstruct kvec iov[2];\n\t\t\tunsigned int len;\n\n\t\t\tif (open_file->invalidHandle) {\n\t\t\t\t/* we could deadlock if we called\n\t\t\t\t   filemap_fdatawait from here so tell\n\t\t\t\t   reopen_file not to flush data to\n\t\t\t\t   server now */\n\t\t\t\trc = cifs_reopen_file(open_file, false);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlen = min(server->ops->wp_retry_size(dentry->d_inode),\n\t\t\t\t  (unsigned int)write_size - total_written);\n\t\t\t/* iov[0] is reserved for smb header */\n\t\t\tiov[1].iov_base = (char *)write_data + total_written;\n\t\t\tiov[1].iov_len = len;\n\t\t\tio_parms.pid = pid;\n\t\t\tio_parms.tcon = tcon;\n\t\t\tio_parms.offset = *offset;\n\t\t\tio_parms.length = len;\n\t\t\trc = server->ops->sync_write(xid, &open_file->fid,\n\t\t\t\t\t&io_parms, &bytes_written, iov, 1);\n\t\t}\n\t\tif (rc || (bytes_written == 0)) {\n\t\t\tif (total_written)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\tspin_lock(&dentry->d_inode->i_lock);\n\t\t\tcifs_update_eof(cifsi, *offset, bytes_written);\n\t\t\tspin_unlock(&dentry->d_inode->i_lock);\n\t\t\t*offset += bytes_written;\n\t\t}\n\t}\n\n\tcifs_stats_bytes_written(tcon, total_written);\n\n\tif (total_written > 0) {\n\t\tspin_lock(&dentry->d_inode->i_lock);\n\t\tif (*offset > dentry->d_inode->i_size)\n\t\t\ti_size_write(dentry->d_inode, *offset);\n\t\tspin_unlock(&dentry->d_inode->i_lock);\n\t}\n\tmark_inode_dirty_sync(dentry->d_inode);\n\tfree_xid(xid);\n\treturn total_written;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 1715
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty_sync",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "291-294",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_inode->i_lock"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "dentry->d_inode",
            "*offset"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_inode->i_lock"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_bytes_written",
          "args": [
            "tcon",
            "total_written"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_stats_bytes_written",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1203-1211",
          "snippet": "static inline void cifs_stats_bytes_written(struct cifs_tcon *tcon,\n\t\t\t\t\t    unsigned int bytes)\n{\n\tif (bytes) {\n\t\tspin_lock(&tcon->stat_lock);\n\t\ttcon->bytes_written += bytes;\n\t\tspin_unlock(&tcon->stat_lock);\n\t}\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_stats_bytes_written(struct cifs_tcon *tcon,\n\t\t\t\t\t    unsigned int bytes)\n{\n\tif (bytes) {\n\t\tspin_lock(&tcon->stat_lock);\n\t\ttcon->bytes_written += bytes;\n\t\tspin_unlock(&tcon->stat_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_update_eof",
          "args": [
            "cifsi",
            "*offset",
            "bytes_written"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_update_eof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1624-1632",
          "snippet": "void\ncifs_update_eof(struct cifsInodeInfo *cifsi, loff_t offset,\n\t\t      unsigned int bytes_written)\n{\n\tloff_t end_of_write = offset + bytes_written;\n\n\tif (end_of_write > cifsi->server_eof)\n\t\tcifsi->server_eof = end_of_write;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid\ncifs_update_eof(struct cifsInodeInfo *cifsi, loff_t offset,\n\t\t      unsigned int bytes_written)\n{\n\tloff_t end_of_write = offset + bytes_written;\n\n\tif (end_of_write > cifsi->server_eof)\n\t\tcifsi->server_eof = end_of_write;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->sync_write",
          "args": [
            "xid",
            "&open_file->fid",
            "&io_parms",
            "&bytes_written",
            "iov",
            "1"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "server->ops->wp_retry_size(dentry->d_inode)",
            "(unsigned int)write_size - total_written"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "minix_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/file.c",
          "lines": "26-48",
          "snippet": "static int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->wp_retry_size",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_reopen_file",
          "args": [
            "open_file",
            "false"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_reopen_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "597-744",
          "snippet": "static int\ncifs_reopen_file(struct cifsFileInfo *cfile, bool can_flush)\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\t__u32 oplock;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsInodeInfo *cinode;\n\tstruct inode *inode;\n\tchar *full_path = NULL;\n\tint desired_access;\n\tint disposition = FILE_OPEN;\n\tint create_options = CREATE_NOT_DIR;\n\tstruct cifs_open_parms oparms;\n\n\txid = get_xid();\n\tmutex_lock(&cfile->fh_mutex);\n\tif (!cfile->invalidHandle) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\trc = 0;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tinode = cfile->dentry->d_inode;\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttcon = tlink_tcon(cfile->tlink);\n\tserver = tcon->ses->server;\n\n\t/*\n\t * Can not grab rename sem here because various ops, including those\n\t * that already have the rename sem can end up causing writepage to get\n\t * called and if the server was down that means we end up here, and we\n\t * can never tell if the caller already has the rename_sem.\n\t */\n\tfull_path = build_path_from_dentry(cfile->dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tcifs_dbg(FYI, \"inode = 0x%p file flags 0x%x for %s\\n\",\n\t\t inode, cfile->f_flags, full_path);\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\t/*\n\t\t * O_CREAT, O_EXCL and O_TRUNC already had their effect on the\n\t\t * original open. Must mask them off for a reopen.\n\t\t */\n\t\tunsigned int oflags = cfile->f_flags &\n\t\t\t\t\t\t~(O_CREAT | O_EXCL | O_TRUNC);\n\n\t\trc = cifs_posix_open(full_path, NULL, inode->i_sb,\n\t\t\t\t     cifs_sb->mnt_file_mode /* ignored */,\n\t\t\t\t     oflags, &oplock, &cfile->fid.netfid, xid);\n\t\tif (rc == 0) {\n\t\t\tcifs_dbg(FYI, \"posix reopen succeeded\\n\");\n\t\t\toparms.reconnect = true;\n\t\t\tgoto reopen_success;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry open the old way on errors, especially\n\t\t * in the reconnect path it is important to retry hard\n\t\t */\n\t}\n\n\tdesired_access = cifs_convert_flags(cfile->f_flags);\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &cfile->fid);\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = &cfile->fid;\n\toparms.reconnect = true;\n\n\t/*\n\t * Can not refresh inode by passing in file_info buf to be returned by\n\t * ops->open and then calling get_inode_info with returned buf since\n\t * file might have write behind data that needs to be flushed and server\n\t * version of file size can be stale. If we knew for sure that inode was\n\t * not dirty locally we could do this.\n\t */\n\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\tif (rc == -ENOENT && oparms.reconnect == false) {\n\t\t/* durable handle timeout is expired - open the file again */\n\t\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\t\t/* indicate that we need to relock the file */\n\t\toparms.reconnect = true;\n\t}\n\n\tif (rc) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tcifs_dbg(FYI, \"cifs_reopen returned 0x%x\\n\", rc);\n\t\tcifs_dbg(FYI, \"oplock: %d\\n\", oplock);\n\t\tgoto reopen_error_exit;\n\t}\n\nreopen_success:\n\tcfile->invalidHandle = false;\n\tmutex_unlock(&cfile->fh_mutex);\n\tcinode = CIFS_I(inode);\n\n\tif (can_flush) {\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\t\tmapping_set_error(inode->i_mapping, rc);\n\n\t\tif (tcon->unix_ext)\n\t\t\trc = cifs_get_inode_info_unix(&inode, full_path,\n\t\t\t\t\t\t      inode->i_sb, xid);\n\t\telse\n\t\t\trc = cifs_get_inode_info(&inode, full_path, NULL,\n\t\t\t\t\t\t inode->i_sb, xid, NULL);\n\t}\n\t/*\n\t * Else we are writing out data to server already and could deadlock if\n\t * we tried to flush data, and since we do not know if we have data that\n\t * would invalidate the current end of file on the server we can not go\n\t * to the server to get the new inode info.\n\t */\n\n\tserver->ops->set_fid(cfile, &cfile->fid, oplock);\n\tif (oparms.reconnect)\n\t\tcifs_relock_file(cfile);\n\nreopen_error_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_reopen_file(struct cifsFileInfo *cfile, bool can_flush)\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\t__u32 oplock;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsInodeInfo *cinode;\n\tstruct inode *inode;\n\tchar *full_path = NULL;\n\tint desired_access;\n\tint disposition = FILE_OPEN;\n\tint create_options = CREATE_NOT_DIR;\n\tstruct cifs_open_parms oparms;\n\n\txid = get_xid();\n\tmutex_lock(&cfile->fh_mutex);\n\tif (!cfile->invalidHandle) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\trc = 0;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tinode = cfile->dentry->d_inode;\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttcon = tlink_tcon(cfile->tlink);\n\tserver = tcon->ses->server;\n\n\t/*\n\t * Can not grab rename sem here because various ops, including those\n\t * that already have the rename sem can end up causing writepage to get\n\t * called and if the server was down that means we end up here, and we\n\t * can never tell if the caller already has the rename_sem.\n\t */\n\tfull_path = build_path_from_dentry(cfile->dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tcifs_dbg(FYI, \"inode = 0x%p file flags 0x%x for %s\\n\",\n\t\t inode, cfile->f_flags, full_path);\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\t/*\n\t\t * O_CREAT, O_EXCL and O_TRUNC already had their effect on the\n\t\t * original open. Must mask them off for a reopen.\n\t\t */\n\t\tunsigned int oflags = cfile->f_flags &\n\t\t\t\t\t\t~(O_CREAT | O_EXCL | O_TRUNC);\n\n\t\trc = cifs_posix_open(full_path, NULL, inode->i_sb,\n\t\t\t\t     cifs_sb->mnt_file_mode /* ignored */,\n\t\t\t\t     oflags, &oplock, &cfile->fid.netfid, xid);\n\t\tif (rc == 0) {\n\t\t\tcifs_dbg(FYI, \"posix reopen succeeded\\n\");\n\t\t\toparms.reconnect = true;\n\t\t\tgoto reopen_success;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry open the old way on errors, especially\n\t\t * in the reconnect path it is important to retry hard\n\t\t */\n\t}\n\n\tdesired_access = cifs_convert_flags(cfile->f_flags);\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &cfile->fid);\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = &cfile->fid;\n\toparms.reconnect = true;\n\n\t/*\n\t * Can not refresh inode by passing in file_info buf to be returned by\n\t * ops->open and then calling get_inode_info with returned buf since\n\t * file might have write behind data that needs to be flushed and server\n\t * version of file size can be stale. If we knew for sure that inode was\n\t * not dirty locally we could do this.\n\t */\n\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\tif (rc == -ENOENT && oparms.reconnect == false) {\n\t\t/* durable handle timeout is expired - open the file again */\n\t\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\t\t/* indicate that we need to relock the file */\n\t\toparms.reconnect = true;\n\t}\n\n\tif (rc) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tcifs_dbg(FYI, \"cifs_reopen returned 0x%x\\n\", rc);\n\t\tcifs_dbg(FYI, \"oplock: %d\\n\", oplock);\n\t\tgoto reopen_error_exit;\n\t}\n\nreopen_success:\n\tcfile->invalidHandle = false;\n\tmutex_unlock(&cfile->fh_mutex);\n\tcinode = CIFS_I(inode);\n\n\tif (can_flush) {\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\t\tmapping_set_error(inode->i_mapping, rc);\n\n\t\tif (tcon->unix_ext)\n\t\t\trc = cifs_get_inode_info_unix(&inode, full_path,\n\t\t\t\t\t\t      inode->i_sb, xid);\n\t\telse\n\t\t\trc = cifs_get_inode_info(&inode, full_path, NULL,\n\t\t\t\t\t\t inode->i_sb, xid, NULL);\n\t}\n\t/*\n\t * Else we are writing out data to server already and could deadlock if\n\t * we tried to flush data, and since we do not know if we have data that\n\t * would invalidate the current end of file on the server we can not go\n\t * to the server to get the new inode info.\n\t */\n\n\tserver->ops->set_fid(cfile, &cfile->fid, oplock);\n\tif (oparms.reconnect)\n\t\tcifs_relock_file(cfile);\n\nreopen_error_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "open_file->tlink"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"write %zd bytes to offset %lld of %pd\\n\"",
            "write_size",
            "*offset",
            "dentry"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic ssize_t\ncifs_write(struct cifsFileInfo *open_file, __u32 pid, const char *write_data,\n\t   size_t write_size, loff_t *offset)\n{\n\tint rc = 0;\n\tunsigned int bytes_written = 0;\n\tunsigned int total_written;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tunsigned int xid;\n\tstruct dentry *dentry = open_file->dentry;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(dentry->d_inode);\n\tstruct cifs_io_parms io_parms;\n\n\tcifs_sb = CIFS_SB(dentry->d_sb);\n\n\tcifs_dbg(FYI, \"write %zd bytes to offset %lld of %pd\\n\",\n\t\t write_size, *offset, dentry);\n\n\ttcon = tlink_tcon(open_file->tlink);\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->sync_write)\n\t\treturn -ENOSYS;\n\n\txid = get_xid();\n\n\tfor (total_written = 0; write_size > total_written;\n\t     total_written += bytes_written) {\n\t\trc = -EAGAIN;\n\t\twhile (rc == -EAGAIN) {\n\t\t\tstruct kvec iov[2];\n\t\t\tunsigned int len;\n\n\t\t\tif (open_file->invalidHandle) {\n\t\t\t\t/* we could deadlock if we called\n\t\t\t\t   filemap_fdatawait from here so tell\n\t\t\t\t   reopen_file not to flush data to\n\t\t\t\t   server now */\n\t\t\t\trc = cifs_reopen_file(open_file, false);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlen = min(server->ops->wp_retry_size(dentry->d_inode),\n\t\t\t\t  (unsigned int)write_size - total_written);\n\t\t\t/* iov[0] is reserved for smb header */\n\t\t\tiov[1].iov_base = (char *)write_data + total_written;\n\t\t\tiov[1].iov_len = len;\n\t\t\tio_parms.pid = pid;\n\t\t\tio_parms.tcon = tcon;\n\t\t\tio_parms.offset = *offset;\n\t\t\tio_parms.length = len;\n\t\t\trc = server->ops->sync_write(xid, &open_file->fid,\n\t\t\t\t\t&io_parms, &bytes_written, iov, 1);\n\t\t}\n\t\tif (rc || (bytes_written == 0)) {\n\t\t\tif (total_written)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\tspin_lock(&dentry->d_inode->i_lock);\n\t\t\tcifs_update_eof(cifsi, *offset, bytes_written);\n\t\t\tspin_unlock(&dentry->d_inode->i_lock);\n\t\t\t*offset += bytes_written;\n\t\t}\n\t}\n\n\tcifs_stats_bytes_written(tcon, total_written);\n\n\tif (total_written > 0) {\n\t\tspin_lock(&dentry->d_inode->i_lock);\n\t\tif (*offset > dentry->d_inode->i_size)\n\t\t\ti_size_write(dentry->d_inode, *offset);\n\t\tspin_unlock(&dentry->d_inode->i_lock);\n\t}\n\tmark_inode_dirty_sync(dentry->d_inode);\n\tfree_xid(xid);\n\treturn total_written;\n}"
  },
  {
    "function_name": "cifs_update_eof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "1624-1632",
    "snippet": "void\ncifs_update_eof(struct cifsInodeInfo *cifsi, loff_t offset,\n\t\t      unsigned int bytes_written)\n{\n\tloff_t end_of_write = offset + bytes_written;\n\n\tif (end_of_write > cifsi->server_eof)\n\t\tcifsi->server_eof = end_of_write;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid\ncifs_update_eof(struct cifsInodeInfo *cifsi, loff_t offset,\n\t\t      unsigned int bytes_written)\n{\n\tloff_t end_of_write = offset + bytes_written;\n\n\tif (end_of_write > cifsi->server_eof)\n\t\tcifsi->server_eof = end_of_write;\n}"
  },
  {
    "function_name": "cifs_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "1561-1618",
    "snippet": "int cifs_lock(struct file *file, int cmd, struct file_lock *flock)\n{\n\tint rc, xid;\n\tint lock = 0, unlock = 0;\n\tbool wait_flag = false;\n\tbool posix_lck = false;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsInodeInfo *cinode;\n\tstruct cifsFileInfo *cfile;\n\t__u16 netfid;\n\t__u32 type;\n\n\trc = -EACCES;\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"Lock parm: 0x%x flockflags: 0x%x flocktype: 0x%x start: %lld end: %lld\\n\",\n\t\t cmd, flock->fl_flags, flock->fl_type,\n\t\t flock->fl_start, flock->fl_end);\n\n\tcfile = (struct cifsFileInfo *)file->private_data;\n\ttcon = tlink_tcon(cfile->tlink);\n\n\tcifs_read_flock(flock, &type, &lock, &unlock, &wait_flag,\n\t\t\ttcon->ses->server);\n\n\tcifs_sb = CIFS_FILE_SB(file);\n\tnetfid = cfile->fid.netfid;\n\tcinode = CIFS_I(file_inode(file));\n\n\tif (cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability)) &&\n\t    ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0))\n\t\tposix_lck = true;\n\t/*\n\t * BB add code here to normalize offset and length to account for\n\t * negative length which we can not accept over the wire.\n\t */\n\tif (IS_GETLK(cmd)) {\n\t\trc = cifs_getlk(file, flock, type, wait_flag, posix_lck, xid);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tif (!lock && !unlock) {\n\t\t/*\n\t\t * if no lock or unlock then nothing to do since we do not\n\t\t * know what it is\n\t\t */\n\t\tfree_xid(xid);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trc = cifs_setlk(file, flock, type, wait_flag, posix_lck, lock, unlock,\n\t\t\txid);\n\tfree_xid(xid);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_setlk",
          "args": [
            "file",
            "flock",
            "type",
            "wait_flag",
            "posix_lck",
            "lock",
            "unlock",
            "xid"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_setlk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1481-1559",
          "snippet": "static int\ncifs_setlk(struct file *file, struct file_lock *flock, __u32 type,\n\t   bool wait_flag, bool posix_lck, int lock, int unlock,\n\t   unsigned int xid)\n{\n\tint rc = 0;\n\t__u64 length = 1 + flock->fl_end - flock->fl_start;\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)file->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct inode *inode = cfile->dentry->d_inode;\n\n\tif (posix_lck) {\n\t\tint posix_lock_type;\n\n\t\trc = cifs_posix_lock_set(file, flock);\n\t\tif (!rc || rc < 0)\n\t\t\treturn rc;\n\n\t\tif (type & server->vals->shared_lock_type)\n\t\t\tposix_lock_type = CIFS_RDLCK;\n\t\telse\n\t\t\tposix_lock_type = CIFS_WRLCK;\n\n\t\tif (unlock == 1)\n\t\t\tposix_lock_type = CIFS_UNLCK;\n\n\t\trc = CIFSSMBPosixLock(xid, tcon, cfile->fid.netfid,\n\t\t\t\t      current->tgid, flock->fl_start, length,\n\t\t\t\t      NULL, posix_lock_type, wait_flag);\n\t\tgoto out;\n\t}\n\n\tif (lock) {\n\t\tstruct cifsLockInfo *lock;\n\n\t\tlock = cifs_lock_init(flock->fl_start, length, type);\n\t\tif (!lock)\n\t\t\treturn -ENOMEM;\n\n\t\trc = cifs_lock_add_if(cfile, lock, wait_flag);\n\t\tif (rc < 0) {\n\t\t\tkfree(lock);\n\t\t\treturn rc;\n\t\t}\n\t\tif (!rc)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Windows 7 server can delay breaking lease from read to None\n\t\t * if we set a byte-range lock on a file - break it explicitly\n\t\t * before sending the lock to the server to be sure the next\n\t\t * read won't conflict with non-overlapted locks due to\n\t\t * pagereading.\n\t\t */\n\t\tif (!CIFS_CACHE_WRITE(CIFS_I(inode)) &&\n\t\t\t\t\tCIFS_CACHE_READ(CIFS_I(inode))) {\n\t\t\tcifs_zap_mapping(inode);\n\t\t\tcifs_dbg(FYI, \"Set no oplock for inode=%p due to mand locks\\n\",\n\t\t\t\t inode);\n\t\t\tCIFS_I(inode)->oplock = 0;\n\t\t}\n\n\t\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\t\t\t    type, 1, 0, wait_flag);\n\t\tif (rc) {\n\t\t\tkfree(lock);\n\t\t\treturn rc;\n\t\t}\n\n\t\tcifs_lock_add(cfile, lock);\n\t} else if (unlock)\n\t\trc = server->ops->mand_unlock_range(cfile, flock, xid);\n\nout:\n\tif (flock->fl_flags & FL_POSIX)\n\t\tposix_lock_file_wait(file, flock);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_setlk(struct file *file, struct file_lock *flock, __u32 type,\n\t   bool wait_flag, bool posix_lck, int lock, int unlock,\n\t   unsigned int xid)\n{\n\tint rc = 0;\n\t__u64 length = 1 + flock->fl_end - flock->fl_start;\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)file->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct inode *inode = cfile->dentry->d_inode;\n\n\tif (posix_lck) {\n\t\tint posix_lock_type;\n\n\t\trc = cifs_posix_lock_set(file, flock);\n\t\tif (!rc || rc < 0)\n\t\t\treturn rc;\n\n\t\tif (type & server->vals->shared_lock_type)\n\t\t\tposix_lock_type = CIFS_RDLCK;\n\t\telse\n\t\t\tposix_lock_type = CIFS_WRLCK;\n\n\t\tif (unlock == 1)\n\t\t\tposix_lock_type = CIFS_UNLCK;\n\n\t\trc = CIFSSMBPosixLock(xid, tcon, cfile->fid.netfid,\n\t\t\t\t      current->tgid, flock->fl_start, length,\n\t\t\t\t      NULL, posix_lock_type, wait_flag);\n\t\tgoto out;\n\t}\n\n\tif (lock) {\n\t\tstruct cifsLockInfo *lock;\n\n\t\tlock = cifs_lock_init(flock->fl_start, length, type);\n\t\tif (!lock)\n\t\t\treturn -ENOMEM;\n\n\t\trc = cifs_lock_add_if(cfile, lock, wait_flag);\n\t\tif (rc < 0) {\n\t\t\tkfree(lock);\n\t\t\treturn rc;\n\t\t}\n\t\tif (!rc)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Windows 7 server can delay breaking lease from read to None\n\t\t * if we set a byte-range lock on a file - break it explicitly\n\t\t * before sending the lock to the server to be sure the next\n\t\t * read won't conflict with non-overlapted locks due to\n\t\t * pagereading.\n\t\t */\n\t\tif (!CIFS_CACHE_WRITE(CIFS_I(inode)) &&\n\t\t\t\t\tCIFS_CACHE_READ(CIFS_I(inode))) {\n\t\t\tcifs_zap_mapping(inode);\n\t\t\tcifs_dbg(FYI, \"Set no oplock for inode=%p due to mand locks\\n\",\n\t\t\t\t inode);\n\t\t\tCIFS_I(inode)->oplock = 0;\n\t\t}\n\n\t\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\t\t\t    type, 1, 0, wait_flag);\n\t\tif (rc) {\n\t\t\tkfree(lock);\n\t\t\treturn rc;\n\t\t}\n\n\t\tcifs_lock_add(cfile, lock);\n\t} else if (unlock)\n\t\trc = server->ops->mand_unlock_range(cfile, flock, xid);\n\nout:\n\tif (flock->fl_flags & FL_POSIX)\n\t\tposix_lock_file_wait(file, flock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_getlk",
          "args": [
            "file",
            "flock",
            "type",
            "wait_flag",
            "posix_lck",
            "xid"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_getlk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1287-1353",
          "snippet": "static int\ncifs_getlk(struct file *file, struct file_lock *flock, __u32 type,\n\t   bool wait_flag, bool posix_lck, unsigned int xid)\n{\n\tint rc = 0;\n\t__u64 length = 1 + flock->fl_end - flock->fl_start;\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)file->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t__u16 netfid = cfile->fid.netfid;\n\n\tif (posix_lck) {\n\t\tint posix_lock_type;\n\n\t\trc = cifs_posix_lock_test(file, flock);\n\t\tif (!rc)\n\t\t\treturn rc;\n\n\t\tif (type & server->vals->shared_lock_type)\n\t\t\tposix_lock_type = CIFS_RDLCK;\n\t\telse\n\t\t\tposix_lock_type = CIFS_WRLCK;\n\t\trc = CIFSSMBPosixLock(xid, tcon, netfid, current->tgid,\n\t\t\t\t      flock->fl_start, length, flock,\n\t\t\t\t      posix_lock_type, wait_flag);\n\t\treturn rc;\n\t}\n\n\trc = cifs_lock_test(cfile, flock->fl_start, length, type, flock);\n\tif (!rc)\n\t\treturn rc;\n\n\t/* BB we could chain these into one lock request BB */\n\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length, type,\n\t\t\t\t    1, 0, false);\n\tif (rc == 0) {\n\t\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\t\t\t    type, 0, 1, false);\n\t\tflock->fl_type = F_UNLCK;\n\t\tif (rc != 0)\n\t\t\tcifs_dbg(VFS, \"Error unlocking previously locked range %d during test of lock\\n\",\n\t\t\t\t rc);\n\t\treturn 0;\n\t}\n\n\tif (type & server->vals->shared_lock_type) {\n\t\tflock->fl_type = F_WRLCK;\n\t\treturn 0;\n\t}\n\n\ttype &= ~server->vals->exclusive_lock_type;\n\n\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\t\t    type | server->vals->shared_lock_type,\n\t\t\t\t    1, 0, false);\n\tif (rc == 0) {\n\t\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\ttype | server->vals->shared_lock_type, 0, 1, false);\n\t\tflock->fl_type = F_RDLCK;\n\t\tif (rc != 0)\n\t\t\tcifs_dbg(VFS, \"Error unlocking previously locked range %d during test of lock\\n\",\n\t\t\t\t rc);\n\t} else\n\t\tflock->fl_type = F_WRLCK;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_getlk(struct file *file, struct file_lock *flock, __u32 type,\n\t   bool wait_flag, bool posix_lck, unsigned int xid)\n{\n\tint rc = 0;\n\t__u64 length = 1 + flock->fl_end - flock->fl_start;\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)file->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t__u16 netfid = cfile->fid.netfid;\n\n\tif (posix_lck) {\n\t\tint posix_lock_type;\n\n\t\trc = cifs_posix_lock_test(file, flock);\n\t\tif (!rc)\n\t\t\treturn rc;\n\n\t\tif (type & server->vals->shared_lock_type)\n\t\t\tposix_lock_type = CIFS_RDLCK;\n\t\telse\n\t\t\tposix_lock_type = CIFS_WRLCK;\n\t\trc = CIFSSMBPosixLock(xid, tcon, netfid, current->tgid,\n\t\t\t\t      flock->fl_start, length, flock,\n\t\t\t\t      posix_lock_type, wait_flag);\n\t\treturn rc;\n\t}\n\n\trc = cifs_lock_test(cfile, flock->fl_start, length, type, flock);\n\tif (!rc)\n\t\treturn rc;\n\n\t/* BB we could chain these into one lock request BB */\n\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length, type,\n\t\t\t\t    1, 0, false);\n\tif (rc == 0) {\n\t\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\t\t\t    type, 0, 1, false);\n\t\tflock->fl_type = F_UNLCK;\n\t\tif (rc != 0)\n\t\t\tcifs_dbg(VFS, \"Error unlocking previously locked range %d during test of lock\\n\",\n\t\t\t\t rc);\n\t\treturn 0;\n\t}\n\n\tif (type & server->vals->shared_lock_type) {\n\t\tflock->fl_type = F_WRLCK;\n\t\treturn 0;\n\t}\n\n\ttype &= ~server->vals->exclusive_lock_type;\n\n\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\t\t    type | server->vals->shared_lock_type,\n\t\t\t\t    1, 0, false);\n\tif (rc == 0) {\n\t\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\ttype | server->vals->shared_lock_type, 0, 1, false);\n\t\tflock->fl_type = F_RDLCK;\n\t\tif (rc != 0)\n\t\t\tcifs_dbg(VFS, \"Error unlocking previously locked range %d during test of lock\\n\",\n\t\t\t\t rc);\n\t} else\n\t\tflock->fl_type = F_WRLCK;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_GETLK",
          "args": [
            "cmd"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "tcon->fsUnixInfo.Capability"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_unix",
          "args": [
            "tcon->ses"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "cap_unix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "804-808",
          "snippet": "static inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_FILE_SB",
          "args": [
            "file"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_FILE_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1171-1175",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_FILE_SB(struct file *file)\n{\n\treturn CIFS_SB(file_inode(file)->i_sb);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_FILE_SB(struct file *file)\n{\n\treturn CIFS_SB(file_inode(file)->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_read_flock",
          "args": [
            "flock",
            "&type",
            "&lock",
            "&unlock",
            "&wait_flag",
            "tcon->ses->server"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_read_flock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1240-1285",
          "snippet": "static void\ncifs_read_flock(struct file_lock *flock, __u32 *type, int *lock, int *unlock,\n\t\tbool *wait_flag, struct TCP_Server_Info *server)\n{\n\tif (flock->fl_flags & FL_POSIX)\n\t\tcifs_dbg(FYI, \"Posix\\n\");\n\tif (flock->fl_flags & FL_FLOCK)\n\t\tcifs_dbg(FYI, \"Flock\\n\");\n\tif (flock->fl_flags & FL_SLEEP) {\n\t\tcifs_dbg(FYI, \"Blocking lock\\n\");\n\t\t*wait_flag = true;\n\t}\n\tif (flock->fl_flags & FL_ACCESS)\n\t\tcifs_dbg(FYI, \"Process suspended by mandatory locking - not implemented yet\\n\");\n\tif (flock->fl_flags & FL_LEASE)\n\t\tcifs_dbg(FYI, \"Lease on file - not implemented yet\\n\");\n\tif (flock->fl_flags &\n\t    (~(FL_POSIX | FL_FLOCK | FL_SLEEP |\n\t       FL_ACCESS | FL_LEASE | FL_CLOSE)))\n\t\tcifs_dbg(FYI, \"Unknown lock flags 0x%x\\n\", flock->fl_flags);\n\n\t*type = server->vals->large_lock_type;\n\tif (flock->fl_type == F_WRLCK) {\n\t\tcifs_dbg(FYI, \"F_WRLCK\\n\");\n\t\t*type |= server->vals->exclusive_lock_type;\n\t\t*lock = 1;\n\t} else if (flock->fl_type == F_UNLCK) {\n\t\tcifs_dbg(FYI, \"F_UNLCK\\n\");\n\t\t*type |= server->vals->unlock_lock_type;\n\t\t*unlock = 1;\n\t\t/* Check if unlock includes more than one lock range */\n\t} else if (flock->fl_type == F_RDLCK) {\n\t\tcifs_dbg(FYI, \"F_RDLCK\\n\");\n\t\t*type |= server->vals->shared_lock_type;\n\t\t*lock = 1;\n\t} else if (flock->fl_type == F_EXLCK) {\n\t\tcifs_dbg(FYI, \"F_EXLCK\\n\");\n\t\t*type |= server->vals->exclusive_lock_type;\n\t\t*lock = 1;\n\t} else if (flock->fl_type == F_SHLCK) {\n\t\tcifs_dbg(FYI, \"F_SHLCK\\n\");\n\t\t*type |= server->vals->shared_lock_type;\n\t\t*lock = 1;\n\t} else\n\t\tcifs_dbg(FYI, \"Unknown type of lock\\n\");\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_read_flock(struct file_lock *flock, __u32 *type, int *lock, int *unlock,\n\t\tbool *wait_flag, struct TCP_Server_Info *server)\n{\n\tif (flock->fl_flags & FL_POSIX)\n\t\tcifs_dbg(FYI, \"Posix\\n\");\n\tif (flock->fl_flags & FL_FLOCK)\n\t\tcifs_dbg(FYI, \"Flock\\n\");\n\tif (flock->fl_flags & FL_SLEEP) {\n\t\tcifs_dbg(FYI, \"Blocking lock\\n\");\n\t\t*wait_flag = true;\n\t}\n\tif (flock->fl_flags & FL_ACCESS)\n\t\tcifs_dbg(FYI, \"Process suspended by mandatory locking - not implemented yet\\n\");\n\tif (flock->fl_flags & FL_LEASE)\n\t\tcifs_dbg(FYI, \"Lease on file - not implemented yet\\n\");\n\tif (flock->fl_flags &\n\t    (~(FL_POSIX | FL_FLOCK | FL_SLEEP |\n\t       FL_ACCESS | FL_LEASE | FL_CLOSE)))\n\t\tcifs_dbg(FYI, \"Unknown lock flags 0x%x\\n\", flock->fl_flags);\n\n\t*type = server->vals->large_lock_type;\n\tif (flock->fl_type == F_WRLCK) {\n\t\tcifs_dbg(FYI, \"F_WRLCK\\n\");\n\t\t*type |= server->vals->exclusive_lock_type;\n\t\t*lock = 1;\n\t} else if (flock->fl_type == F_UNLCK) {\n\t\tcifs_dbg(FYI, \"F_UNLCK\\n\");\n\t\t*type |= server->vals->unlock_lock_type;\n\t\t*unlock = 1;\n\t\t/* Check if unlock includes more than one lock range */\n\t} else if (flock->fl_type == F_RDLCK) {\n\t\tcifs_dbg(FYI, \"F_RDLCK\\n\");\n\t\t*type |= server->vals->shared_lock_type;\n\t\t*lock = 1;\n\t} else if (flock->fl_type == F_EXLCK) {\n\t\tcifs_dbg(FYI, \"F_EXLCK\\n\");\n\t\t*type |= server->vals->exclusive_lock_type;\n\t\t*lock = 1;\n\t} else if (flock->fl_type == F_SHLCK) {\n\t\tcifs_dbg(FYI, \"F_SHLCK\\n\");\n\t\t*type |= server->vals->shared_lock_type;\n\t\t*lock = 1;\n\t} else\n\t\tcifs_dbg(FYI, \"Unknown type of lock\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Lock parm: 0x%x flockflags: 0x%x flocktype: 0x%x start: %lld end: %lld\\n\"",
            "cmd",
            "flock->fl_flags",
            "flock->fl_type",
            "flock->fl_start",
            "flock->fl_end"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nint cifs_lock(struct file *file, int cmd, struct file_lock *flock)\n{\n\tint rc, xid;\n\tint lock = 0, unlock = 0;\n\tbool wait_flag = false;\n\tbool posix_lck = false;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsInodeInfo *cinode;\n\tstruct cifsFileInfo *cfile;\n\t__u16 netfid;\n\t__u32 type;\n\n\trc = -EACCES;\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"Lock parm: 0x%x flockflags: 0x%x flocktype: 0x%x start: %lld end: %lld\\n\",\n\t\t cmd, flock->fl_flags, flock->fl_type,\n\t\t flock->fl_start, flock->fl_end);\n\n\tcfile = (struct cifsFileInfo *)file->private_data;\n\ttcon = tlink_tcon(cfile->tlink);\n\n\tcifs_read_flock(flock, &type, &lock, &unlock, &wait_flag,\n\t\t\ttcon->ses->server);\n\n\tcifs_sb = CIFS_FILE_SB(file);\n\tnetfid = cfile->fid.netfid;\n\tcinode = CIFS_I(file_inode(file));\n\n\tif (cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability)) &&\n\t    ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0))\n\t\tposix_lck = true;\n\t/*\n\t * BB add code here to normalize offset and length to account for\n\t * negative length which we can not accept over the wire.\n\t */\n\tif (IS_GETLK(cmd)) {\n\t\trc = cifs_getlk(file, flock, type, wait_flag, posix_lck, xid);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tif (!lock && !unlock) {\n\t\t/*\n\t\t * if no lock or unlock then nothing to do since we do not\n\t\t * know what it is\n\t\t */\n\t\tfree_xid(xid);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trc = cifs_setlk(file, flock, type, wait_flag, posix_lck, lock, unlock,\n\t\t\txid);\n\tfree_xid(xid);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_setlk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "1481-1559",
    "snippet": "static int\ncifs_setlk(struct file *file, struct file_lock *flock, __u32 type,\n\t   bool wait_flag, bool posix_lck, int lock, int unlock,\n\t   unsigned int xid)\n{\n\tint rc = 0;\n\t__u64 length = 1 + flock->fl_end - flock->fl_start;\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)file->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct inode *inode = cfile->dentry->d_inode;\n\n\tif (posix_lck) {\n\t\tint posix_lock_type;\n\n\t\trc = cifs_posix_lock_set(file, flock);\n\t\tif (!rc || rc < 0)\n\t\t\treturn rc;\n\n\t\tif (type & server->vals->shared_lock_type)\n\t\t\tposix_lock_type = CIFS_RDLCK;\n\t\telse\n\t\t\tposix_lock_type = CIFS_WRLCK;\n\n\t\tif (unlock == 1)\n\t\t\tposix_lock_type = CIFS_UNLCK;\n\n\t\trc = CIFSSMBPosixLock(xid, tcon, cfile->fid.netfid,\n\t\t\t\t      current->tgid, flock->fl_start, length,\n\t\t\t\t      NULL, posix_lock_type, wait_flag);\n\t\tgoto out;\n\t}\n\n\tif (lock) {\n\t\tstruct cifsLockInfo *lock;\n\n\t\tlock = cifs_lock_init(flock->fl_start, length, type);\n\t\tif (!lock)\n\t\t\treturn -ENOMEM;\n\n\t\trc = cifs_lock_add_if(cfile, lock, wait_flag);\n\t\tif (rc < 0) {\n\t\t\tkfree(lock);\n\t\t\treturn rc;\n\t\t}\n\t\tif (!rc)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Windows 7 server can delay breaking lease from read to None\n\t\t * if we set a byte-range lock on a file - break it explicitly\n\t\t * before sending the lock to the server to be sure the next\n\t\t * read won't conflict with non-overlapted locks due to\n\t\t * pagereading.\n\t\t */\n\t\tif (!CIFS_CACHE_WRITE(CIFS_I(inode)) &&\n\t\t\t\t\tCIFS_CACHE_READ(CIFS_I(inode))) {\n\t\t\tcifs_zap_mapping(inode);\n\t\t\tcifs_dbg(FYI, \"Set no oplock for inode=%p due to mand locks\\n\",\n\t\t\t\t inode);\n\t\t\tCIFS_I(inode)->oplock = 0;\n\t\t}\n\n\t\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\t\t\t    type, 1, 0, wait_flag);\n\t\tif (rc) {\n\t\t\tkfree(lock);\n\t\t\treturn rc;\n\t\t}\n\n\t\tcifs_lock_add(cfile, lock);\n\t} else if (unlock)\n\t\trc = server->ops->mand_unlock_range(cfile, flock, xid);\n\nout:\n\tif (flock->fl_flags & FL_POSIX)\n\t\tposix_lock_file_wait(file, flock);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_lock_file_wait",
          "args": [
            "file",
            "flock"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1173-1189",
          "snippet": "int posix_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_file(filp, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint posix_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_file(filp, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->mand_unlock_range",
          "args": [
            "cfile",
            "flock",
            "xid"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_lock_add",
          "args": [
            "cfile",
            "lock"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_lock_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "927-934",
          "snippet": "static void\ncifs_lock_add(struct cifsFileInfo *cfile, struct cifsLockInfo *lock)\n{\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tdown_write(&cinode->lock_sem);\n\tlist_add_tail(&lock->llist, &cfile->llist->locks);\n\tup_write(&cinode->lock_sem);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic void\ncifs_lock_add(struct cifsFileInfo *cfile, struct cifsLockInfo *lock)\n{\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tdown_write(&cinode->lock_sem);\n\tlist_add_tail(&lock->llist, &cfile->llist->locks);\n\tup_write(&cinode->lock_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lock"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->mand_lock",
          "args": [
            "xid",
            "cfile",
            "flock->fl_start",
            "length",
            "type",
            "1",
            "0",
            "wait_flag"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Set no oplock for inode=%p due to mand locks\\n\"",
            "inode"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_zap_mapping",
          "args": [
            "inode"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "CIFS_I(inode)"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_WRITE",
          "args": [
            "CIFS_I(inode)"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lock"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_lock_add_if",
          "args": [
            "cfile",
            "lock",
            "wait_flag"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_lock_add_if",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "942-981",
          "snippet": "static int\ncifs_lock_add_if(struct cifsFileInfo *cfile, struct cifsLockInfo *lock,\n\t\t bool wait)\n{\n\tstruct cifsLockInfo *conf_lock;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tbool exist;\n\tint rc = 0;\n\ntry_again:\n\texist = false;\n\tdown_write(&cinode->lock_sem);\n\n\texist = cifs_find_lock_conflict(cfile, lock->offset, lock->length,\n\t\t\t\t\tlock->type, &conf_lock, CIFS_LOCK_OP);\n\tif (!exist && cinode->can_cache_brlcks) {\n\t\tlist_add_tail(&lock->llist, &cfile->llist->locks);\n\t\tup_write(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n\tif (!exist)\n\t\trc = 1;\n\telse if (!wait)\n\t\trc = -EACCES;\n\telse {\n\t\tlist_add_tail(&lock->blist, &conf_lock->blist);\n\t\tup_write(&cinode->lock_sem);\n\t\trc = wait_event_interruptible(lock->block_q,\n\t\t\t\t\t(lock->blist.prev == &lock->blist) &&\n\t\t\t\t\t(lock->blist.next == &lock->blist));\n\t\tif (!rc)\n\t\t\tgoto try_again;\n\t\tdown_write(&cinode->lock_sem);\n\t\tlist_del_init(&lock->blist);\n\t}\n\n\tup_write(&cinode->lock_sem);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define CIFS_LOCK_OP\t0"
          ],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\n#define CIFS_LOCK_OP\t0\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_lock_add_if(struct cifsFileInfo *cfile, struct cifsLockInfo *lock,\n\t\t bool wait)\n{\n\tstruct cifsLockInfo *conf_lock;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tbool exist;\n\tint rc = 0;\n\ntry_again:\n\texist = false;\n\tdown_write(&cinode->lock_sem);\n\n\texist = cifs_find_lock_conflict(cfile, lock->offset, lock->length,\n\t\t\t\t\tlock->type, &conf_lock, CIFS_LOCK_OP);\n\tif (!exist && cinode->can_cache_brlcks) {\n\t\tlist_add_tail(&lock->llist, &cfile->llist->locks);\n\t\tup_write(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n\tif (!exist)\n\t\trc = 1;\n\telse if (!wait)\n\t\trc = -EACCES;\n\telse {\n\t\tlist_add_tail(&lock->blist, &conf_lock->blist);\n\t\tup_write(&cinode->lock_sem);\n\t\trc = wait_event_interruptible(lock->block_q,\n\t\t\t\t\t(lock->blist.prev == &lock->blist) &&\n\t\t\t\t\t(lock->blist.next == &lock->blist));\n\t\tif (!rc)\n\t\t\tgoto try_again;\n\t\tdown_write(&cinode->lock_sem);\n\t\tlist_del_init(&lock->blist);\n\t}\n\n\tup_write(&cinode->lock_sem);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_lock_init",
          "args": [
            "flock->fl_start",
            "length",
            "type"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_lock_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "808-822",
          "snippet": "static struct cifsLockInfo *\ncifs_lock_init(__u64 offset, __u64 length, __u8 type)\n{\n\tstruct cifsLockInfo *lock =\n\t\tkmalloc(sizeof(struct cifsLockInfo), GFP_KERNEL);\n\tif (!lock)\n\t\treturn lock;\n\tlock->offset = offset;\n\tlock->length = length;\n\tlock->type = type;\n\tlock->pid = current->tgid;\n\tINIT_LIST_HEAD(&lock->blist);\n\tinit_waitqueue_head(&lock->block_q);\n\treturn lock;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic struct cifsLockInfo *\ncifs_lock_init(__u64 offset, __u64 length, __u8 type)\n{\n\tstruct cifsLockInfo *lock =\n\t\tkmalloc(sizeof(struct cifsLockInfo), GFP_KERNEL);\n\tif (!lock)\n\t\treturn lock;\n\tlock->offset = offset;\n\tlock->length = length;\n\tlock->type = type;\n\tlock->pid = current->tgid;\n\tINIT_LIST_HEAD(&lock->blist);\n\tinit_waitqueue_head(&lock->block_q);\n\treturn lock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBPosixLock",
          "args": [
            "xid",
            "tcon",
            "cfile->fid.netfid",
            "current->tgid",
            "flock->fl_start",
            "length",
            "NULL",
            "posix_lock_type",
            "wait_flag"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBPosixLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2377-2507",
          "snippet": "int\nCIFSSMBPosixLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tconst __u16 smb_file_id, const __u32 netpid,\n\t\tconst loff_t start_offset, const __u64 len,\n\t\tstruct file_lock *pLockData, const __u16 lock_type,\n\t\tconst bool waitFlag)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\n\tstruct cifs_posix_lock *parm_data;\n\tint rc = 0;\n\tint timeout = 0;\n\tint bytes_returned = 0;\n\tint resp_buf_type = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tstruct kvec iov[1];\n\n\tcifs_dbg(FYI, \"Posix Lock\\n\");\n\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)pSMB;\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tcount = sizeof(struct cifs_posix_lock);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000); /* BB find max SMB from sess */\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tif (pLockData)\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\telse\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tparm_data = (struct cifs_posix_lock *)\n\t\t\t(((char *) &pSMB->hdr.Protocol) + offset);\n\n\tparm_data->lock_type = cpu_to_le16(lock_type);\n\tif (waitFlag) {\n\t\ttimeout = CIFS_BLOCKING_OP; /* blocking operation, no timeout */\n\t\tparm_data->lock_flags = cpu_to_le16(1);\n\t\tpSMB->Timeout = cpu_to_le32(-1);\n\t} else\n\t\tpSMB->Timeout = 0;\n\n\tparm_data->pid = cpu_to_le32(netpid);\n\tparm_data->start = cpu_to_le64(start_offset);\n\tparm_data->length = cpu_to_le64(len);  /* normalize negative numbers */\n\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = smb_file_id;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_POSIX_LOCK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned);\n\t} else {\n\t\tiov[0].iov_base = (char *)pSMB;\n\t\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\t\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,\n\t\t\t\t&resp_buf_type, timeout);\n\t\tpSMB = NULL; /* request buf already freed by SendReceive2. Do\n\t\t\t\tnot try to free it twice below on exit */\n\t\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)iov[0].iov_base;\n\t}\n\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in Posix Lock = %d\\n\", rc);\n\t} else if (pLockData) {\n\t\t/* lock structure can be returned on get */\n\t\t__u16 data_offset;\n\t\t__u16 data_count;\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(*parm_data)) {\n\t\t\trc = -EIO;      /* bad smb */\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tdata_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\tdata_count  = le16_to_cpu(pSMBr->t2.DataCount);\n\t\tif (data_count < sizeof(struct cifs_posix_lock)) {\n\t\t\trc = -EIO;\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tparm_data = (struct cifs_posix_lock *)\n\t\t\t((char *)&pSMBr->hdr.Protocol + data_offset);\n\t\tif (parm_data->lock_type == cpu_to_le16(CIFS_UNLCK))\n\t\t\tpLockData->fl_type = F_UNLCK;\n\t\telse {\n\t\t\tif (parm_data->lock_type ==\n\t\t\t\t\tcpu_to_le16(CIFS_RDLCK))\n\t\t\t\tpLockData->fl_type = F_RDLCK;\n\t\t\telse if (parm_data->lock_type ==\n\t\t\t\t\tcpu_to_le16(CIFS_WRLCK))\n\t\t\t\tpLockData->fl_type = F_WRLCK;\n\n\t\t\tpLockData->fl_start = le64_to_cpu(parm_data->start);\n\t\t\tpLockData->fl_end = pLockData->fl_start +\n\t\t\t\t\tle64_to_cpu(parm_data->length) - 1;\n\t\t\tpLockData->fl_pid = le32_to_cpu(parm_data->pid);\n\t\t}\n\t}\n\nplk_err_exit:\n\tif (pSMB)\n\t\tcifs_small_buf_release(pSMB);\n\n\tfree_rsp_buf(resp_buf_type, iov[0].iov_base);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t   since file handle passed in no longer valid */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBPosixLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tconst __u16 smb_file_id, const __u32 netpid,\n\t\tconst loff_t start_offset, const __u64 len,\n\t\tstruct file_lock *pLockData, const __u16 lock_type,\n\t\tconst bool waitFlag)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\n\tstruct cifs_posix_lock *parm_data;\n\tint rc = 0;\n\tint timeout = 0;\n\tint bytes_returned = 0;\n\tint resp_buf_type = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tstruct kvec iov[1];\n\n\tcifs_dbg(FYI, \"Posix Lock\\n\");\n\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)pSMB;\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tcount = sizeof(struct cifs_posix_lock);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000); /* BB find max SMB from sess */\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tif (pLockData)\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\telse\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tparm_data = (struct cifs_posix_lock *)\n\t\t\t(((char *) &pSMB->hdr.Protocol) + offset);\n\n\tparm_data->lock_type = cpu_to_le16(lock_type);\n\tif (waitFlag) {\n\t\ttimeout = CIFS_BLOCKING_OP; /* blocking operation, no timeout */\n\t\tparm_data->lock_flags = cpu_to_le16(1);\n\t\tpSMB->Timeout = cpu_to_le32(-1);\n\t} else\n\t\tpSMB->Timeout = 0;\n\n\tparm_data->pid = cpu_to_le32(netpid);\n\tparm_data->start = cpu_to_le64(start_offset);\n\tparm_data->length = cpu_to_le64(len);  /* normalize negative numbers */\n\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = smb_file_id;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_POSIX_LOCK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned);\n\t} else {\n\t\tiov[0].iov_base = (char *)pSMB;\n\t\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\t\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,\n\t\t\t\t&resp_buf_type, timeout);\n\t\tpSMB = NULL; /* request buf already freed by SendReceive2. Do\n\t\t\t\tnot try to free it twice below on exit */\n\t\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)iov[0].iov_base;\n\t}\n\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in Posix Lock = %d\\n\", rc);\n\t} else if (pLockData) {\n\t\t/* lock structure can be returned on get */\n\t\t__u16 data_offset;\n\t\t__u16 data_count;\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(*parm_data)) {\n\t\t\trc = -EIO;      /* bad smb */\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tdata_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\tdata_count  = le16_to_cpu(pSMBr->t2.DataCount);\n\t\tif (data_count < sizeof(struct cifs_posix_lock)) {\n\t\t\trc = -EIO;\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tparm_data = (struct cifs_posix_lock *)\n\t\t\t((char *)&pSMBr->hdr.Protocol + data_offset);\n\t\tif (parm_data->lock_type == cpu_to_le16(CIFS_UNLCK))\n\t\t\tpLockData->fl_type = F_UNLCK;\n\t\telse {\n\t\t\tif (parm_data->lock_type ==\n\t\t\t\t\tcpu_to_le16(CIFS_RDLCK))\n\t\t\t\tpLockData->fl_type = F_RDLCK;\n\t\t\telse if (parm_data->lock_type ==\n\t\t\t\t\tcpu_to_le16(CIFS_WRLCK))\n\t\t\t\tpLockData->fl_type = F_WRLCK;\n\n\t\t\tpLockData->fl_start = le64_to_cpu(parm_data->start);\n\t\t\tpLockData->fl_end = pLockData->fl_start +\n\t\t\t\t\tle64_to_cpu(parm_data->length) - 1;\n\t\t\tpLockData->fl_pid = le32_to_cpu(parm_data->pid);\n\t\t}\n\t}\n\nplk_err_exit:\n\tif (pSMB)\n\t\tcifs_small_buf_release(pSMB);\n\n\tfree_rsp_buf(resp_buf_type, iov[0].iov_base);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t   since file handle passed in no longer valid */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_posix_lock_set",
          "args": [
            "file",
            "flock"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_posix_lock_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1018-1043",
          "snippet": "static int\ncifs_posix_lock_set(struct file *file, struct file_lock *flock)\n{\n\tstruct cifsInodeInfo *cinode = CIFS_I(file_inode(file));\n\tint rc = 1;\n\n\tif ((flock->fl_flags & FL_POSIX) == 0)\n\t\treturn rc;\n\ntry_again:\n\tdown_write(&cinode->lock_sem);\n\tif (!cinode->can_cache_brlcks) {\n\t\tup_write(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n\trc = posix_lock_file(file, flock, NULL);\n\tup_write(&cinode->lock_sem);\n\tif (rc == FILE_LOCK_DEFERRED) {\n\t\trc = wait_event_interruptible(flock->fl_wait, !flock->fl_next);\n\t\tif (!rc)\n\t\t\tgoto try_again;\n\t\tposix_unblock_lock(flock);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_posix_lock_set(struct file *file, struct file_lock *flock)\n{\n\tstruct cifsInodeInfo *cinode = CIFS_I(file_inode(file));\n\tint rc = 1;\n\n\tif ((flock->fl_flags & FL_POSIX) == 0)\n\t\treturn rc;\n\ntry_again:\n\tdown_write(&cinode->lock_sem);\n\tif (!cinode->can_cache_brlcks) {\n\t\tup_write(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n\trc = posix_lock_file(file, flock, NULL);\n\tup_write(&cinode->lock_sem);\n\tif (rc == FILE_LOCK_DEFERRED) {\n\t\trc = wait_event_interruptible(flock->fl_wait, !flock->fl_next);\n\t\tif (!rc)\n\t\t\tgoto try_again;\n\t\tposix_unblock_lock(flock);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_setlk(struct file *file, struct file_lock *flock, __u32 type,\n\t   bool wait_flag, bool posix_lck, int lock, int unlock,\n\t   unsigned int xid)\n{\n\tint rc = 0;\n\t__u64 length = 1 + flock->fl_end - flock->fl_start;\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)file->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct inode *inode = cfile->dentry->d_inode;\n\n\tif (posix_lck) {\n\t\tint posix_lock_type;\n\n\t\trc = cifs_posix_lock_set(file, flock);\n\t\tif (!rc || rc < 0)\n\t\t\treturn rc;\n\n\t\tif (type & server->vals->shared_lock_type)\n\t\t\tposix_lock_type = CIFS_RDLCK;\n\t\telse\n\t\t\tposix_lock_type = CIFS_WRLCK;\n\n\t\tif (unlock == 1)\n\t\t\tposix_lock_type = CIFS_UNLCK;\n\n\t\trc = CIFSSMBPosixLock(xid, tcon, cfile->fid.netfid,\n\t\t\t\t      current->tgid, flock->fl_start, length,\n\t\t\t\t      NULL, posix_lock_type, wait_flag);\n\t\tgoto out;\n\t}\n\n\tif (lock) {\n\t\tstruct cifsLockInfo *lock;\n\n\t\tlock = cifs_lock_init(flock->fl_start, length, type);\n\t\tif (!lock)\n\t\t\treturn -ENOMEM;\n\n\t\trc = cifs_lock_add_if(cfile, lock, wait_flag);\n\t\tif (rc < 0) {\n\t\t\tkfree(lock);\n\t\t\treturn rc;\n\t\t}\n\t\tif (!rc)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Windows 7 server can delay breaking lease from read to None\n\t\t * if we set a byte-range lock on a file - break it explicitly\n\t\t * before sending the lock to the server to be sure the next\n\t\t * read won't conflict with non-overlapted locks due to\n\t\t * pagereading.\n\t\t */\n\t\tif (!CIFS_CACHE_WRITE(CIFS_I(inode)) &&\n\t\t\t\t\tCIFS_CACHE_READ(CIFS_I(inode))) {\n\t\t\tcifs_zap_mapping(inode);\n\t\t\tcifs_dbg(FYI, \"Set no oplock for inode=%p due to mand locks\\n\",\n\t\t\t\t inode);\n\t\t\tCIFS_I(inode)->oplock = 0;\n\t\t}\n\n\t\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\t\t\t    type, 1, 0, wait_flag);\n\t\tif (rc) {\n\t\t\tkfree(lock);\n\t\t\treturn rc;\n\t\t}\n\n\t\tcifs_lock_add(cfile, lock);\n\t} else if (unlock)\n\t\trc = server->ops->mand_unlock_range(cfile, flock, xid);\n\nout:\n\tif (flock->fl_flags & FL_POSIX)\n\t\tposix_lock_file_wait(file, flock);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_unlock_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "1374-1479",
    "snippet": "int\ncifs_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,\n\t\t  unsigned int xid)\n{\n\tint rc = 0, stored_rc;\n\tint types[] = {LOCKING_ANDX_LARGE_FILES,\n\t\t       LOCKING_ANDX_SHARED_LOCK | LOCKING_ANDX_LARGE_FILES};\n\tunsigned int i;\n\tunsigned int max_num, num, max_buf;\n\tLOCKING_ANDX_RANGE *buf, *cur;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct cifsLockInfo *li, *tmp;\n\t__u64 length = 1 + flock->fl_end - flock->fl_start;\n\tstruct list_head tmp_llist;\n\n\tINIT_LIST_HEAD(&tmp_llist);\n\n\t/*\n\t * Accessing maxBuf is racy with cifs_reconnect - need to store value\n\t * and check it for zero before using.\n\t */\n\tmax_buf = tcon->ses->server->maxBuf;\n\tif (!max_buf)\n\t\treturn -EINVAL;\n\n\tmax_num = (max_buf - sizeof(struct smb_hdr)) /\n\t\t\t\t\t\tsizeof(LOCKING_ANDX_RANGE);\n\tbuf = kcalloc(max_num, sizeof(LOCKING_ANDX_RANGE), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tdown_write(&cinode->lock_sem);\n\tfor (i = 0; i < 2; i++) {\n\t\tcur = buf;\n\t\tnum = 0;\n\t\tlist_for_each_entry_safe(li, tmp, &cfile->llist->locks, llist) {\n\t\t\tif (flock->fl_start > li->offset ||\n\t\t\t    (flock->fl_start + length) <\n\t\t\t    (li->offset + li->length))\n\t\t\t\tcontinue;\n\t\t\tif (current->tgid != li->pid)\n\t\t\t\tcontinue;\n\t\t\tif (types[i] != li->type)\n\t\t\t\tcontinue;\n\t\t\tif (cinode->can_cache_brlcks) {\n\t\t\t\t/*\n\t\t\t\t * We can cache brlock requests - simply remove\n\t\t\t\t * a lock from the file's list.\n\t\t\t\t */\n\t\t\t\tlist_del(&li->llist);\n\t\t\t\tcifs_del_lock_waiters(li);\n\t\t\t\tkfree(li);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcur->Pid = cpu_to_le16(li->pid);\n\t\t\tcur->LengthLow = cpu_to_le32((u32)li->length);\n\t\t\tcur->LengthHigh = cpu_to_le32((u32)(li->length>>32));\n\t\t\tcur->OffsetLow = cpu_to_le32((u32)li->offset);\n\t\t\tcur->OffsetHigh = cpu_to_le32((u32)(li->offset>>32));\n\t\t\t/*\n\t\t\t * We need to save a lock here to let us add it again to\n\t\t\t * the file's list if the unlock range request fails on\n\t\t\t * the server.\n\t\t\t */\n\t\t\tlist_move(&li->llist, &tmp_llist);\n\t\t\tif (++num == max_num) {\n\t\t\t\tstored_rc = cifs_lockv(xid, tcon,\n\t\t\t\t\t\t       cfile->fid.netfid,\n\t\t\t\t\t\t       li->type, num, 0, buf);\n\t\t\t\tif (stored_rc) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We failed on the unlock range\n\t\t\t\t\t * request - add all locks from the tmp\n\t\t\t\t\t * list to the head of the file's list.\n\t\t\t\t\t */\n\t\t\t\t\tcifs_move_llist(&tmp_llist,\n\t\t\t\t\t\t\t&cfile->llist->locks);\n\t\t\t\t\trc = stored_rc;\n\t\t\t\t} else\n\t\t\t\t\t/*\n\t\t\t\t\t * The unlock range request succeed -\n\t\t\t\t\t * free the tmp list.\n\t\t\t\t\t */\n\t\t\t\t\tcifs_free_llist(&tmp_llist);\n\t\t\t\tcur = buf;\n\t\t\t\tnum = 0;\n\t\t\t} else\n\t\t\t\tcur++;\n\t\t}\n\t\tif (num) {\n\t\t\tstored_rc = cifs_lockv(xid, tcon, cfile->fid.netfid,\n\t\t\t\t\t       types[i], num, 0, buf);\n\t\t\tif (stored_rc) {\n\t\t\t\tcifs_move_llist(&tmp_llist,\n\t\t\t\t\t\t&cfile->llist->locks);\n\t\t\t\trc = stored_rc;\n\t\t\t} else\n\t\t\t\tcifs_free_llist(&tmp_llist);\n\t\t}\n\t}\n\n\tup_write(&cinode->lock_sem);\n\tkfree(buf);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_free_llist",
          "args": [
            "&tmp_llist"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_free_llist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1363-1372",
          "snippet": "void\ncifs_free_llist(struct list_head *llist)\n{\n\tstruct cifsLockInfo *li, *tmp;\n\tlist_for_each_entry_safe(li, tmp, llist, llist) {\n\t\tcifs_del_lock_waiters(li);\n\t\tlist_del(&li->llist);\n\t\tkfree(li);\n\t}\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid\ncifs_free_llist(struct list_head *llist)\n{\n\tstruct cifsLockInfo *li, *tmp;\n\tlist_for_each_entry_safe(li, tmp, llist, llist) {\n\t\tcifs_del_lock_waiters(li);\n\t\tlist_del(&li->llist);\n\t\tkfree(li);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_move_llist",
          "args": [
            "&tmp_llist",
            "&cfile->llist->locks"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_move_llist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1355-1361",
          "snippet": "void\ncifs_move_llist(struct list_head *source, struct list_head *dest)\n{\n\tstruct list_head *li, *tmp;\n\tlist_for_each_safe(li, tmp, source)\n\t\tlist_move(li, dest);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid\ncifs_move_llist(struct list_head *source, struct list_head *dest)\n{\n\tstruct list_head *li, *tmp;\n\tlist_for_each_safe(li, tmp, source)\n\t\tlist_move(li, dest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_lockv",
          "args": [
            "xid",
            "tcon",
            "cfile->fid.netfid",
            "types[i]",
            "num",
            "0",
            "buf"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_lockv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2264-2304",
          "snippet": "int cifs_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t       const __u16 netfid, const __u8 lock_type, const __u32 num_unlock,\n\t       const __u32 num_lock, LOCKING_ANDX_RANGE *buf)\n{\n\tint rc = 0;\n\tLOCK_REQ *pSMB = NULL;\n\tstruct kvec iov[2];\n\tint resp_buf_type;\n\t__u16 count;\n\n\tcifs_dbg(FYI, \"cifs_lockv num lock %d num unlock %d\\n\",\n\t\t num_lock, num_unlock);\n\n\trc = small_smb_init(SMB_COM_LOCKING_ANDX, 8, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->Timeout = 0;\n\tpSMB->NumberOfLocks = cpu_to_le16(num_lock);\n\tpSMB->NumberOfUnlocks = cpu_to_le16(num_unlock);\n\tpSMB->LockType = lock_type;\n\tpSMB->AndXCommand = 0xFF; /* none */\n\tpSMB->Fid = netfid; /* netfid stays le */\n\n\tcount = (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4 -\n\t\t\t (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\tiov[1].iov_base = (char *)buf;\n\tiov[1].iov_len = (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\trc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type, CIFS_NO_RESP);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in cifs_lockv = %d\\n\", rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint cifs_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t       const __u16 netfid, const __u8 lock_type, const __u32 num_unlock,\n\t       const __u32 num_lock, LOCKING_ANDX_RANGE *buf)\n{\n\tint rc = 0;\n\tLOCK_REQ *pSMB = NULL;\n\tstruct kvec iov[2];\n\tint resp_buf_type;\n\t__u16 count;\n\n\tcifs_dbg(FYI, \"cifs_lockv num lock %d num unlock %d\\n\",\n\t\t num_lock, num_unlock);\n\n\trc = small_smb_init(SMB_COM_LOCKING_ANDX, 8, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->Timeout = 0;\n\tpSMB->NumberOfLocks = cpu_to_le16(num_lock);\n\tpSMB->NumberOfUnlocks = cpu_to_le16(num_unlock);\n\tpSMB->LockType = lock_type;\n\tpSMB->AndXCommand = 0xFF; /* none */\n\tpSMB->Fid = netfid; /* netfid stays le */\n\n\tcount = (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4 -\n\t\t\t (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\tiov[1].iov_base = (char *)buf;\n\tiov[1].iov_len = (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\trc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type, CIFS_NO_RESP);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in cifs_lockv = %d\\n\", rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&li->llist",
            "&tmp_llist"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)(li->offset>>32)"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "li->offset>>32"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)li->offset"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)(li->length>>32)"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "li->length>>32"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)li->length"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "li->pid"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "li"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_del_lock_waiters",
          "args": [
            "li"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_del_lock_waiters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "824-832",
          "snippet": "void\ncifs_del_lock_waiters(struct cifsLockInfo *lock)\n{\n\tstruct cifsLockInfo *li, *tmp;\n\tlist_for_each_entry_safe(li, tmp, &lock->blist, blist) {\n\t\tlist_del_init(&li->blist);\n\t\twake_up(&li->block_q);\n\t}\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid\ncifs_del_lock_waiters(struct cifsLockInfo *lock)\n{\n\tstruct cifsLockInfo *li, *tmp;\n\tlist_for_each_entry_safe(li, tmp, &lock->blist, blist) {\n\t\tlist_del_init(&li->blist);\n\t\twake_up(&li->block_q);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&li->llist"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "li",
            "tmp",
            "&cfile->llist->locks",
            "llist"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "max_num",
            "sizeof(LOCKING_ANDX_RANGE)",
            "GFP_KERNEL"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tmp_llist"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "cfile->dentry->d_inode"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nint\ncifs_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,\n\t\t  unsigned int xid)\n{\n\tint rc = 0, stored_rc;\n\tint types[] = {LOCKING_ANDX_LARGE_FILES,\n\t\t       LOCKING_ANDX_SHARED_LOCK | LOCKING_ANDX_LARGE_FILES};\n\tunsigned int i;\n\tunsigned int max_num, num, max_buf;\n\tLOCKING_ANDX_RANGE *buf, *cur;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct cifsLockInfo *li, *tmp;\n\t__u64 length = 1 + flock->fl_end - flock->fl_start;\n\tstruct list_head tmp_llist;\n\n\tINIT_LIST_HEAD(&tmp_llist);\n\n\t/*\n\t * Accessing maxBuf is racy with cifs_reconnect - need to store value\n\t * and check it for zero before using.\n\t */\n\tmax_buf = tcon->ses->server->maxBuf;\n\tif (!max_buf)\n\t\treturn -EINVAL;\n\n\tmax_num = (max_buf - sizeof(struct smb_hdr)) /\n\t\t\t\t\t\tsizeof(LOCKING_ANDX_RANGE);\n\tbuf = kcalloc(max_num, sizeof(LOCKING_ANDX_RANGE), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tdown_write(&cinode->lock_sem);\n\tfor (i = 0; i < 2; i++) {\n\t\tcur = buf;\n\t\tnum = 0;\n\t\tlist_for_each_entry_safe(li, tmp, &cfile->llist->locks, llist) {\n\t\t\tif (flock->fl_start > li->offset ||\n\t\t\t    (flock->fl_start + length) <\n\t\t\t    (li->offset + li->length))\n\t\t\t\tcontinue;\n\t\t\tif (current->tgid != li->pid)\n\t\t\t\tcontinue;\n\t\t\tif (types[i] != li->type)\n\t\t\t\tcontinue;\n\t\t\tif (cinode->can_cache_brlcks) {\n\t\t\t\t/*\n\t\t\t\t * We can cache brlock requests - simply remove\n\t\t\t\t * a lock from the file's list.\n\t\t\t\t */\n\t\t\t\tlist_del(&li->llist);\n\t\t\t\tcifs_del_lock_waiters(li);\n\t\t\t\tkfree(li);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcur->Pid = cpu_to_le16(li->pid);\n\t\t\tcur->LengthLow = cpu_to_le32((u32)li->length);\n\t\t\tcur->LengthHigh = cpu_to_le32((u32)(li->length>>32));\n\t\t\tcur->OffsetLow = cpu_to_le32((u32)li->offset);\n\t\t\tcur->OffsetHigh = cpu_to_le32((u32)(li->offset>>32));\n\t\t\t/*\n\t\t\t * We need to save a lock here to let us add it again to\n\t\t\t * the file's list if the unlock range request fails on\n\t\t\t * the server.\n\t\t\t */\n\t\t\tlist_move(&li->llist, &tmp_llist);\n\t\t\tif (++num == max_num) {\n\t\t\t\tstored_rc = cifs_lockv(xid, tcon,\n\t\t\t\t\t\t       cfile->fid.netfid,\n\t\t\t\t\t\t       li->type, num, 0, buf);\n\t\t\t\tif (stored_rc) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We failed on the unlock range\n\t\t\t\t\t * request - add all locks from the tmp\n\t\t\t\t\t * list to the head of the file's list.\n\t\t\t\t\t */\n\t\t\t\t\tcifs_move_llist(&tmp_llist,\n\t\t\t\t\t\t\t&cfile->llist->locks);\n\t\t\t\t\trc = stored_rc;\n\t\t\t\t} else\n\t\t\t\t\t/*\n\t\t\t\t\t * The unlock range request succeed -\n\t\t\t\t\t * free the tmp list.\n\t\t\t\t\t */\n\t\t\t\t\tcifs_free_llist(&tmp_llist);\n\t\t\t\tcur = buf;\n\t\t\t\tnum = 0;\n\t\t\t} else\n\t\t\t\tcur++;\n\t\t}\n\t\tif (num) {\n\t\t\tstored_rc = cifs_lockv(xid, tcon, cfile->fid.netfid,\n\t\t\t\t\t       types[i], num, 0, buf);\n\t\t\tif (stored_rc) {\n\t\t\t\tcifs_move_llist(&tmp_llist,\n\t\t\t\t\t\t&cfile->llist->locks);\n\t\t\t\trc = stored_rc;\n\t\t\t} else\n\t\t\t\tcifs_free_llist(&tmp_llist);\n\t\t}\n\t}\n\n\tup_write(&cinode->lock_sem);\n\tkfree(buf);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_free_llist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "1363-1372",
    "snippet": "void\ncifs_free_llist(struct list_head *llist)\n{\n\tstruct cifsLockInfo *li, *tmp;\n\tlist_for_each_entry_safe(li, tmp, llist, llist) {\n\t\tcifs_del_lock_waiters(li);\n\t\tlist_del(&li->llist);\n\t\tkfree(li);\n\t}\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "li"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&li->llist"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_del_lock_waiters",
          "args": [
            "li"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_del_lock_waiters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "824-832",
          "snippet": "void\ncifs_del_lock_waiters(struct cifsLockInfo *lock)\n{\n\tstruct cifsLockInfo *li, *tmp;\n\tlist_for_each_entry_safe(li, tmp, &lock->blist, blist) {\n\t\tlist_del_init(&li->blist);\n\t\twake_up(&li->block_q);\n\t}\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid\ncifs_del_lock_waiters(struct cifsLockInfo *lock)\n{\n\tstruct cifsLockInfo *li, *tmp;\n\tlist_for_each_entry_safe(li, tmp, &lock->blist, blist) {\n\t\tlist_del_init(&li->blist);\n\t\twake_up(&li->block_q);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "li",
            "tmp",
            "llist",
            "llist"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid\ncifs_free_llist(struct list_head *llist)\n{\n\tstruct cifsLockInfo *li, *tmp;\n\tlist_for_each_entry_safe(li, tmp, llist, llist) {\n\t\tcifs_del_lock_waiters(li);\n\t\tlist_del(&li->llist);\n\t\tkfree(li);\n\t}\n}"
  },
  {
    "function_name": "cifs_move_llist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "1355-1361",
    "snippet": "void\ncifs_move_llist(struct list_head *source, struct list_head *dest)\n{\n\tstruct list_head *li, *tmp;\n\tlist_for_each_safe(li, tmp, source)\n\t\tlist_move(li, dest);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "li",
            "dest"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "li",
            "tmp",
            "source"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid\ncifs_move_llist(struct list_head *source, struct list_head *dest)\n{\n\tstruct list_head *li, *tmp;\n\tlist_for_each_safe(li, tmp, source)\n\t\tlist_move(li, dest);\n}"
  },
  {
    "function_name": "cifs_getlk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "1287-1353",
    "snippet": "static int\ncifs_getlk(struct file *file, struct file_lock *flock, __u32 type,\n\t   bool wait_flag, bool posix_lck, unsigned int xid)\n{\n\tint rc = 0;\n\t__u64 length = 1 + flock->fl_end - flock->fl_start;\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)file->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t__u16 netfid = cfile->fid.netfid;\n\n\tif (posix_lck) {\n\t\tint posix_lock_type;\n\n\t\trc = cifs_posix_lock_test(file, flock);\n\t\tif (!rc)\n\t\t\treturn rc;\n\n\t\tif (type & server->vals->shared_lock_type)\n\t\t\tposix_lock_type = CIFS_RDLCK;\n\t\telse\n\t\t\tposix_lock_type = CIFS_WRLCK;\n\t\trc = CIFSSMBPosixLock(xid, tcon, netfid, current->tgid,\n\t\t\t\t      flock->fl_start, length, flock,\n\t\t\t\t      posix_lock_type, wait_flag);\n\t\treturn rc;\n\t}\n\n\trc = cifs_lock_test(cfile, flock->fl_start, length, type, flock);\n\tif (!rc)\n\t\treturn rc;\n\n\t/* BB we could chain these into one lock request BB */\n\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length, type,\n\t\t\t\t    1, 0, false);\n\tif (rc == 0) {\n\t\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\t\t\t    type, 0, 1, false);\n\t\tflock->fl_type = F_UNLCK;\n\t\tif (rc != 0)\n\t\t\tcifs_dbg(VFS, \"Error unlocking previously locked range %d during test of lock\\n\",\n\t\t\t\t rc);\n\t\treturn 0;\n\t}\n\n\tif (type & server->vals->shared_lock_type) {\n\t\tflock->fl_type = F_WRLCK;\n\t\treturn 0;\n\t}\n\n\ttype &= ~server->vals->exclusive_lock_type;\n\n\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\t\t    type | server->vals->shared_lock_type,\n\t\t\t\t    1, 0, false);\n\tif (rc == 0) {\n\t\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\ttype | server->vals->shared_lock_type, 0, 1, false);\n\t\tflock->fl_type = F_RDLCK;\n\t\tif (rc != 0)\n\t\t\tcifs_dbg(VFS, \"Error unlocking previously locked range %d during test of lock\\n\",\n\t\t\t\t rc);\n\t} else\n\t\tflock->fl_type = F_WRLCK;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Error unlocking previously locked range %d during test of lock\\n\"",
            "rc"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->mand_lock",
          "args": [
            "xid",
            "cfile",
            "flock->fl_start",
            "length",
            "type | server->vals->shared_lock_type",
            "0",
            "1",
            "false"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->mand_lock",
          "args": [
            "xid",
            "cfile",
            "flock->fl_start",
            "length",
            "type | server->vals->shared_lock_type",
            "1",
            "0",
            "false"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Error unlocking previously locked range %d during test of lock\\n\"",
            "rc"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->mand_lock",
          "args": [
            "xid",
            "cfile",
            "flock->fl_start",
            "length",
            "type",
            "0",
            "1",
            "false"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->mand_lock",
          "args": [
            "xid",
            "cfile",
            "flock->fl_start",
            "length",
            "type",
            "1",
            "0",
            "false"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_lock_test",
          "args": [
            "cfile",
            "flock->fl_start",
            "length",
            "type",
            "flock"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_lock_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "896-925",
          "snippet": "static int\ncifs_lock_test(struct cifsFileInfo *cfile, __u64 offset, __u64 length,\n\t       __u8 type, struct file_lock *flock)\n{\n\tint rc = 0;\n\tstruct cifsLockInfo *conf_lock;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;\n\tbool exist;\n\n\tdown_read(&cinode->lock_sem);\n\n\texist = cifs_find_lock_conflict(cfile, offset, length, type,\n\t\t\t\t\t&conf_lock, CIFS_LOCK_OP);\n\tif (exist) {\n\t\tflock->fl_start = conf_lock->offset;\n\t\tflock->fl_end = conf_lock->offset + conf_lock->length - 1;\n\t\tflock->fl_pid = conf_lock->pid;\n\t\tif (conf_lock->type & server->vals->shared_lock_type)\n\t\t\tflock->fl_type = F_RDLCK;\n\t\telse\n\t\t\tflock->fl_type = F_WRLCK;\n\t} else if (!cinode->can_cache_brlcks)\n\t\trc = 1;\n\telse\n\t\tflock->fl_type = F_UNLCK;\n\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define CIFS_LOCK_OP\t0"
          ],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\n#define CIFS_LOCK_OP\t0\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_lock_test(struct cifsFileInfo *cfile, __u64 offset, __u64 length,\n\t       __u8 type, struct file_lock *flock)\n{\n\tint rc = 0;\n\tstruct cifsLockInfo *conf_lock;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;\n\tbool exist;\n\n\tdown_read(&cinode->lock_sem);\n\n\texist = cifs_find_lock_conflict(cfile, offset, length, type,\n\t\t\t\t\t&conf_lock, CIFS_LOCK_OP);\n\tif (exist) {\n\t\tflock->fl_start = conf_lock->offset;\n\t\tflock->fl_end = conf_lock->offset + conf_lock->length - 1;\n\t\tflock->fl_pid = conf_lock->pid;\n\t\tif (conf_lock->type & server->vals->shared_lock_type)\n\t\t\tflock->fl_type = F_RDLCK;\n\t\telse\n\t\t\tflock->fl_type = F_WRLCK;\n\t} else if (!cinode->can_cache_brlcks)\n\t\trc = 1;\n\telse\n\t\tflock->fl_type = F_UNLCK;\n\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBPosixLock",
          "args": [
            "xid",
            "tcon",
            "netfid",
            "current->tgid",
            "flock->fl_start",
            "length",
            "flock",
            "posix_lock_type",
            "wait_flag"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBPosixLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2377-2507",
          "snippet": "int\nCIFSSMBPosixLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tconst __u16 smb_file_id, const __u32 netpid,\n\t\tconst loff_t start_offset, const __u64 len,\n\t\tstruct file_lock *pLockData, const __u16 lock_type,\n\t\tconst bool waitFlag)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\n\tstruct cifs_posix_lock *parm_data;\n\tint rc = 0;\n\tint timeout = 0;\n\tint bytes_returned = 0;\n\tint resp_buf_type = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tstruct kvec iov[1];\n\n\tcifs_dbg(FYI, \"Posix Lock\\n\");\n\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)pSMB;\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tcount = sizeof(struct cifs_posix_lock);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000); /* BB find max SMB from sess */\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tif (pLockData)\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\telse\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tparm_data = (struct cifs_posix_lock *)\n\t\t\t(((char *) &pSMB->hdr.Protocol) + offset);\n\n\tparm_data->lock_type = cpu_to_le16(lock_type);\n\tif (waitFlag) {\n\t\ttimeout = CIFS_BLOCKING_OP; /* blocking operation, no timeout */\n\t\tparm_data->lock_flags = cpu_to_le16(1);\n\t\tpSMB->Timeout = cpu_to_le32(-1);\n\t} else\n\t\tpSMB->Timeout = 0;\n\n\tparm_data->pid = cpu_to_le32(netpid);\n\tparm_data->start = cpu_to_le64(start_offset);\n\tparm_data->length = cpu_to_le64(len);  /* normalize negative numbers */\n\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = smb_file_id;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_POSIX_LOCK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned);\n\t} else {\n\t\tiov[0].iov_base = (char *)pSMB;\n\t\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\t\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,\n\t\t\t\t&resp_buf_type, timeout);\n\t\tpSMB = NULL; /* request buf already freed by SendReceive2. Do\n\t\t\t\tnot try to free it twice below on exit */\n\t\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)iov[0].iov_base;\n\t}\n\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in Posix Lock = %d\\n\", rc);\n\t} else if (pLockData) {\n\t\t/* lock structure can be returned on get */\n\t\t__u16 data_offset;\n\t\t__u16 data_count;\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(*parm_data)) {\n\t\t\trc = -EIO;      /* bad smb */\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tdata_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\tdata_count  = le16_to_cpu(pSMBr->t2.DataCount);\n\t\tif (data_count < sizeof(struct cifs_posix_lock)) {\n\t\t\trc = -EIO;\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tparm_data = (struct cifs_posix_lock *)\n\t\t\t((char *)&pSMBr->hdr.Protocol + data_offset);\n\t\tif (parm_data->lock_type == cpu_to_le16(CIFS_UNLCK))\n\t\t\tpLockData->fl_type = F_UNLCK;\n\t\telse {\n\t\t\tif (parm_data->lock_type ==\n\t\t\t\t\tcpu_to_le16(CIFS_RDLCK))\n\t\t\t\tpLockData->fl_type = F_RDLCK;\n\t\t\telse if (parm_data->lock_type ==\n\t\t\t\t\tcpu_to_le16(CIFS_WRLCK))\n\t\t\t\tpLockData->fl_type = F_WRLCK;\n\n\t\t\tpLockData->fl_start = le64_to_cpu(parm_data->start);\n\t\t\tpLockData->fl_end = pLockData->fl_start +\n\t\t\t\t\tle64_to_cpu(parm_data->length) - 1;\n\t\t\tpLockData->fl_pid = le32_to_cpu(parm_data->pid);\n\t\t}\n\t}\n\nplk_err_exit:\n\tif (pSMB)\n\t\tcifs_small_buf_release(pSMB);\n\n\tfree_rsp_buf(resp_buf_type, iov[0].iov_base);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t   since file handle passed in no longer valid */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBPosixLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tconst __u16 smb_file_id, const __u32 netpid,\n\t\tconst loff_t start_offset, const __u64 len,\n\t\tstruct file_lock *pLockData, const __u16 lock_type,\n\t\tconst bool waitFlag)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\n\tstruct cifs_posix_lock *parm_data;\n\tint rc = 0;\n\tint timeout = 0;\n\tint bytes_returned = 0;\n\tint resp_buf_type = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tstruct kvec iov[1];\n\n\tcifs_dbg(FYI, \"Posix Lock\\n\");\n\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)pSMB;\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tcount = sizeof(struct cifs_posix_lock);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000); /* BB find max SMB from sess */\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tif (pLockData)\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\telse\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tparm_data = (struct cifs_posix_lock *)\n\t\t\t(((char *) &pSMB->hdr.Protocol) + offset);\n\n\tparm_data->lock_type = cpu_to_le16(lock_type);\n\tif (waitFlag) {\n\t\ttimeout = CIFS_BLOCKING_OP; /* blocking operation, no timeout */\n\t\tparm_data->lock_flags = cpu_to_le16(1);\n\t\tpSMB->Timeout = cpu_to_le32(-1);\n\t} else\n\t\tpSMB->Timeout = 0;\n\n\tparm_data->pid = cpu_to_le32(netpid);\n\tparm_data->start = cpu_to_le64(start_offset);\n\tparm_data->length = cpu_to_le64(len);  /* normalize negative numbers */\n\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = smb_file_id;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_POSIX_LOCK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned);\n\t} else {\n\t\tiov[0].iov_base = (char *)pSMB;\n\t\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\t\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,\n\t\t\t\t&resp_buf_type, timeout);\n\t\tpSMB = NULL; /* request buf already freed by SendReceive2. Do\n\t\t\t\tnot try to free it twice below on exit */\n\t\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)iov[0].iov_base;\n\t}\n\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in Posix Lock = %d\\n\", rc);\n\t} else if (pLockData) {\n\t\t/* lock structure can be returned on get */\n\t\t__u16 data_offset;\n\t\t__u16 data_count;\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(*parm_data)) {\n\t\t\trc = -EIO;      /* bad smb */\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tdata_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\tdata_count  = le16_to_cpu(pSMBr->t2.DataCount);\n\t\tif (data_count < sizeof(struct cifs_posix_lock)) {\n\t\t\trc = -EIO;\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tparm_data = (struct cifs_posix_lock *)\n\t\t\t((char *)&pSMBr->hdr.Protocol + data_offset);\n\t\tif (parm_data->lock_type == cpu_to_le16(CIFS_UNLCK))\n\t\t\tpLockData->fl_type = F_UNLCK;\n\t\telse {\n\t\t\tif (parm_data->lock_type ==\n\t\t\t\t\tcpu_to_le16(CIFS_RDLCK))\n\t\t\t\tpLockData->fl_type = F_RDLCK;\n\t\t\telse if (parm_data->lock_type ==\n\t\t\t\t\tcpu_to_le16(CIFS_WRLCK))\n\t\t\t\tpLockData->fl_type = F_WRLCK;\n\n\t\t\tpLockData->fl_start = le64_to_cpu(parm_data->start);\n\t\t\tpLockData->fl_end = pLockData->fl_start +\n\t\t\t\t\tle64_to_cpu(parm_data->length) - 1;\n\t\t\tpLockData->fl_pid = le32_to_cpu(parm_data->pid);\n\t\t}\n\t}\n\nplk_err_exit:\n\tif (pSMB)\n\t\tcifs_small_buf_release(pSMB);\n\n\tfree_rsp_buf(resp_buf_type, iov[0].iov_base);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t   since file handle passed in no longer valid */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_posix_lock_test",
          "args": [
            "file",
            "flock"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_posix_lock_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "990-1010",
          "snippet": "static int\ncifs_posix_lock_test(struct file *file, struct file_lock *flock)\n{\n\tint rc = 0;\n\tstruct cifsInodeInfo *cinode = CIFS_I(file_inode(file));\n\tunsigned char saved_type = flock->fl_type;\n\n\tif ((flock->fl_flags & FL_POSIX) == 0)\n\t\treturn 1;\n\n\tdown_read(&cinode->lock_sem);\n\tposix_test_lock(file, flock);\n\n\tif (flock->fl_type == F_UNLCK && !cinode->can_cache_brlcks) {\n\t\tflock->fl_type = saved_type;\n\t\trc = 1;\n\t}\n\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_posix_lock_test(struct file *file, struct file_lock *flock)\n{\n\tint rc = 0;\n\tstruct cifsInodeInfo *cinode = CIFS_I(file_inode(file));\n\tunsigned char saved_type = flock->fl_type;\n\n\tif ((flock->fl_flags & FL_POSIX) == 0)\n\t\treturn 1;\n\n\tdown_read(&cinode->lock_sem);\n\tposix_test_lock(file, flock);\n\n\tif (flock->fl_type == F_UNLCK && !cinode->can_cache_brlcks) {\n\t\tflock->fl_type = saved_type;\n\t\trc = 1;\n\t}\n\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_getlk(struct file *file, struct file_lock *flock, __u32 type,\n\t   bool wait_flag, bool posix_lck, unsigned int xid)\n{\n\tint rc = 0;\n\t__u64 length = 1 + flock->fl_end - flock->fl_start;\n\tstruct cifsFileInfo *cfile = (struct cifsFileInfo *)file->private_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t__u16 netfid = cfile->fid.netfid;\n\n\tif (posix_lck) {\n\t\tint posix_lock_type;\n\n\t\trc = cifs_posix_lock_test(file, flock);\n\t\tif (!rc)\n\t\t\treturn rc;\n\n\t\tif (type & server->vals->shared_lock_type)\n\t\t\tposix_lock_type = CIFS_RDLCK;\n\t\telse\n\t\t\tposix_lock_type = CIFS_WRLCK;\n\t\trc = CIFSSMBPosixLock(xid, tcon, netfid, current->tgid,\n\t\t\t\t      flock->fl_start, length, flock,\n\t\t\t\t      posix_lock_type, wait_flag);\n\t\treturn rc;\n\t}\n\n\trc = cifs_lock_test(cfile, flock->fl_start, length, type, flock);\n\tif (!rc)\n\t\treturn rc;\n\n\t/* BB we could chain these into one lock request BB */\n\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length, type,\n\t\t\t\t    1, 0, false);\n\tif (rc == 0) {\n\t\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\t\t\t    type, 0, 1, false);\n\t\tflock->fl_type = F_UNLCK;\n\t\tif (rc != 0)\n\t\t\tcifs_dbg(VFS, \"Error unlocking previously locked range %d during test of lock\\n\",\n\t\t\t\t rc);\n\t\treturn 0;\n\t}\n\n\tif (type & server->vals->shared_lock_type) {\n\t\tflock->fl_type = F_WRLCK;\n\t\treturn 0;\n\t}\n\n\ttype &= ~server->vals->exclusive_lock_type;\n\n\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\t\t    type | server->vals->shared_lock_type,\n\t\t\t\t    1, 0, false);\n\tif (rc == 0) {\n\t\trc = server->ops->mand_lock(xid, cfile, flock->fl_start, length,\n\t\t\ttype | server->vals->shared_lock_type, 0, 1, false);\n\t\tflock->fl_type = F_RDLCK;\n\t\tif (rc != 0)\n\t\t\tcifs_dbg(VFS, \"Error unlocking previously locked range %d during test of lock\\n\",\n\t\t\t\t rc);\n\t} else\n\t\tflock->fl_type = F_WRLCK;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_read_flock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "1240-1285",
    "snippet": "static void\ncifs_read_flock(struct file_lock *flock, __u32 *type, int *lock, int *unlock,\n\t\tbool *wait_flag, struct TCP_Server_Info *server)\n{\n\tif (flock->fl_flags & FL_POSIX)\n\t\tcifs_dbg(FYI, \"Posix\\n\");\n\tif (flock->fl_flags & FL_FLOCK)\n\t\tcifs_dbg(FYI, \"Flock\\n\");\n\tif (flock->fl_flags & FL_SLEEP) {\n\t\tcifs_dbg(FYI, \"Blocking lock\\n\");\n\t\t*wait_flag = true;\n\t}\n\tif (flock->fl_flags & FL_ACCESS)\n\t\tcifs_dbg(FYI, \"Process suspended by mandatory locking - not implemented yet\\n\");\n\tif (flock->fl_flags & FL_LEASE)\n\t\tcifs_dbg(FYI, \"Lease on file - not implemented yet\\n\");\n\tif (flock->fl_flags &\n\t    (~(FL_POSIX | FL_FLOCK | FL_SLEEP |\n\t       FL_ACCESS | FL_LEASE | FL_CLOSE)))\n\t\tcifs_dbg(FYI, \"Unknown lock flags 0x%x\\n\", flock->fl_flags);\n\n\t*type = server->vals->large_lock_type;\n\tif (flock->fl_type == F_WRLCK) {\n\t\tcifs_dbg(FYI, \"F_WRLCK\\n\");\n\t\t*type |= server->vals->exclusive_lock_type;\n\t\t*lock = 1;\n\t} else if (flock->fl_type == F_UNLCK) {\n\t\tcifs_dbg(FYI, \"F_UNLCK\\n\");\n\t\t*type |= server->vals->unlock_lock_type;\n\t\t*unlock = 1;\n\t\t/* Check if unlock includes more than one lock range */\n\t} else if (flock->fl_type == F_RDLCK) {\n\t\tcifs_dbg(FYI, \"F_RDLCK\\n\");\n\t\t*type |= server->vals->shared_lock_type;\n\t\t*lock = 1;\n\t} else if (flock->fl_type == F_EXLCK) {\n\t\tcifs_dbg(FYI, \"F_EXLCK\\n\");\n\t\t*type |= server->vals->exclusive_lock_type;\n\t\t*lock = 1;\n\t} else if (flock->fl_type == F_SHLCK) {\n\t\tcifs_dbg(FYI, \"F_SHLCK\\n\");\n\t\t*type |= server->vals->shared_lock_type;\n\t\t*lock = 1;\n\t} else\n\t\tcifs_dbg(FYI, \"Unknown type of lock\\n\");\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Unknown type of lock\\n\""
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"F_SHLCK\\n\""
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"F_EXLCK\\n\""
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"F_RDLCK\\n\""
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"F_UNLCK\\n\""
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"F_WRLCK\\n\""
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Unknown lock flags 0x%x\\n\"",
            "flock->fl_flags"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Lease on file - not implemented yet\\n\""
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Process suspended by mandatory locking - not implemented yet\\n\""
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Blocking lock\\n\""
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Flock\\n\""
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Posix\\n\""
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_read_flock(struct file_lock *flock, __u32 *type, int *lock, int *unlock,\n\t\tbool *wait_flag, struct TCP_Server_Info *server)\n{\n\tif (flock->fl_flags & FL_POSIX)\n\t\tcifs_dbg(FYI, \"Posix\\n\");\n\tif (flock->fl_flags & FL_FLOCK)\n\t\tcifs_dbg(FYI, \"Flock\\n\");\n\tif (flock->fl_flags & FL_SLEEP) {\n\t\tcifs_dbg(FYI, \"Blocking lock\\n\");\n\t\t*wait_flag = true;\n\t}\n\tif (flock->fl_flags & FL_ACCESS)\n\t\tcifs_dbg(FYI, \"Process suspended by mandatory locking - not implemented yet\\n\");\n\tif (flock->fl_flags & FL_LEASE)\n\t\tcifs_dbg(FYI, \"Lease on file - not implemented yet\\n\");\n\tif (flock->fl_flags &\n\t    (~(FL_POSIX | FL_FLOCK | FL_SLEEP |\n\t       FL_ACCESS | FL_LEASE | FL_CLOSE)))\n\t\tcifs_dbg(FYI, \"Unknown lock flags 0x%x\\n\", flock->fl_flags);\n\n\t*type = server->vals->large_lock_type;\n\tif (flock->fl_type == F_WRLCK) {\n\t\tcifs_dbg(FYI, \"F_WRLCK\\n\");\n\t\t*type |= server->vals->exclusive_lock_type;\n\t\t*lock = 1;\n\t} else if (flock->fl_type == F_UNLCK) {\n\t\tcifs_dbg(FYI, \"F_UNLCK\\n\");\n\t\t*type |= server->vals->unlock_lock_type;\n\t\t*unlock = 1;\n\t\t/* Check if unlock includes more than one lock range */\n\t} else if (flock->fl_type == F_RDLCK) {\n\t\tcifs_dbg(FYI, \"F_RDLCK\\n\");\n\t\t*type |= server->vals->shared_lock_type;\n\t\t*lock = 1;\n\t} else if (flock->fl_type == F_EXLCK) {\n\t\tcifs_dbg(FYI, \"F_EXLCK\\n\");\n\t\t*type |= server->vals->exclusive_lock_type;\n\t\t*lock = 1;\n\t} else if (flock->fl_type == F_SHLCK) {\n\t\tcifs_dbg(FYI, \"F_SHLCK\\n\");\n\t\t*type |= server->vals->shared_lock_type;\n\t\t*lock = 1;\n\t} else\n\t\tcifs_dbg(FYI, \"Unknown type of lock\\n\");\n}"
  },
  {
    "function_name": "cifs_push_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "1213-1238",
    "snippet": "static int\ncifs_push_locks(struct cifsFileInfo *cfile)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(cfile->dentry->d_sb);\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tint rc = 0;\n\n\t/* we are going to update can_cache_brlcks here - need a write access */\n\tdown_write(&cinode->lock_sem);\n\tif (!cinode->can_cache_brlcks) {\n\t\tup_write(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n\tif (cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability)) &&\n\t    ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0))\n\t\trc = cifs_push_posix_locks(cfile);\n\telse\n\t\trc = tcon->ses->server->ops->push_mand_locks(cfile);\n\n\tcinode->can_cache_brlcks = false;\n\tup_write(&cinode->lock_sem);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->push_mand_locks",
          "args": [
            "cfile"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_push_posix_locks",
          "args": [
            "cfile"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_push_posix_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1125-1211",
          "snippet": "static int\ncifs_push_posix_locks(struct cifsFileInfo *cfile)\n{\n\tstruct inode *inode = cfile->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct file_lock *flock;\n\tstruct file_lock_context *flctx = inode->i_flctx;\n\tunsigned int count = 0, i;\n\tint rc = 0, xid, type;\n\tstruct list_head locks_to_send, *el;\n\tstruct lock_to_push *lck, *tmp;\n\t__u64 length;\n\n\txid = get_xid();\n\n\tif (!flctx)\n\t\tgoto out;\n\n\tspin_lock(&flctx->flc_lock);\n\tlist_for_each(el, &flctx->flc_posix) {\n\t\tcount++;\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\n\tINIT_LIST_HEAD(&locks_to_send);\n\n\t/*\n\t * Allocating count locks is enough because no FL_POSIX locks can be\n\t * added to the list while we are holding cinode->lock_sem that\n\t * protects locking operations of this inode.\n\t */\n\tfor (i = 0; i < count; i++) {\n\t\tlck = kmalloc(sizeof(struct lock_to_push), GFP_KERNEL);\n\t\tif (!lck) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\tlist_add_tail(&lck->llist, &locks_to_send);\n\t}\n\n\tel = locks_to_send.next;\n\tspin_lock(&flctx->flc_lock);\n\tlist_for_each_entry(flock, &flctx->flc_posix, fl_list) {\n\t\tif (el == &locks_to_send) {\n\t\t\t/*\n\t\t\t * The list ended. We don't have enough allocated\n\t\t\t * structures - something is really wrong.\n\t\t\t */\n\t\t\tcifs_dbg(VFS, \"Can't push all brlocks!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tlength = 1 + flock->fl_end - flock->fl_start;\n\t\tif (flock->fl_type == F_RDLCK || flock->fl_type == F_SHLCK)\n\t\t\ttype = CIFS_RDLCK;\n\t\telse\n\t\t\ttype = CIFS_WRLCK;\n\t\tlck = list_entry(el, struct lock_to_push, llist);\n\t\tlck->pid = flock->fl_pid;\n\t\tlck->netfid = cfile->fid.netfid;\n\t\tlck->length = length;\n\t\tlck->type = type;\n\t\tlck->offset = flock->fl_start;\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\n\tlist_for_each_entry_safe(lck, tmp, &locks_to_send, llist) {\n\t\tint stored_rc;\n\n\t\tstored_rc = CIFSSMBPosixLock(xid, tcon, lck->netfid, lck->pid,\n\t\t\t\t\t     lck->offset, lck->length, NULL,\n\t\t\t\t\t     lck->type, 0);\n\t\tif (stored_rc)\n\t\t\trc = stored_rc;\n\t\tlist_del(&lck->llist);\n\t\tkfree(lck);\n\t}\n\nout:\n\tfree_xid(xid);\n\treturn rc;\nerr_out:\n\tlist_for_each_entry_safe(lck, tmp, &locks_to_send, llist) {\n\t\tlist_del(&lck->llist);\n\t\tkfree(lck);\n\t}\n\tgoto out;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_push_posix_locks(struct cifsFileInfo *cfile)\n{\n\tstruct inode *inode = cfile->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct file_lock *flock;\n\tstruct file_lock_context *flctx = inode->i_flctx;\n\tunsigned int count = 0, i;\n\tint rc = 0, xid, type;\n\tstruct list_head locks_to_send, *el;\n\tstruct lock_to_push *lck, *tmp;\n\t__u64 length;\n\n\txid = get_xid();\n\n\tif (!flctx)\n\t\tgoto out;\n\n\tspin_lock(&flctx->flc_lock);\n\tlist_for_each(el, &flctx->flc_posix) {\n\t\tcount++;\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\n\tINIT_LIST_HEAD(&locks_to_send);\n\n\t/*\n\t * Allocating count locks is enough because no FL_POSIX locks can be\n\t * added to the list while we are holding cinode->lock_sem that\n\t * protects locking operations of this inode.\n\t */\n\tfor (i = 0; i < count; i++) {\n\t\tlck = kmalloc(sizeof(struct lock_to_push), GFP_KERNEL);\n\t\tif (!lck) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\tlist_add_tail(&lck->llist, &locks_to_send);\n\t}\n\n\tel = locks_to_send.next;\n\tspin_lock(&flctx->flc_lock);\n\tlist_for_each_entry(flock, &flctx->flc_posix, fl_list) {\n\t\tif (el == &locks_to_send) {\n\t\t\t/*\n\t\t\t * The list ended. We don't have enough allocated\n\t\t\t * structures - something is really wrong.\n\t\t\t */\n\t\t\tcifs_dbg(VFS, \"Can't push all brlocks!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tlength = 1 + flock->fl_end - flock->fl_start;\n\t\tif (flock->fl_type == F_RDLCK || flock->fl_type == F_SHLCK)\n\t\t\ttype = CIFS_RDLCK;\n\t\telse\n\t\t\ttype = CIFS_WRLCK;\n\t\tlck = list_entry(el, struct lock_to_push, llist);\n\t\tlck->pid = flock->fl_pid;\n\t\tlck->netfid = cfile->fid.netfid;\n\t\tlck->length = length;\n\t\tlck->type = type;\n\t\tlck->offset = flock->fl_start;\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\n\tlist_for_each_entry_safe(lck, tmp, &locks_to_send, llist) {\n\t\tint stored_rc;\n\n\t\tstored_rc = CIFSSMBPosixLock(xid, tcon, lck->netfid, lck->pid,\n\t\t\t\t\t     lck->offset, lck->length, NULL,\n\t\t\t\t\t     lck->type, 0);\n\t\tif (stored_rc)\n\t\t\trc = stored_rc;\n\t\tlist_del(&lck->llist);\n\t\tkfree(lck);\n\t}\n\nout:\n\tfree_xid(xid);\n\treturn rc;\nerr_out:\n\tlist_for_each_entry_safe(lck, tmp, &locks_to_send, llist) {\n\t\tlist_del(&lck->llist);\n\t\tkfree(lck);\n\t}\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "tcon->fsUnixInfo.Capability"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_unix",
          "args": [
            "tcon->ses"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "cap_unix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "804-808",
          "snippet": "static inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "cfile->dentry->d_inode"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "cfile->dentry->d_sb"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_push_locks(struct cifsFileInfo *cfile)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(cfile->dentry->d_sb);\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tint rc = 0;\n\n\t/* we are going to update can_cache_brlcks here - need a write access */\n\tdown_write(&cinode->lock_sem);\n\tif (!cinode->can_cache_brlcks) {\n\t\tup_write(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n\tif (cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability)) &&\n\t    ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0))\n\t\trc = cifs_push_posix_locks(cfile);\n\telse\n\t\trc = tcon->ses->server->ops->push_mand_locks(cfile);\n\n\tcinode->can_cache_brlcks = false;\n\tup_write(&cinode->lock_sem);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_push_posix_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "1125-1211",
    "snippet": "static int\ncifs_push_posix_locks(struct cifsFileInfo *cfile)\n{\n\tstruct inode *inode = cfile->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct file_lock *flock;\n\tstruct file_lock_context *flctx = inode->i_flctx;\n\tunsigned int count = 0, i;\n\tint rc = 0, xid, type;\n\tstruct list_head locks_to_send, *el;\n\tstruct lock_to_push *lck, *tmp;\n\t__u64 length;\n\n\txid = get_xid();\n\n\tif (!flctx)\n\t\tgoto out;\n\n\tspin_lock(&flctx->flc_lock);\n\tlist_for_each(el, &flctx->flc_posix) {\n\t\tcount++;\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\n\tINIT_LIST_HEAD(&locks_to_send);\n\n\t/*\n\t * Allocating count locks is enough because no FL_POSIX locks can be\n\t * added to the list while we are holding cinode->lock_sem that\n\t * protects locking operations of this inode.\n\t */\n\tfor (i = 0; i < count; i++) {\n\t\tlck = kmalloc(sizeof(struct lock_to_push), GFP_KERNEL);\n\t\tif (!lck) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\tlist_add_tail(&lck->llist, &locks_to_send);\n\t}\n\n\tel = locks_to_send.next;\n\tspin_lock(&flctx->flc_lock);\n\tlist_for_each_entry(flock, &flctx->flc_posix, fl_list) {\n\t\tif (el == &locks_to_send) {\n\t\t\t/*\n\t\t\t * The list ended. We don't have enough allocated\n\t\t\t * structures - something is really wrong.\n\t\t\t */\n\t\t\tcifs_dbg(VFS, \"Can't push all brlocks!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tlength = 1 + flock->fl_end - flock->fl_start;\n\t\tif (flock->fl_type == F_RDLCK || flock->fl_type == F_SHLCK)\n\t\t\ttype = CIFS_RDLCK;\n\t\telse\n\t\t\ttype = CIFS_WRLCK;\n\t\tlck = list_entry(el, struct lock_to_push, llist);\n\t\tlck->pid = flock->fl_pid;\n\t\tlck->netfid = cfile->fid.netfid;\n\t\tlck->length = length;\n\t\tlck->type = type;\n\t\tlck->offset = flock->fl_start;\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\n\tlist_for_each_entry_safe(lck, tmp, &locks_to_send, llist) {\n\t\tint stored_rc;\n\n\t\tstored_rc = CIFSSMBPosixLock(xid, tcon, lck->netfid, lck->pid,\n\t\t\t\t\t     lck->offset, lck->length, NULL,\n\t\t\t\t\t     lck->type, 0);\n\t\tif (stored_rc)\n\t\t\trc = stored_rc;\n\t\tlist_del(&lck->llist);\n\t\tkfree(lck);\n\t}\n\nout:\n\tfree_xid(xid);\n\treturn rc;\nerr_out:\n\tlist_for_each_entry_safe(lck, tmp, &locks_to_send, llist) {\n\t\tlist_del(&lck->llist);\n\t\tkfree(lck);\n\t}\n\tgoto out;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lck"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&lck->llist"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lck",
            "tmp",
            "&locks_to_send",
            "llist"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lck"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSSMBPosixLock",
          "args": [
            "xid",
            "tcon",
            "lck->netfid",
            "lck->pid",
            "lck->offset",
            "lck->length",
            "NULL",
            "lck->type",
            "0"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBPosixLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2377-2507",
          "snippet": "int\nCIFSSMBPosixLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tconst __u16 smb_file_id, const __u32 netpid,\n\t\tconst loff_t start_offset, const __u64 len,\n\t\tstruct file_lock *pLockData, const __u16 lock_type,\n\t\tconst bool waitFlag)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\n\tstruct cifs_posix_lock *parm_data;\n\tint rc = 0;\n\tint timeout = 0;\n\tint bytes_returned = 0;\n\tint resp_buf_type = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tstruct kvec iov[1];\n\n\tcifs_dbg(FYI, \"Posix Lock\\n\");\n\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)pSMB;\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tcount = sizeof(struct cifs_posix_lock);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000); /* BB find max SMB from sess */\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tif (pLockData)\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\telse\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tparm_data = (struct cifs_posix_lock *)\n\t\t\t(((char *) &pSMB->hdr.Protocol) + offset);\n\n\tparm_data->lock_type = cpu_to_le16(lock_type);\n\tif (waitFlag) {\n\t\ttimeout = CIFS_BLOCKING_OP; /* blocking operation, no timeout */\n\t\tparm_data->lock_flags = cpu_to_le16(1);\n\t\tpSMB->Timeout = cpu_to_le32(-1);\n\t} else\n\t\tpSMB->Timeout = 0;\n\n\tparm_data->pid = cpu_to_le32(netpid);\n\tparm_data->start = cpu_to_le64(start_offset);\n\tparm_data->length = cpu_to_le64(len);  /* normalize negative numbers */\n\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = smb_file_id;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_POSIX_LOCK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned);\n\t} else {\n\t\tiov[0].iov_base = (char *)pSMB;\n\t\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\t\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,\n\t\t\t\t&resp_buf_type, timeout);\n\t\tpSMB = NULL; /* request buf already freed by SendReceive2. Do\n\t\t\t\tnot try to free it twice below on exit */\n\t\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)iov[0].iov_base;\n\t}\n\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in Posix Lock = %d\\n\", rc);\n\t} else if (pLockData) {\n\t\t/* lock structure can be returned on get */\n\t\t__u16 data_offset;\n\t\t__u16 data_count;\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(*parm_data)) {\n\t\t\trc = -EIO;      /* bad smb */\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tdata_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\tdata_count  = le16_to_cpu(pSMBr->t2.DataCount);\n\t\tif (data_count < sizeof(struct cifs_posix_lock)) {\n\t\t\trc = -EIO;\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tparm_data = (struct cifs_posix_lock *)\n\t\t\t((char *)&pSMBr->hdr.Protocol + data_offset);\n\t\tif (parm_data->lock_type == cpu_to_le16(CIFS_UNLCK))\n\t\t\tpLockData->fl_type = F_UNLCK;\n\t\telse {\n\t\t\tif (parm_data->lock_type ==\n\t\t\t\t\tcpu_to_le16(CIFS_RDLCK))\n\t\t\t\tpLockData->fl_type = F_RDLCK;\n\t\t\telse if (parm_data->lock_type ==\n\t\t\t\t\tcpu_to_le16(CIFS_WRLCK))\n\t\t\t\tpLockData->fl_type = F_WRLCK;\n\n\t\t\tpLockData->fl_start = le64_to_cpu(parm_data->start);\n\t\t\tpLockData->fl_end = pLockData->fl_start +\n\t\t\t\t\tle64_to_cpu(parm_data->length) - 1;\n\t\t\tpLockData->fl_pid = le32_to_cpu(parm_data->pid);\n\t\t}\n\t}\n\nplk_err_exit:\n\tif (pSMB)\n\t\tcifs_small_buf_release(pSMB);\n\n\tfree_rsp_buf(resp_buf_type, iov[0].iov_base);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t   since file handle passed in no longer valid */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBPosixLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tconst __u16 smb_file_id, const __u32 netpid,\n\t\tconst loff_t start_offset, const __u64 len,\n\t\tstruct file_lock *pLockData, const __u16 lock_type,\n\t\tconst bool waitFlag)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\n\tstruct cifs_posix_lock *parm_data;\n\tint rc = 0;\n\tint timeout = 0;\n\tint bytes_returned = 0;\n\tint resp_buf_type = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tstruct kvec iov[1];\n\n\tcifs_dbg(FYI, \"Posix Lock\\n\");\n\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)pSMB;\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tcount = sizeof(struct cifs_posix_lock);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000); /* BB find max SMB from sess */\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tif (pLockData)\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\telse\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tparm_data = (struct cifs_posix_lock *)\n\t\t\t(((char *) &pSMB->hdr.Protocol) + offset);\n\n\tparm_data->lock_type = cpu_to_le16(lock_type);\n\tif (waitFlag) {\n\t\ttimeout = CIFS_BLOCKING_OP; /* blocking operation, no timeout */\n\t\tparm_data->lock_flags = cpu_to_le16(1);\n\t\tpSMB->Timeout = cpu_to_le32(-1);\n\t} else\n\t\tpSMB->Timeout = 0;\n\n\tparm_data->pid = cpu_to_le32(netpid);\n\tparm_data->start = cpu_to_le64(start_offset);\n\tparm_data->length = cpu_to_le64(len);  /* normalize negative numbers */\n\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = smb_file_id;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_POSIX_LOCK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned);\n\t} else {\n\t\tiov[0].iov_base = (char *)pSMB;\n\t\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\t\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,\n\t\t\t\t&resp_buf_type, timeout);\n\t\tpSMB = NULL; /* request buf already freed by SendReceive2. Do\n\t\t\t\tnot try to free it twice below on exit */\n\t\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)iov[0].iov_base;\n\t}\n\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in Posix Lock = %d\\n\", rc);\n\t} else if (pLockData) {\n\t\t/* lock structure can be returned on get */\n\t\t__u16 data_offset;\n\t\t__u16 data_count;\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(*parm_data)) {\n\t\t\trc = -EIO;      /* bad smb */\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tdata_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\tdata_count  = le16_to_cpu(pSMBr->t2.DataCount);\n\t\tif (data_count < sizeof(struct cifs_posix_lock)) {\n\t\t\trc = -EIO;\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tparm_data = (struct cifs_posix_lock *)\n\t\t\t((char *)&pSMBr->hdr.Protocol + data_offset);\n\t\tif (parm_data->lock_type == cpu_to_le16(CIFS_UNLCK))\n\t\t\tpLockData->fl_type = F_UNLCK;\n\t\telse {\n\t\t\tif (parm_data->lock_type ==\n\t\t\t\t\tcpu_to_le16(CIFS_RDLCK))\n\t\t\t\tpLockData->fl_type = F_RDLCK;\n\t\t\telse if (parm_data->lock_type ==\n\t\t\t\t\tcpu_to_le16(CIFS_WRLCK))\n\t\t\t\tpLockData->fl_type = F_WRLCK;\n\n\t\t\tpLockData->fl_start = le64_to_cpu(parm_data->start);\n\t\t\tpLockData->fl_end = pLockData->fl_start +\n\t\t\t\t\tle64_to_cpu(parm_data->length) - 1;\n\t\t\tpLockData->fl_pid = le32_to_cpu(parm_data->pid);\n\t\t}\n\t}\n\nplk_err_exit:\n\tif (pSMB)\n\t\tcifs_small_buf_release(pSMB);\n\n\tfree_rsp_buf(resp_buf_type, iov[0].iov_base);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t   since file handle passed in no longer valid */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lck",
            "tmp",
            "&locks_to_send",
            "llist"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&flctx->flc_lock"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "el",
            "structlock_to_push",
            "llist"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Can't push all brlocks!\\n\""
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "flock",
            "&flctx->flc_posix",
            "fl_list"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&flctx->flc_lock"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lck->llist",
            "&locks_to_send"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct lock_to_push)",
            "GFP_KERNEL"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&locks_to_send"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "el",
            "&flctx->flc_posix"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_push_posix_locks(struct cifsFileInfo *cfile)\n{\n\tstruct inode *inode = cfile->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct file_lock *flock;\n\tstruct file_lock_context *flctx = inode->i_flctx;\n\tunsigned int count = 0, i;\n\tint rc = 0, xid, type;\n\tstruct list_head locks_to_send, *el;\n\tstruct lock_to_push *lck, *tmp;\n\t__u64 length;\n\n\txid = get_xid();\n\n\tif (!flctx)\n\t\tgoto out;\n\n\tspin_lock(&flctx->flc_lock);\n\tlist_for_each(el, &flctx->flc_posix) {\n\t\tcount++;\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\n\tINIT_LIST_HEAD(&locks_to_send);\n\n\t/*\n\t * Allocating count locks is enough because no FL_POSIX locks can be\n\t * added to the list while we are holding cinode->lock_sem that\n\t * protects locking operations of this inode.\n\t */\n\tfor (i = 0; i < count; i++) {\n\t\tlck = kmalloc(sizeof(struct lock_to_push), GFP_KERNEL);\n\t\tif (!lck) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\tlist_add_tail(&lck->llist, &locks_to_send);\n\t}\n\n\tel = locks_to_send.next;\n\tspin_lock(&flctx->flc_lock);\n\tlist_for_each_entry(flock, &flctx->flc_posix, fl_list) {\n\t\tif (el == &locks_to_send) {\n\t\t\t/*\n\t\t\t * The list ended. We don't have enough allocated\n\t\t\t * structures - something is really wrong.\n\t\t\t */\n\t\t\tcifs_dbg(VFS, \"Can't push all brlocks!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tlength = 1 + flock->fl_end - flock->fl_start;\n\t\tif (flock->fl_type == F_RDLCK || flock->fl_type == F_SHLCK)\n\t\t\ttype = CIFS_RDLCK;\n\t\telse\n\t\t\ttype = CIFS_WRLCK;\n\t\tlck = list_entry(el, struct lock_to_push, llist);\n\t\tlck->pid = flock->fl_pid;\n\t\tlck->netfid = cfile->fid.netfid;\n\t\tlck->length = length;\n\t\tlck->type = type;\n\t\tlck->offset = flock->fl_start;\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\n\tlist_for_each_entry_safe(lck, tmp, &locks_to_send, llist) {\n\t\tint stored_rc;\n\n\t\tstored_rc = CIFSSMBPosixLock(xid, tcon, lck->netfid, lck->pid,\n\t\t\t\t\t     lck->offset, lck->length, NULL,\n\t\t\t\t\t     lck->type, 0);\n\t\tif (stored_rc)\n\t\t\trc = stored_rc;\n\t\tlist_del(&lck->llist);\n\t\tkfree(lck);\n\t}\n\nout:\n\tfree_xid(xid);\n\treturn rc;\nerr_out:\n\tlist_for_each_entry_safe(lck, tmp, &locks_to_send, llist) {\n\t\tlist_del(&lck->llist);\n\t\tkfree(lck);\n\t}\n\tgoto out;\n}"
  },
  {
    "function_name": "cifs_push_mandatory_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "1045-1114",
    "snippet": "int\ncifs_push_mandatory_locks(struct cifsFileInfo *cfile)\n{\n\tunsigned int xid;\n\tint rc = 0, stored_rc;\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_tcon *tcon;\n\tunsigned int num, max_num, max_buf;\n\tLOCKING_ANDX_RANGE *buf, *cur;\n\tint types[] = {LOCKING_ANDX_LARGE_FILES,\n\t\t       LOCKING_ANDX_SHARED_LOCK | LOCKING_ANDX_LARGE_FILES};\n\tint i;\n\n\txid = get_xid();\n\ttcon = tlink_tcon(cfile->tlink);\n\n\t/*\n\t * Accessing maxBuf is racy with cifs_reconnect - need to store value\n\t * and check it for zero before using.\n\t */\n\tmax_buf = tcon->ses->server->maxBuf;\n\tif (!max_buf) {\n\t\tfree_xid(xid);\n\t\treturn -EINVAL;\n\t}\n\n\tmax_num = (max_buf - sizeof(struct smb_hdr)) /\n\t\t\t\t\t\tsizeof(LOCKING_ANDX_RANGE);\n\tbuf = kcalloc(max_num, sizeof(LOCKING_ANDX_RANGE), GFP_KERNEL);\n\tif (!buf) {\n\t\tfree_xid(xid);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tcur = buf;\n\t\tnum = 0;\n\t\tlist_for_each_entry_safe(li, tmp, &cfile->llist->locks, llist) {\n\t\t\tif (li->type != types[i])\n\t\t\t\tcontinue;\n\t\t\tcur->Pid = cpu_to_le16(li->pid);\n\t\t\tcur->LengthLow = cpu_to_le32((u32)li->length);\n\t\t\tcur->LengthHigh = cpu_to_le32((u32)(li->length>>32));\n\t\t\tcur->OffsetLow = cpu_to_le32((u32)li->offset);\n\t\t\tcur->OffsetHigh = cpu_to_le32((u32)(li->offset>>32));\n\t\t\tif (++num == max_num) {\n\t\t\t\tstored_rc = cifs_lockv(xid, tcon,\n\t\t\t\t\t\t       cfile->fid.netfid,\n\t\t\t\t\t\t       (__u8)li->type, 0, num,\n\t\t\t\t\t\t       buf);\n\t\t\t\tif (stored_rc)\n\t\t\t\t\trc = stored_rc;\n\t\t\t\tcur = buf;\n\t\t\t\tnum = 0;\n\t\t\t} else\n\t\t\t\tcur++;\n\t\t}\n\n\t\tif (num) {\n\t\t\tstored_rc = cifs_lockv(xid, tcon, cfile->fid.netfid,\n\t\t\t\t\t       (__u8)types[i], 0, num, buf);\n\t\t\tif (stored_rc)\n\t\t\t\trc = stored_rc;\n\t\t}\n\t}\n\n\tkfree(buf);\n\tfree_xid(xid);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_lockv",
          "args": [
            "xid",
            "tcon",
            "cfile->fid.netfid",
            "(__u8)types[i]",
            "0",
            "num",
            "buf"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_lockv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2264-2304",
          "snippet": "int cifs_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t       const __u16 netfid, const __u8 lock_type, const __u32 num_unlock,\n\t       const __u32 num_lock, LOCKING_ANDX_RANGE *buf)\n{\n\tint rc = 0;\n\tLOCK_REQ *pSMB = NULL;\n\tstruct kvec iov[2];\n\tint resp_buf_type;\n\t__u16 count;\n\n\tcifs_dbg(FYI, \"cifs_lockv num lock %d num unlock %d\\n\",\n\t\t num_lock, num_unlock);\n\n\trc = small_smb_init(SMB_COM_LOCKING_ANDX, 8, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->Timeout = 0;\n\tpSMB->NumberOfLocks = cpu_to_le16(num_lock);\n\tpSMB->NumberOfUnlocks = cpu_to_le16(num_unlock);\n\tpSMB->LockType = lock_type;\n\tpSMB->AndXCommand = 0xFF; /* none */\n\tpSMB->Fid = netfid; /* netfid stays le */\n\n\tcount = (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4 -\n\t\t\t (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\tiov[1].iov_base = (char *)buf;\n\tiov[1].iov_len = (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\trc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type, CIFS_NO_RESP);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in cifs_lockv = %d\\n\", rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint cifs_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t       const __u16 netfid, const __u8 lock_type, const __u32 num_unlock,\n\t       const __u32 num_lock, LOCKING_ANDX_RANGE *buf)\n{\n\tint rc = 0;\n\tLOCK_REQ *pSMB = NULL;\n\tstruct kvec iov[2];\n\tint resp_buf_type;\n\t__u16 count;\n\n\tcifs_dbg(FYI, \"cifs_lockv num lock %d num unlock %d\\n\",\n\t\t num_lock, num_unlock);\n\n\trc = small_smb_init(SMB_COM_LOCKING_ANDX, 8, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->Timeout = 0;\n\tpSMB->NumberOfLocks = cpu_to_le16(num_lock);\n\tpSMB->NumberOfUnlocks = cpu_to_le16(num_unlock);\n\tpSMB->LockType = lock_type;\n\tpSMB->AndXCommand = 0xFF; /* none */\n\tpSMB->Fid = netfid; /* netfid stays le */\n\n\tcount = (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4 -\n\t\t\t (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\tiov[1].iov_base = (char *)buf;\n\tiov[1].iov_len = (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\trc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type, CIFS_NO_RESP);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in cifs_lockv = %d\\n\", rc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)(li->offset>>32)"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "li->offset>>32"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)li->offset"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)(li->length>>32)"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "li->length>>32"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)li->length"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "li->pid"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "li",
            "tmp",
            "&cfile->llist->locks",
            "llist"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "max_num",
            "sizeof(LOCKING_ANDX_RANGE)",
            "GFP_KERNEL"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nint\ncifs_push_mandatory_locks(struct cifsFileInfo *cfile)\n{\n\tunsigned int xid;\n\tint rc = 0, stored_rc;\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_tcon *tcon;\n\tunsigned int num, max_num, max_buf;\n\tLOCKING_ANDX_RANGE *buf, *cur;\n\tint types[] = {LOCKING_ANDX_LARGE_FILES,\n\t\t       LOCKING_ANDX_SHARED_LOCK | LOCKING_ANDX_LARGE_FILES};\n\tint i;\n\n\txid = get_xid();\n\ttcon = tlink_tcon(cfile->tlink);\n\n\t/*\n\t * Accessing maxBuf is racy with cifs_reconnect - need to store value\n\t * and check it for zero before using.\n\t */\n\tmax_buf = tcon->ses->server->maxBuf;\n\tif (!max_buf) {\n\t\tfree_xid(xid);\n\t\treturn -EINVAL;\n\t}\n\n\tmax_num = (max_buf - sizeof(struct smb_hdr)) /\n\t\t\t\t\t\tsizeof(LOCKING_ANDX_RANGE);\n\tbuf = kcalloc(max_num, sizeof(LOCKING_ANDX_RANGE), GFP_KERNEL);\n\tif (!buf) {\n\t\tfree_xid(xid);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tcur = buf;\n\t\tnum = 0;\n\t\tlist_for_each_entry_safe(li, tmp, &cfile->llist->locks, llist) {\n\t\t\tif (li->type != types[i])\n\t\t\t\tcontinue;\n\t\t\tcur->Pid = cpu_to_le16(li->pid);\n\t\t\tcur->LengthLow = cpu_to_le32((u32)li->length);\n\t\t\tcur->LengthHigh = cpu_to_le32((u32)(li->length>>32));\n\t\t\tcur->OffsetLow = cpu_to_le32((u32)li->offset);\n\t\t\tcur->OffsetHigh = cpu_to_le32((u32)(li->offset>>32));\n\t\t\tif (++num == max_num) {\n\t\t\t\tstored_rc = cifs_lockv(xid, tcon,\n\t\t\t\t\t\t       cfile->fid.netfid,\n\t\t\t\t\t\t       (__u8)li->type, 0, num,\n\t\t\t\t\t\t       buf);\n\t\t\t\tif (stored_rc)\n\t\t\t\t\trc = stored_rc;\n\t\t\t\tcur = buf;\n\t\t\t\tnum = 0;\n\t\t\t} else\n\t\t\t\tcur++;\n\t\t}\n\n\t\tif (num) {\n\t\t\tstored_rc = cifs_lockv(xid, tcon, cfile->fid.netfid,\n\t\t\t\t\t       (__u8)types[i], 0, num, buf);\n\t\t\tif (stored_rc)\n\t\t\t\trc = stored_rc;\n\t\t}\n\t}\n\n\tkfree(buf);\n\tfree_xid(xid);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_posix_lock_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "1018-1043",
    "snippet": "static int\ncifs_posix_lock_set(struct file *file, struct file_lock *flock)\n{\n\tstruct cifsInodeInfo *cinode = CIFS_I(file_inode(file));\n\tint rc = 1;\n\n\tif ((flock->fl_flags & FL_POSIX) == 0)\n\t\treturn rc;\n\ntry_again:\n\tdown_write(&cinode->lock_sem);\n\tif (!cinode->can_cache_brlcks) {\n\t\tup_write(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n\trc = posix_lock_file(file, flock, NULL);\n\tup_write(&cinode->lock_sem);\n\tif (rc == FILE_LOCK_DEFERRED) {\n\t\trc = wait_event_interruptible(flock->fl_wait, !flock->fl_next);\n\t\tif (!rc)\n\t\t\tgoto try_again;\n\t\tposix_unblock_lock(flock);\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_unblock_lock",
          "args": [
            "flock"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "posix_unblock_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "2460-2472",
          "snippet": "int\nposix_unblock_lock(struct file_lock *waiter)\n{\n\tint status = 0;\n\n\tspin_lock(&blocked_lock_lock);\n\tif (waiter->fl_next)\n\t\t__locks_delete_block(waiter);\n\telse\n\t\tstatus = -ENOENT;\n\tspin_unlock(&blocked_lock_lock);\n\treturn status;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nint\nposix_unblock_lock(struct file_lock *waiter)\n{\n\tint status = 0;\n\n\tspin_lock(&blocked_lock_lock);\n\tif (waiter->fl_next)\n\t\t__locks_delete_block(waiter);\n\telse\n\t\tstatus = -ENOENT;\n\tspin_unlock(&blocked_lock_lock);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "flock->fl_wait",
            "!flock->fl_next"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_lock_file",
          "args": [
            "file",
            "flock",
            "NULL"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1157-1161",
          "snippet": "int posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn __posix_lock_file(file_inode(filp), fl, conflock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn __posix_lock_file(file_inode(filp), fl, conflock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_posix_lock_set(struct file *file, struct file_lock *flock)\n{\n\tstruct cifsInodeInfo *cinode = CIFS_I(file_inode(file));\n\tint rc = 1;\n\n\tif ((flock->fl_flags & FL_POSIX) == 0)\n\t\treturn rc;\n\ntry_again:\n\tdown_write(&cinode->lock_sem);\n\tif (!cinode->can_cache_brlcks) {\n\t\tup_write(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n\trc = posix_lock_file(file, flock, NULL);\n\tup_write(&cinode->lock_sem);\n\tif (rc == FILE_LOCK_DEFERRED) {\n\t\trc = wait_event_interruptible(flock->fl_wait, !flock->fl_next);\n\t\tif (!rc)\n\t\t\tgoto try_again;\n\t\tposix_unblock_lock(flock);\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_posix_lock_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "990-1010",
    "snippet": "static int\ncifs_posix_lock_test(struct file *file, struct file_lock *flock)\n{\n\tint rc = 0;\n\tstruct cifsInodeInfo *cinode = CIFS_I(file_inode(file));\n\tunsigned char saved_type = flock->fl_type;\n\n\tif ((flock->fl_flags & FL_POSIX) == 0)\n\t\treturn 1;\n\n\tdown_read(&cinode->lock_sem);\n\tposix_test_lock(file, flock);\n\n\tif (flock->fl_type == F_UNLCK && !cinode->can_cache_brlcks) {\n\t\tflock->fl_type = saved_type;\n\t\trc = 1;\n\t}\n\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_test_lock",
          "args": [
            "file",
            "flock"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "posix_test_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "759-785",
          "snippet": "void\nposix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tstruct file_lock *cfl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = file_inode(filp);\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix)) {\n\t\tfl->fl_type = F_UNLCK;\n\t\treturn;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_locks_conflict(fl, cfl)) {\n\t\t\tlocks_copy_conflock(fl, cfl);\n\t\t\tif (cfl->fl_nspid)\n\t\t\t\tfl->fl_pid = pid_vnr(cfl->fl_nspid);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfl->fl_type = F_UNLCK;\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid\nposix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tstruct file_lock *cfl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = file_inode(filp);\n\n\tctx = inode->i_flctx;\n\tif (!ctx || list_empty_careful(&ctx->flc_posix)) {\n\t\tfl->fl_type = F_UNLCK;\n\t\treturn;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_locks_conflict(fl, cfl)) {\n\t\t\tlocks_copy_conflock(fl, cfl);\n\t\t\tif (cfl->fl_nspid)\n\t\t\t\tfl->fl_pid = pid_vnr(cfl->fl_nspid);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfl->fl_type = F_UNLCK;\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_posix_lock_test(struct file *file, struct file_lock *flock)\n{\n\tint rc = 0;\n\tstruct cifsInodeInfo *cinode = CIFS_I(file_inode(file));\n\tunsigned char saved_type = flock->fl_type;\n\n\tif ((flock->fl_flags & FL_POSIX) == 0)\n\t\treturn 1;\n\n\tdown_read(&cinode->lock_sem);\n\tposix_test_lock(file, flock);\n\n\tif (flock->fl_type == F_UNLCK && !cinode->can_cache_brlcks) {\n\t\tflock->fl_type = saved_type;\n\t\trc = 1;\n\t}\n\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_lock_add_if",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "942-981",
    "snippet": "static int\ncifs_lock_add_if(struct cifsFileInfo *cfile, struct cifsLockInfo *lock,\n\t\t bool wait)\n{\n\tstruct cifsLockInfo *conf_lock;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tbool exist;\n\tint rc = 0;\n\ntry_again:\n\texist = false;\n\tdown_write(&cinode->lock_sem);\n\n\texist = cifs_find_lock_conflict(cfile, lock->offset, lock->length,\n\t\t\t\t\tlock->type, &conf_lock, CIFS_LOCK_OP);\n\tif (!exist && cinode->can_cache_brlcks) {\n\t\tlist_add_tail(&lock->llist, &cfile->llist->locks);\n\t\tup_write(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n\tif (!exist)\n\t\trc = 1;\n\telse if (!wait)\n\t\trc = -EACCES;\n\telse {\n\t\tlist_add_tail(&lock->blist, &conf_lock->blist);\n\t\tup_write(&cinode->lock_sem);\n\t\trc = wait_event_interruptible(lock->block_q,\n\t\t\t\t\t(lock->blist.prev == &lock->blist) &&\n\t\t\t\t\t(lock->blist.next == &lock->blist));\n\t\tif (!rc)\n\t\t\tgoto try_again;\n\t\tdown_write(&cinode->lock_sem);\n\t\tlist_del_init(&lock->blist);\n\t}\n\n\tup_write(&cinode->lock_sem);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CIFS_LOCK_OP\t0"
    ],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lock->blist"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "lock->block_q",
            "(lock->blist.prev == &lock->blist) &&\n\t\t\t\t\t(lock->blist.next == &lock->blist)"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lock->blist",
            "&conf_lock->blist"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lock->llist",
            "&cfile->llist->locks"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_find_lock_conflict",
          "args": [
            "cfile",
            "lock->offset",
            "lock->length",
            "lock->type",
            "&conf_lock",
            "CIFS_LOCK_OP"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_find_lock_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "870-887",
          "snippet": "bool\ncifs_find_lock_conflict(struct cifsFileInfo *cfile, __u64 offset, __u64 length,\n\t\t\t__u8 type, struct cifsLockInfo **conf_lock,\n\t\t\tint rw_check)\n{\n\tbool rc = false;\n\tstruct cifs_fid_locks *cur;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\n\tlist_for_each_entry(cur, &cinode->llist, llist) {\n\t\trc = cifs_find_fid_lock_conflict(cur, offset, length, type,\n\t\t\t\t\t\t cfile, conf_lock, rw_check);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nbool\ncifs_find_lock_conflict(struct cifsFileInfo *cfile, __u64 offset, __u64 length,\n\t\t\t__u8 type, struct cifsLockInfo **conf_lock,\n\t\t\tint rw_check)\n{\n\tbool rc = false;\n\tstruct cifs_fid_locks *cur;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\n\tlist_for_each_entry(cur, &cinode->llist, llist) {\n\t\trc = cifs_find_fid_lock_conflict(cur, offset, length, type,\n\t\t\t\t\t\t cfile, conf_lock, rw_check);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "cfile->dentry->d_inode"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\n#define CIFS_LOCK_OP\t0\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_lock_add_if(struct cifsFileInfo *cfile, struct cifsLockInfo *lock,\n\t\t bool wait)\n{\n\tstruct cifsLockInfo *conf_lock;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tbool exist;\n\tint rc = 0;\n\ntry_again:\n\texist = false;\n\tdown_write(&cinode->lock_sem);\n\n\texist = cifs_find_lock_conflict(cfile, lock->offset, lock->length,\n\t\t\t\t\tlock->type, &conf_lock, CIFS_LOCK_OP);\n\tif (!exist && cinode->can_cache_brlcks) {\n\t\tlist_add_tail(&lock->llist, &cfile->llist->locks);\n\t\tup_write(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n\tif (!exist)\n\t\trc = 1;\n\telse if (!wait)\n\t\trc = -EACCES;\n\telse {\n\t\tlist_add_tail(&lock->blist, &conf_lock->blist);\n\t\tup_write(&cinode->lock_sem);\n\t\trc = wait_event_interruptible(lock->block_q,\n\t\t\t\t\t(lock->blist.prev == &lock->blist) &&\n\t\t\t\t\t(lock->blist.next == &lock->blist));\n\t\tif (!rc)\n\t\t\tgoto try_again;\n\t\tdown_write(&cinode->lock_sem);\n\t\tlist_del_init(&lock->blist);\n\t}\n\n\tup_write(&cinode->lock_sem);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_lock_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "927-934",
    "snippet": "static void\ncifs_lock_add(struct cifsFileInfo *cfile, struct cifsLockInfo *lock)\n{\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tdown_write(&cinode->lock_sem);\n\tlist_add_tail(&lock->llist, &cfile->llist->locks);\n\tup_write(&cinode->lock_sem);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lock->llist",
            "&cfile->llist->locks"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "cfile->dentry->d_inode"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic void\ncifs_lock_add(struct cifsFileInfo *cfile, struct cifsLockInfo *lock)\n{\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tdown_write(&cinode->lock_sem);\n\tlist_add_tail(&lock->llist, &cfile->llist->locks);\n\tup_write(&cinode->lock_sem);\n}"
  },
  {
    "function_name": "cifs_lock_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "896-925",
    "snippet": "static int\ncifs_lock_test(struct cifsFileInfo *cfile, __u64 offset, __u64 length,\n\t       __u8 type, struct file_lock *flock)\n{\n\tint rc = 0;\n\tstruct cifsLockInfo *conf_lock;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;\n\tbool exist;\n\n\tdown_read(&cinode->lock_sem);\n\n\texist = cifs_find_lock_conflict(cfile, offset, length, type,\n\t\t\t\t\t&conf_lock, CIFS_LOCK_OP);\n\tif (exist) {\n\t\tflock->fl_start = conf_lock->offset;\n\t\tflock->fl_end = conf_lock->offset + conf_lock->length - 1;\n\t\tflock->fl_pid = conf_lock->pid;\n\t\tif (conf_lock->type & server->vals->shared_lock_type)\n\t\t\tflock->fl_type = F_RDLCK;\n\t\telse\n\t\t\tflock->fl_type = F_WRLCK;\n\t} else if (!cinode->can_cache_brlcks)\n\t\trc = 1;\n\telse\n\t\tflock->fl_type = F_UNLCK;\n\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CIFS_LOCK_OP\t0"
    ],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_find_lock_conflict",
          "args": [
            "cfile",
            "offset",
            "length",
            "type",
            "&conf_lock",
            "CIFS_LOCK_OP"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_find_lock_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "870-887",
          "snippet": "bool\ncifs_find_lock_conflict(struct cifsFileInfo *cfile, __u64 offset, __u64 length,\n\t\t\t__u8 type, struct cifsLockInfo **conf_lock,\n\t\t\tint rw_check)\n{\n\tbool rc = false;\n\tstruct cifs_fid_locks *cur;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\n\tlist_for_each_entry(cur, &cinode->llist, llist) {\n\t\trc = cifs_find_fid_lock_conflict(cur, offset, length, type,\n\t\t\t\t\t\t cfile, conf_lock, rw_check);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nbool\ncifs_find_lock_conflict(struct cifsFileInfo *cfile, __u64 offset, __u64 length,\n\t\t\t__u8 type, struct cifsLockInfo **conf_lock,\n\t\t\tint rw_check)\n{\n\tbool rc = false;\n\tstruct cifs_fid_locks *cur;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\n\tlist_for_each_entry(cur, &cinode->llist, llist) {\n\t\trc = cifs_find_fid_lock_conflict(cur, offset, length, type,\n\t\t\t\t\t\t cfile, conf_lock, rw_check);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "cfile->dentry->d_inode"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\n#define CIFS_LOCK_OP\t0\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_lock_test(struct cifsFileInfo *cfile, __u64 offset, __u64 length,\n\t       __u8 type, struct file_lock *flock)\n{\n\tint rc = 0;\n\tstruct cifsLockInfo *conf_lock;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;\n\tbool exist;\n\n\tdown_read(&cinode->lock_sem);\n\n\texist = cifs_find_lock_conflict(cfile, offset, length, type,\n\t\t\t\t\t&conf_lock, CIFS_LOCK_OP);\n\tif (exist) {\n\t\tflock->fl_start = conf_lock->offset;\n\t\tflock->fl_end = conf_lock->offset + conf_lock->length - 1;\n\t\tflock->fl_pid = conf_lock->pid;\n\t\tif (conf_lock->type & server->vals->shared_lock_type)\n\t\t\tflock->fl_type = F_RDLCK;\n\t\telse\n\t\t\tflock->fl_type = F_WRLCK;\n\t} else if (!cinode->can_cache_brlcks)\n\t\trc = 1;\n\telse\n\t\tflock->fl_type = F_UNLCK;\n\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_find_lock_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "870-887",
    "snippet": "bool\ncifs_find_lock_conflict(struct cifsFileInfo *cfile, __u64 offset, __u64 length,\n\t\t\t__u8 type, struct cifsLockInfo **conf_lock,\n\t\t\tint rw_check)\n{\n\tbool rc = false;\n\tstruct cifs_fid_locks *cur;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\n\tlist_for_each_entry(cur, &cinode->llist, llist) {\n\t\trc = cifs_find_fid_lock_conflict(cur, offset, length, type,\n\t\t\t\t\t\t cfile, conf_lock, rw_check);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_find_fid_lock_conflict",
          "args": [
            "cur",
            "offset",
            "length",
            "type",
            "cfile",
            "conf_lock",
            "rw_check"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_find_fid_lock_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "839-868",
          "snippet": "static bool\ncifs_find_fid_lock_conflict(struct cifs_fid_locks *fdlocks, __u64 offset,\n\t\t\t    __u64 length, __u8 type, struct cifsFileInfo *cfile,\n\t\t\t    struct cifsLockInfo **conf_lock, int rw_check)\n{\n\tstruct cifsLockInfo *li;\n\tstruct cifsFileInfo *cur_cfile = fdlocks->cfile;\n\tstruct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;\n\n\tlist_for_each_entry(li, &fdlocks->locks, llist) {\n\t\tif (offset + length <= li->offset ||\n\t\t    offset >= li->offset + li->length)\n\t\t\tcontinue;\n\t\tif (rw_check != CIFS_LOCK_OP && current->tgid == li->pid &&\n\t\t    server->ops->compare_fids(cfile, cur_cfile)) {\n\t\t\t/* shared lock prevents write op through the same fid */\n\t\t\tif (!(li->type & server->vals->shared_lock_type) ||\n\t\t\t    rw_check != CIFS_WRITE_OP)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif ((type & server->vals->shared_lock_type) &&\n\t\t    ((server->ops->compare_fids(cfile, cur_cfile) &&\n\t\t     current->tgid == li->pid) || type == li->type))\n\t\t\tcontinue;\n\t\tif (conf_lock)\n\t\t\t*conf_lock = li;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define CIFS_WRITE_OP\t2",
            "#define CIFS_LOCK_OP\t0"
          ],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\n#define CIFS_WRITE_OP\t2\n#define CIFS_LOCK_OP\t0\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic bool\ncifs_find_fid_lock_conflict(struct cifs_fid_locks *fdlocks, __u64 offset,\n\t\t\t    __u64 length, __u8 type, struct cifsFileInfo *cfile,\n\t\t\t    struct cifsLockInfo **conf_lock, int rw_check)\n{\n\tstruct cifsLockInfo *li;\n\tstruct cifsFileInfo *cur_cfile = fdlocks->cfile;\n\tstruct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;\n\n\tlist_for_each_entry(li, &fdlocks->locks, llist) {\n\t\tif (offset + length <= li->offset ||\n\t\t    offset >= li->offset + li->length)\n\t\t\tcontinue;\n\t\tif (rw_check != CIFS_LOCK_OP && current->tgid == li->pid &&\n\t\t    server->ops->compare_fids(cfile, cur_cfile)) {\n\t\t\t/* shared lock prevents write op through the same fid */\n\t\t\tif (!(li->type & server->vals->shared_lock_type) ||\n\t\t\t    rw_check != CIFS_WRITE_OP)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif ((type & server->vals->shared_lock_type) &&\n\t\t    ((server->ops->compare_fids(cfile, cur_cfile) &&\n\t\t     current->tgid == li->pid) || type == li->type))\n\t\t\tcontinue;\n\t\tif (conf_lock)\n\t\t\t*conf_lock = li;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cur",
            "&cinode->llist",
            "llist"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "cfile->dentry->d_inode"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nbool\ncifs_find_lock_conflict(struct cifsFileInfo *cfile, __u64 offset, __u64 length,\n\t\t\t__u8 type, struct cifsLockInfo **conf_lock,\n\t\t\tint rw_check)\n{\n\tbool rc = false;\n\tstruct cifs_fid_locks *cur;\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\n\tlist_for_each_entry(cur, &cinode->llist, llist) {\n\t\trc = cifs_find_fid_lock_conflict(cur, offset, length, type,\n\t\t\t\t\t\t cfile, conf_lock, rw_check);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_find_fid_lock_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "839-868",
    "snippet": "static bool\ncifs_find_fid_lock_conflict(struct cifs_fid_locks *fdlocks, __u64 offset,\n\t\t\t    __u64 length, __u8 type, struct cifsFileInfo *cfile,\n\t\t\t    struct cifsLockInfo **conf_lock, int rw_check)\n{\n\tstruct cifsLockInfo *li;\n\tstruct cifsFileInfo *cur_cfile = fdlocks->cfile;\n\tstruct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;\n\n\tlist_for_each_entry(li, &fdlocks->locks, llist) {\n\t\tif (offset + length <= li->offset ||\n\t\t    offset >= li->offset + li->length)\n\t\t\tcontinue;\n\t\tif (rw_check != CIFS_LOCK_OP && current->tgid == li->pid &&\n\t\t    server->ops->compare_fids(cfile, cur_cfile)) {\n\t\t\t/* shared lock prevents write op through the same fid */\n\t\t\tif (!(li->type & server->vals->shared_lock_type) ||\n\t\t\t    rw_check != CIFS_WRITE_OP)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif ((type & server->vals->shared_lock_type) &&\n\t\t    ((server->ops->compare_fids(cfile, cur_cfile) &&\n\t\t     current->tgid == li->pid) || type == li->type))\n\t\t\tcontinue;\n\t\tif (conf_lock)\n\t\t\t*conf_lock = li;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CIFS_WRITE_OP\t2",
      "#define CIFS_LOCK_OP\t0"
    ],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "server->ops->compare_fids",
          "args": [
            "cfile",
            "cur_cfile"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->compare_fids",
          "args": [
            "cfile",
            "cur_cfile"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "li",
            "&fdlocks->locks",
            "llist"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\n#define CIFS_WRITE_OP\t2\n#define CIFS_LOCK_OP\t0\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic bool\ncifs_find_fid_lock_conflict(struct cifs_fid_locks *fdlocks, __u64 offset,\n\t\t\t    __u64 length, __u8 type, struct cifsFileInfo *cfile,\n\t\t\t    struct cifsLockInfo **conf_lock, int rw_check)\n{\n\tstruct cifsLockInfo *li;\n\tstruct cifsFileInfo *cur_cfile = fdlocks->cfile;\n\tstruct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;\n\n\tlist_for_each_entry(li, &fdlocks->locks, llist) {\n\t\tif (offset + length <= li->offset ||\n\t\t    offset >= li->offset + li->length)\n\t\t\tcontinue;\n\t\tif (rw_check != CIFS_LOCK_OP && current->tgid == li->pid &&\n\t\t    server->ops->compare_fids(cfile, cur_cfile)) {\n\t\t\t/* shared lock prevents write op through the same fid */\n\t\t\tif (!(li->type & server->vals->shared_lock_type) ||\n\t\t\t    rw_check != CIFS_WRITE_OP)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif ((type & server->vals->shared_lock_type) &&\n\t\t    ((server->ops->compare_fids(cfile, cur_cfile) &&\n\t\t     current->tgid == li->pid) || type == li->type))\n\t\t\tcontinue;\n\t\tif (conf_lock)\n\t\t\t*conf_lock = li;\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "cifs_del_lock_waiters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "824-832",
    "snippet": "void\ncifs_del_lock_waiters(struct cifsLockInfo *lock)\n{\n\tstruct cifsLockInfo *li, *tmp;\n\tlist_for_each_entry_safe(li, tmp, &lock->blist, blist) {\n\t\tlist_del_init(&li->blist);\n\t\twake_up(&li->block_q);\n\t}\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&li->block_q"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_wake_up_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "40-44",
          "snippet": "void\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&li->blist"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "li",
            "tmp",
            "&lock->blist",
            "blist"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid\ncifs_del_lock_waiters(struct cifsLockInfo *lock)\n{\n\tstruct cifsLockInfo *li, *tmp;\n\tlist_for_each_entry_safe(li, tmp, &lock->blist, blist) {\n\t\tlist_del_init(&li->blist);\n\t\twake_up(&li->block_q);\n\t}\n}"
  },
  {
    "function_name": "cifs_lock_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "808-822",
    "snippet": "static struct cifsLockInfo *\ncifs_lock_init(__u64 offset, __u64 length, __u8 type)\n{\n\tstruct cifsLockInfo *lock =\n\t\tkmalloc(sizeof(struct cifsLockInfo), GFP_KERNEL);\n\tif (!lock)\n\t\treturn lock;\n\tlock->offset = offset;\n\tlock->length = length;\n\tlock->type = type;\n\tlock->pid = current->tgid;\n\tINIT_LIST_HEAD(&lock->blist);\n\tinit_waitqueue_head(&lock->block_q);\n\treturn lock;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&lock->block_q"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&lock->blist"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct cifsLockInfo)",
            "GFP_KERNEL"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic struct cifsLockInfo *\ncifs_lock_init(__u64 offset, __u64 length, __u8 type)\n{\n\tstruct cifsLockInfo *lock =\n\t\tkmalloc(sizeof(struct cifsLockInfo), GFP_KERNEL);\n\tif (!lock)\n\t\treturn lock;\n\tlock->offset = offset;\n\tlock->length = length;\n\tlock->type = type;\n\tlock->pid = current->tgid;\n\tINIT_LIST_HEAD(&lock->blist);\n\tinit_waitqueue_head(&lock->block_q);\n\treturn lock;\n}"
  },
  {
    "function_name": "cifs_closedir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "757-806",
    "snippet": "int cifs_closedir(struct inode *inode, struct file *file)\n{\n\tint rc = 0;\n\tunsigned int xid;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tchar *buf;\n\n\tcifs_dbg(FYI, \"Closedir inode = 0x%p\\n\", inode);\n\n\tif (cfile == NULL)\n\t\treturn rc;\n\n\txid = get_xid();\n\ttcon = tlink_tcon(cfile->tlink);\n\tserver = tcon->ses->server;\n\n\tcifs_dbg(FYI, \"Freeing private data in close dir\\n\");\n\tspin_lock(&cifs_file_list_lock);\n\tif (server->ops->dir_needs_close(cfile)) {\n\t\tcfile->invalidHandle = true;\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\tif (server->ops->close_dir)\n\t\t\trc = server->ops->close_dir(xid, tcon, &cfile->fid);\n\t\telse\n\t\t\trc = -ENOSYS;\n\t\tcifs_dbg(FYI, \"Closing uncompleted readdir with rc %d\\n\", rc);\n\t\t/* not much we can do if it fails anyway, ignore rc */\n\t\trc = 0;\n\t} else\n\t\tspin_unlock(&cifs_file_list_lock);\n\n\tbuf = cfile->srch_inf.ntwrk_buf_start;\n\tif (buf) {\n\t\tcifs_dbg(FYI, \"closedir free smb buf in srch struct\\n\");\n\t\tcfile->srch_inf.ntwrk_buf_start = NULL;\n\t\tif (cfile->srch_inf.smallBuf)\n\t\t\tcifs_small_buf_release(buf);\n\t\telse\n\t\t\tcifs_buf_release(buf);\n\t}\n\n\tcifs_put_tlink(cfile->tlink);\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\t/* BB can we lock the filestruct while this is going on? */\n\tfree_xid(xid);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "file->private_data"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "cfile->tlink"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "buf"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_small_buf_release",
          "args": [
            "buf"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "215-227",
          "snippet": "void\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nvoid\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"closedir free smb buf in srch struct\\n\""
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Closing uncompleted readdir with rc %d\\n\"",
            "rc"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->close_dir",
          "args": [
            "xid",
            "tcon",
            "&cfile->fid"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->dir_needs_close",
          "args": [
            "cfile"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Freeing private data in close dir\\n\""
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Closedir inode = 0x%p\\n\"",
            "inode"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nint cifs_closedir(struct inode *inode, struct file *file)\n{\n\tint rc = 0;\n\tunsigned int xid;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tchar *buf;\n\n\tcifs_dbg(FYI, \"Closedir inode = 0x%p\\n\", inode);\n\n\tif (cfile == NULL)\n\t\treturn rc;\n\n\txid = get_xid();\n\ttcon = tlink_tcon(cfile->tlink);\n\tserver = tcon->ses->server;\n\n\tcifs_dbg(FYI, \"Freeing private data in close dir\\n\");\n\tspin_lock(&cifs_file_list_lock);\n\tif (server->ops->dir_needs_close(cfile)) {\n\t\tcfile->invalidHandle = true;\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\tif (server->ops->close_dir)\n\t\t\trc = server->ops->close_dir(xid, tcon, &cfile->fid);\n\t\telse\n\t\t\trc = -ENOSYS;\n\t\tcifs_dbg(FYI, \"Closing uncompleted readdir with rc %d\\n\", rc);\n\t\t/* not much we can do if it fails anyway, ignore rc */\n\t\trc = 0;\n\t} else\n\t\tspin_unlock(&cifs_file_list_lock);\n\n\tbuf = cfile->srch_inf.ntwrk_buf_start;\n\tif (buf) {\n\t\tcifs_dbg(FYI, \"closedir free smb buf in srch struct\\n\");\n\t\tcfile->srch_inf.ntwrk_buf_start = NULL;\n\t\tif (cfile->srch_inf.smallBuf)\n\t\t\tcifs_small_buf_release(buf);\n\t\telse\n\t\t\tcifs_buf_release(buf);\n\t}\n\n\tcifs_put_tlink(cfile->tlink);\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\t/* BB can we lock the filestruct while this is going on? */\n\tfree_xid(xid);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "746-755",
    "snippet": "int cifs_close(struct inode *inode, struct file *file)\n{\n\tif (file->private_data != NULL) {\n\t\tcifsFileInfo_put(file->private_data);\n\t\tfile->private_data = NULL;\n\t}\n\n\t/* return code from the ->release op is always ignored */\n\treturn 0;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifsFileInfo_put",
          "args": [
            "file->private_data"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "cifsFileInfo_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "358-436",
          "snippet": "void cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nint cifs_close(struct inode *inode, struct file *file)\n{\n\tif (file->private_data != NULL) {\n\t\tcifsFileInfo_put(file->private_data);\n\t\tfile->private_data = NULL;\n\t}\n\n\t/* return code from the ->release op is always ignored */\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_reopen_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "597-744",
    "snippet": "static int\ncifs_reopen_file(struct cifsFileInfo *cfile, bool can_flush)\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\t__u32 oplock;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsInodeInfo *cinode;\n\tstruct inode *inode;\n\tchar *full_path = NULL;\n\tint desired_access;\n\tint disposition = FILE_OPEN;\n\tint create_options = CREATE_NOT_DIR;\n\tstruct cifs_open_parms oparms;\n\n\txid = get_xid();\n\tmutex_lock(&cfile->fh_mutex);\n\tif (!cfile->invalidHandle) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\trc = 0;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tinode = cfile->dentry->d_inode;\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttcon = tlink_tcon(cfile->tlink);\n\tserver = tcon->ses->server;\n\n\t/*\n\t * Can not grab rename sem here because various ops, including those\n\t * that already have the rename sem can end up causing writepage to get\n\t * called and if the server was down that means we end up here, and we\n\t * can never tell if the caller already has the rename_sem.\n\t */\n\tfull_path = build_path_from_dentry(cfile->dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tcifs_dbg(FYI, \"inode = 0x%p file flags 0x%x for %s\\n\",\n\t\t inode, cfile->f_flags, full_path);\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\t/*\n\t\t * O_CREAT, O_EXCL and O_TRUNC already had their effect on the\n\t\t * original open. Must mask them off for a reopen.\n\t\t */\n\t\tunsigned int oflags = cfile->f_flags &\n\t\t\t\t\t\t~(O_CREAT | O_EXCL | O_TRUNC);\n\n\t\trc = cifs_posix_open(full_path, NULL, inode->i_sb,\n\t\t\t\t     cifs_sb->mnt_file_mode /* ignored */,\n\t\t\t\t     oflags, &oplock, &cfile->fid.netfid, xid);\n\t\tif (rc == 0) {\n\t\t\tcifs_dbg(FYI, \"posix reopen succeeded\\n\");\n\t\t\toparms.reconnect = true;\n\t\t\tgoto reopen_success;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry open the old way on errors, especially\n\t\t * in the reconnect path it is important to retry hard\n\t\t */\n\t}\n\n\tdesired_access = cifs_convert_flags(cfile->f_flags);\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &cfile->fid);\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = &cfile->fid;\n\toparms.reconnect = true;\n\n\t/*\n\t * Can not refresh inode by passing in file_info buf to be returned by\n\t * ops->open and then calling get_inode_info with returned buf since\n\t * file might have write behind data that needs to be flushed and server\n\t * version of file size can be stale. If we knew for sure that inode was\n\t * not dirty locally we could do this.\n\t */\n\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\tif (rc == -ENOENT && oparms.reconnect == false) {\n\t\t/* durable handle timeout is expired - open the file again */\n\t\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\t\t/* indicate that we need to relock the file */\n\t\toparms.reconnect = true;\n\t}\n\n\tif (rc) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tcifs_dbg(FYI, \"cifs_reopen returned 0x%x\\n\", rc);\n\t\tcifs_dbg(FYI, \"oplock: %d\\n\", oplock);\n\t\tgoto reopen_error_exit;\n\t}\n\nreopen_success:\n\tcfile->invalidHandle = false;\n\tmutex_unlock(&cfile->fh_mutex);\n\tcinode = CIFS_I(inode);\n\n\tif (can_flush) {\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\t\tmapping_set_error(inode->i_mapping, rc);\n\n\t\tif (tcon->unix_ext)\n\t\t\trc = cifs_get_inode_info_unix(&inode, full_path,\n\t\t\t\t\t\t      inode->i_sb, xid);\n\t\telse\n\t\t\trc = cifs_get_inode_info(&inode, full_path, NULL,\n\t\t\t\t\t\t inode->i_sb, xid, NULL);\n\t}\n\t/*\n\t * Else we are writing out data to server already and could deadlock if\n\t * we tried to flush data, and since we do not know if we have data that\n\t * would invalidate the current end of file on the server we can not go\n\t * to the server to get the new inode info.\n\t */\n\n\tserver->ops->set_fid(cfile, &cfile->fid, oplock);\n\tif (oparms.reconnect)\n\t\tcifs_relock_file(cfile);\n\nreopen_error_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_relock_file",
          "args": [
            "cfile"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_relock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "571-595",
          "snippet": "static int\ncifs_relock_file(struct cifsFileInfo *cfile)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(cfile->dentry->d_sb);\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tint rc = 0;\n\n\tdown_read(&cinode->lock_sem);\n\tif (cinode->can_cache_brlcks) {\n\t\t/* can cache locks - no need to relock */\n\t\tup_read(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n\tif (cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability)) &&\n\t    ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0))\n\t\trc = cifs_push_posix_locks(cfile);\n\telse\n\t\trc = tcon->ses->server->ops->push_mand_locks(cfile);\n\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_relock_file(struct cifsFileInfo *cfile)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(cfile->dentry->d_sb);\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tint rc = 0;\n\n\tdown_read(&cinode->lock_sem);\n\tif (cinode->can_cache_brlcks) {\n\t\t/* can cache locks - no need to relock */\n\t\tup_read(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n\tif (cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability)) &&\n\t    ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0))\n\t\trc = cifs_push_posix_locks(cfile);\n\telse\n\t\trc = tcon->ses->server->ops->push_mand_locks(cfile);\n\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->set_fid",
          "args": [
            "cfile",
            "&cfile->fid",
            "oplock"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_inode_info",
          "args": [
            "&inode",
            "full_path",
            "NULL",
            "inode->i_sb",
            "xid",
            "NULL"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_inode_info_unix",
          "args": [
            "&inode",
            "full_path",
            "inode->i_sb",
            "xid"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "inode->i_mapping",
            "rc"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "inode->i_mapping"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cfile->fh_mutex"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"oplock: %d\\n\"",
            "oplock"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"cifs_reopen returned 0x%x\\n\"",
            "rc"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cfile->fh_mutex"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->open",
          "args": [
            "xid",
            "&oparms",
            "&oplock",
            "NULL"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->open",
          "args": [
            "xid",
            "&oparms",
            "&oplock",
            "NULL"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->get_lease_key",
          "args": [
            "inode",
            "&cfile->fid"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "backup_cred",
          "args": [
            "cifs_sb"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "backup_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "598-611",
          "snippet": "bool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nbool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_convert_flags",
          "args": [
            "cfile->f_flags"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_convert_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "47-63",
          "snippet": "static inline int cifs_convert_flags(unsigned int flags)\n{\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\treturn GENERIC_READ;\n\telse if ((flags & O_ACCMODE) == O_WRONLY)\n\t\treturn GENERIC_WRITE;\n\telse if ((flags & O_ACCMODE) == O_RDWR) {\n\t\t/* GENERIC_ALL is too much permission to request\n\t\t   can cause unnecessary access denied on create */\n\t\t/* return GENERIC_ALL; */\n\t\treturn (GENERIC_READ | GENERIC_WRITE);\n\t}\n\n\treturn (READ_CONTROL | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES |\n\t\tFILE_WRITE_EA | FILE_APPEND_DATA | FILE_WRITE_DATA |\n\t\tFILE_READ_DATA);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic inline int cifs_convert_flags(unsigned int flags)\n{\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\treturn GENERIC_READ;\n\telse if ((flags & O_ACCMODE) == O_WRONLY)\n\t\treturn GENERIC_WRITE;\n\telse if ((flags & O_ACCMODE) == O_RDWR) {\n\t\t/* GENERIC_ALL is too much permission to request\n\t\t   can cause unnecessary access denied on create */\n\t\t/* return GENERIC_ALL; */\n\t\treturn (GENERIC_READ | GENERIC_WRITE);\n\t}\n\n\treturn (READ_CONTROL | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES |\n\t\tFILE_WRITE_EA | FILE_APPEND_DATA | FILE_WRITE_DATA |\n\t\tFILE_READ_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"posix reopen succeeded\\n\""
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_posix_open",
          "args": [
            "full_path",
            "NULL",
            "inode->i_sb",
            "cifs_sb->mnt_file_mode/* ignored */",
            "oflags",
            "&oplock",
            "&cfile->fid.netfid",
            "xid"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_posix_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "113-173",
          "snippet": "int cifs_posix_open(char *full_path, struct inode **pinode,\n\t\t\tstruct super_block *sb, int mode, unsigned int f_flags,\n\t\t\t__u32 *poplock, __u16 *pnetfid, unsigned int xid)\n{\n\tint rc;\n\tFILE_UNIX_BASIC_INFO *presp_data;\n\t__u32 posix_flags = 0;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_fattr fattr;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\n\tcifs_dbg(FYI, \"posix open %s\\n\", full_path);\n\n\tpresp_data = kzalloc(sizeof(FILE_UNIX_BASIC_INFO), GFP_KERNEL);\n\tif (presp_data == NULL)\n\t\treturn -ENOMEM;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto posix_open_ret;\n\t}\n\n\ttcon = tlink_tcon(tlink);\n\tmode &= ~current_umask();\n\n\tposix_flags = cifs_posix_convert_flags(f_flags);\n\trc = CIFSPOSIXCreate(xid, tcon, posix_flags, mode, pnetfid, presp_data,\n\t\t\t     poplock, full_path, cifs_sb->local_nls,\n\t\t\t     cifs_sb->mnt_cifs_flags &\n\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\tcifs_put_tlink(tlink);\n\n\tif (rc)\n\t\tgoto posix_open_ret;\n\n\tif (presp_data->Type == cpu_to_le32(-1))\n\t\tgoto posix_open_ret; /* open ok, caller does qpathinfo */\n\n\tif (!pinode)\n\t\tgoto posix_open_ret; /* caller does not need info */\n\n\tcifs_unix_basic_to_fattr(&fattr, presp_data, cifs_sb);\n\n\t/* get new inode and set it up */\n\tif (*pinode == NULL) {\n\t\tcifs_fill_uniqueid(sb, &fattr);\n\t\t*pinode = cifs_iget(sb, &fattr);\n\t\tif (!*pinode) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto posix_open_ret;\n\t\t}\n\t} else {\n\t\tcifs_fattr_to_inode(*pinode, &fattr);\n\t}\n\nposix_open_ret:\n\tkfree(presp_data);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nint cifs_posix_open(char *full_path, struct inode **pinode,\n\t\t\tstruct super_block *sb, int mode, unsigned int f_flags,\n\t\t\t__u32 *poplock, __u16 *pnetfid, unsigned int xid)\n{\n\tint rc;\n\tFILE_UNIX_BASIC_INFO *presp_data;\n\t__u32 posix_flags = 0;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_fattr fattr;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\n\tcifs_dbg(FYI, \"posix open %s\\n\", full_path);\n\n\tpresp_data = kzalloc(sizeof(FILE_UNIX_BASIC_INFO), GFP_KERNEL);\n\tif (presp_data == NULL)\n\t\treturn -ENOMEM;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto posix_open_ret;\n\t}\n\n\ttcon = tlink_tcon(tlink);\n\tmode &= ~current_umask();\n\n\tposix_flags = cifs_posix_convert_flags(f_flags);\n\trc = CIFSPOSIXCreate(xid, tcon, posix_flags, mode, pnetfid, presp_data,\n\t\t\t     poplock, full_path, cifs_sb->local_nls,\n\t\t\t     cifs_sb->mnt_cifs_flags &\n\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\tcifs_put_tlink(tlink);\n\n\tif (rc)\n\t\tgoto posix_open_ret;\n\n\tif (presp_data->Type == cpu_to_le32(-1))\n\t\tgoto posix_open_ret; /* open ok, caller does qpathinfo */\n\n\tif (!pinode)\n\t\tgoto posix_open_ret; /* caller does not need info */\n\n\tcifs_unix_basic_to_fattr(&fattr, presp_data, cifs_sb);\n\n\t/* get new inode and set it up */\n\tif (*pinode == NULL) {\n\t\tcifs_fill_uniqueid(sb, &fattr);\n\t\t*pinode = cifs_iget(sb, &fattr);\n\t\tif (!*pinode) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto posix_open_ret;\n\t\t}\n\t} else {\n\t\tcifs_fattr_to_inode(*pinode, &fattr);\n\t}\n\nposix_open_ret:\n\tkfree(presp_data);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "tcon->fsUnixInfo.Capability"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_unix",
          "args": [
            "tcon->ses"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "cap_unix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "804-808",
          "snippet": "static inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"inode = 0x%p file flags 0x%x for %s\\n\"",
            "inode",
            "cfile->f_flags",
            "full_path"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cfile->fh_mutex"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_path_from_dentry",
          "args": [
            "cfile->dentry"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "build_path_from_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
          "lines": "81-167",
          "snippet": "char *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nchar *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cfile->fh_mutex"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cfile->fh_mutex"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_reopen_file(struct cifsFileInfo *cfile, bool can_flush)\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\t__u32 oplock;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifsInodeInfo *cinode;\n\tstruct inode *inode;\n\tchar *full_path = NULL;\n\tint desired_access;\n\tint disposition = FILE_OPEN;\n\tint create_options = CREATE_NOT_DIR;\n\tstruct cifs_open_parms oparms;\n\n\txid = get_xid();\n\tmutex_lock(&cfile->fh_mutex);\n\tif (!cfile->invalidHandle) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\trc = 0;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tinode = cfile->dentry->d_inode;\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttcon = tlink_tcon(cfile->tlink);\n\tserver = tcon->ses->server;\n\n\t/*\n\t * Can not grab rename sem here because various ops, including those\n\t * that already have the rename sem can end up causing writepage to get\n\t * called and if the server was down that means we end up here, and we\n\t * can never tell if the caller already has the rename_sem.\n\t */\n\tfull_path = build_path_from_dentry(cfile->dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tcifs_dbg(FYI, \"inode = 0x%p file flags 0x%x for %s\\n\",\n\t\t inode, cfile->f_flags, full_path);\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\t/*\n\t\t * O_CREAT, O_EXCL and O_TRUNC already had their effect on the\n\t\t * original open. Must mask them off for a reopen.\n\t\t */\n\t\tunsigned int oflags = cfile->f_flags &\n\t\t\t\t\t\t~(O_CREAT | O_EXCL | O_TRUNC);\n\n\t\trc = cifs_posix_open(full_path, NULL, inode->i_sb,\n\t\t\t\t     cifs_sb->mnt_file_mode /* ignored */,\n\t\t\t\t     oflags, &oplock, &cfile->fid.netfid, xid);\n\t\tif (rc == 0) {\n\t\t\tcifs_dbg(FYI, \"posix reopen succeeded\\n\");\n\t\t\toparms.reconnect = true;\n\t\t\tgoto reopen_success;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry open the old way on errors, especially\n\t\t * in the reconnect path it is important to retry hard\n\t\t */\n\t}\n\n\tdesired_access = cifs_convert_flags(cfile->f_flags);\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &cfile->fid);\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = &cfile->fid;\n\toparms.reconnect = true;\n\n\t/*\n\t * Can not refresh inode by passing in file_info buf to be returned by\n\t * ops->open and then calling get_inode_info with returned buf since\n\t * file might have write behind data that needs to be flushed and server\n\t * version of file size can be stale. If we knew for sure that inode was\n\t * not dirty locally we could do this.\n\t */\n\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\tif (rc == -ENOENT && oparms.reconnect == false) {\n\t\t/* durable handle timeout is expired - open the file again */\n\t\trc = server->ops->open(xid, &oparms, &oplock, NULL);\n\t\t/* indicate that we need to relock the file */\n\t\toparms.reconnect = true;\n\t}\n\n\tif (rc) {\n\t\tmutex_unlock(&cfile->fh_mutex);\n\t\tcifs_dbg(FYI, \"cifs_reopen returned 0x%x\\n\", rc);\n\t\tcifs_dbg(FYI, \"oplock: %d\\n\", oplock);\n\t\tgoto reopen_error_exit;\n\t}\n\nreopen_success:\n\tcfile->invalidHandle = false;\n\tmutex_unlock(&cfile->fh_mutex);\n\tcinode = CIFS_I(inode);\n\n\tif (can_flush) {\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\t\tmapping_set_error(inode->i_mapping, rc);\n\n\t\tif (tcon->unix_ext)\n\t\t\trc = cifs_get_inode_info_unix(&inode, full_path,\n\t\t\t\t\t\t      inode->i_sb, xid);\n\t\telse\n\t\t\trc = cifs_get_inode_info(&inode, full_path, NULL,\n\t\t\t\t\t\t inode->i_sb, xid, NULL);\n\t}\n\t/*\n\t * Else we are writing out data to server already and could deadlock if\n\t * we tried to flush data, and since we do not know if we have data that\n\t * would invalidate the current end of file on the server we can not go\n\t * to the server to get the new inode info.\n\t */\n\n\tserver->ops->set_fid(cfile, &cfile->fid, oplock);\n\tif (oparms.reconnect)\n\t\tcifs_relock_file(cfile);\n\nreopen_error_exit:\n\tkfree(full_path);\n\tfree_xid(xid);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_relock_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "571-595",
    "snippet": "static int\ncifs_relock_file(struct cifsFileInfo *cfile)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(cfile->dentry->d_sb);\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tint rc = 0;\n\n\tdown_read(&cinode->lock_sem);\n\tif (cinode->can_cache_brlcks) {\n\t\t/* can cache locks - no need to relock */\n\t\tup_read(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n\tif (cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability)) &&\n\t    ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0))\n\t\trc = cifs_push_posix_locks(cfile);\n\telse\n\t\trc = tcon->ses->server->ops->push_mand_locks(cfile);\n\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->push_mand_locks",
          "args": [
            "cfile"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_push_posix_locks",
          "args": [
            "cfile"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_push_posix_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1125-1211",
          "snippet": "static int\ncifs_push_posix_locks(struct cifsFileInfo *cfile)\n{\n\tstruct inode *inode = cfile->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct file_lock *flock;\n\tstruct file_lock_context *flctx = inode->i_flctx;\n\tunsigned int count = 0, i;\n\tint rc = 0, xid, type;\n\tstruct list_head locks_to_send, *el;\n\tstruct lock_to_push *lck, *tmp;\n\t__u64 length;\n\n\txid = get_xid();\n\n\tif (!flctx)\n\t\tgoto out;\n\n\tspin_lock(&flctx->flc_lock);\n\tlist_for_each(el, &flctx->flc_posix) {\n\t\tcount++;\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\n\tINIT_LIST_HEAD(&locks_to_send);\n\n\t/*\n\t * Allocating count locks is enough because no FL_POSIX locks can be\n\t * added to the list while we are holding cinode->lock_sem that\n\t * protects locking operations of this inode.\n\t */\n\tfor (i = 0; i < count; i++) {\n\t\tlck = kmalloc(sizeof(struct lock_to_push), GFP_KERNEL);\n\t\tif (!lck) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\tlist_add_tail(&lck->llist, &locks_to_send);\n\t}\n\n\tel = locks_to_send.next;\n\tspin_lock(&flctx->flc_lock);\n\tlist_for_each_entry(flock, &flctx->flc_posix, fl_list) {\n\t\tif (el == &locks_to_send) {\n\t\t\t/*\n\t\t\t * The list ended. We don't have enough allocated\n\t\t\t * structures - something is really wrong.\n\t\t\t */\n\t\t\tcifs_dbg(VFS, \"Can't push all brlocks!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tlength = 1 + flock->fl_end - flock->fl_start;\n\t\tif (flock->fl_type == F_RDLCK || flock->fl_type == F_SHLCK)\n\t\t\ttype = CIFS_RDLCK;\n\t\telse\n\t\t\ttype = CIFS_WRLCK;\n\t\tlck = list_entry(el, struct lock_to_push, llist);\n\t\tlck->pid = flock->fl_pid;\n\t\tlck->netfid = cfile->fid.netfid;\n\t\tlck->length = length;\n\t\tlck->type = type;\n\t\tlck->offset = flock->fl_start;\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\n\tlist_for_each_entry_safe(lck, tmp, &locks_to_send, llist) {\n\t\tint stored_rc;\n\n\t\tstored_rc = CIFSSMBPosixLock(xid, tcon, lck->netfid, lck->pid,\n\t\t\t\t\t     lck->offset, lck->length, NULL,\n\t\t\t\t\t     lck->type, 0);\n\t\tif (stored_rc)\n\t\t\trc = stored_rc;\n\t\tlist_del(&lck->llist);\n\t\tkfree(lck);\n\t}\n\nout:\n\tfree_xid(xid);\n\treturn rc;\nerr_out:\n\tlist_for_each_entry_safe(lck, tmp, &locks_to_send, llist) {\n\t\tlist_del(&lck->llist);\n\t\tkfree(lck);\n\t}\n\tgoto out;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_push_posix_locks(struct cifsFileInfo *cfile)\n{\n\tstruct inode *inode = cfile->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tstruct file_lock *flock;\n\tstruct file_lock_context *flctx = inode->i_flctx;\n\tunsigned int count = 0, i;\n\tint rc = 0, xid, type;\n\tstruct list_head locks_to_send, *el;\n\tstruct lock_to_push *lck, *tmp;\n\t__u64 length;\n\n\txid = get_xid();\n\n\tif (!flctx)\n\t\tgoto out;\n\n\tspin_lock(&flctx->flc_lock);\n\tlist_for_each(el, &flctx->flc_posix) {\n\t\tcount++;\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\n\tINIT_LIST_HEAD(&locks_to_send);\n\n\t/*\n\t * Allocating count locks is enough because no FL_POSIX locks can be\n\t * added to the list while we are holding cinode->lock_sem that\n\t * protects locking operations of this inode.\n\t */\n\tfor (i = 0; i < count; i++) {\n\t\tlck = kmalloc(sizeof(struct lock_to_push), GFP_KERNEL);\n\t\tif (!lck) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\tlist_add_tail(&lck->llist, &locks_to_send);\n\t}\n\n\tel = locks_to_send.next;\n\tspin_lock(&flctx->flc_lock);\n\tlist_for_each_entry(flock, &flctx->flc_posix, fl_list) {\n\t\tif (el == &locks_to_send) {\n\t\t\t/*\n\t\t\t * The list ended. We don't have enough allocated\n\t\t\t * structures - something is really wrong.\n\t\t\t */\n\t\t\tcifs_dbg(VFS, \"Can't push all brlocks!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tlength = 1 + flock->fl_end - flock->fl_start;\n\t\tif (flock->fl_type == F_RDLCK || flock->fl_type == F_SHLCK)\n\t\t\ttype = CIFS_RDLCK;\n\t\telse\n\t\t\ttype = CIFS_WRLCK;\n\t\tlck = list_entry(el, struct lock_to_push, llist);\n\t\tlck->pid = flock->fl_pid;\n\t\tlck->netfid = cfile->fid.netfid;\n\t\tlck->length = length;\n\t\tlck->type = type;\n\t\tlck->offset = flock->fl_start;\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\n\tlist_for_each_entry_safe(lck, tmp, &locks_to_send, llist) {\n\t\tint stored_rc;\n\n\t\tstored_rc = CIFSSMBPosixLock(xid, tcon, lck->netfid, lck->pid,\n\t\t\t\t\t     lck->offset, lck->length, NULL,\n\t\t\t\t\t     lck->type, 0);\n\t\tif (stored_rc)\n\t\t\trc = stored_rc;\n\t\tlist_del(&lck->llist);\n\t\tkfree(lck);\n\t}\n\nout:\n\tfree_xid(xid);\n\treturn rc;\nerr_out:\n\tlist_for_each_entry_safe(lck, tmp, &locks_to_send, llist) {\n\t\tlist_del(&lck->llist);\n\t\tkfree(lck);\n\t}\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "tcon->fsUnixInfo.Capability"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_unix",
          "args": [
            "tcon->ses"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "cap_unix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "804-808",
          "snippet": "static inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "cfile->dentry->d_inode"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "cfile->dentry->d_sb"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstatic int\ncifs_relock_file(struct cifsFileInfo *cfile)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(cfile->dentry->d_sb);\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\n\tint rc = 0;\n\n\tdown_read(&cinode->lock_sem);\n\tif (cinode->can_cache_brlcks) {\n\t\t/* can cache locks - no need to relock */\n\t\tup_read(&cinode->lock_sem);\n\t\treturn rc;\n\t}\n\n\tif (cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability)) &&\n\t    ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0))\n\t\trc = cifs_push_posix_locks(cfile);\n\telse\n\t\trc = tcon->ses->server->ops->push_mand_locks(cfile);\n\n\tup_read(&cinode->lock_sem);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "438-563",
    "snippet": "int cifs_open(struct inode *inode, struct file *file)\n\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\t__u32 oplock;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink;\n\tstruct cifsFileInfo *cfile = NULL;\n\tchar *full_path = NULL;\n\tbool posix_open_ok = false;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\n\txid = get_xid();\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tfree_xid(xid);\n\t\treturn PTR_ERR(tlink);\n\t}\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tfull_path = build_path_from_dentry(file->f_path.dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcifs_dbg(FYI, \"inode = 0x%p file flags are 0x%x for %s\\n\",\n\t\t inode, file->f_flags, full_path);\n\n\tif (file->f_flags & O_DIRECT &&\n\t    cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO) {\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\t\tfile->f_op = &cifs_file_direct_nobrl_ops;\n\t\telse\n\t\t\tfile->f_op = &cifs_file_direct_ops;\n\t}\n\n\tif (server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\n\tif (!tcon->broken_posix_open && tcon->unix_ext &&\n\t    cap_unix(tcon->ses) && (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\t/* can not refresh inode info since size could be stale */\n\t\trc = cifs_posix_open(full_path, &inode, inode->i_sb,\n\t\t\t\tcifs_sb->mnt_file_mode /* ignored */,\n\t\t\t\tfile->f_flags, &oplock, &fid.netfid, xid);\n\t\tif (rc == 0) {\n\t\t\tcifs_dbg(FYI, \"posix open succeeded\\n\");\n\t\t\tposix_open_ok = true;\n\t\t} else if ((rc == -EINVAL) || (rc == -EOPNOTSUPP)) {\n\t\t\tif (tcon->ses->serverNOS)\n\t\t\t\tcifs_dbg(VFS, \"server %s of type %s returned unexpected error on SMB posix open, disabling posix open support. Check if server update available.\\n\",\n\t\t\t\t\t tcon->ses->serverName,\n\t\t\t\t\t tcon->ses->serverNOS);\n\t\t\ttcon->broken_posix_open = true;\n\t\t} else if ((rc != -EIO) && (rc != -EREMOTE) &&\n\t\t\t (rc != -EOPNOTSUPP)) /* path not found or net err */\n\t\t\tgoto out;\n\t\t/*\n\t\t * Else fallthrough to retry open the old way on network i/o\n\t\t * or DFS errors.\n\t\t */\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\tcifs_add_pending_open(&fid, tlink, &open);\n\n\tif (!posix_open_ok) {\n\t\tif (server->ops->get_lease_key)\n\t\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t\trc = cifs_nt_open(full_path, inode, cifs_sb, tcon,\n\t\t\t\t  file->f_flags, &oplock, &fid, xid);\n\t\tif (rc) {\n\t\t\tcifs_del_pending_open(&open);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcfile = cifs_new_fileinfo(&fid, file, tlink, oplock);\n\tif (cfile == NULL) {\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &fid);\n\t\tcifs_del_pending_open(&open);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcifs_fscache_set_inode_cookie(inode, file);\n\n\tif ((oplock & CIFS_CREATE_ACTION) && !posix_open_ok && tcon->unix_ext) {\n\t\t/*\n\t\t * Time to set mode which we can not set earlier due to\n\t\t * problems creating new read-only files.\n\t\t */\n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t.mode\t= inode->i_mode,\n\t\t\t.uid\t= INVALID_UID, /* no change */\n\t\t\t.gid\t= INVALID_GID, /* no change */\n\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t.device\t= 0,\n\t\t};\n\t\tCIFSSMBUnixSetFileInfo(xid, tcon, &args, fid.netfid,\n\t\t\t\t       cfile->pid);\n\t}\n\nout:\n\tkfree(full_path);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSSMBUnixSetFileInfo",
          "args": [
            "xid",
            "tcon",
            "&args",
            "fid.netfid",
            "cfile->pid"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBUnixSetFileInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "5991-6054",
          "snippet": "int\nCIFSSMBUnixSetFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       u16 fid, u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\tu16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set Unix Info (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *)pSMB +\n\t\t\toffsetof(struct smb_hdr, Protocol) + offset;\n\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\tcifs_fill_unix_set_info((FILE_UNIX_BASIC_INFO *)data_offset, args);\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Set Time (SetFileInfo) = %d\\n\",\n\t\t\t rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBUnixSetFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       u16 fid, u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\tu16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set Unix Info (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *)pSMB +\n\t\t\toffsetof(struct smb_hdr, Protocol) + offset;\n\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\tcifs_fill_unix_set_info((FILE_UNIX_BASIC_INFO *)data_offset, args);\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Set Time (SetFileInfo) = %d\\n\",\n\t\t\t rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_fscache_set_inode_cookie",
          "args": [
            "inode",
            "file"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_fscache_set_inode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/fscache.c",
          "lines": "101-107",
          "snippet": "void cifs_fscache_set_inode_cookie(struct inode *inode, struct file *filp)\n{\n\tif ((filp->f_flags & O_ACCMODE) != O_RDONLY)\n\t\tcifs_fscache_disable_inode_cookie(inode);\n\telse\n\t\tcifs_fscache_enable_inode_cookie(inode);\n}",
          "includes": [
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"fscache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"fscache.h\"\n\nvoid cifs_fscache_set_inode_cookie(struct inode *inode, struct file *filp)\n{\n\tif ((filp->f_flags & O_ACCMODE) != O_RDONLY)\n\t\tcifs_fscache_disable_inode_cookie(inode);\n\telse\n\t\tcifs_fscache_enable_inode_cookie(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_del_pending_open",
          "args": [
            "&open"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_del_pending_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "613-619",
          "snippet": "void\ncifs_del_pending_open(struct cifs_pending_open *open)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tlist_del(&open->olist);\n\tspin_unlock(&cifs_file_list_lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ncifs_del_pending_open(struct cifs_pending_open *open)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tlist_del(&open->olist);\n\tspin_unlock(&cifs_file_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->close",
          "args": [
            "xid",
            "tcon",
            "&fid"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_new_fileinfo",
          "args": [
            "&fid",
            "file",
            "tlink",
            "oplock"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_new_fileinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "271-342",
          "snippet": "struct cifsFileInfo *\ncifs_new_fileinfo(struct cifs_fid *fid, struct file *file,\n\t\t  struct tcon_link *tlink, __u32 oplock)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifsFileInfo *cfile;\n\tstruct cifs_fid_locks *fdlocks;\n\tstruct cifs_tcon *tcon = tlink_tcon(tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\tcfile = kzalloc(sizeof(struct cifsFileInfo), GFP_KERNEL);\n\tif (cfile == NULL)\n\t\treturn cfile;\n\n\tfdlocks = kzalloc(sizeof(struct cifs_fid_locks), GFP_KERNEL);\n\tif (!fdlocks) {\n\t\tkfree(cfile);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&fdlocks->locks);\n\tfdlocks->cfile = cfile;\n\tcfile->llist = fdlocks;\n\tdown_write(&cinode->lock_sem);\n\tlist_add(&fdlocks->llist, &cinode->llist);\n\tup_write(&cinode->lock_sem);\n\n\tcfile->count = 1;\n\tcfile->pid = current->tgid;\n\tcfile->uid = current_fsuid();\n\tcfile->dentry = dget(dentry);\n\tcfile->f_flags = file->f_flags;\n\tcfile->invalidHandle = false;\n\tcfile->tlink = cifs_get_tlink(tlink);\n\tINIT_WORK(&cfile->oplock_break, cifs_oplock_break);\n\tmutex_init(&cfile->fh_mutex);\n\n\tcifs_sb_active(inode->i_sb);\n\n\t/*\n\t * If the server returned a read oplock and we have mandatory brlocks,\n\t * set oplock level to None.\n\t */\n\tif (server->ops->is_read_op(oplock) && cifs_has_mand_locks(cinode)) {\n\t\tcifs_dbg(FYI, \"Reset oplock val from read to None due to mand locks\\n\");\n\t\toplock = 0;\n\t}\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (fid->pending_open->oplock != CIFS_OPLOCK_NO_CHANGE && oplock)\n\t\toplock = fid->pending_open->oplock;\n\tlist_del(&fid->pending_open->olist);\n\n\tfid->purge_cache = false;\n\tserver->ops->set_fid(cfile, fid, oplock);\n\n\tlist_add(&cfile->tlist, &tcon->openFileList);\n\t/* if readable file instance put first in list*/\n\tif (file->f_mode & FMODE_READ)\n\t\tlist_add(&cfile->flist, &cinode->openFileList);\n\telse\n\t\tlist_add_tail(&cfile->flist, &cinode->openFileList);\n\tspin_unlock(&cifs_file_list_lock);\n\n\tif (fid->purge_cache)\n\t\tcifs_zap_mapping(inode);\n\n\tfile->private_data = cfile;\n\treturn cfile;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstruct cifsFileInfo *\ncifs_new_fileinfo(struct cifs_fid *fid, struct file *file,\n\t\t  struct tcon_link *tlink, __u32 oplock)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifsFileInfo *cfile;\n\tstruct cifs_fid_locks *fdlocks;\n\tstruct cifs_tcon *tcon = tlink_tcon(tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\tcfile = kzalloc(sizeof(struct cifsFileInfo), GFP_KERNEL);\n\tif (cfile == NULL)\n\t\treturn cfile;\n\n\tfdlocks = kzalloc(sizeof(struct cifs_fid_locks), GFP_KERNEL);\n\tif (!fdlocks) {\n\t\tkfree(cfile);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&fdlocks->locks);\n\tfdlocks->cfile = cfile;\n\tcfile->llist = fdlocks;\n\tdown_write(&cinode->lock_sem);\n\tlist_add(&fdlocks->llist, &cinode->llist);\n\tup_write(&cinode->lock_sem);\n\n\tcfile->count = 1;\n\tcfile->pid = current->tgid;\n\tcfile->uid = current_fsuid();\n\tcfile->dentry = dget(dentry);\n\tcfile->f_flags = file->f_flags;\n\tcfile->invalidHandle = false;\n\tcfile->tlink = cifs_get_tlink(tlink);\n\tINIT_WORK(&cfile->oplock_break, cifs_oplock_break);\n\tmutex_init(&cfile->fh_mutex);\n\n\tcifs_sb_active(inode->i_sb);\n\n\t/*\n\t * If the server returned a read oplock and we have mandatory brlocks,\n\t * set oplock level to None.\n\t */\n\tif (server->ops->is_read_op(oplock) && cifs_has_mand_locks(cinode)) {\n\t\tcifs_dbg(FYI, \"Reset oplock val from read to None due to mand locks\\n\");\n\t\toplock = 0;\n\t}\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (fid->pending_open->oplock != CIFS_OPLOCK_NO_CHANGE && oplock)\n\t\toplock = fid->pending_open->oplock;\n\tlist_del(&fid->pending_open->olist);\n\n\tfid->purge_cache = false;\n\tserver->ops->set_fid(cfile, fid, oplock);\n\n\tlist_add(&cfile->tlist, &tcon->openFileList);\n\t/* if readable file instance put first in list*/\n\tif (file->f_mode & FMODE_READ)\n\t\tlist_add(&cfile->flist, &cinode->openFileList);\n\telse\n\t\tlist_add_tail(&cfile->flist, &cinode->openFileList);\n\tspin_unlock(&cifs_file_list_lock);\n\n\tif (fid->purge_cache)\n\t\tcifs_zap_mapping(inode);\n\n\tfile->private_data = cfile;\n\treturn cfile;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_nt_open",
          "args": [
            "full_path",
            "inode",
            "cifs_sb",
            "tcon",
            "file->f_flags",
            "&oplock",
            "&fid",
            "xid"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_nt_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "175-252",
          "snippet": "static int\ncifs_nt_open(char *full_path, struct inode *inode, struct cifs_sb_info *cifs_sb,\n\t     struct cifs_tcon *tcon, unsigned int f_flags, __u32 *oplock,\n\t     struct cifs_fid *fid, unsigned int xid)\n{\n\tint rc;\n\tint desired_access;\n\tint disposition;\n\tint create_options = CREATE_NOT_DIR;\n\tFILE_ALL_INFO *buf;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifs_open_parms oparms;\n\n\tif (!server->ops->open)\n\t\treturn -ENOSYS;\n\n\tdesired_access = cifs_convert_flags(f_flags);\n\n/*********************************************************************\n *  open flag mapping table:\n *\n *\tPOSIX Flag            CIFS Disposition\n *\t----------            ----------------\n *\tO_CREAT               FILE_OPEN_IF\n *\tO_CREAT | O_EXCL      FILE_CREATE\n *\tO_CREAT | O_TRUNC     FILE_OVERWRITE_IF\n *\tO_TRUNC               FILE_OVERWRITE\n *\tnone of the above     FILE_OPEN\n *\n *\tNote that there is not a direct match between disposition\n *\tFILE_SUPERSEDE (ie create whether or not file exists although\n *\tO_CREAT | O_TRUNC is similar but truncates the existing\n *\tfile rather than creating a new file as FILE_SUPERSEDE does\n *\t(which uses the attributes / metadata passed in on open call)\n *?\n *?  O_SYNC is a reasonable match to CIFS writethrough flag\n *?  and the read write flags match reasonably.  O_LARGEFILE\n *?  is irrelevant because largefile support is always used\n *?  by this client. Flags O_APPEND, O_DIRECT, O_DIRECTORY,\n *\t O_FASYNC, O_NOFOLLOW, O_NONBLOCK need further investigation\n *********************************************************************/\n\n\tdisposition = cifs_get_disposition(f_flags);\n\n\t/* BB pass O_SYNC flag through on file attributes .. BB */\n\n\tbuf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = fid;\n\toparms.reconnect = false;\n\n\trc = server->ops->open(xid, &oparms, oplock, buf);\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (tcon->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&inode, full_path, inode->i_sb,\n\t\t\t\t\t      xid);\n\telse\n\t\trc = cifs_get_inode_info(&inode, full_path, buf, inode->i_sb,\n\t\t\t\t\t xid, fid);\n\nout:\n\tkfree(buf);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_nt_open(char *full_path, struct inode *inode, struct cifs_sb_info *cifs_sb,\n\t     struct cifs_tcon *tcon, unsigned int f_flags, __u32 *oplock,\n\t     struct cifs_fid *fid, unsigned int xid)\n{\n\tint rc;\n\tint desired_access;\n\tint disposition;\n\tint create_options = CREATE_NOT_DIR;\n\tFILE_ALL_INFO *buf;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifs_open_parms oparms;\n\n\tif (!server->ops->open)\n\t\treturn -ENOSYS;\n\n\tdesired_access = cifs_convert_flags(f_flags);\n\n/*********************************************************************\n *  open flag mapping table:\n *\n *\tPOSIX Flag            CIFS Disposition\n *\t----------            ----------------\n *\tO_CREAT               FILE_OPEN_IF\n *\tO_CREAT | O_EXCL      FILE_CREATE\n *\tO_CREAT | O_TRUNC     FILE_OVERWRITE_IF\n *\tO_TRUNC               FILE_OVERWRITE\n *\tnone of the above     FILE_OPEN\n *\n *\tNote that there is not a direct match between disposition\n *\tFILE_SUPERSEDE (ie create whether or not file exists although\n *\tO_CREAT | O_TRUNC is similar but truncates the existing\n *\tfile rather than creating a new file as FILE_SUPERSEDE does\n *\t(which uses the attributes / metadata passed in on open call)\n *?\n *?  O_SYNC is a reasonable match to CIFS writethrough flag\n *?  and the read write flags match reasonably.  O_LARGEFILE\n *?  is irrelevant because largefile support is always used\n *?  by this client. Flags O_APPEND, O_DIRECT, O_DIRECTORY,\n *\t O_FASYNC, O_NOFOLLOW, O_NONBLOCK need further investigation\n *********************************************************************/\n\n\tdisposition = cifs_get_disposition(f_flags);\n\n\t/* BB pass O_SYNC flag through on file attributes .. BB */\n\n\tbuf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = fid;\n\toparms.reconnect = false;\n\n\trc = server->ops->open(xid, &oparms, oplock, buf);\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (tcon->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&inode, full_path, inode->i_sb,\n\t\t\t\t\t      xid);\n\telse\n\t\trc = cifs_get_inode_info(&inode, full_path, buf, inode->i_sb,\n\t\t\t\t\t xid, fid);\n\nout:\n\tkfree(buf);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->get_lease_key",
          "args": [
            "inode",
            "&fid"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_add_pending_open",
          "args": [
            "&fid",
            "tlink",
            "&open"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_add_pending_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "634-641",
          "snippet": "void\ncifs_add_pending_open(struct cifs_fid *fid, struct tcon_link *tlink,\n\t\t      struct cifs_pending_open *open)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tcifs_add_pending_open_locked(fid, tlink, open);\n\tspin_unlock(&cifs_file_list_lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ncifs_add_pending_open(struct cifs_fid *fid, struct tcon_link *tlink,\n\t\t      struct cifs_pending_open *open)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tcifs_add_pending_open_locked(fid, tlink, open);\n\tspin_unlock(&cifs_file_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->get_lease_key",
          "args": [
            "inode",
            "&fid"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"server %s of type %s returned unexpected error on SMB posix open, disabling posix open support. Check if server update available.\\n\"",
            "tcon->ses->serverName",
            "tcon->ses->serverNOS"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"posix open succeeded\\n\""
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_posix_open",
          "args": [
            "full_path",
            "&inode",
            "inode->i_sb",
            "cifs_sb->mnt_file_mode/* ignored */",
            "file->f_flags",
            "&oplock",
            "&fid.netfid",
            "xid"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_posix_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "113-173",
          "snippet": "int cifs_posix_open(char *full_path, struct inode **pinode,\n\t\t\tstruct super_block *sb, int mode, unsigned int f_flags,\n\t\t\t__u32 *poplock, __u16 *pnetfid, unsigned int xid)\n{\n\tint rc;\n\tFILE_UNIX_BASIC_INFO *presp_data;\n\t__u32 posix_flags = 0;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_fattr fattr;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\n\tcifs_dbg(FYI, \"posix open %s\\n\", full_path);\n\n\tpresp_data = kzalloc(sizeof(FILE_UNIX_BASIC_INFO), GFP_KERNEL);\n\tif (presp_data == NULL)\n\t\treturn -ENOMEM;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto posix_open_ret;\n\t}\n\n\ttcon = tlink_tcon(tlink);\n\tmode &= ~current_umask();\n\n\tposix_flags = cifs_posix_convert_flags(f_flags);\n\trc = CIFSPOSIXCreate(xid, tcon, posix_flags, mode, pnetfid, presp_data,\n\t\t\t     poplock, full_path, cifs_sb->local_nls,\n\t\t\t     cifs_sb->mnt_cifs_flags &\n\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\tcifs_put_tlink(tlink);\n\n\tif (rc)\n\t\tgoto posix_open_ret;\n\n\tif (presp_data->Type == cpu_to_le32(-1))\n\t\tgoto posix_open_ret; /* open ok, caller does qpathinfo */\n\n\tif (!pinode)\n\t\tgoto posix_open_ret; /* caller does not need info */\n\n\tcifs_unix_basic_to_fattr(&fattr, presp_data, cifs_sb);\n\n\t/* get new inode and set it up */\n\tif (*pinode == NULL) {\n\t\tcifs_fill_uniqueid(sb, &fattr);\n\t\t*pinode = cifs_iget(sb, &fattr);\n\t\tif (!*pinode) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto posix_open_ret;\n\t\t}\n\t} else {\n\t\tcifs_fattr_to_inode(*pinode, &fattr);\n\t}\n\nposix_open_ret:\n\tkfree(presp_data);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nint cifs_posix_open(char *full_path, struct inode **pinode,\n\t\t\tstruct super_block *sb, int mode, unsigned int f_flags,\n\t\t\t__u32 *poplock, __u16 *pnetfid, unsigned int xid)\n{\n\tint rc;\n\tFILE_UNIX_BASIC_INFO *presp_data;\n\t__u32 posix_flags = 0;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_fattr fattr;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\n\tcifs_dbg(FYI, \"posix open %s\\n\", full_path);\n\n\tpresp_data = kzalloc(sizeof(FILE_UNIX_BASIC_INFO), GFP_KERNEL);\n\tif (presp_data == NULL)\n\t\treturn -ENOMEM;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto posix_open_ret;\n\t}\n\n\ttcon = tlink_tcon(tlink);\n\tmode &= ~current_umask();\n\n\tposix_flags = cifs_posix_convert_flags(f_flags);\n\trc = CIFSPOSIXCreate(xid, tcon, posix_flags, mode, pnetfid, presp_data,\n\t\t\t     poplock, full_path, cifs_sb->local_nls,\n\t\t\t     cifs_sb->mnt_cifs_flags &\n\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\tcifs_put_tlink(tlink);\n\n\tif (rc)\n\t\tgoto posix_open_ret;\n\n\tif (presp_data->Type == cpu_to_le32(-1))\n\t\tgoto posix_open_ret; /* open ok, caller does qpathinfo */\n\n\tif (!pinode)\n\t\tgoto posix_open_ret; /* caller does not need info */\n\n\tcifs_unix_basic_to_fattr(&fattr, presp_data, cifs_sb);\n\n\t/* get new inode and set it up */\n\tif (*pinode == NULL) {\n\t\tcifs_fill_uniqueid(sb, &fattr);\n\t\t*pinode = cifs_iget(sb, &fattr);\n\t\tif (!*pinode) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto posix_open_ret;\n\t\t}\n\t} else {\n\t\tcifs_fattr_to_inode(*pinode, &fattr);\n\t}\n\nposix_open_ret:\n\tkfree(presp_data);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "tcon->fsUnixInfo.Capability"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_unix",
          "args": [
            "tcon->ses"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "cap_unix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "804-808",
          "snippet": "static inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"inode = 0x%p file flags are 0x%x for %s\\n\"",
            "inode",
            "file->f_flags",
            "full_path"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_path_from_dentry",
          "args": [
            "file->f_path.dentry"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "build_path_from_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
          "lines": "81-167",
          "snippet": "char *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nchar *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "4011-4082",
          "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nint cifs_open(struct inode *inode, struct file *file)\n\n{\n\tint rc = -EACCES;\n\tunsigned int xid;\n\t__u32 oplock;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink;\n\tstruct cifsFileInfo *cfile = NULL;\n\tchar *full_path = NULL;\n\tbool posix_open_ok = false;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\n\txid = get_xid();\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tfree_xid(xid);\n\t\treturn PTR_ERR(tlink);\n\t}\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tfull_path = build_path_from_dentry(file->f_path.dentry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcifs_dbg(FYI, \"inode = 0x%p file flags are 0x%x for %s\\n\",\n\t\t inode, file->f_flags, full_path);\n\n\tif (file->f_flags & O_DIRECT &&\n\t    cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO) {\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\t\tfile->f_op = &cifs_file_direct_nobrl_ops;\n\t\telse\n\t\t\tfile->f_op = &cifs_file_direct_ops;\n\t}\n\n\tif (server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\n\tif (!tcon->broken_posix_open && tcon->unix_ext &&\n\t    cap_unix(tcon->ses) && (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\t/* can not refresh inode info since size could be stale */\n\t\trc = cifs_posix_open(full_path, &inode, inode->i_sb,\n\t\t\t\tcifs_sb->mnt_file_mode /* ignored */,\n\t\t\t\tfile->f_flags, &oplock, &fid.netfid, xid);\n\t\tif (rc == 0) {\n\t\t\tcifs_dbg(FYI, \"posix open succeeded\\n\");\n\t\t\tposix_open_ok = true;\n\t\t} else if ((rc == -EINVAL) || (rc == -EOPNOTSUPP)) {\n\t\t\tif (tcon->ses->serverNOS)\n\t\t\t\tcifs_dbg(VFS, \"server %s of type %s returned unexpected error on SMB posix open, disabling posix open support. Check if server update available.\\n\",\n\t\t\t\t\t tcon->ses->serverName,\n\t\t\t\t\t tcon->ses->serverNOS);\n\t\t\ttcon->broken_posix_open = true;\n\t\t} else if ((rc != -EIO) && (rc != -EREMOTE) &&\n\t\t\t (rc != -EOPNOTSUPP)) /* path not found or net err */\n\t\t\tgoto out;\n\t\t/*\n\t\t * Else fallthrough to retry open the old way on network i/o\n\t\t * or DFS errors.\n\t\t */\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\tcifs_add_pending_open(&fid, tlink, &open);\n\n\tif (!posix_open_ok) {\n\t\tif (server->ops->get_lease_key)\n\t\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t\trc = cifs_nt_open(full_path, inode, cifs_sb, tcon,\n\t\t\t\t  file->f_flags, &oplock, &fid, xid);\n\t\tif (rc) {\n\t\t\tcifs_del_pending_open(&open);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcfile = cifs_new_fileinfo(&fid, file, tlink, oplock);\n\tif (cfile == NULL) {\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &fid);\n\t\tcifs_del_pending_open(&open);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcifs_fscache_set_inode_cookie(inode, file);\n\n\tif ((oplock & CIFS_CREATE_ACTION) && !posix_open_ok && tcon->unix_ext) {\n\t\t/*\n\t\t * Time to set mode which we can not set earlier due to\n\t\t * problems creating new read-only files.\n\t\t */\n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t.mode\t= inode->i_mode,\n\t\t\t.uid\t= INVALID_UID, /* no change */\n\t\t\t.gid\t= INVALID_GID, /* no change */\n\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t.device\t= 0,\n\t\t};\n\t\tCIFSSMBUnixSetFileInfo(xid, tcon, &args, fid.netfid,\n\t\t\t\t       cfile->pid);\n\t}\n\nout:\n\tkfree(full_path);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifsFileInfo_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "358-436",
    "snippet": "void cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cifs_file"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_deactive",
          "args": [
            "sb"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_deactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
          "lines": "105-112",
          "snippet": "void\ncifs_sb_deactive(struct super_block *sb)\n{\n\tstruct cifs_sb_info *server = CIFS_SB(sb);\n\n\tif (atomic_dec_and_test(&server->active))\n\t\tdeactivate_super(sb);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_spnego.h\"",
            "#include <linux/key-type.h>",
            "#include <linux/mm.h>",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/vfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid\ncifs_sb_deactive(struct super_block *sb)\n{\n\tstruct cifs_sb_info *server = CIFS_SB(sb);\n\n\tif (atomic_dec_and_test(&server->active))\n\t\tdeactivate_super(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "cifs_file->dentry"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "cifs_file->tlink"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&cifsi->lock_sem"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cifs_file->llist"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cifs_file->llist->llist"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "li"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_del_lock_waiters",
          "args": [
            "li"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_del_lock_waiters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "824-832",
          "snippet": "void\ncifs_del_lock_waiters(struct cifsLockInfo *lock)\n{\n\tstruct cifsLockInfo *li, *tmp;\n\tlist_for_each_entry_safe(li, tmp, &lock->blist, blist) {\n\t\tlist_del_init(&li->blist);\n\t\twake_up(&li->block_q);\n\t}\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid\ncifs_del_lock_waiters(struct cifsLockInfo *lock)\n{\n\tstruct cifsLockInfo *li, *tmp;\n\tlist_for_each_entry_safe(li, tmp, &lock->blist, blist) {\n\t\tlist_del_init(&li->blist);\n\t\twake_up(&li->block_q);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "li",
            "tmp",
            "&cifs_file->llist->locks",
            "llist"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&cifsi->lock_sem"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_del_pending_open",
          "args": [
            "&open"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_del_pending_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "613-619",
          "snippet": "void\ncifs_del_pending_open(struct cifs_pending_open *open)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tlist_del(&open->olist);\n\tspin_unlock(&cifs_file_list_lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ncifs_del_pending_open(struct cifs_pending_open *open)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tlist_del(&open->olist);\n\tspin_unlock(&cifs_file_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_done_oplock_break",
          "args": [
            "cifsi"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_done_oplock_break",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "592-596",
          "snippet": "void cifs_done_oplock_break(struct cifsInodeInfo *cinode)\n{\n\tclear_bit(CIFS_INODE_PENDING_OPLOCK_BREAK, &cinode->flags);\n\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_OPLOCK_BREAK);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid cifs_done_oplock_break(struct cifsInodeInfo *cinode)\n{\n\tclear_bit(CIFS_INODE_PENDING_OPLOCK_BREAK, &cinode->flags);\n\twake_up_bit(&cinode->flags, CIFS_INODE_PENDING_OPLOCK_BREAK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_free_xid",
          "args": [
            "xid"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->close",
          "args": [
            "xid",
            "tcon",
            "&cifs_file->fid"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_work_sync",
          "args": [
            "&cifs_file->oplock_break"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_set_oplock_level",
          "args": [
            "cifsi",
            "0"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_set_oplock_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "533-547",
          "snippet": "void cifs_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)\n{\n\toplock &= 0xF;\n\n\tif (oplock == OPLOCK_EXCLUSIVE) {\n\t\tcinode->oplock = CIFS_CACHE_WRITE_FLG | CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Exclusive Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else if (oplock == OPLOCK_READ) {\n\t\tcinode->oplock = CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Level II Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else\n\t\tcinode->oplock = 0;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid cifs_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)\n{\n\toplock &= 0xF;\n\n\tif (oplock == OPLOCK_EXCLUSIVE) {\n\t\tcinode->oplock = CIFS_CACHE_WRITE_FLG | CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Exclusive Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else if (oplock == OPLOCK_READ) {\n\t\tcinode->oplock = CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Level II Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else\n\t\tcinode->oplock = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CIFS_INO_INVALID_MAPPING",
            "&cifsi->flags"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"closing last open instance for inode %p\\n\"",
            "cifs_file->dentry->d_inode"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cifsi->openFileList"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_add_pending_open_locked",
          "args": [
            "&fid",
            "cifs_file->tlink",
            "&open"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_add_pending_open_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "621-632",
          "snippet": "void\ncifs_add_pending_open_locked(struct cifs_fid *fid, struct tcon_link *tlink,\n\t\t\t     struct cifs_pending_open *open)\n{\n#ifdef CONFIG_CIFS_SMB2\n\tmemcpy(open->lease_key, fid->lease_key, SMB2_LEASE_KEY_SIZE);\n#endif\n\topen->oplock = CIFS_OPLOCK_NO_CHANGE;\n\topen->tlink = tlink;\n\tfid->pending_open = open;\n\tlist_add_tail(&open->olist, &tlink_tcon(tlink)->pending_opens);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ncifs_add_pending_open_locked(struct cifs_fid *fid, struct tcon_link *tlink,\n\t\t\t     struct cifs_pending_open *open)\n{\n#ifdef CONFIG_CIFS_SMB2\n\tmemcpy(open->lease_key, fid->lease_key, SMB2_LEASE_KEY_SIZE);\n#endif\n\topen->oplock = CIFS_OPLOCK_NO_CHANGE;\n\topen->tlink = tlink;\n\tfid->pending_open = open;\n\tlist_add_tail(&open->olist, &tlink_tcon(tlink)->pending_opens);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->get_lease_key",
          "args": [
            "inode",
            "&fid"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "sb"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cifs_file->tlink"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}"
  },
  {
    "function_name": "cifsFileInfo_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "344-351",
    "snippet": "struct cifsFileInfo *\ncifsFileInfo_get(struct cifsFileInfo *cifs_file)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tcifsFileInfo_get_locked(cifs_file);\n\tspin_unlock(&cifs_file_list_lock);\n\treturn cifs_file;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifsFileInfo_get_locked",
          "args": [
            "cifs_file"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "cifsFileInfo_get_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1104-1108",
          "snippet": "static inline void\ncifsFileInfo_get_locked(struct cifsFileInfo *cifs_file)\n{\n\t++cifs_file->count;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\ncifsFileInfo_get_locked(struct cifsFileInfo *cifs_file)\n{\n\t++cifs_file->count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstruct cifsFileInfo *\ncifsFileInfo_get(struct cifsFileInfo *cifs_file)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tcifsFileInfo_get_locked(cifs_file);\n\tspin_unlock(&cifs_file_list_lock);\n\treturn cifs_file;\n}"
  },
  {
    "function_name": "cifs_new_fileinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "271-342",
    "snippet": "struct cifsFileInfo *\ncifs_new_fileinfo(struct cifs_fid *fid, struct file *file,\n\t\t  struct tcon_link *tlink, __u32 oplock)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifsFileInfo *cfile;\n\tstruct cifs_fid_locks *fdlocks;\n\tstruct cifs_tcon *tcon = tlink_tcon(tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\tcfile = kzalloc(sizeof(struct cifsFileInfo), GFP_KERNEL);\n\tif (cfile == NULL)\n\t\treturn cfile;\n\n\tfdlocks = kzalloc(sizeof(struct cifs_fid_locks), GFP_KERNEL);\n\tif (!fdlocks) {\n\t\tkfree(cfile);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&fdlocks->locks);\n\tfdlocks->cfile = cfile;\n\tcfile->llist = fdlocks;\n\tdown_write(&cinode->lock_sem);\n\tlist_add(&fdlocks->llist, &cinode->llist);\n\tup_write(&cinode->lock_sem);\n\n\tcfile->count = 1;\n\tcfile->pid = current->tgid;\n\tcfile->uid = current_fsuid();\n\tcfile->dentry = dget(dentry);\n\tcfile->f_flags = file->f_flags;\n\tcfile->invalidHandle = false;\n\tcfile->tlink = cifs_get_tlink(tlink);\n\tINIT_WORK(&cfile->oplock_break, cifs_oplock_break);\n\tmutex_init(&cfile->fh_mutex);\n\n\tcifs_sb_active(inode->i_sb);\n\n\t/*\n\t * If the server returned a read oplock and we have mandatory brlocks,\n\t * set oplock level to None.\n\t */\n\tif (server->ops->is_read_op(oplock) && cifs_has_mand_locks(cinode)) {\n\t\tcifs_dbg(FYI, \"Reset oplock val from read to None due to mand locks\\n\");\n\t\toplock = 0;\n\t}\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (fid->pending_open->oplock != CIFS_OPLOCK_NO_CHANGE && oplock)\n\t\toplock = fid->pending_open->oplock;\n\tlist_del(&fid->pending_open->olist);\n\n\tfid->purge_cache = false;\n\tserver->ops->set_fid(cfile, fid, oplock);\n\n\tlist_add(&cfile->tlist, &tcon->openFileList);\n\t/* if readable file instance put first in list*/\n\tif (file->f_mode & FMODE_READ)\n\t\tlist_add(&cfile->flist, &cinode->openFileList);\n\telse\n\t\tlist_add_tail(&cfile->flist, &cinode->openFileList);\n\tspin_unlock(&cifs_file_list_lock);\n\n\tif (fid->purge_cache)\n\t\tcifs_zap_mapping(inode);\n\n\tfile->private_data = cfile;\n\treturn cfile;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_zap_mapping",
          "args": [
            "inode"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cfile->flist",
            "&cinode->openFileList"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cfile->flist",
            "&cinode->openFileList"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->set_fid",
          "args": [
            "cfile",
            "fid",
            "oplock"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&fid->pending_open->olist"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Reset oplock val from read to None due to mand locks\\n\""
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_has_mand_locks",
          "args": [
            "cinode"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_has_mand_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "254-269",
          "snippet": "static bool\ncifs_has_mand_locks(struct cifsInodeInfo *cinode)\n{\n\tstruct cifs_fid_locks *cur;\n\tbool has_locks = false;\n\n\tdown_read(&cinode->lock_sem);\n\tlist_for_each_entry(cur, &cinode->llist, llist) {\n\t\tif (!list_empty(&cur->locks)) {\n\t\t\thas_locks = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&cinode->lock_sem);\n\treturn has_locks;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic bool\ncifs_has_mand_locks(struct cifsInodeInfo *cinode)\n{\n\tstruct cifs_fid_locks *cur;\n\tbool has_locks = false;\n\n\tdown_read(&cinode->lock_sem);\n\tlist_for_each_entry(cur, &cinode->llist, llist) {\n\t\tif (!list_empty(&cur->locks)) {\n\t\t\thas_locks = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&cinode->lock_sem);\n\treturn has_locks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->is_read_op",
          "args": [
            "oplock"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_active",
          "args": [
            "inode->i_sb"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsfs.c",
          "lines": "96-103",
          "snippet": "void\ncifs_sb_active(struct super_block *sb)\n{\n\tstruct cifs_sb_info *server = CIFS_SB(sb);\n\n\tif (atomic_inc_return(&server->active) == 1)\n\t\tatomic_inc(&sb->s_active);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_spnego.h\"",
            "#include <linux/key-type.h>",
            "#include <linux/mm.h>",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/vfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"fscache.h\"\n#include \"cifs_spnego.h\"\n#include <linux/key-type.h>\n#include <linux/mm.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <net/ipv6.h>\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/vfs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid\ncifs_sb_active(struct super_block *sb)\n{\n\tstruct cifs_sb_info *server = CIFS_SB(sb);\n\n\tif (atomic_inc_return(&server->active) == 1)\n\t\tatomic_inc(&sb->s_active);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&cfile->fh_mutex"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&cfile->oplock_break",
            "cifs_oplock_break"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_tlink",
          "args": [
            "tlink"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "939-945",
          "snippet": "static inline struct tcon_link *\ncifs_get_tlink(struct tcon_link *tlink)\n{\n\tif (tlink && !IS_ERR(tlink))\n\t\tatomic_inc(&tlink->tl_count);\n\treturn tlink;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct tcon_link *\ncifs_get_tlink(struct tcon_link *tlink)\n{\n\tif (tlink && !IS_ERR(tlink))\n\t\tatomic_inc(&tlink->tl_count);\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "706-718",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fdlocks->locks"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cfile"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct cifs_fid_locks)",
            "GFP_KERNEL"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct cifsFileInfo)",
            "GFP_KERNEL"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstruct cifsFileInfo *\ncifs_new_fileinfo(struct cifs_fid *fid, struct file *file,\n\t\t  struct tcon_link *tlink, __u32 oplock)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifsFileInfo *cfile;\n\tstruct cifs_fid_locks *fdlocks;\n\tstruct cifs_tcon *tcon = tlink_tcon(tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\tcfile = kzalloc(sizeof(struct cifsFileInfo), GFP_KERNEL);\n\tif (cfile == NULL)\n\t\treturn cfile;\n\n\tfdlocks = kzalloc(sizeof(struct cifs_fid_locks), GFP_KERNEL);\n\tif (!fdlocks) {\n\t\tkfree(cfile);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&fdlocks->locks);\n\tfdlocks->cfile = cfile;\n\tcfile->llist = fdlocks;\n\tdown_write(&cinode->lock_sem);\n\tlist_add(&fdlocks->llist, &cinode->llist);\n\tup_write(&cinode->lock_sem);\n\n\tcfile->count = 1;\n\tcfile->pid = current->tgid;\n\tcfile->uid = current_fsuid();\n\tcfile->dentry = dget(dentry);\n\tcfile->f_flags = file->f_flags;\n\tcfile->invalidHandle = false;\n\tcfile->tlink = cifs_get_tlink(tlink);\n\tINIT_WORK(&cfile->oplock_break, cifs_oplock_break);\n\tmutex_init(&cfile->fh_mutex);\n\n\tcifs_sb_active(inode->i_sb);\n\n\t/*\n\t * If the server returned a read oplock and we have mandatory brlocks,\n\t * set oplock level to None.\n\t */\n\tif (server->ops->is_read_op(oplock) && cifs_has_mand_locks(cinode)) {\n\t\tcifs_dbg(FYI, \"Reset oplock val from read to None due to mand locks\\n\");\n\t\toplock = 0;\n\t}\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (fid->pending_open->oplock != CIFS_OPLOCK_NO_CHANGE && oplock)\n\t\toplock = fid->pending_open->oplock;\n\tlist_del(&fid->pending_open->olist);\n\n\tfid->purge_cache = false;\n\tserver->ops->set_fid(cfile, fid, oplock);\n\n\tlist_add(&cfile->tlist, &tcon->openFileList);\n\t/* if readable file instance put first in list*/\n\tif (file->f_mode & FMODE_READ)\n\t\tlist_add(&cfile->flist, &cinode->openFileList);\n\telse\n\t\tlist_add_tail(&cfile->flist, &cinode->openFileList);\n\tspin_unlock(&cifs_file_list_lock);\n\n\tif (fid->purge_cache)\n\t\tcifs_zap_mapping(inode);\n\n\tfile->private_data = cfile;\n\treturn cfile;\n}"
  },
  {
    "function_name": "cifs_has_mand_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "254-269",
    "snippet": "static bool\ncifs_has_mand_locks(struct cifsInodeInfo *cinode)\n{\n\tstruct cifs_fid_locks *cur;\n\tbool has_locks = false;\n\n\tdown_read(&cinode->lock_sem);\n\tlist_for_each_entry(cur, &cinode->llist, llist) {\n\t\tif (!list_empty(&cur->locks)) {\n\t\t\thas_locks = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&cinode->lock_sem);\n\treturn has_locks;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cur->locks"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cur",
            "&cinode->llist",
            "llist"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&cinode->lock_sem"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic bool\ncifs_has_mand_locks(struct cifsInodeInfo *cinode)\n{\n\tstruct cifs_fid_locks *cur;\n\tbool has_locks = false;\n\n\tdown_read(&cinode->lock_sem);\n\tlist_for_each_entry(cur, &cinode->llist, llist) {\n\t\tif (!list_empty(&cur->locks)) {\n\t\t\thas_locks = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&cinode->lock_sem);\n\treturn has_locks;\n}"
  },
  {
    "function_name": "cifs_nt_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "175-252",
    "snippet": "static int\ncifs_nt_open(char *full_path, struct inode *inode, struct cifs_sb_info *cifs_sb,\n\t     struct cifs_tcon *tcon, unsigned int f_flags, __u32 *oplock,\n\t     struct cifs_fid *fid, unsigned int xid)\n{\n\tint rc;\n\tint desired_access;\n\tint disposition;\n\tint create_options = CREATE_NOT_DIR;\n\tFILE_ALL_INFO *buf;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifs_open_parms oparms;\n\n\tif (!server->ops->open)\n\t\treturn -ENOSYS;\n\n\tdesired_access = cifs_convert_flags(f_flags);\n\n/*********************************************************************\n *  open flag mapping table:\n *\n *\tPOSIX Flag            CIFS Disposition\n *\t----------            ----------------\n *\tO_CREAT               FILE_OPEN_IF\n *\tO_CREAT | O_EXCL      FILE_CREATE\n *\tO_CREAT | O_TRUNC     FILE_OVERWRITE_IF\n *\tO_TRUNC               FILE_OVERWRITE\n *\tnone of the above     FILE_OPEN\n *\n *\tNote that there is not a direct match between disposition\n *\tFILE_SUPERSEDE (ie create whether or not file exists although\n *\tO_CREAT | O_TRUNC is similar but truncates the existing\n *\tfile rather than creating a new file as FILE_SUPERSEDE does\n *\t(which uses the attributes / metadata passed in on open call)\n *?\n *?  O_SYNC is a reasonable match to CIFS writethrough flag\n *?  and the read write flags match reasonably.  O_LARGEFILE\n *?  is irrelevant because largefile support is always used\n *?  by this client. Flags O_APPEND, O_DIRECT, O_DIRECTORY,\n *\t O_FASYNC, O_NOFOLLOW, O_NONBLOCK need further investigation\n *********************************************************************/\n\n\tdisposition = cifs_get_disposition(f_flags);\n\n\t/* BB pass O_SYNC flag through on file attributes .. BB */\n\n\tbuf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = fid;\n\toparms.reconnect = false;\n\n\trc = server->ops->open(xid, &oparms, oplock, buf);\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (tcon->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&inode, full_path, inode->i_sb,\n\t\t\t\t\t      xid);\n\telse\n\t\trc = cifs_get_inode_info(&inode, full_path, buf, inode->i_sb,\n\t\t\t\t\t xid, fid);\n\nout:\n\tkfree(buf);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_inode_info",
          "args": [
            "&inode",
            "full_path",
            "buf",
            "inode->i_sb",
            "xid",
            "fid"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_inode_info_unix",
          "args": [
            "&inode",
            "full_path",
            "inode->i_sb",
            "xid"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->open",
          "args": [
            "xid",
            "&oparms",
            "oplock",
            "buf"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "backup_cred",
          "args": [
            "cifs_sb"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "backup_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "598-611",
          "snippet": "bool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nbool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(FILE_ALL_INFO)",
            "GFP_KERNEL"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_get_disposition",
          "args": [
            "f_flags"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_disposition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "99-111",
          "snippet": "static inline int cifs_get_disposition(unsigned int flags)\n{\n\tif ((flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\treturn FILE_CREATE;\n\telse if ((flags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))\n\t\treturn FILE_OVERWRITE_IF;\n\telse if ((flags & O_CREAT) == O_CREAT)\n\t\treturn FILE_OPEN_IF;\n\telse if ((flags & O_TRUNC) == O_TRUNC)\n\t\treturn FILE_OVERWRITE;\n\telse\n\t\treturn FILE_OPEN;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic inline int cifs_get_disposition(unsigned int flags)\n{\n\tif ((flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\treturn FILE_CREATE;\n\telse if ((flags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))\n\t\treturn FILE_OVERWRITE_IF;\n\telse if ((flags & O_CREAT) == O_CREAT)\n\t\treturn FILE_OPEN_IF;\n\telse if ((flags & O_TRUNC) == O_TRUNC)\n\t\treturn FILE_OVERWRITE;\n\telse\n\t\treturn FILE_OPEN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_convert_flags",
          "args": [
            "f_flags"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_convert_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "47-63",
          "snippet": "static inline int cifs_convert_flags(unsigned int flags)\n{\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\treturn GENERIC_READ;\n\telse if ((flags & O_ACCMODE) == O_WRONLY)\n\t\treturn GENERIC_WRITE;\n\telse if ((flags & O_ACCMODE) == O_RDWR) {\n\t\t/* GENERIC_ALL is too much permission to request\n\t\t   can cause unnecessary access denied on create */\n\t\t/* return GENERIC_ALL; */\n\t\treturn (GENERIC_READ | GENERIC_WRITE);\n\t}\n\n\treturn (READ_CONTROL | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES |\n\t\tFILE_WRITE_EA | FILE_APPEND_DATA | FILE_WRITE_DATA |\n\t\tFILE_READ_DATA);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic inline int cifs_convert_flags(unsigned int flags)\n{\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\treturn GENERIC_READ;\n\telse if ((flags & O_ACCMODE) == O_WRONLY)\n\t\treturn GENERIC_WRITE;\n\telse if ((flags & O_ACCMODE) == O_RDWR) {\n\t\t/* GENERIC_ALL is too much permission to request\n\t\t   can cause unnecessary access denied on create */\n\t\t/* return GENERIC_ALL; */\n\t\treturn (GENERIC_READ | GENERIC_WRITE);\n\t}\n\n\treturn (READ_CONTROL | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES |\n\t\tFILE_WRITE_EA | FILE_APPEND_DATA | FILE_WRITE_DATA |\n\t\tFILE_READ_DATA);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_nt_open(char *full_path, struct inode *inode, struct cifs_sb_info *cifs_sb,\n\t     struct cifs_tcon *tcon, unsigned int f_flags, __u32 *oplock,\n\t     struct cifs_fid *fid, unsigned int xid)\n{\n\tint rc;\n\tint desired_access;\n\tint disposition;\n\tint create_options = CREATE_NOT_DIR;\n\tFILE_ALL_INFO *buf;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifs_open_parms oparms;\n\n\tif (!server->ops->open)\n\t\treturn -ENOSYS;\n\n\tdesired_access = cifs_convert_flags(f_flags);\n\n/*********************************************************************\n *  open flag mapping table:\n *\n *\tPOSIX Flag            CIFS Disposition\n *\t----------            ----------------\n *\tO_CREAT               FILE_OPEN_IF\n *\tO_CREAT | O_EXCL      FILE_CREATE\n *\tO_CREAT | O_TRUNC     FILE_OVERWRITE_IF\n *\tO_TRUNC               FILE_OVERWRITE\n *\tnone of the above     FILE_OPEN\n *\n *\tNote that there is not a direct match between disposition\n *\tFILE_SUPERSEDE (ie create whether or not file exists although\n *\tO_CREAT | O_TRUNC is similar but truncates the existing\n *\tfile rather than creating a new file as FILE_SUPERSEDE does\n *\t(which uses the attributes / metadata passed in on open call)\n *?\n *?  O_SYNC is a reasonable match to CIFS writethrough flag\n *?  and the read write flags match reasonably.  O_LARGEFILE\n *?  is irrelevant because largefile support is always used\n *?  by this client. Flags O_APPEND, O_DIRECT, O_DIRECTORY,\n *\t O_FASYNC, O_NOFOLLOW, O_NONBLOCK need further investigation\n *********************************************************************/\n\n\tdisposition = cifs_get_disposition(f_flags);\n\n\t/* BB pass O_SYNC flag through on file attributes .. BB */\n\n\tbuf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = fid;\n\toparms.reconnect = false;\n\n\trc = server->ops->open(xid, &oparms, oplock, buf);\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (tcon->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&inode, full_path, inode->i_sb,\n\t\t\t\t\t      xid);\n\telse\n\t\trc = cifs_get_inode_info(&inode, full_path, buf, inode->i_sb,\n\t\t\t\t\t xid, fid);\n\nout:\n\tkfree(buf);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_posix_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "113-173",
    "snippet": "int cifs_posix_open(char *full_path, struct inode **pinode,\n\t\t\tstruct super_block *sb, int mode, unsigned int f_flags,\n\t\t\t__u32 *poplock, __u16 *pnetfid, unsigned int xid)\n{\n\tint rc;\n\tFILE_UNIX_BASIC_INFO *presp_data;\n\t__u32 posix_flags = 0;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_fattr fattr;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\n\tcifs_dbg(FYI, \"posix open %s\\n\", full_path);\n\n\tpresp_data = kzalloc(sizeof(FILE_UNIX_BASIC_INFO), GFP_KERNEL);\n\tif (presp_data == NULL)\n\t\treturn -ENOMEM;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto posix_open_ret;\n\t}\n\n\ttcon = tlink_tcon(tlink);\n\tmode &= ~current_umask();\n\n\tposix_flags = cifs_posix_convert_flags(f_flags);\n\trc = CIFSPOSIXCreate(xid, tcon, posix_flags, mode, pnetfid, presp_data,\n\t\t\t     poplock, full_path, cifs_sb->local_nls,\n\t\t\t     cifs_sb->mnt_cifs_flags &\n\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\tcifs_put_tlink(tlink);\n\n\tif (rc)\n\t\tgoto posix_open_ret;\n\n\tif (presp_data->Type == cpu_to_le32(-1))\n\t\tgoto posix_open_ret; /* open ok, caller does qpathinfo */\n\n\tif (!pinode)\n\t\tgoto posix_open_ret; /* caller does not need info */\n\n\tcifs_unix_basic_to_fattr(&fattr, presp_data, cifs_sb);\n\n\t/* get new inode and set it up */\n\tif (*pinode == NULL) {\n\t\tcifs_fill_uniqueid(sb, &fattr);\n\t\t*pinode = cifs_iget(sb, &fattr);\n\t\tif (!*pinode) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto posix_open_ret;\n\t\t}\n\t} else {\n\t\tcifs_fattr_to_inode(*pinode, &fattr);\n\t}\n\nposix_open_ret:\n\tkfree(presp_data);\n\treturn rc;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "presp_data"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_fattr_to_inode",
          "args": [
            "*pinode",
            "&fattr"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_iget",
          "args": [
            "sb",
            "&fattr"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_fill_uniqueid",
          "args": [
            "sb",
            "&fattr"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_unix_basic_to_fattr",
          "args": [
            "&fattr",
            "presp_data",
            "cifs_sb"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSPOSIXCreate",
          "args": [
            "xid",
            "tcon",
            "posix_flags",
            "mode",
            "pnetfid",
            "presp_data",
            "poplock",
            "full_path",
            "cifs_sb->local_nls",
            "cifs_sb->mnt_cifs_flags &\n\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSPOSIXCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "997-1118",
          "snippet": "int\nCIFSPOSIXCreate(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t__u32 posix_flags, __u64 mode, __u16 *netfid,\n\t\tFILE_UNIX_BASIC_INFO *pRetData, __u32 *pOplock,\n\t\tconst char *name, const struct nls_table *nls_codepage,\n\t\tint remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tOPEN_PSX_REQ *pdata;\n\tOPEN_PSX_RSP *psx_rsp;\n\n\tcifs_dbg(FYI, \"In POSIX Create\\n\");\nPsxCreat:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, name, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(OPEN_PSX_REQ);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\t/* large enough */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tpdata = (OPEN_PSX_REQ *)(((char *)&pSMB->hdr.Protocol) + offset);\n\tpdata->Level = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpdata->Permissions = cpu_to_le64(mode);\n\tpdata->PosixOpenFlags = cpu_to_le32(posix_flags);\n\tpdata->OpenFlags =  cpu_to_le32(*pOplock);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_POSIX_OPEN);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Posix create returned %d\\n\", rc);\n\t\tgoto psx_create_err;\n\t}\n\n\tcifs_dbg(FYI, \"copying inode info\\n\");\n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)) {\n\t\trc = -EIO;\t/* bad smb */\n\t\tgoto psx_create_err;\n\t}\n\n\t/* copy return information to pRetData */\n\tpsx_rsp = (OPEN_PSX_RSP *)((char *) &pSMBr->hdr.Protocol\n\t\t\t+ le16_to_cpu(pSMBr->t2.DataOffset));\n\n\t*pOplock = le16_to_cpu(psx_rsp->OplockFlags);\n\tif (netfid)\n\t\t*netfid = psx_rsp->Fid;   /* cifs fid stays in le */\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == psx_rsp->CreateAction)\n\t\t*pOplock |= CIFS_CREATE_ACTION;\n\t/* check to make sure response data is there */\n\tif (psx_rsp->ReturnedLevel != cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC)) {\n\t\tpRetData->Type = cpu_to_le32(-1); /* unknown */\n\t\tcifs_dbg(NOISY, \"unknown type\\n\");\n\t} else {\n\t\tif (get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)\n\t\t\t\t\t+ sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcifs_dbg(VFS, \"Open response data too small\\n\");\n\t\t\tpRetData->Type = cpu_to_le32(-1);\n\t\t\tgoto psx_create_err;\n\t\t}\n\t\tmemcpy((char *) pRetData,\n\t\t\t(char *)psx_rsp + sizeof(OPEN_PSX_RSP),\n\t\t\tsizeof(FILE_UNIX_BASIC_INFO));\n\t}\n\npsx_create_err:\n\tcifs_buf_release(pSMB);\n\n\tif (posix_flags & SMB_O_DIRECTORY)\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_posixmkdirs);\n\telse\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_posixopens);\n\n\tif (rc == -EAGAIN)\n\t\tgoto PsxCreat;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSPOSIXCreate(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t__u32 posix_flags, __u64 mode, __u16 *netfid,\n\t\tFILE_UNIX_BASIC_INFO *pRetData, __u32 *pOplock,\n\t\tconst char *name, const struct nls_table *nls_codepage,\n\t\tint remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tOPEN_PSX_REQ *pdata;\n\tOPEN_PSX_RSP *psx_rsp;\n\n\tcifs_dbg(FYI, \"In POSIX Create\\n\");\nPsxCreat:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, name, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(OPEN_PSX_REQ);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\t/* large enough */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tpdata = (OPEN_PSX_REQ *)(((char *)&pSMB->hdr.Protocol) + offset);\n\tpdata->Level = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpdata->Permissions = cpu_to_le64(mode);\n\tpdata->PosixOpenFlags = cpu_to_le32(posix_flags);\n\tpdata->OpenFlags =  cpu_to_le32(*pOplock);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_POSIX_OPEN);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Posix create returned %d\\n\", rc);\n\t\tgoto psx_create_err;\n\t}\n\n\tcifs_dbg(FYI, \"copying inode info\\n\");\n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)) {\n\t\trc = -EIO;\t/* bad smb */\n\t\tgoto psx_create_err;\n\t}\n\n\t/* copy return information to pRetData */\n\tpsx_rsp = (OPEN_PSX_RSP *)((char *) &pSMBr->hdr.Protocol\n\t\t\t+ le16_to_cpu(pSMBr->t2.DataOffset));\n\n\t*pOplock = le16_to_cpu(psx_rsp->OplockFlags);\n\tif (netfid)\n\t\t*netfid = psx_rsp->Fid;   /* cifs fid stays in le */\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == psx_rsp->CreateAction)\n\t\t*pOplock |= CIFS_CREATE_ACTION;\n\t/* check to make sure response data is there */\n\tif (psx_rsp->ReturnedLevel != cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC)) {\n\t\tpRetData->Type = cpu_to_le32(-1); /* unknown */\n\t\tcifs_dbg(NOISY, \"unknown type\\n\");\n\t} else {\n\t\tif (get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)\n\t\t\t\t\t+ sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcifs_dbg(VFS, \"Open response data too small\\n\");\n\t\t\tpRetData->Type = cpu_to_le32(-1);\n\t\t\tgoto psx_create_err;\n\t\t}\n\t\tmemcpy((char *) pRetData,\n\t\t\t(char *)psx_rsp + sizeof(OPEN_PSX_RSP),\n\t\t\tsizeof(FILE_UNIX_BASIC_INFO));\n\t}\n\npsx_create_err:\n\tcifs_buf_release(pSMB);\n\n\tif (posix_flags & SMB_O_DIRECTORY)\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_posixmkdirs);\n\telse\n\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_posixopens);\n\n\tif (rc == -EAGAIN)\n\t\tgoto PsxCreat;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_posix_convert_flags",
          "args": [
            "f_flags"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_posix_convert_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "65-97",
          "snippet": "static u32 cifs_posix_convert_flags(unsigned int flags)\n{\n\tu32 posix_flags = 0;\n\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\tposix_flags = SMB_O_RDONLY;\n\telse if ((flags & O_ACCMODE) == O_WRONLY)\n\t\tposix_flags = SMB_O_WRONLY;\n\telse if ((flags & O_ACCMODE) == O_RDWR)\n\t\tposix_flags = SMB_O_RDWR;\n\n\tif (flags & O_CREAT) {\n\t\tposix_flags |= SMB_O_CREAT;\n\t\tif (flags & O_EXCL)\n\t\t\tposix_flags |= SMB_O_EXCL;\n\t} else if (flags & O_EXCL)\n\t\tcifs_dbg(FYI, \"Application %s pid %d has incorrectly set O_EXCL flag but not O_CREAT on file open. Ignoring O_EXCL\\n\",\n\t\t\t current->comm, current->tgid);\n\n\tif (flags & O_TRUNC)\n\t\tposix_flags |= SMB_O_TRUNC;\n\t/* be safe and imply O_SYNC for O_DSYNC */\n\tif (flags & O_DSYNC)\n\t\tposix_flags |= SMB_O_SYNC;\n\tif (flags & O_DIRECTORY)\n\t\tposix_flags |= SMB_O_DIRECTORY;\n\tif (flags & O_NOFOLLOW)\n\t\tposix_flags |= SMB_O_NOFOLLOW;\n\tif (flags & O_DIRECT)\n\t\tposix_flags |= SMB_O_DIRECT;\n\n\treturn posix_flags;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic u32 cifs_posix_convert_flags(unsigned int flags)\n{\n\tu32 posix_flags = 0;\n\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\tposix_flags = SMB_O_RDONLY;\n\telse if ((flags & O_ACCMODE) == O_WRONLY)\n\t\tposix_flags = SMB_O_WRONLY;\n\telse if ((flags & O_ACCMODE) == O_RDWR)\n\t\tposix_flags = SMB_O_RDWR;\n\n\tif (flags & O_CREAT) {\n\t\tposix_flags |= SMB_O_CREAT;\n\t\tif (flags & O_EXCL)\n\t\t\tposix_flags |= SMB_O_EXCL;\n\t} else if (flags & O_EXCL)\n\t\tcifs_dbg(FYI, \"Application %s pid %d has incorrectly set O_EXCL flag but not O_CREAT on file open. Ignoring O_EXCL\\n\",\n\t\t\t current->comm, current->tgid);\n\n\tif (flags & O_TRUNC)\n\t\tposix_flags |= SMB_O_TRUNC;\n\t/* be safe and imply O_SYNC for O_DSYNC */\n\tif (flags & O_DSYNC)\n\t\tposix_flags |= SMB_O_SYNC;\n\tif (flags & O_DIRECTORY)\n\t\tposix_flags |= SMB_O_DIRECTORY;\n\tif (flags & O_NOFOLLOW)\n\t\tposix_flags |= SMB_O_NOFOLLOW;\n\tif (flags & O_DIRECT)\n\t\tposix_flags |= SMB_O_DIRECT;\n\n\treturn posix_flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_umask",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "current_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_struct.c",
          "lines": "154-157",
          "snippet": "int current_umask(void)\n{\n\treturn current->fs->umask;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nint current_umask(void)\n{\n\treturn current->fs->umask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "4011-4082",
          "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(FILE_UNIX_BASIC_INFO)",
            "GFP_KERNEL"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"posix open %s\\n\"",
            "full_path"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "sb"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nint cifs_posix_open(char *full_path, struct inode **pinode,\n\t\t\tstruct super_block *sb, int mode, unsigned int f_flags,\n\t\t\t__u32 *poplock, __u16 *pnetfid, unsigned int xid)\n{\n\tint rc;\n\tFILE_UNIX_BASIC_INFO *presp_data;\n\t__u32 posix_flags = 0;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_fattr fattr;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\n\tcifs_dbg(FYI, \"posix open %s\\n\", full_path);\n\n\tpresp_data = kzalloc(sizeof(FILE_UNIX_BASIC_INFO), GFP_KERNEL);\n\tif (presp_data == NULL)\n\t\treturn -ENOMEM;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto posix_open_ret;\n\t}\n\n\ttcon = tlink_tcon(tlink);\n\tmode &= ~current_umask();\n\n\tposix_flags = cifs_posix_convert_flags(f_flags);\n\trc = CIFSPOSIXCreate(xid, tcon, posix_flags, mode, pnetfid, presp_data,\n\t\t\t     poplock, full_path, cifs_sb->local_nls,\n\t\t\t     cifs_sb->mnt_cifs_flags &\n\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\tcifs_put_tlink(tlink);\n\n\tif (rc)\n\t\tgoto posix_open_ret;\n\n\tif (presp_data->Type == cpu_to_le32(-1))\n\t\tgoto posix_open_ret; /* open ok, caller does qpathinfo */\n\n\tif (!pinode)\n\t\tgoto posix_open_ret; /* caller does not need info */\n\n\tcifs_unix_basic_to_fattr(&fattr, presp_data, cifs_sb);\n\n\t/* get new inode and set it up */\n\tif (*pinode == NULL) {\n\t\tcifs_fill_uniqueid(sb, &fattr);\n\t\t*pinode = cifs_iget(sb, &fattr);\n\t\tif (!*pinode) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto posix_open_ret;\n\t\t}\n\t} else {\n\t\tcifs_fattr_to_inode(*pinode, &fattr);\n\t}\n\nposix_open_ret:\n\tkfree(presp_data);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_get_disposition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "99-111",
    "snippet": "static inline int cifs_get_disposition(unsigned int flags)\n{\n\tif ((flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\treturn FILE_CREATE;\n\telse if ((flags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))\n\t\treturn FILE_OVERWRITE_IF;\n\telse if ((flags & O_CREAT) == O_CREAT)\n\t\treturn FILE_OPEN_IF;\n\telse if ((flags & O_TRUNC) == O_TRUNC)\n\t\treturn FILE_OVERWRITE;\n\telse\n\t\treturn FILE_OPEN;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic inline int cifs_get_disposition(unsigned int flags)\n{\n\tif ((flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\treturn FILE_CREATE;\n\telse if ((flags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))\n\t\treturn FILE_OVERWRITE_IF;\n\telse if ((flags & O_CREAT) == O_CREAT)\n\t\treturn FILE_OPEN_IF;\n\telse if ((flags & O_TRUNC) == O_TRUNC)\n\t\treturn FILE_OVERWRITE;\n\telse\n\t\treturn FILE_OPEN;\n}"
  },
  {
    "function_name": "cifs_posix_convert_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "65-97",
    "snippet": "static u32 cifs_posix_convert_flags(unsigned int flags)\n{\n\tu32 posix_flags = 0;\n\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\tposix_flags = SMB_O_RDONLY;\n\telse if ((flags & O_ACCMODE) == O_WRONLY)\n\t\tposix_flags = SMB_O_WRONLY;\n\telse if ((flags & O_ACCMODE) == O_RDWR)\n\t\tposix_flags = SMB_O_RDWR;\n\n\tif (flags & O_CREAT) {\n\t\tposix_flags |= SMB_O_CREAT;\n\t\tif (flags & O_EXCL)\n\t\t\tposix_flags |= SMB_O_EXCL;\n\t} else if (flags & O_EXCL)\n\t\tcifs_dbg(FYI, \"Application %s pid %d has incorrectly set O_EXCL flag but not O_CREAT on file open. Ignoring O_EXCL\\n\",\n\t\t\t current->comm, current->tgid);\n\n\tif (flags & O_TRUNC)\n\t\tposix_flags |= SMB_O_TRUNC;\n\t/* be safe and imply O_SYNC for O_DSYNC */\n\tif (flags & O_DSYNC)\n\t\tposix_flags |= SMB_O_SYNC;\n\tif (flags & O_DIRECTORY)\n\t\tposix_flags |= SMB_O_DIRECTORY;\n\tif (flags & O_NOFOLLOW)\n\t\tposix_flags |= SMB_O_NOFOLLOW;\n\tif (flags & O_DIRECT)\n\t\tposix_flags |= SMB_O_DIRECT;\n\n\treturn posix_flags;\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Application %s pid %d has incorrectly set O_EXCL flag but not O_CREAT on file open. Ignoring O_EXCL\\n\"",
            "current->comm",
            "current->tgid"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic u32 cifs_posix_convert_flags(unsigned int flags)\n{\n\tu32 posix_flags = 0;\n\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\tposix_flags = SMB_O_RDONLY;\n\telse if ((flags & O_ACCMODE) == O_WRONLY)\n\t\tposix_flags = SMB_O_WRONLY;\n\telse if ((flags & O_ACCMODE) == O_RDWR)\n\t\tposix_flags = SMB_O_RDWR;\n\n\tif (flags & O_CREAT) {\n\t\tposix_flags |= SMB_O_CREAT;\n\t\tif (flags & O_EXCL)\n\t\t\tposix_flags |= SMB_O_EXCL;\n\t} else if (flags & O_EXCL)\n\t\tcifs_dbg(FYI, \"Application %s pid %d has incorrectly set O_EXCL flag but not O_CREAT on file open. Ignoring O_EXCL\\n\",\n\t\t\t current->comm, current->tgid);\n\n\tif (flags & O_TRUNC)\n\t\tposix_flags |= SMB_O_TRUNC;\n\t/* be safe and imply O_SYNC for O_DSYNC */\n\tif (flags & O_DSYNC)\n\t\tposix_flags |= SMB_O_SYNC;\n\tif (flags & O_DIRECTORY)\n\t\tposix_flags |= SMB_O_DIRECTORY;\n\tif (flags & O_NOFOLLOW)\n\t\tposix_flags |= SMB_O_NOFOLLOW;\n\tif (flags & O_DIRECT)\n\t\tposix_flags |= SMB_O_DIRECT;\n\n\treturn posix_flags;\n}"
  },
  {
    "function_name": "cifs_convert_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
    "lines": "47-63",
    "snippet": "static inline int cifs_convert_flags(unsigned int flags)\n{\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\treturn GENERIC_READ;\n\telse if ((flags & O_ACCMODE) == O_WRONLY)\n\t\treturn GENERIC_WRITE;\n\telse if ((flags & O_ACCMODE) == O_RDWR) {\n\t\t/* GENERIC_ALL is too much permission to request\n\t\t   can cause unnecessary access denied on create */\n\t\t/* return GENERIC_ALL; */\n\t\treturn (GENERIC_READ | GENERIC_WRITE);\n\t}\n\n\treturn (READ_CONTROL | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES |\n\t\tFILE_WRITE_EA | FILE_APPEND_DATA | FILE_WRITE_DATA |\n\t\tFILE_READ_DATA);\n}",
    "includes": [
      "#include \"fscache.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <asm/div64.h>",
      "#include <linux/swap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/delay.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic inline int cifs_convert_flags(unsigned int flags)\n{\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\treturn GENERIC_READ;\n\telse if ((flags & O_ACCMODE) == O_WRONLY)\n\t\treturn GENERIC_WRITE;\n\telse if ((flags & O_ACCMODE) == O_RDWR) {\n\t\t/* GENERIC_ALL is too much permission to request\n\t\t   can cause unnecessary access denied on create */\n\t\t/* return GENERIC_ALL; */\n\t\treturn (GENERIC_READ | GENERIC_WRITE);\n\t}\n\n\treturn (READ_CONTROL | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES |\n\t\tFILE_WRITE_EA | FILE_APPEND_DATA | FILE_WRITE_DATA |\n\t\tFILE_READ_DATA);\n}"
  }
]