[
  {
    "function_name": "ntfs_dir_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/dir.c",
    "lines": "1500-1537",
    "snippet": "static int ntfs_dir_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\t  int datasync)\n{\n\tstruct inode *bmp_vi, *vi = filp->f_mapping->host;\n\tint err, ret;\n\tntfs_attr na;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", vi->i_ino);\n\n\terr = filemap_write_and_wait_range(vi->i_mapping, start, end);\n\tif (err)\n\t\treturn err;\n\tmutex_lock(&vi->i_mutex);\n\n\tBUG_ON(!S_ISDIR(vi->i_mode));\n\t/* If the bitmap attribute inode is in memory sync it, too. */\n\tna.mft_no = vi->i_ino;\n\tna.type = AT_BITMAP;\n\tna.name = I30;\n\tna.name_len = 4;\n\tbmp_vi = ilookup5(vi->i_sb, vi->i_ino, (test_t)ntfs_test_inode, &na);\n\tif (bmp_vi) {\n \t\twrite_inode_now(bmp_vi, !datasync);\n\t\tiput(bmp_vi);\n\t}\n\tret = __ntfs_write_inode(vi, 1);\n\twrite_inode_now(vi, !datasync);\n\terr = sync_blockdev(vi->i_sb->s_bdev);\n\tif (unlikely(err && !ret))\n\t\tret = err;\n\tif (likely(!ret))\n\t\tntfs_debug(\"Done.\");\n\telse\n\t\tntfs_warning(vi->i_sb, \"Failed to f%ssync inode 0x%lx.  Error \"\n\t\t\t\t\"%u.\", datasync ? \"data\" : \"\", vi->i_ino, -ret);\n\tmutex_unlock(&vi->i_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"mft.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include \"dir.h\"",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ntfschar I30[5] = { cpu_to_le16('$'), cpu_to_le16('I'),\n\t\tcpu_to_le16('3'),\tcpu_to_le16('0'), 0 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vi->i_mutex"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vi->i_sb",
            "\"Failed to f%ssync inode 0x%lx.  Error \"\n\t\t\t\t\"%u.\"",
            "datasync ? \"data\" : \"\"",
            "vi->i_ino",
            "-ret"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "43-65",
          "snippet": "void __ntfs_warning(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_warn(\"(device %s): %s(): %pV\\n\",\n\t\t\tsb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_warn(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_warning(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_warn(\"(device %s): %s(): %pV\\n\",\n\t\t\tsb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_warn(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ret"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err && !ret"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "vi->i_sb->s_bdev"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "174-177",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_inode_now",
          "args": [
            "vi",
            "!datasync"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1469-1484",
          "snippet": "int write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ntfs_write_inode",
          "args": [
            "vi",
            "1"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "2967-3110",
          "snippet": "int __ntfs_write_inode(struct inode *vi, int sync)\n{\n\tsle64 nt;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tSTANDARD_INFORMATION *si;\n\tint err = 0;\n\tbool modified = false;\n\n\tntfs_debug(\"Entering for %sinode 0x%lx.\", NInoAttr(ni) ? \"attr \" : \"\",\n\t\t\tvi->i_ino);\n\t/*\n\t * Dirty attribute inodes are written via their real inodes so just\n\t * clean them here.  Access time updates are taken care off when the\n\t * real inode is written.\n\t */\n\tif (NInoAttr(ni)) {\n\t\tNInoClearDirty(ni);\n\t\tntfs_debug(\"Done.\");\n\t\treturn 0;\n\t}\n\t/* Map, pin, and lock the mft record belonging to the inode. */\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\t/* Update the access times in the standard information attribute. */\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tgoto unm_err_out;\n\t}\n\tsi = (STANDARD_INFORMATION*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\t/* Update the access times if they have changed. */\n\tnt = utc2ntfs(vi->i_mtime);\n\tif (si->last_data_change_time != nt) {\n\t\tntfs_debug(\"Updating mtime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_data_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_data_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_ctime);\n\tif (si->last_mft_change_time != nt) {\n\t\tntfs_debug(\"Updating ctime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_mft_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_mft_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_atime);\n\tif (si->last_access_time != nt) {\n\t\tntfs_debug(\"Updating atime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino,\n\t\t\t\t(long long)sle64_to_cpu(si->last_access_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_access_time = nt;\n\t\tmodified = true;\n\t}\n\t/*\n\t * If we just modified the standard information attribute we need to\n\t * mark the mft record it is in dirty.  We do this manually so that\n\t * mark_inode_dirty() is not called which would redirty the inode and\n\t * hence result in an infinite loop of trying to write the inode.\n\t * There is no need to mark the base inode nor the base mft record\n\t * dirty, since we are going to write this mft record below in any case\n\t * and the base mft record may actually not have been modified so it\n\t * might not need to be written out.\n\t * NOTE: It is not a problem when the inode for $MFT itself is being\n\t * written out as mark_ntfs_record_dirty() will only set I_DIRTY_PAGES\n\t * on the $MFT inode and hence ntfs_write_inode() will not be\n\t * re-invoked because of it which in turn is ok since the dirtied mft\n\t * record will be cleaned and written out to disk below, i.e. before\n\t * this function returns.\n\t */\n\tif (modified) {\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tif (!NInoTestSetDirty(ctx->ntfs_ino))\n\t\t\tmark_ntfs_record_dirty(ctx->ntfs_ino->page,\n\t\t\t\t\tctx->ntfs_ino->page_ofs);\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\t/* Now the access times are updated, write the base mft record. */\n\tif (NInoDirty(ni))\n\t\terr = write_mft_record(ni, m, sync);\n\t/* Write all attached extent mft records. */\n\tmutex_lock(&ni->extent_lock);\n\tif (ni->nr_extents > 0) {\n\t\tntfs_inode **extent_nis = ni->ext.extent_ntfs_inos;\n\t\tint i;\n\n\t\tntfs_debug(\"Writing %i extent inodes.\", ni->nr_extents);\n\t\tfor (i = 0; i < ni->nr_extents; i++) {\n\t\t\tntfs_inode *tni = extent_nis[i];\n\n\t\t\tif (NInoDirty(tni)) {\n\t\t\t\tMFT_RECORD *tm = map_mft_record(tni);\n\t\t\t\tint ret;\n\n\t\t\t\tif (IS_ERR(tm)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = PTR_ERR(tm);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tret = write_mft_record(tni, tm, sync);\n\t\t\t\tunmap_mft_record(tni);\n\t\t\t\tif (unlikely(ret)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ni->extent_lock);\n\tunmap_mft_record(ni);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\tntfs_debug(\"Done.\");\n\treturn 0;\nunm_err_out:\n\tunmap_mft_record(ni);\nerr_out:\n\tif (err == -ENOMEM) {\n\t\tntfs_warning(vi->i_sb, \"Not enough memory to write inode.  \"\n\t\t\t\t\"Marking the inode dirty again, so the VFS \"\n\t\t\t\t\"retries later.\");\n\t\tmark_inode_dirty(vi);\n\t} else {\n\t\tntfs_error(vi->i_sb, \"Failed (error %i):  Run chkdsk.\", -err);\n\t\tNVolSetErrors(ni->vol);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nint __ntfs_write_inode(struct inode *vi, int sync)\n{\n\tsle64 nt;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tSTANDARD_INFORMATION *si;\n\tint err = 0;\n\tbool modified = false;\n\n\tntfs_debug(\"Entering for %sinode 0x%lx.\", NInoAttr(ni) ? \"attr \" : \"\",\n\t\t\tvi->i_ino);\n\t/*\n\t * Dirty attribute inodes are written via their real inodes so just\n\t * clean them here.  Access time updates are taken care off when the\n\t * real inode is written.\n\t */\n\tif (NInoAttr(ni)) {\n\t\tNInoClearDirty(ni);\n\t\tntfs_debug(\"Done.\");\n\t\treturn 0;\n\t}\n\t/* Map, pin, and lock the mft record belonging to the inode. */\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\t/* Update the access times in the standard information attribute. */\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tgoto unm_err_out;\n\t}\n\tsi = (STANDARD_INFORMATION*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\t/* Update the access times if they have changed. */\n\tnt = utc2ntfs(vi->i_mtime);\n\tif (si->last_data_change_time != nt) {\n\t\tntfs_debug(\"Updating mtime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_data_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_data_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_ctime);\n\tif (si->last_mft_change_time != nt) {\n\t\tntfs_debug(\"Updating ctime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_mft_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_mft_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_atime);\n\tif (si->last_access_time != nt) {\n\t\tntfs_debug(\"Updating atime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino,\n\t\t\t\t(long long)sle64_to_cpu(si->last_access_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_access_time = nt;\n\t\tmodified = true;\n\t}\n\t/*\n\t * If we just modified the standard information attribute we need to\n\t * mark the mft record it is in dirty.  We do this manually so that\n\t * mark_inode_dirty() is not called which would redirty the inode and\n\t * hence result in an infinite loop of trying to write the inode.\n\t * There is no need to mark the base inode nor the base mft record\n\t * dirty, since we are going to write this mft record below in any case\n\t * and the base mft record may actually not have been modified so it\n\t * might not need to be written out.\n\t * NOTE: It is not a problem when the inode for $MFT itself is being\n\t * written out as mark_ntfs_record_dirty() will only set I_DIRTY_PAGES\n\t * on the $MFT inode and hence ntfs_write_inode() will not be\n\t * re-invoked because of it which in turn is ok since the dirtied mft\n\t * record will be cleaned and written out to disk below, i.e. before\n\t * this function returns.\n\t */\n\tif (modified) {\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tif (!NInoTestSetDirty(ctx->ntfs_ino))\n\t\t\tmark_ntfs_record_dirty(ctx->ntfs_ino->page,\n\t\t\t\t\tctx->ntfs_ino->page_ofs);\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\t/* Now the access times are updated, write the base mft record. */\n\tif (NInoDirty(ni))\n\t\terr = write_mft_record(ni, m, sync);\n\t/* Write all attached extent mft records. */\n\tmutex_lock(&ni->extent_lock);\n\tif (ni->nr_extents > 0) {\n\t\tntfs_inode **extent_nis = ni->ext.extent_ntfs_inos;\n\t\tint i;\n\n\t\tntfs_debug(\"Writing %i extent inodes.\", ni->nr_extents);\n\t\tfor (i = 0; i < ni->nr_extents; i++) {\n\t\t\tntfs_inode *tni = extent_nis[i];\n\n\t\t\tif (NInoDirty(tni)) {\n\t\t\t\tMFT_RECORD *tm = map_mft_record(tni);\n\t\t\t\tint ret;\n\n\t\t\t\tif (IS_ERR(tm)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = PTR_ERR(tm);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tret = write_mft_record(tni, tm, sync);\n\t\t\t\tunmap_mft_record(tni);\n\t\t\t\tif (unlikely(ret)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ni->extent_lock);\n\tunmap_mft_record(ni);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\tntfs_debug(\"Done.\");\n\treturn 0;\nunm_err_out:\n\tunmap_mft_record(ni);\nerr_out:\n\tif (err == -ENOMEM) {\n\t\tntfs_warning(vi->i_sb, \"Not enough memory to write inode.  \"\n\t\t\t\t\"Marking the inode dirty again, so the VFS \"\n\t\t\t\t\"retries later.\");\n\t\tmark_inode_dirty(vi);\n\t} else {\n\t\tntfs_error(vi->i_sb, \"Failed (error %i):  Run chkdsk.\", -err);\n\t\tNVolSetErrors(ni->vol);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "bmp_vi"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilookup5",
          "args": [
            "vi->i_sb",
            "vi->i_ino",
            "(test_t)ntfs_test_inode",
            "&na"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "ilookup5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1239-1247",
          "snippet": "struct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!S_ISDIR(vi->i_mode)"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "vi->i_mode"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vi->i_mutex"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "vi->i_mapping",
            "start",
            "end"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for inode 0x%lx.\"",
            "vi->i_ino"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include \"dir.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nntfschar I30[5] = { cpu_to_le16('$'), cpu_to_le16('I'),\n\t\tcpu_to_le16('3'),\tcpu_to_le16('0'), 0 };\n\nstatic int ntfs_dir_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\t  int datasync)\n{\n\tstruct inode *bmp_vi, *vi = filp->f_mapping->host;\n\tint err, ret;\n\tntfs_attr na;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", vi->i_ino);\n\n\terr = filemap_write_and_wait_range(vi->i_mapping, start, end);\n\tif (err)\n\t\treturn err;\n\tmutex_lock(&vi->i_mutex);\n\n\tBUG_ON(!S_ISDIR(vi->i_mode));\n\t/* If the bitmap attribute inode is in memory sync it, too. */\n\tna.mft_no = vi->i_ino;\n\tna.type = AT_BITMAP;\n\tna.name = I30;\n\tna.name_len = 4;\n\tbmp_vi = ilookup5(vi->i_sb, vi->i_ino, (test_t)ntfs_test_inode, &na);\n\tif (bmp_vi) {\n \t\twrite_inode_now(bmp_vi, !datasync);\n\t\tiput(bmp_vi);\n\t}\n\tret = __ntfs_write_inode(vi, 1);\n\twrite_inode_now(vi, !datasync);\n\terr = sync_blockdev(vi->i_sb->s_bdev);\n\tif (unlikely(err && !ret))\n\t\tret = err;\n\tif (likely(!ret))\n\t\tntfs_debug(\"Done.\");\n\telse\n\t\tntfs_warning(vi->i_sb, \"Failed to f%ssync inode 0x%lx.  Error \"\n\t\t\t\t\"%u.\", datasync ? \"data\" : \"\", vi->i_ino, -ret);\n\tmutex_unlock(&vi->i_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "ntfs_dir_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/dir.c",
    "lines": "1464-1471",
    "snippet": "static int ntfs_dir_open(struct inode *vi, struct file *filp)\n{\n\tif (sizeof(unsigned long) < 8) {\n\t\tif (i_size_read(vi) > MAX_LFS_FILESIZE)\n\t\t\treturn -EFBIG;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"mft.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include \"dir.h\"",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include \"dir.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_dir_open(struct inode *vi, struct file *filp)\n{\n\tif (sizeof(unsigned long) < 8) {\n\t\tif (i_size_read(vi) > MAX_LFS_FILESIZE)\n\t\t\treturn -EFBIG;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ntfs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/dir.c",
    "lines": "1099-1446",
    "snippet": "static int ntfs_readdir(struct file *file, struct dir_context *actor)\n{\n\ts64 ia_pos, ia_start, prev_ia_pos, bmp_pos;\n\tloff_t i_size;\n\tstruct inode *bmp_vi, *vdir = file_inode(file);\n\tstruct super_block *sb = vdir->i_sb;\n\tntfs_inode *ndir = NTFS_I(vdir);\n\tntfs_volume *vol = NTFS_SB(sb);\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir = NULL;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *name = NULL;\n\tint rc, err, ir_pos, cur_bmp_pos;\n\tstruct address_space *ia_mapping, *bmp_mapping;\n\tstruct page *bmp_page = NULL, *ia_page = NULL;\n\tu8 *kaddr, *bmp, *index_end;\n\tntfs_attr_search_ctx *ctx;\n\n\tntfs_debug(\"Entering for inode 0x%lx, fpos 0x%llx.\",\n\t\t\tvdir->i_ino, actor->pos);\n\trc = err = 0;\n\t/* Are we at end of dir yet? */\n\ti_size = i_size_read(vdir);\n\tif (actor->pos >= i_size + vol->mft_record_size)\n\t\treturn 0;\n\t/* Emulate . and .. for all directories. */\n\tif (!dir_emit_dots(file, actor))\n\t\treturn 0;\n\tm = NULL;\n\tctx = NULL;\n\t/*\n\t * Allocate a buffer to store the current name being processed\n\t * converted to format determined by current NLS.\n\t */\n\tname = kmalloc(NTFS_MAX_NAME_LEN * NLS_MAX_CHARSET_SIZE + 1, GFP_NOFS);\n\tif (unlikely(!name)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Are we jumping straight into the index allocation attribute? */\n\tif (actor->pos >= vol->mft_record_size)\n\t\tgoto skip_index_root;\n\t/* Get hold of the mft record for the directory. */\n\tm = map_mft_record(ndir);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ndir, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Get the offset into the index root attribute. */\n\tir_pos = (s64)actor->pos;\n\t/* Find the index root attribute in the mft record. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_error(sb, \"Index root attribute missing in directory \"\n\t\t\t\t\"inode 0x%lx.\", vdir->i_ino);\n\t\tgoto err_out;\n\t}\n\t/*\n\t * Copy the index root attribute value to a buffer so that we can put\n\t * the search context and unmap the mft record before calling the\n\t * filldir() callback.  We need to do this because of NFSd which calls\n\t * ->lookup() from its filldir callback() and this causes NTFS to\n\t * deadlock as ntfs_lookup() maps the mft record of the directory and\n\t * we have got it mapped here already.  The only solution is for us to\n\t * unmap the mft record here so that a call to ntfs_lookup() is able to\n\t * map the mft record without deadlocking.\n\t */\n\trc = le32_to_cpu(ctx->attr->data.resident.value_length);\n\tir = kmalloc(rc, GFP_NOFS);\n\tif (unlikely(!ir)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Copy the index root value (it has been verified in read_inode). */\n\tmemcpy(ir, (u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset), rc);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ndir);\n\tctx = NULL;\n\tm = NULL;\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry or until filldir tells us it has had enough\n\t * or signals an error (both covered by the rc test).\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\tntfs_debug(\"In index root, offset 0x%zx.\", (u8*)ie - (u8*)ir);\n\t\t/* Bounds checks. */\n\t\tif (unlikely((u8*)ie < (u8*)ir || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end))\n\t\t\tgoto err_out;\n\t\t/* The last entry cannot contain a name. */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/* Skip index root entry if continuing previous readdir. */\n\t\tif (ir_pos > (u8*)ie - (u8*)ir)\n\t\t\tcontinue;\n\t\t/* Advance the position even if going to skip the entry. */\n\t\tactor->pos = (u8*)ie - (u8*)ir;\n\t\t/* Submit the name to the filldir callback. */\n\t\trc = ntfs_filldir(vol, ndir, NULL, ie, name, actor);\n\t\tif (rc) {\n\t\t\tkfree(ir);\n\t\t\tgoto abort;\n\t\t}\n\t}\n\t/* We are done with the index root and can free the buffer. */\n\tkfree(ir);\n\tir = NULL;\n\t/* If there is no index allocation attribute we are finished. */\n\tif (!NInoIndexAllocPresent(ndir))\n\t\tgoto EOD;\n\t/* Advance fpos to the beginning of the index allocation. */\n\tactor->pos = vol->mft_record_size;\nskip_index_root:\n\tkaddr = NULL;\n\tprev_ia_pos = -1LL;\n\t/* Get the offset into the index allocation attribute. */\n\tia_pos = (s64)actor->pos - vol->mft_record_size;\n\tia_mapping = vdir->i_mapping;\n\tntfs_debug(\"Inode 0x%lx, getting index bitmap.\", vdir->i_ino);\n\tbmp_vi = ntfs_attr_iget(vdir, AT_BITMAP, I30, 4);\n\tif (IS_ERR(bmp_vi)) {\n\t\tntfs_error(sb, \"Failed to get bitmap attribute.\");\n\t\terr = PTR_ERR(bmp_vi);\n\t\tgoto err_out;\n\t}\n\tbmp_mapping = bmp_vi->i_mapping;\n\t/* Get the starting bitmap bit position and sanity check it. */\n\tbmp_pos = ia_pos >> ndir->itype.index.block_size_bits;\n\tif (unlikely(bmp_pos >> 3 >= i_size_read(bmp_vi))) {\n\t\tntfs_error(sb, \"Current index allocation position exceeds \"\n\t\t\t\t\"index bitmap size.\");\n\t\tgoto iput_err_out;\n\t}\n\t/* Get the starting bit position in the current bitmap page. */\n\tcur_bmp_pos = bmp_pos & ((PAGE_CACHE_SIZE * 8) - 1);\n\tbmp_pos &= ~(u64)((PAGE_CACHE_SIZE * 8) - 1);\nget_next_bmp_page:\n\tntfs_debug(\"Reading bitmap with page index 0x%llx, bit ofs 0x%llx\",\n\t\t\t(unsigned long long)bmp_pos >> (3 + PAGE_CACHE_SHIFT),\n\t\t\t(unsigned long long)bmp_pos &\n\t\t\t(unsigned long long)((PAGE_CACHE_SIZE * 8) - 1));\n\tbmp_page = ntfs_map_page(bmp_mapping,\n\t\t\tbmp_pos >> (3 + PAGE_CACHE_SHIFT));\n\tif (IS_ERR(bmp_page)) {\n\t\tntfs_error(sb, \"Reading index bitmap failed.\");\n\t\terr = PTR_ERR(bmp_page);\n\t\tbmp_page = NULL;\n\t\tgoto iput_err_out;\n\t}\n\tbmp = (u8*)page_address(bmp_page);\n\t/* Find next index block in use. */\n\twhile (!(bmp[cur_bmp_pos >> 3] & (1 << (cur_bmp_pos & 7)))) {\nfind_next_index_buffer:\n\t\tcur_bmp_pos++;\n\t\t/*\n\t\t * If we have reached the end of the bitmap page, get the next\n\t\t * page, and put away the old one.\n\t\t */\n\t\tif (unlikely((cur_bmp_pos >> 3) >= PAGE_CACHE_SIZE)) {\n\t\t\tntfs_unmap_page(bmp_page);\n\t\t\tbmp_pos += PAGE_CACHE_SIZE * 8;\n\t\t\tcur_bmp_pos = 0;\n\t\t\tgoto get_next_bmp_page;\n\t\t}\n\t\t/* If we have reached the end of the bitmap, we are done. */\n\t\tif (unlikely(((bmp_pos + cur_bmp_pos) >> 3) >= i_size))\n\t\t\tgoto unm_EOD;\n\t\tia_pos = (bmp_pos + cur_bmp_pos) <<\n\t\t\t\tndir->itype.index.block_size_bits;\n\t}\n\tntfs_debug(\"Handling index buffer 0x%llx.\",\n\t\t\t(unsigned long long)bmp_pos + cur_bmp_pos);\n\t/* If the current index buffer is in the same page we reuse the page. */\n\tif ((prev_ia_pos & (s64)PAGE_CACHE_MASK) !=\n\t\t\t(ia_pos & (s64)PAGE_CACHE_MASK)) {\n\t\tprev_ia_pos = ia_pos;\n\t\tif (likely(ia_page != NULL)) {\n\t\t\tunlock_page(ia_page);\n\t\t\tntfs_unmap_page(ia_page);\n\t\t}\n\t\t/*\n\t\t * Map the page cache page containing the current ia_pos,\n\t\t * reading it from disk if necessary.\n\t\t */\n\t\tia_page = ntfs_map_page(ia_mapping, ia_pos >> PAGE_CACHE_SHIFT);\n\t\tif (IS_ERR(ia_page)) {\n\t\t\tntfs_error(sb, \"Reading index allocation data failed.\");\n\t\t\terr = PTR_ERR(ia_page);\n\t\t\tia_page = NULL;\n\t\t\tgoto err_out;\n\t\t}\n\t\tlock_page(ia_page);\n\t\tkaddr = (u8*)page_address(ia_page);\n\t}\n\t/* Get the current index buffer. */\n\tia = (INDEX_ALLOCATION*)(kaddr + (ia_pos & ~PAGE_CACHE_MASK &\n\t\t\t~(s64)(ndir->itype.index.block_size - 1)));\n\t/* Bounds checks. */\n\tif (unlikely((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE)) {\n\t\tntfs_error(sb, \"Out of bounds check failed. Corrupt directory \"\n\t\t\t\t\"inode 0x%lx or driver bug.\", vdir->i_ino);\n\t\tgoto err_out;\n\t}\n\t/* Catch multi sector transfer fixup errors. */\n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Directory index record with vcn 0x%llx is \"\n\t\t\t\t\"corrupt.  Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(unsigned long long)ia_pos >>\n\t\t\t\tndir->itype.index.vcn_size_bits, vdir->i_ino);\n\t\tgoto err_out;\n\t}\n\tif (unlikely(sle64_to_cpu(ia->index_block_vcn) != (ia_pos &\n\t\t\t~(s64)(ndir->itype.index.block_size - 1)) >>\n\t\t\tndir->itype.index.vcn_size_bits)) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx). \"\n\t\t\t\t\"Directory inode 0x%lx is corrupt or driver \"\n\t\t\t\t\"bug. \", (unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)ia_pos >>\n\t\t\t\tndir->itype.index.vcn_size_bits, vdir->i_ino);\n\t\tgoto err_out;\n\t}\n\tif (unlikely(le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tndir->itype.index.block_size)) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx has a size (%u) differing from the \"\n\t\t\t\t\"directory specified size (%u). Directory \"\n\t\t\t\t\"inode is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)ia_pos >>\n\t\t\t\tndir->itype.index.vcn_size_bits, vdir->i_ino,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tndir->itype.index.block_size);\n\t\tgoto err_out;\n\t}\n\tindex_end = (u8*)ia + ndir->itype.index.block_size;\n\tif (unlikely(index_end > kaddr + PAGE_CACHE_SIZE)) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx crosses page boundary. Impossible! \"\n\t\t\t\t\"Cannot access! This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)ia_pos >>\n\t\t\t\tndir->itype.index.vcn_size_bits, vdir->i_ino);\n\t\tgoto err_out;\n\t}\n\tia_start = ia_pos & ~(s64)(ndir->itype.index.block_size - 1);\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (unlikely(index_end > (u8*)ia + ndir->itype.index.block_size)) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of directory \"\n\t\t\t\t\"inode 0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)ia_pos >>\n\t\t\t\tndir->itype.index.vcn_size_bits, vdir->i_ino);\n\t\tgoto err_out;\n\t}\n\t/* The first index entry in this index buffer. */\n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry or until filldir tells us it has had enough\n\t * or signals an error (both covered by the rc test).\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\tntfs_debug(\"In index allocation, offset 0x%llx.\",\n\t\t\t\t(unsigned long long)ia_start +\n\t\t\t\t(unsigned long long)((u8*)ie - (u8*)ia));\n\t\t/* Bounds checks. */\n\t\tif (unlikely((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end))\n\t\t\tgoto err_out;\n\t\t/* The last entry cannot contain a name. */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/* Skip index block entry if continuing previous readdir. */\n\t\tif (ia_pos - ia_start > (u8*)ie - (u8*)ia)\n\t\t\tcontinue;\n\t\t/* Advance the position even if going to skip the entry. */\n\t\tactor->pos = (u8*)ie - (u8*)ia +\n\t\t\t\t(sle64_to_cpu(ia->index_block_vcn) <<\n\t\t\t\tndir->itype.index.vcn_size_bits) +\n\t\t\t\tvol->mft_record_size;\n\t\t/*\n\t\t * Submit the name to the @filldir callback.  Note,\n\t\t * ntfs_filldir() drops the lock on @ia_page but it retakes it\n\t\t * before returning, unless a non-zero value is returned in\n\t\t * which case the page is left unlocked.\n\t\t */\n\t\trc = ntfs_filldir(vol, ndir, ia_page, ie, name, actor);\n\t\tif (rc) {\n\t\t\t/* @ia_page is already unlocked in this case. */\n\t\t\tntfs_unmap_page(ia_page);\n\t\t\tntfs_unmap_page(bmp_page);\n\t\t\tiput(bmp_vi);\n\t\t\tgoto abort;\n\t\t}\n\t}\n\tgoto find_next_index_buffer;\nunm_EOD:\n\tif (ia_page) {\n\t\tunlock_page(ia_page);\n\t\tntfs_unmap_page(ia_page);\n\t}\n\tntfs_unmap_page(bmp_page);\n\tiput(bmp_vi);\nEOD:\n\t/* We are finished, set fpos to EOD. */\n\tactor->pos = i_size + vol->mft_record_size;\nabort:\n\tkfree(name);\n\treturn 0;\nerr_out:\n\tif (bmp_page) {\n\t\tntfs_unmap_page(bmp_page);\niput_err_out:\n\t\tiput(bmp_vi);\n\t}\n\tif (ia_page) {\n\t\tunlock_page(ia_page);\n\t\tntfs_unmap_page(ia_page);\n\t}\n\tkfree(ir);\n\tkfree(name);\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ndir);\n\tif (!err)\n\t\terr = -EIO;\n\tntfs_debug(\"Failed. Returning error code %i.\", -err);\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"mft.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include \"dir.h\"",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ntfschar I30[5] = { cpu_to_le16('$'), cpu_to_le16('I'),\n\t\tcpu_to_le16('3'),\tcpu_to_le16('0'), 0 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Failed. Returning error code %i.\"",
            "-err"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "ndir"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ir"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "ia_page"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "ia_page"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "bmp_vi"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_filldir",
          "args": [
            "vol",
            "ndir",
            "ia_page",
            "ie",
            "name",
            "actor"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_filldir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/dir.c",
          "lines": "1025-1077",
          "snippet": "static inline int ntfs_filldir(ntfs_volume *vol,\n\t\tntfs_inode *ndir, struct page *ia_page, INDEX_ENTRY *ie,\n\t\tu8 *name, struct dir_context *actor)\n{\n\tunsigned long mref;\n\tint name_len;\n\tunsigned dt_type;\n\tFILE_NAME_TYPE_FLAGS name_type;\n\n\tname_type = ie->key.file_name.file_name_type;\n\tif (name_type == FILE_NAME_DOS) {\n\t\tntfs_debug(\"Skipping DOS name space entry.\");\n\t\treturn 0;\n\t}\n\tif (MREF_LE(ie->data.dir.indexed_file) == FILE_root) {\n\t\tntfs_debug(\"Skipping root directory self reference entry.\");\n\t\treturn 0;\n\t}\n\tif (MREF_LE(ie->data.dir.indexed_file) < FILE_first_user &&\n\t\t\t!NVolShowSystemFiles(vol)) {\n\t\tntfs_debug(\"Skipping system file.\");\n\t\treturn 0;\n\t}\n\tname_len = ntfs_ucstonls(vol, (ntfschar*)&ie->key.file_name.file_name,\n\t\t\tie->key.file_name.file_name_length, &name,\n\t\t\tNTFS_MAX_NAME_LEN * NLS_MAX_CHARSET_SIZE + 1);\n\tif (name_len <= 0) {\n\t\tntfs_warning(vol->sb, \"Skipping unrepresentable inode 0x%llx.\",\n\t\t\t\t(long long)MREF_LE(ie->data.dir.indexed_file));\n\t\treturn 0;\n\t}\n\tif (ie->key.file_name.file_attributes &\n\t\t\tFILE_ATTR_DUP_FILE_NAME_INDEX_PRESENT)\n\t\tdt_type = DT_DIR;\n\telse\n\t\tdt_type = DT_REG;\n\tmref = MREF_LE(ie->data.dir.indexed_file);\n\t/*\n\t * Drop the page lock otherwise we deadlock with NFS when it calls\n\t * ->lookup since ntfs_lookup() will lock the same page.\n\t */\n\tif (ia_page)\n\t\tunlock_page(ia_page);\n\tntfs_debug(\"Calling filldir for %s with len %i, fpos 0x%llx, inode \"\n\t\t\t\"0x%lx, DT_%s.\", name, name_len, actor->pos, mref,\n\t\t\tdt_type == DT_DIR ? \"DIR\" : \"REG\");\n\tif (!dir_emit(actor, name, name_len, mref, dt_type))\n\t\treturn 1;\n\t/* Relock the page but not if we are aborting ->readdir. */\n\tif (ia_page)\n\t\tlock_page(ia_page);\n\treturn 0;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include \"dir.h\"",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include \"dir.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic inline int ntfs_filldir(ntfs_volume *vol,\n\t\tntfs_inode *ndir, struct page *ia_page, INDEX_ENTRY *ie,\n\t\tu8 *name, struct dir_context *actor)\n{\n\tunsigned long mref;\n\tint name_len;\n\tunsigned dt_type;\n\tFILE_NAME_TYPE_FLAGS name_type;\n\n\tname_type = ie->key.file_name.file_name_type;\n\tif (name_type == FILE_NAME_DOS) {\n\t\tntfs_debug(\"Skipping DOS name space entry.\");\n\t\treturn 0;\n\t}\n\tif (MREF_LE(ie->data.dir.indexed_file) == FILE_root) {\n\t\tntfs_debug(\"Skipping root directory self reference entry.\");\n\t\treturn 0;\n\t}\n\tif (MREF_LE(ie->data.dir.indexed_file) < FILE_first_user &&\n\t\t\t!NVolShowSystemFiles(vol)) {\n\t\tntfs_debug(\"Skipping system file.\");\n\t\treturn 0;\n\t}\n\tname_len = ntfs_ucstonls(vol, (ntfschar*)&ie->key.file_name.file_name,\n\t\t\tie->key.file_name.file_name_length, &name,\n\t\t\tNTFS_MAX_NAME_LEN * NLS_MAX_CHARSET_SIZE + 1);\n\tif (name_len <= 0) {\n\t\tntfs_warning(vol->sb, \"Skipping unrepresentable inode 0x%llx.\",\n\t\t\t\t(long long)MREF_LE(ie->data.dir.indexed_file));\n\t\treturn 0;\n\t}\n\tif (ie->key.file_name.file_attributes &\n\t\t\tFILE_ATTR_DUP_FILE_NAME_INDEX_PRESENT)\n\t\tdt_type = DT_DIR;\n\telse\n\t\tdt_type = DT_REG;\n\tmref = MREF_LE(ie->data.dir.indexed_file);\n\t/*\n\t * Drop the page lock otherwise we deadlock with NFS when it calls\n\t * ->lookup since ntfs_lookup() will lock the same page.\n\t */\n\tif (ia_page)\n\t\tunlock_page(ia_page);\n\tntfs_debug(\"Calling filldir for %s with len %i, fpos 0x%llx, inode \"\n\t\t\t\"0x%lx, DT_%s.\", name, name_len, actor->pos, mref,\n\t\t\tdt_type == DT_DIR ? \"DIR\" : \"REG\");\n\tif (!dir_emit(actor, name, name_len, mref, dt_type))\n\t\treturn 1;\n\t/* Relock the page but not if we are aborting ->readdir. */\n\tif (ia_page)\n\t\tlock_page(ia_page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sle64_to_cpu",
          "args": [
            "ia->index_block_vcn"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ie->key_length"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"In index allocation, offset 0x%llx.\"",
            "(unsigned long long)ia_start +\n\t\t\t\t(unsigned long long)((u8*)ie - (u8*)ia)"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ia->index.entries_offset"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Size of index buffer (VCN 0x%llx) of directory \"\n\t\t\t\t\"inode 0x%lx exceeds maximum size.\"",
            "(unsigned long long)ia_pos >>\n\t\t\t\tndir->itype.index.vcn_size_bits",
            "vdir->i_ino"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index_end > (u8*)ia + ndir->itype.index.block_size"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "ndir->itype.index.block_size - 1"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index_end > kaddr + PAGE_CACHE_SIZE"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tndir->itype.index.block_size"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sle64_to_cpu(ia->index_block_vcn) != (ia_pos &\n\t\t\t~(s64)(ndir->itype.index.block_size - 1)) >>\n\t\t\tndir->itype.index.vcn_size_bits"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "ndir->itype.index.block_size - 1"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ntfs_is_indx_record(ia->magic)"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_is_indx_record",
          "args": [
            "ia->magic"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "ndir->itype.index.block_size - 1"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "ia_page"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ia_page"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Reading index allocation data failed.\""
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ia_page"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_page",
          "args": [
            "ia_mapping",
            "ia_pos >> PAGE_CACHE_SHIFT"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "86-99",
          "snippet": "static inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ia_page != NULL"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Handling index buffer 0x%llx.\"",
            "(unsigned long long)bmp_pos + cur_bmp_pos"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "((bmp_pos + cur_bmp_pos) >> 3) >= i_size"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(cur_bmp_pos >> 3) >= PAGE_CACHE_SIZE"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "bmp_page"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bmp_page"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Reading index bitmap failed.\""
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bmp_page"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Reading bitmap with page index 0x%llx, bit ofs 0x%llx\"",
            "(unsigned long long)bmp_pos >> (3 + PAGE_CACHE_SHIFT)",
            "(unsigned long long)bmp_pos &\n\t\t\t(unsigned long long)((PAGE_CACHE_SIZE * 8) - 1)"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(PAGE_CACHE_SIZE * 8) - 1"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Current index allocation position exceeds \"\n\t\t\t\t\"index bitmap size.\""
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bmp_pos >> 3 >= i_size_read(bmp_vi)"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "bmp_vi"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bmp_vi"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Failed to get bitmap attribute.\""
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bmp_vi"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_iget",
          "args": [
            "vdir",
            "AT_BITMAP",
            "I30",
            "4"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "228-265",
          "snippet": "struct inode *ntfs_attr_iget(struct inode *base_vi, ATTR_TYPE type,\n\t\tntfschar *name, u32 name_len)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\t/* Make sure no one calls ntfs_attr_iget() for indices. */\n\tBUG_ON(type == AT_INDEX_ALLOCATION);\n\n\tna.mft_no = base_vi->i_ino;\n\tna.type = type;\n\tna.name = name;\n\tna.name_len = name_len;\n\n\tvi = iget5_locked(base_vi->i_sb, na.mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_attr_inode(base_vi, vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad attribute inodes around. This also\n\t * simplifies things in that we never need to check for bad attribute\n\t * inodes elsewhere.\n\t */\n\tif (unlikely(err)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstruct inode *ntfs_attr_iget(struct inode *base_vi, ATTR_TYPE type,\n\t\tntfschar *name, u32 name_len)\n{\n\tstruct inode *vi;\n\tint err;\n\tntfs_attr na;\n\n\t/* Make sure no one calls ntfs_attr_iget() for indices. */\n\tBUG_ON(type == AT_INDEX_ALLOCATION);\n\n\tna.mft_no = base_vi->i_ino;\n\tna.type = type;\n\tna.name = name;\n\tna.name_len = name_len;\n\n\tvi = iget5_locked(base_vi->i_sb, na.mft_no, (test_t)ntfs_test_inode,\n\t\t\t(set_t)ntfs_init_locked_inode, &na);\n\tif (unlikely(!vi))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = 0;\n\n\t/* If this is a freshly allocated inode, need to read it now. */\n\tif (vi->i_state & I_NEW) {\n\t\terr = ntfs_read_locked_attr_inode(base_vi, vi);\n\t\tunlock_new_inode(vi);\n\t}\n\t/*\n\t * There is no point in keeping bad attribute inodes around. This also\n\t * simplifies things in that we never need to check for bad attribute\n\t * inodes elsewhere.\n\t */\n\tif (unlikely(err)) {\n\t\tiput(vi);\n\t\tvi = ERR_PTR(err);\n\t}\n\treturn vi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Inode 0x%lx, getting index bitmap.\"",
            "vdir->i_ino"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoIndexAllocPresent",
          "args": [
            "ndir"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ir"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ir"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(u8*)ie < (u8*)ir || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"In index root, offset 0x%zx.\"",
            "(u8*)ie - (u8*)ir"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ir",
            "(u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset)",
            "rc"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ir"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "rc",
            "GFP_NOFS"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "AT_INDEX_ROOT",
            "I30",
            "4",
            "CASE_SENSITIVE",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "ndir",
            "m"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!name"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit_dots",
          "args": [
            "file",
            "actor"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vdir"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for inode 0x%lx, fpos 0x%llx.\"",
            "vdir->i_ino",
            "actor->pos"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_SB",
          "args": [
            "sb"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/ntfs.h",
          "lines": "80-83",
          "snippet": "static inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"layout.h\"",
            "#include \"volume.h\"",
            "#include \"types.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/smp.h>",
            "#include <linux/nls.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n#include \"volume.h\"\n#include \"types.h\"\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/nls.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vdir"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include \"dir.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nntfschar I30[5] = { cpu_to_le16('$'), cpu_to_le16('I'),\n\t\tcpu_to_le16('3'),\tcpu_to_le16('0'), 0 };\n\nstatic int ntfs_readdir(struct file *file, struct dir_context *actor)\n{\n\ts64 ia_pos, ia_start, prev_ia_pos, bmp_pos;\n\tloff_t i_size;\n\tstruct inode *bmp_vi, *vdir = file_inode(file);\n\tstruct super_block *sb = vdir->i_sb;\n\tntfs_inode *ndir = NTFS_I(vdir);\n\tntfs_volume *vol = NTFS_SB(sb);\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir = NULL;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *name = NULL;\n\tint rc, err, ir_pos, cur_bmp_pos;\n\tstruct address_space *ia_mapping, *bmp_mapping;\n\tstruct page *bmp_page = NULL, *ia_page = NULL;\n\tu8 *kaddr, *bmp, *index_end;\n\tntfs_attr_search_ctx *ctx;\n\n\tntfs_debug(\"Entering for inode 0x%lx, fpos 0x%llx.\",\n\t\t\tvdir->i_ino, actor->pos);\n\trc = err = 0;\n\t/* Are we at end of dir yet? */\n\ti_size = i_size_read(vdir);\n\tif (actor->pos >= i_size + vol->mft_record_size)\n\t\treturn 0;\n\t/* Emulate . and .. for all directories. */\n\tif (!dir_emit_dots(file, actor))\n\t\treturn 0;\n\tm = NULL;\n\tctx = NULL;\n\t/*\n\t * Allocate a buffer to store the current name being processed\n\t * converted to format determined by current NLS.\n\t */\n\tname = kmalloc(NTFS_MAX_NAME_LEN * NLS_MAX_CHARSET_SIZE + 1, GFP_NOFS);\n\tif (unlikely(!name)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Are we jumping straight into the index allocation attribute? */\n\tif (actor->pos >= vol->mft_record_size)\n\t\tgoto skip_index_root;\n\t/* Get hold of the mft record for the directory. */\n\tm = map_mft_record(ndir);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ndir, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Get the offset into the index root attribute. */\n\tir_pos = (s64)actor->pos;\n\t/* Find the index root attribute in the mft record. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_error(sb, \"Index root attribute missing in directory \"\n\t\t\t\t\"inode 0x%lx.\", vdir->i_ino);\n\t\tgoto err_out;\n\t}\n\t/*\n\t * Copy the index root attribute value to a buffer so that we can put\n\t * the search context and unmap the mft record before calling the\n\t * filldir() callback.  We need to do this because of NFSd which calls\n\t * ->lookup() from its filldir callback() and this causes NTFS to\n\t * deadlock as ntfs_lookup() maps the mft record of the directory and\n\t * we have got it mapped here already.  The only solution is for us to\n\t * unmap the mft record here so that a call to ntfs_lookup() is able to\n\t * map the mft record without deadlocking.\n\t */\n\trc = le32_to_cpu(ctx->attr->data.resident.value_length);\n\tir = kmalloc(rc, GFP_NOFS);\n\tif (unlikely(!ir)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Copy the index root value (it has been verified in read_inode). */\n\tmemcpy(ir, (u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset), rc);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(ndir);\n\tctx = NULL;\n\tm = NULL;\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry or until filldir tells us it has had enough\n\t * or signals an error (both covered by the rc test).\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\tntfs_debug(\"In index root, offset 0x%zx.\", (u8*)ie - (u8*)ir);\n\t\t/* Bounds checks. */\n\t\tif (unlikely((u8*)ie < (u8*)ir || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end))\n\t\t\tgoto err_out;\n\t\t/* The last entry cannot contain a name. */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/* Skip index root entry if continuing previous readdir. */\n\t\tif (ir_pos > (u8*)ie - (u8*)ir)\n\t\t\tcontinue;\n\t\t/* Advance the position even if going to skip the entry. */\n\t\tactor->pos = (u8*)ie - (u8*)ir;\n\t\t/* Submit the name to the filldir callback. */\n\t\trc = ntfs_filldir(vol, ndir, NULL, ie, name, actor);\n\t\tif (rc) {\n\t\t\tkfree(ir);\n\t\t\tgoto abort;\n\t\t}\n\t}\n\t/* We are done with the index root and can free the buffer. */\n\tkfree(ir);\n\tir = NULL;\n\t/* If there is no index allocation attribute we are finished. */\n\tif (!NInoIndexAllocPresent(ndir))\n\t\tgoto EOD;\n\t/* Advance fpos to the beginning of the index allocation. */\n\tactor->pos = vol->mft_record_size;\nskip_index_root:\n\tkaddr = NULL;\n\tprev_ia_pos = -1LL;\n\t/* Get the offset into the index allocation attribute. */\n\tia_pos = (s64)actor->pos - vol->mft_record_size;\n\tia_mapping = vdir->i_mapping;\n\tntfs_debug(\"Inode 0x%lx, getting index bitmap.\", vdir->i_ino);\n\tbmp_vi = ntfs_attr_iget(vdir, AT_BITMAP, I30, 4);\n\tif (IS_ERR(bmp_vi)) {\n\t\tntfs_error(sb, \"Failed to get bitmap attribute.\");\n\t\terr = PTR_ERR(bmp_vi);\n\t\tgoto err_out;\n\t}\n\tbmp_mapping = bmp_vi->i_mapping;\n\t/* Get the starting bitmap bit position and sanity check it. */\n\tbmp_pos = ia_pos >> ndir->itype.index.block_size_bits;\n\tif (unlikely(bmp_pos >> 3 >= i_size_read(bmp_vi))) {\n\t\tntfs_error(sb, \"Current index allocation position exceeds \"\n\t\t\t\t\"index bitmap size.\");\n\t\tgoto iput_err_out;\n\t}\n\t/* Get the starting bit position in the current bitmap page. */\n\tcur_bmp_pos = bmp_pos & ((PAGE_CACHE_SIZE * 8) - 1);\n\tbmp_pos &= ~(u64)((PAGE_CACHE_SIZE * 8) - 1);\nget_next_bmp_page:\n\tntfs_debug(\"Reading bitmap with page index 0x%llx, bit ofs 0x%llx\",\n\t\t\t(unsigned long long)bmp_pos >> (3 + PAGE_CACHE_SHIFT),\n\t\t\t(unsigned long long)bmp_pos &\n\t\t\t(unsigned long long)((PAGE_CACHE_SIZE * 8) - 1));\n\tbmp_page = ntfs_map_page(bmp_mapping,\n\t\t\tbmp_pos >> (3 + PAGE_CACHE_SHIFT));\n\tif (IS_ERR(bmp_page)) {\n\t\tntfs_error(sb, \"Reading index bitmap failed.\");\n\t\terr = PTR_ERR(bmp_page);\n\t\tbmp_page = NULL;\n\t\tgoto iput_err_out;\n\t}\n\tbmp = (u8*)page_address(bmp_page);\n\t/* Find next index block in use. */\n\twhile (!(bmp[cur_bmp_pos >> 3] & (1 << (cur_bmp_pos & 7)))) {\nfind_next_index_buffer:\n\t\tcur_bmp_pos++;\n\t\t/*\n\t\t * If we have reached the end of the bitmap page, get the next\n\t\t * page, and put away the old one.\n\t\t */\n\t\tif (unlikely((cur_bmp_pos >> 3) >= PAGE_CACHE_SIZE)) {\n\t\t\tntfs_unmap_page(bmp_page);\n\t\t\tbmp_pos += PAGE_CACHE_SIZE * 8;\n\t\t\tcur_bmp_pos = 0;\n\t\t\tgoto get_next_bmp_page;\n\t\t}\n\t\t/* If we have reached the end of the bitmap, we are done. */\n\t\tif (unlikely(((bmp_pos + cur_bmp_pos) >> 3) >= i_size))\n\t\t\tgoto unm_EOD;\n\t\tia_pos = (bmp_pos + cur_bmp_pos) <<\n\t\t\t\tndir->itype.index.block_size_bits;\n\t}\n\tntfs_debug(\"Handling index buffer 0x%llx.\",\n\t\t\t(unsigned long long)bmp_pos + cur_bmp_pos);\n\t/* If the current index buffer is in the same page we reuse the page. */\n\tif ((prev_ia_pos & (s64)PAGE_CACHE_MASK) !=\n\t\t\t(ia_pos & (s64)PAGE_CACHE_MASK)) {\n\t\tprev_ia_pos = ia_pos;\n\t\tif (likely(ia_page != NULL)) {\n\t\t\tunlock_page(ia_page);\n\t\t\tntfs_unmap_page(ia_page);\n\t\t}\n\t\t/*\n\t\t * Map the page cache page containing the current ia_pos,\n\t\t * reading it from disk if necessary.\n\t\t */\n\t\tia_page = ntfs_map_page(ia_mapping, ia_pos >> PAGE_CACHE_SHIFT);\n\t\tif (IS_ERR(ia_page)) {\n\t\t\tntfs_error(sb, \"Reading index allocation data failed.\");\n\t\t\terr = PTR_ERR(ia_page);\n\t\t\tia_page = NULL;\n\t\t\tgoto err_out;\n\t\t}\n\t\tlock_page(ia_page);\n\t\tkaddr = (u8*)page_address(ia_page);\n\t}\n\t/* Get the current index buffer. */\n\tia = (INDEX_ALLOCATION*)(kaddr + (ia_pos & ~PAGE_CACHE_MASK &\n\t\t\t~(s64)(ndir->itype.index.block_size - 1)));\n\t/* Bounds checks. */\n\tif (unlikely((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE)) {\n\t\tntfs_error(sb, \"Out of bounds check failed. Corrupt directory \"\n\t\t\t\t\"inode 0x%lx or driver bug.\", vdir->i_ino);\n\t\tgoto err_out;\n\t}\n\t/* Catch multi sector transfer fixup errors. */\n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Directory index record with vcn 0x%llx is \"\n\t\t\t\t\"corrupt.  Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(unsigned long long)ia_pos >>\n\t\t\t\tndir->itype.index.vcn_size_bits, vdir->i_ino);\n\t\tgoto err_out;\n\t}\n\tif (unlikely(sle64_to_cpu(ia->index_block_vcn) != (ia_pos &\n\t\t\t~(s64)(ndir->itype.index.block_size - 1)) >>\n\t\t\tndir->itype.index.vcn_size_bits)) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx). \"\n\t\t\t\t\"Directory inode 0x%lx is corrupt or driver \"\n\t\t\t\t\"bug. \", (unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)ia_pos >>\n\t\t\t\tndir->itype.index.vcn_size_bits, vdir->i_ino);\n\t\tgoto err_out;\n\t}\n\tif (unlikely(le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tndir->itype.index.block_size)) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx has a size (%u) differing from the \"\n\t\t\t\t\"directory specified size (%u). Directory \"\n\t\t\t\t\"inode is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)ia_pos >>\n\t\t\t\tndir->itype.index.vcn_size_bits, vdir->i_ino,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tndir->itype.index.block_size);\n\t\tgoto err_out;\n\t}\n\tindex_end = (u8*)ia + ndir->itype.index.block_size;\n\tif (unlikely(index_end > kaddr + PAGE_CACHE_SIZE)) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx crosses page boundary. Impossible! \"\n\t\t\t\t\"Cannot access! This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)ia_pos >>\n\t\t\t\tndir->itype.index.vcn_size_bits, vdir->i_ino);\n\t\tgoto err_out;\n\t}\n\tia_start = ia_pos & ~(s64)(ndir->itype.index.block_size - 1);\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (unlikely(index_end > (u8*)ia + ndir->itype.index.block_size)) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of directory \"\n\t\t\t\t\"inode 0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)ia_pos >>\n\t\t\t\tndir->itype.index.vcn_size_bits, vdir->i_ino);\n\t\tgoto err_out;\n\t}\n\t/* The first index entry in this index buffer. */\n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry or until filldir tells us it has had enough\n\t * or signals an error (both covered by the rc test).\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\tntfs_debug(\"In index allocation, offset 0x%llx.\",\n\t\t\t\t(unsigned long long)ia_start +\n\t\t\t\t(unsigned long long)((u8*)ie - (u8*)ia));\n\t\t/* Bounds checks. */\n\t\tif (unlikely((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end))\n\t\t\tgoto err_out;\n\t\t/* The last entry cannot contain a name. */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/* Skip index block entry if continuing previous readdir. */\n\t\tif (ia_pos - ia_start > (u8*)ie - (u8*)ia)\n\t\t\tcontinue;\n\t\t/* Advance the position even if going to skip the entry. */\n\t\tactor->pos = (u8*)ie - (u8*)ia +\n\t\t\t\t(sle64_to_cpu(ia->index_block_vcn) <<\n\t\t\t\tndir->itype.index.vcn_size_bits) +\n\t\t\t\tvol->mft_record_size;\n\t\t/*\n\t\t * Submit the name to the @filldir callback.  Note,\n\t\t * ntfs_filldir() drops the lock on @ia_page but it retakes it\n\t\t * before returning, unless a non-zero value is returned in\n\t\t * which case the page is left unlocked.\n\t\t */\n\t\trc = ntfs_filldir(vol, ndir, ia_page, ie, name, actor);\n\t\tif (rc) {\n\t\t\t/* @ia_page is already unlocked in this case. */\n\t\t\tntfs_unmap_page(ia_page);\n\t\t\tntfs_unmap_page(bmp_page);\n\t\t\tiput(bmp_vi);\n\t\t\tgoto abort;\n\t\t}\n\t}\n\tgoto find_next_index_buffer;\nunm_EOD:\n\tif (ia_page) {\n\t\tunlock_page(ia_page);\n\t\tntfs_unmap_page(ia_page);\n\t}\n\tntfs_unmap_page(bmp_page);\n\tiput(bmp_vi);\nEOD:\n\t/* We are finished, set fpos to EOD. */\n\tactor->pos = i_size + vol->mft_record_size;\nabort:\n\tkfree(name);\n\treturn 0;\nerr_out:\n\tif (bmp_page) {\n\t\tntfs_unmap_page(bmp_page);\niput_err_out:\n\t\tiput(bmp_vi);\n\t}\n\tif (ia_page) {\n\t\tunlock_page(ia_page);\n\t\tntfs_unmap_page(ia_page);\n\t}\n\tkfree(ir);\n\tkfree(name);\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ndir);\n\tif (!err)\n\t\terr = -EIO;\n\tntfs_debug(\"Failed. Returning error code %i.\", -err);\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_filldir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/dir.c",
    "lines": "1025-1077",
    "snippet": "static inline int ntfs_filldir(ntfs_volume *vol,\n\t\tntfs_inode *ndir, struct page *ia_page, INDEX_ENTRY *ie,\n\t\tu8 *name, struct dir_context *actor)\n{\n\tunsigned long mref;\n\tint name_len;\n\tunsigned dt_type;\n\tFILE_NAME_TYPE_FLAGS name_type;\n\n\tname_type = ie->key.file_name.file_name_type;\n\tif (name_type == FILE_NAME_DOS) {\n\t\tntfs_debug(\"Skipping DOS name space entry.\");\n\t\treturn 0;\n\t}\n\tif (MREF_LE(ie->data.dir.indexed_file) == FILE_root) {\n\t\tntfs_debug(\"Skipping root directory self reference entry.\");\n\t\treturn 0;\n\t}\n\tif (MREF_LE(ie->data.dir.indexed_file) < FILE_first_user &&\n\t\t\t!NVolShowSystemFiles(vol)) {\n\t\tntfs_debug(\"Skipping system file.\");\n\t\treturn 0;\n\t}\n\tname_len = ntfs_ucstonls(vol, (ntfschar*)&ie->key.file_name.file_name,\n\t\t\tie->key.file_name.file_name_length, &name,\n\t\t\tNTFS_MAX_NAME_LEN * NLS_MAX_CHARSET_SIZE + 1);\n\tif (name_len <= 0) {\n\t\tntfs_warning(vol->sb, \"Skipping unrepresentable inode 0x%llx.\",\n\t\t\t\t(long long)MREF_LE(ie->data.dir.indexed_file));\n\t\treturn 0;\n\t}\n\tif (ie->key.file_name.file_attributes &\n\t\t\tFILE_ATTR_DUP_FILE_NAME_INDEX_PRESENT)\n\t\tdt_type = DT_DIR;\n\telse\n\t\tdt_type = DT_REG;\n\tmref = MREF_LE(ie->data.dir.indexed_file);\n\t/*\n\t * Drop the page lock otherwise we deadlock with NFS when it calls\n\t * ->lookup since ntfs_lookup() will lock the same page.\n\t */\n\tif (ia_page)\n\t\tunlock_page(ia_page);\n\tntfs_debug(\"Calling filldir for %s with len %i, fpos 0x%llx, inode \"\n\t\t\t\"0x%lx, DT_%s.\", name, name_len, actor->pos, mref,\n\t\t\tdt_type == DT_DIR ? \"DIR\" : \"REG\");\n\tif (!dir_emit(actor, name, name_len, mref, dt_type))\n\t\treturn 1;\n\t/* Relock the page but not if we are aborting ->readdir. */\n\tif (ia_page)\n\t\tlock_page(ia_page);\n\treturn 0;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"mft.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include \"dir.h\"",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "ia_page"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "actor",
            "name",
            "name_len",
            "mref",
            "dt_type"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Calling filldir for %s with len %i, fpos 0x%llx, inode \"\n\t\t\t\"0x%lx, DT_%s.\"",
            "name",
            "name_len",
            "actor->pos",
            "mref",
            "dt_type == DT_DIR ? \"DIR\" : \"REG\""
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MREF_LE",
          "args": [
            "ie->data.dir.indexed_file"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vol->sb",
            "\"Skipping unrepresentable inode 0x%llx.\"",
            "(long long)MREF_LE(ie->data.dir.indexed_file)"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "43-65",
          "snippet": "void __ntfs_warning(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_warn(\"(device %s): %s(): %pV\\n\",\n\t\t\tsb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_warn(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_warning(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_warn(\"(device %s): %s(): %pV\\n\",\n\t\t\tsb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_warn(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MREF_LE",
          "args": [
            "ie->data.dir.indexed_file"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_ucstonls",
          "args": [
            "vol",
            "(ntfschar*)&ie->key.file_name.file_name",
            "ie->key.file_name.file_name_length",
            "&name",
            "NTFS_MAX_NAME_LEN * NLS_MAX_CHARSET_SIZE + 1"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_ucstonls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
          "lines": "336-398",
          "snippet": "int ntfs_ucstonls(const ntfs_volume *vol, const ntfschar *ins,\n\t\tconst int ins_len, unsigned char **outs, int outs_len)\n{\n\tstruct nls_table *nls = vol->nls_map;\n\tunsigned char *ns;\n\tint i, o, ns_len, wc;\n\n\t/* We don't trust outside sources. */\n\tif (ins) {\n\t\tns = *outs;\n\t\tns_len = outs_len;\n\t\tif (ns && !ns_len) {\n\t\t\twc = -ENAMETOOLONG;\n\t\t\tgoto conversion_err;\n\t\t}\n\t\tif (!ns) {\n\t\t\tns_len = ins_len * NLS_MAX_CHARSET_SIZE;\n\t\t\tns = kmalloc(ns_len + 1, GFP_NOFS);\n\t\t\tif (!ns)\n\t\t\t\tgoto mem_err_out;\n\t\t}\n\t\tfor (i = o = 0; i < ins_len; i++) {\nretry:\t\t\twc = nls->uni2char(le16_to_cpu(ins[i]), ns + o,\n\t\t\t\t\tns_len - o);\n\t\t\tif (wc > 0) {\n\t\t\t\to += wc;\n\t\t\t\tcontinue;\n\t\t\t} else if (!wc)\n\t\t\t\tbreak;\n\t\t\telse if (wc == -ENAMETOOLONG && ns != *outs) {\n\t\t\t\tunsigned char *tc;\n\t\t\t\t/* Grow in multiples of 64 bytes. */\n\t\t\t\ttc = kmalloc((ns_len + 64) &\n\t\t\t\t\t\t~63, GFP_NOFS);\n\t\t\t\tif (tc) {\n\t\t\t\t\tmemcpy(tc, ns, ns_len);\n\t\t\t\t\tns_len = ((ns_len + 64) & ~63) - 1;\n\t\t\t\t\tkfree(ns);\n\t\t\t\t\tns = tc;\n\t\t\t\t\tgoto retry;\n\t\t\t\t} /* No memory so goto conversion_error; */\n\t\t\t} /* wc < 0, real error. */\n\t\t\tgoto conversion_err;\n\t\t}\n\t\tns[o] = 0;\n\t\t*outs = ns;\n\t\treturn o;\n\t} /* else (!ins) */\n\tntfs_error(vol->sb, \"Received NULL pointer.\");\n\treturn -EINVAL;\nconversion_err:\n\tntfs_error(vol->sb, \"Unicode name contains characters that cannot be \"\n\t\t\t\"converted to character set %s.  You might want to \"\n\t\t\t\"try to use the mount option nls=utf8.\", nls->charset);\n\tif (ns != *outs)\n\t\tkfree(ns);\n\tif (wc != -ENAMETOOLONG)\n\t\twc = -EILSEQ;\n\treturn wc;\nmem_err_out:\n\tntfs_error(vol->sb, \"Failed to allocate name!\");\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"types.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nint ntfs_ucstonls(const ntfs_volume *vol, const ntfschar *ins,\n\t\tconst int ins_len, unsigned char **outs, int outs_len)\n{\n\tstruct nls_table *nls = vol->nls_map;\n\tunsigned char *ns;\n\tint i, o, ns_len, wc;\n\n\t/* We don't trust outside sources. */\n\tif (ins) {\n\t\tns = *outs;\n\t\tns_len = outs_len;\n\t\tif (ns && !ns_len) {\n\t\t\twc = -ENAMETOOLONG;\n\t\t\tgoto conversion_err;\n\t\t}\n\t\tif (!ns) {\n\t\t\tns_len = ins_len * NLS_MAX_CHARSET_SIZE;\n\t\t\tns = kmalloc(ns_len + 1, GFP_NOFS);\n\t\t\tif (!ns)\n\t\t\t\tgoto mem_err_out;\n\t\t}\n\t\tfor (i = o = 0; i < ins_len; i++) {\nretry:\t\t\twc = nls->uni2char(le16_to_cpu(ins[i]), ns + o,\n\t\t\t\t\tns_len - o);\n\t\t\tif (wc > 0) {\n\t\t\t\to += wc;\n\t\t\t\tcontinue;\n\t\t\t} else if (!wc)\n\t\t\t\tbreak;\n\t\t\telse if (wc == -ENAMETOOLONG && ns != *outs) {\n\t\t\t\tunsigned char *tc;\n\t\t\t\t/* Grow in multiples of 64 bytes. */\n\t\t\t\ttc = kmalloc((ns_len + 64) &\n\t\t\t\t\t\t~63, GFP_NOFS);\n\t\t\t\tif (tc) {\n\t\t\t\t\tmemcpy(tc, ns, ns_len);\n\t\t\t\t\tns_len = ((ns_len + 64) & ~63) - 1;\n\t\t\t\t\tkfree(ns);\n\t\t\t\t\tns = tc;\n\t\t\t\t\tgoto retry;\n\t\t\t\t} /* No memory so goto conversion_error; */\n\t\t\t} /* wc < 0, real error. */\n\t\t\tgoto conversion_err;\n\t\t}\n\t\tns[o] = 0;\n\t\t*outs = ns;\n\t\treturn o;\n\t} /* else (!ins) */\n\tntfs_error(vol->sb, \"Received NULL pointer.\");\n\treturn -EINVAL;\nconversion_err:\n\tntfs_error(vol->sb, \"Unicode name contains characters that cannot be \"\n\t\t\t\"converted to character set %s.  You might want to \"\n\t\t\t\"try to use the mount option nls=utf8.\", nls->charset);\n\tif (ns != *outs)\n\t\tkfree(ns);\n\tif (wc != -ENAMETOOLONG)\n\t\twc = -EILSEQ;\n\treturn wc;\nmem_err_out:\n\tntfs_error(vol->sb, \"Failed to allocate name!\");\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Skipping system file.\""
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolShowSystemFiles",
          "args": [
            "vol"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MREF_LE",
          "args": [
            "ie->data.dir.indexed_file"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MREF_LE",
          "args": [
            "ie->data.dir.indexed_file"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include \"dir.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nstatic inline int ntfs_filldir(ntfs_volume *vol,\n\t\tntfs_inode *ndir, struct page *ia_page, INDEX_ENTRY *ie,\n\t\tu8 *name, struct dir_context *actor)\n{\n\tunsigned long mref;\n\tint name_len;\n\tunsigned dt_type;\n\tFILE_NAME_TYPE_FLAGS name_type;\n\n\tname_type = ie->key.file_name.file_name_type;\n\tif (name_type == FILE_NAME_DOS) {\n\t\tntfs_debug(\"Skipping DOS name space entry.\");\n\t\treturn 0;\n\t}\n\tif (MREF_LE(ie->data.dir.indexed_file) == FILE_root) {\n\t\tntfs_debug(\"Skipping root directory self reference entry.\");\n\t\treturn 0;\n\t}\n\tif (MREF_LE(ie->data.dir.indexed_file) < FILE_first_user &&\n\t\t\t!NVolShowSystemFiles(vol)) {\n\t\tntfs_debug(\"Skipping system file.\");\n\t\treturn 0;\n\t}\n\tname_len = ntfs_ucstonls(vol, (ntfschar*)&ie->key.file_name.file_name,\n\t\t\tie->key.file_name.file_name_length, &name,\n\t\t\tNTFS_MAX_NAME_LEN * NLS_MAX_CHARSET_SIZE + 1);\n\tif (name_len <= 0) {\n\t\tntfs_warning(vol->sb, \"Skipping unrepresentable inode 0x%llx.\",\n\t\t\t\t(long long)MREF_LE(ie->data.dir.indexed_file));\n\t\treturn 0;\n\t}\n\tif (ie->key.file_name.file_attributes &\n\t\t\tFILE_ATTR_DUP_FILE_NAME_INDEX_PRESENT)\n\t\tdt_type = DT_DIR;\n\telse\n\t\tdt_type = DT_REG;\n\tmref = MREF_LE(ie->data.dir.indexed_file);\n\t/*\n\t * Drop the page lock otherwise we deadlock with NFS when it calls\n\t * ->lookup since ntfs_lookup() will lock the same page.\n\t */\n\tif (ia_page)\n\t\tunlock_page(ia_page);\n\tntfs_debug(\"Calling filldir for %s with len %i, fpos 0x%llx, inode \"\n\t\t\t\"0x%lx, DT_%s.\", name, name_len, actor->pos, mref,\n\t\t\tdt_type == DT_DIR ? \"DIR\" : \"REG\");\n\tif (!dir_emit(actor, name, name_len, mref, dt_type))\n\t\treturn 1;\n\t/* Relock the page but not if we are aborting ->readdir. */\n\tif (ia_page)\n\t\tlock_page(ia_page);\n\treturn 0;\n}"
  },
  {
    "function_name": "ntfs_lookup_inode_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/dir.c",
    "lines": "633-1000",
    "snippet": "u64 ntfs_lookup_inode_by_name(ntfs_inode *dir_ni, const ntfschar *uname,\n\t\tconst int uname_len)\n{\n\tntfs_volume *vol = dir_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *index_end;\n\tu64 mref;\n\tntfs_attr_search_ctx *ctx;\n\tint err, rc;\n\tIGNORE_CASE_BOOL ic;\n\tVCN vcn, old_vcn;\n\tstruct address_space *ia_mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\n\t/* Get hold of the mft record for the directory. */\n\tm = map_mft_record(dir_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(sb, \"map_mft_record() failed with error code %ld.\",\n\t\t\t\t-PTR_ERR(m));\n\t\treturn ERR_MREF(PTR_ERR(m));\n\t}\n\tctx = ntfs_attr_get_search_ctx(dir_ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Find the index root attribute in the mft record. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(sb, \"Index root attribute missing in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_out;\n\t}\n\t/* Get to the index root value (it's been verified in read_inode). */\n\tir = (INDEX_ROOT*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)ctx->mrec || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end)\n\t\t\tgoto dir_err_out;\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * If the current entry has a name type of POSIX, the name is\n\t\t * case sensitive and not otherwise. This has the effect of us\n\t\t * not being able to access any POSIX file names which collate\n\t\t * after the non-POSIX one when they only differ in case, but\n\t\t * anyone doing screwy stuff like that deserves to burn in\n\t\t * hell... Doing that kind of stuff on NT4 actually causes\n\t\t * corruption on the partition even when using SP6a and Linux\n\t\t * is not involved at all.\n\t\t */\n\t\tic = ie->key.file_name.file_name_type ? IGNORE_CASE :\n\t\t\t\tCASE_SENSITIVE;\n\t\t/*\n\t\t * If the names match perfectly, we are done and return the\n\t\t * mft reference of the inode (i.e. the inode number together\n\t\t * with the sequence number for consistency checking. We\n\t\t * convert it to cpu format before returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, ic,\n\t\t\t\tvol->upcase, vol->upcase_len)) {\nfound_it:\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it;\n\t}\n\t/*\n\t * We have finished with this index without success. Check for the\n\t * presence of a child node.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\t/* No child node, return -ENOENT. */\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t} /* Child node present, descend into it. */\n\t/* Consistency check: Verify that an index allocation exists. */\n\tif (!NInoIndexAllocPresent(dir_ni)) {\n\t\tntfs_error(sb, \"No index allocation attribute but index entry \"\n\t\t\t\t\"requires one. Directory inode 0x%lx is \"\n\t\t\t\t\"corrupt or driver bug.\", dir_ni->mft_no);\n\t\tgoto err_out;\n\t}\n\t/* Get the starting vcn of the index_block holding the child node. */\n\tvcn = sle64_to_cpup((u8*)ie + le16_to_cpu(ie->length) - 8);\n\tia_mapping = VFS_I(dir_ni)->i_mapping;\n\t/*\n\t * We are done with the index root and the mft record. Release them,\n\t * otherwise we deadlock with ntfs_map_page().\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(dir_ni);\n\tm = NULL;\n\tctx = NULL;\ndescend_into_child_node:\n\t/*\n\t * Convert vcn to index into the index allocation attribute in units\n\t * of PAGE_CACHE_SIZE and map the page cache page, reading it from\n\t * disk if necessary.\n\t */\n\tpage = ntfs_map_page(ia_mapping, vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(sb, \"Failed to map directory index page, error %ld.\",\n\t\t\t\t-PTR_ERR(page));\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tkaddr = (u8*)page_address(page);\nfast_descend_into_child_node:\n\t/* Get to the index allocation block. */\n\tia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits) & ~PAGE_CACHE_MASK));\n\t/* Bounds checks. */\n\tif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Out of bounds check failed. Corrupt directory \"\n\t\t\t\t\"inode 0x%lx or driver bug.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Catch multi sector transfer fixup errors. */\n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Directory index record with vcn 0x%llx is \"\n\t\t\t\t\"corrupt.  Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx). \"\n\t\t\t\t\"Directory inode 0x%lx is corrupt or driver \"\n\t\t\t\t\"bug.\", (unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tdir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx has a size (%u) differing from the \"\n\t\t\t\t\"directory specified size (%u). Directory \"\n\t\t\t\t\"inode is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tdir_ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)ia + dir_ni->itype.index.block_size;\n\tif (index_end > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx crosses page boundary. Impossible! \"\n\t\t\t\t\"Cannot access! This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)vcn,\n\t\t\t\tdir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (index_end > (u8*)ia + dir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of directory \"\n\t\t\t\t\"inode 0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t/*\n\t * Iterate similar to above big loop but applied to index buffer, thus\n\t * loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds check. */\n\t\tif ((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * If the current entry has a name type of POSIX, the name is\n\t\t * case sensitive and not otherwise. This has the effect of us\n\t\t * not being able to access any POSIX file names which collate\n\t\t * after the non-POSIX one when they only differ in case, but\n\t\t * anyone doing screwy stuff like that deserves to burn in\n\t\t * hell... Doing that kind of stuff on NT4 actually causes\n\t\t * corruption on the partition even when using SP6a and Linux\n\t\t * is not involved at all.\n\t\t */\n\t\tic = ie->key.file_name.file_name_type ? IGNORE_CASE :\n\t\t\t\tCASE_SENSITIVE;\n\t\t/*\n\t\t * If the names match perfectly, we are done and return the\n\t\t * mft reference of the inode (i.e. the inode number together\n\t\t * with the sequence number for consistency checking. We\n\t\t * convert it to cpu format before returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, ic,\n\t\t\t\tvol->upcase, vol->upcase_len)) {\nfound_it2:\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it2;\n\t}\n\t/*\n\t * We have finished with this index buffer without success. Check for\n\t * the presence of a child node.\n\t */\n\tif (ie->flags & INDEX_ENTRY_NODE) {\n\t\tif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\n\t\t\tntfs_error(sb, \"Index entry with child node found in \"\n\t\t\t\t\t\"a leaf node in directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Child node present, descend into it. */\n\t\told_vcn = vcn;\n\t\tvcn = sle64_to_cpup((u8*)ie + le16_to_cpu(ie->length) - 8);\n\t\tif (vcn >= 0) {\n\t\t\t/* If vcn is in the same page cache page as old_vcn we\n\t\t\t * recycle the mapped page. */\n\t\t\tif (old_vcn << vol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT == vcn <<\n\t\t\t\t\tvol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT)\n\t\t\t\tgoto fast_descend_into_child_node;\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto descend_into_child_node;\n\t\t}\n\t\tntfs_error(sb, \"Negative child node vcn in directory inode \"\n\t\t\t\t\"0x%lx.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* No child node, return -ENOENT. */\n\tntfs_debug(\"Entry not found.\");\n\terr = -ENOENT;\nunm_err_out:\n\tunlock_page(page);\n\tntfs_unmap_page(page);\nerr_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(dir_ni);\n\treturn ERR_MREF(err);\ndir_err_out:\n\tntfs_error(sb, \"Corrupt directory. Aborting lookup.\");\n\tgoto err_out;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"mft.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include \"dir.h\"",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ntfschar I30[5] = { cpu_to_le16('$'), cpu_to_le16('I'),\n\t\tcpu_to_le16('3'),\tcpu_to_le16('0'), 0 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Corrupt directory. Aborting lookup.\""
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_MREF",
          "args": [
            "err"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "dir_ni"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "page"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entry not found.\""
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Negative child node vcn in directory inode \"\n\t\t\t\t\"0x%lx.\"",
            "dir_ni->mft_no"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sle64_to_cpup",
          "args": [
            "(u8*)ie + le16_to_cpu(ie->length) - 8"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ie->length"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_collate_names",
          "args": [
            "uname",
            "uname_len",
            "(ntfschar*)&ie->key.file_name.file_name",
            "ie->key.file_name.file_name_length",
            "1",
            "CASE_SENSITIVE",
            "vol->upcase",
            "vol->upcase_len"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_collate_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
          "lines": "97-133",
          "snippet": "int ntfs_collate_names(const ntfschar *name1, const u32 name1_len,\n\t\tconst ntfschar *name2, const u32 name2_len,\n\t\tconst int err_val, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_len)\n{\n\tu32 cnt, min_len;\n\tu16 c1, c2;\n\n\tmin_len = name1_len;\n\tif (name1_len > name2_len)\n\t\tmin_len = name2_len;\n\tfor (cnt = 0; cnt < min_len; ++cnt) {\n\t\tc1 = le16_to_cpu(*name1++);\n\t\tc2 = le16_to_cpu(*name2++);\n\t\tif (ic) {\n\t\t\tif (c1 < upcase_len)\n\t\t\t\tc1 = le16_to_cpu(upcase[c1]);\n\t\t\tif (c2 < upcase_len)\n\t\t\t\tc2 = le16_to_cpu(upcase[c2]);\n\t\t}\n\t\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\t\treturn err_val;\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t}\n\tif (name1_len < name2_len)\n\t\treturn -1;\n\tif (name1_len == name2_len)\n\t\treturn 0;\n\t/* name1_len > name2_len */\n\tc1 = le16_to_cpu(*name1);\n\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\treturn err_val;\n\treturn 1;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"types.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const u8 legal_ansi_char_array[0x40] = {\n\t0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x17, 0x07, 0x18, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x18, 0x16, 0x16, 0x17, 0x07, 0x00,\n\n\t0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x04, 0x16, 0x18, 0x16, 0x18, 0x18,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nstatic const u8 legal_ansi_char_array[0x40] = {\n\t0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x17, 0x07, 0x18, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x18, 0x16, 0x16, 0x17, 0x07, 0x00,\n\n\t0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x04, 0x16, 0x18, 0x16, 0x18, 0x18,\n};\n\nint ntfs_collate_names(const ntfschar *name1, const u32 name1_len,\n\t\tconst ntfschar *name2, const u32 name2_len,\n\t\tconst int err_val, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_len)\n{\n\tu32 cnt, min_len;\n\tu16 c1, c2;\n\n\tmin_len = name1_len;\n\tif (name1_len > name2_len)\n\t\tmin_len = name2_len;\n\tfor (cnt = 0; cnt < min_len; ++cnt) {\n\t\tc1 = le16_to_cpu(*name1++);\n\t\tc2 = le16_to_cpu(*name2++);\n\t\tif (ic) {\n\t\t\tif (c1 < upcase_len)\n\t\t\t\tc1 = le16_to_cpu(upcase[c1]);\n\t\t\tif (c2 < upcase_len)\n\t\t\t\tc2 = le16_to_cpu(upcase[c2]);\n\t\t}\n\t\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\t\treturn err_val;\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t}\n\tif (name1_len < name2_len)\n\t\treturn -1;\n\tif (name1_len == name2_len)\n\t\treturn 0;\n\t/* name1_len > name2_len */\n\tc1 = le16_to_cpu(*name1);\n\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\treturn err_val;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_are_names_equal",
          "args": [
            "uname",
            "uname_len",
            "(ntfschar*)&ie->key.file_name.file_name",
            "ie->key.file_name.file_name_length",
            "ic",
            "vol->upcase",
            "vol->upcase_len"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_are_names_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
          "lines": "68-77",
          "snippet": "bool ntfs_are_names_equal(const ntfschar *s1, size_t s1_len,\n\t\tconst ntfschar *s2, size_t s2_len, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_size)\n{\n\tif (s1_len != s2_len)\n\t\treturn false;\n\tif (ic == CASE_SENSITIVE)\n\t\treturn !ntfs_ucsncmp(s1, s2, s1_len);\n\treturn !ntfs_ucsncasecmp(s1, s2, s1_len, upcase, upcase_size);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"types.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nbool ntfs_are_names_equal(const ntfschar *s1, size_t s1_len,\n\t\tconst ntfschar *s2, size_t s2_len, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_size)\n{\n\tif (s1_len != s2_len)\n\t\treturn false;\n\tif (ic == CASE_SENSITIVE)\n\t\treturn !ntfs_ucsncmp(s1, s2, s1_len);\n\treturn !ntfs_ucsncasecmp(s1, s2, s1_len, upcase, upcase_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ia->index.entries_offset"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ntfs_is_indx_record(ia->magic)"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_is_indx_record",
          "args": [
            "ia->magic"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_page",
          "args": [
            "ia_mapping",
            "vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "86-99",
          "snippet": "static inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "dir_ni"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "245-248",
          "snippet": "static inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoIndexAllocPresent",
          "args": [
            "dir_ni"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "AT_INDEX_ROOT",
            "I30",
            "4",
            "CASE_SENSITIVE",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "dir_ni",
            "m"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_MREF",
          "args": [
            "PTR_ERR(m)"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include \"dir.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nntfschar I30[5] = { cpu_to_le16('$'), cpu_to_le16('I'),\n\t\tcpu_to_le16('3'),\tcpu_to_le16('0'), 0 };\n\nu64 ntfs_lookup_inode_by_name(ntfs_inode *dir_ni, const ntfschar *uname,\n\t\tconst int uname_len)\n{\n\tntfs_volume *vol = dir_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *index_end;\n\tu64 mref;\n\tntfs_attr_search_ctx *ctx;\n\tint err, rc;\n\tIGNORE_CASE_BOOL ic;\n\tVCN vcn, old_vcn;\n\tstruct address_space *ia_mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\n\t/* Get hold of the mft record for the directory. */\n\tm = map_mft_record(dir_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(sb, \"map_mft_record() failed with error code %ld.\",\n\t\t\t\t-PTR_ERR(m));\n\t\treturn ERR_MREF(PTR_ERR(m));\n\t}\n\tctx = ntfs_attr_get_search_ctx(dir_ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Find the index root attribute in the mft record. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(sb, \"Index root attribute missing in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_out;\n\t}\n\t/* Get to the index root value (it's been verified in read_inode). */\n\tir = (INDEX_ROOT*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)ctx->mrec || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end)\n\t\t\tgoto dir_err_out;\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * If the current entry has a name type of POSIX, the name is\n\t\t * case sensitive and not otherwise. This has the effect of us\n\t\t * not being able to access any POSIX file names which collate\n\t\t * after the non-POSIX one when they only differ in case, but\n\t\t * anyone doing screwy stuff like that deserves to burn in\n\t\t * hell... Doing that kind of stuff on NT4 actually causes\n\t\t * corruption on the partition even when using SP6a and Linux\n\t\t * is not involved at all.\n\t\t */\n\t\tic = ie->key.file_name.file_name_type ? IGNORE_CASE :\n\t\t\t\tCASE_SENSITIVE;\n\t\t/*\n\t\t * If the names match perfectly, we are done and return the\n\t\t * mft reference of the inode (i.e. the inode number together\n\t\t * with the sequence number for consistency checking. We\n\t\t * convert it to cpu format before returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, ic,\n\t\t\t\tvol->upcase, vol->upcase_len)) {\nfound_it:\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it;\n\t}\n\t/*\n\t * We have finished with this index without success. Check for the\n\t * presence of a child node.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\t/* No child node, return -ENOENT. */\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t} /* Child node present, descend into it. */\n\t/* Consistency check: Verify that an index allocation exists. */\n\tif (!NInoIndexAllocPresent(dir_ni)) {\n\t\tntfs_error(sb, \"No index allocation attribute but index entry \"\n\t\t\t\t\"requires one. Directory inode 0x%lx is \"\n\t\t\t\t\"corrupt or driver bug.\", dir_ni->mft_no);\n\t\tgoto err_out;\n\t}\n\t/* Get the starting vcn of the index_block holding the child node. */\n\tvcn = sle64_to_cpup((u8*)ie + le16_to_cpu(ie->length) - 8);\n\tia_mapping = VFS_I(dir_ni)->i_mapping;\n\t/*\n\t * We are done with the index root and the mft record. Release them,\n\t * otherwise we deadlock with ntfs_map_page().\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(dir_ni);\n\tm = NULL;\n\tctx = NULL;\ndescend_into_child_node:\n\t/*\n\t * Convert vcn to index into the index allocation attribute in units\n\t * of PAGE_CACHE_SIZE and map the page cache page, reading it from\n\t * disk if necessary.\n\t */\n\tpage = ntfs_map_page(ia_mapping, vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(sb, \"Failed to map directory index page, error %ld.\",\n\t\t\t\t-PTR_ERR(page));\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tkaddr = (u8*)page_address(page);\nfast_descend_into_child_node:\n\t/* Get to the index allocation block. */\n\tia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits) & ~PAGE_CACHE_MASK));\n\t/* Bounds checks. */\n\tif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Out of bounds check failed. Corrupt directory \"\n\t\t\t\t\"inode 0x%lx or driver bug.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Catch multi sector transfer fixup errors. */\n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Directory index record with vcn 0x%llx is \"\n\t\t\t\t\"corrupt.  Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx). \"\n\t\t\t\t\"Directory inode 0x%lx is corrupt or driver \"\n\t\t\t\t\"bug.\", (unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tdir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx has a size (%u) differing from the \"\n\t\t\t\t\"directory specified size (%u). Directory \"\n\t\t\t\t\"inode is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tdir_ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)ia + dir_ni->itype.index.block_size;\n\tif (index_end > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx crosses page boundary. Impossible! \"\n\t\t\t\t\"Cannot access! This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)vcn,\n\t\t\t\tdir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (index_end > (u8*)ia + dir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of directory \"\n\t\t\t\t\"inode 0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t/*\n\t * Iterate similar to above big loop but applied to index buffer, thus\n\t * loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds check. */\n\t\tif ((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * If the current entry has a name type of POSIX, the name is\n\t\t * case sensitive and not otherwise. This has the effect of us\n\t\t * not being able to access any POSIX file names which collate\n\t\t * after the non-POSIX one when they only differ in case, but\n\t\t * anyone doing screwy stuff like that deserves to burn in\n\t\t * hell... Doing that kind of stuff on NT4 actually causes\n\t\t * corruption on the partition even when using SP6a and Linux\n\t\t * is not involved at all.\n\t\t */\n\t\tic = ie->key.file_name.file_name_type ? IGNORE_CASE :\n\t\t\t\tCASE_SENSITIVE;\n\t\t/*\n\t\t * If the names match perfectly, we are done and return the\n\t\t * mft reference of the inode (i.e. the inode number together\n\t\t * with the sequence number for consistency checking. We\n\t\t * convert it to cpu format before returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, ic,\n\t\t\t\tvol->upcase, vol->upcase_len)) {\nfound_it2:\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it2;\n\t}\n\t/*\n\t * We have finished with this index buffer without success. Check for\n\t * the presence of a child node.\n\t */\n\tif (ie->flags & INDEX_ENTRY_NODE) {\n\t\tif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\n\t\t\tntfs_error(sb, \"Index entry with child node found in \"\n\t\t\t\t\t\"a leaf node in directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Child node present, descend into it. */\n\t\told_vcn = vcn;\n\t\tvcn = sle64_to_cpup((u8*)ie + le16_to_cpu(ie->length) - 8);\n\t\tif (vcn >= 0) {\n\t\t\t/* If vcn is in the same page cache page as old_vcn we\n\t\t\t * recycle the mapped page. */\n\t\t\tif (old_vcn << vol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT == vcn <<\n\t\t\t\t\tvol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT)\n\t\t\t\tgoto fast_descend_into_child_node;\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto descend_into_child_node;\n\t\t}\n\t\tntfs_error(sb, \"Negative child node vcn in directory inode \"\n\t\t\t\t\"0x%lx.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* No child node, return -ENOENT. */\n\tntfs_debug(\"Entry not found.\");\n\terr = -ENOENT;\nunm_err_out:\n\tunlock_page(page);\n\tntfs_unmap_page(page);\nerr_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(dir_ni);\n\treturn ERR_MREF(err);\ndir_err_out:\n\tntfs_error(sb, \"Corrupt directory. Aborting lookup.\");\n\tgoto err_out;\n}"
  },
  {
    "function_name": "ntfs_lookup_inode_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/dir.c",
    "lines": "80-604",
    "snippet": "MFT_REF ntfs_lookup_inode_by_name(ntfs_inode *dir_ni, const ntfschar *uname,\n\t\tconst int uname_len, ntfs_name **res)\n{\n\tntfs_volume *vol = dir_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *index_end;\n\tu64 mref;\n\tntfs_attr_search_ctx *ctx;\n\tint err, rc;\n\tVCN vcn, old_vcn;\n\tstruct address_space *ia_mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tntfs_name *name = NULL;\n\n\tBUG_ON(!S_ISDIR(VFS_I(dir_ni)->i_mode));\n\tBUG_ON(NInoAttr(dir_ni));\n\t/* Get hold of the mft record for the directory. */\n\tm = map_mft_record(dir_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(sb, \"map_mft_record() failed with error code %ld.\",\n\t\t\t\t-PTR_ERR(m));\n\t\treturn ERR_MREF(PTR_ERR(m));\n\t}\n\tctx = ntfs_attr_get_search_ctx(dir_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Find the index root attribute in the mft record. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(sb, \"Index root attribute missing in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_out;\n\t}\n\t/* Get to the index root value (it's been verified in read_inode). */\n\tir = (INDEX_ROOT*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)ctx->mrec || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end)\n\t\t\tgoto dir_err_out;\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 1. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it;\n\t}\n\t/*\n\t * We have finished with this index without success. Check for the\n\t * presence of a child node and if not present return -ENOENT, unless\n\t * we have got a matching name cached in name in which case return the\n\t * mft reference associated with it.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tif (name) {\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn name->mref;\n\t\t}\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t} /* Child node present, descend into it. */\n\t/* Consistency check: Verify that an index allocation exists. */\n\tif (!NInoIndexAllocPresent(dir_ni)) {\n\t\tntfs_error(sb, \"No index allocation attribute but index entry \"\n\t\t\t\t\"requires one. Directory inode 0x%lx is \"\n\t\t\t\t\"corrupt or driver bug.\", dir_ni->mft_no);\n\t\tgoto err_out;\n\t}\n\t/* Get the starting vcn of the index_block holding the child node. */\n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tia_mapping = VFS_I(dir_ni)->i_mapping;\n\t/*\n\t * We are done with the index root and the mft record. Release them,\n\t * otherwise we deadlock with ntfs_map_page().\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(dir_ni);\n\tm = NULL;\n\tctx = NULL;\ndescend_into_child_node:\n\t/*\n\t * Convert vcn to index into the index allocation attribute in units\n\t * of PAGE_CACHE_SIZE and map the page cache page, reading it from\n\t * disk if necessary.\n\t */\n\tpage = ntfs_map_page(ia_mapping, vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(sb, \"Failed to map directory index page, error %ld.\",\n\t\t\t\t-PTR_ERR(page));\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tkaddr = (u8*)page_address(page);\nfast_descend_into_child_node:\n\t/* Get to the index allocation block. */\n\tia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits) & ~PAGE_CACHE_MASK));\n\t/* Bounds checks. */\n\tif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Out of bounds check failed. Corrupt directory \"\n\t\t\t\t\"inode 0x%lx or driver bug.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Catch multi sector transfer fixup errors. */\n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Directory index record with vcn 0x%llx is \"\n\t\t\t\t\"corrupt.  Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx). \"\n\t\t\t\t\"Directory inode 0x%lx is corrupt or driver \"\n\t\t\t\t\"bug.\", (unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tdir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx has a size (%u) differing from the \"\n\t\t\t\t\"directory specified size (%u). Directory \"\n\t\t\t\t\"inode is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tdir_ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)ia + dir_ni->itype.index.block_size;\n\tif (index_end > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx crosses page boundary. Impossible! \"\n\t\t\t\t\"Cannot access! This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)vcn,\n\t\t\t\tdir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (index_end > (u8*)ia + dir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of directory \"\n\t\t\t\t\"inode 0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t/*\n\t * Iterate similar to above big loop but applied to index buffer, thus\n\t * loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds check. */\n\t\tif ((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it2:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 2. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tunlock_page(page);\n\t\t\t\tntfs_unmap_page(page);\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it2;\n\t}\n\t/*\n\t * We have finished with this index buffer without success. Check for\n\t * the presence of a child node.\n\t */\n\tif (ie->flags & INDEX_ENTRY_NODE) {\n\t\tif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\n\t\t\tntfs_error(sb, \"Index entry with child node found in \"\n\t\t\t\t\t\"a leaf node in directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Child node present, descend into it. */\n\t\told_vcn = vcn;\n\t\tvcn = sle64_to_cpup((sle64*)((u8*)ie +\n\t\t\t\tle16_to_cpu(ie->length) - 8));\n\t\tif (vcn >= 0) {\n\t\t\t/* If vcn is in the same page cache page as old_vcn we\n\t\t\t * recycle the mapped page. */\n\t\t\tif (old_vcn << vol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT == vcn <<\n\t\t\t\t\tvol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT)\n\t\t\t\tgoto fast_descend_into_child_node;\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto descend_into_child_node;\n\t\t}\n\t\tntfs_error(sb, \"Negative child node vcn in directory inode \"\n\t\t\t\t\"0x%lx.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/*\n\t * No child node present, return -ENOENT, unless we have got a matching\n\t * name cached in name in which case return the mft reference\n\t * associated with it.\n\t */\n\tif (name) {\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\treturn name->mref;\n\t}\n\tntfs_debug(\"Entry not found.\");\n\terr = -ENOENT;\nunm_err_out:\n\tunlock_page(page);\n\tntfs_unmap_page(page);\nerr_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(dir_ni);\n\tif (name) {\n\t\tkfree(name);\n\t\t*res = NULL;\n\t}\n\treturn ERR_MREF(err);\ndir_err_out:\n\tntfs_error(sb, \"Corrupt directory.  Aborting lookup.\");\n\tgoto err_out;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"mft.h\"",
      "#include \"attrib.h\"",
      "#include \"aops.h\"",
      "#include \"dir.h\"",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ntfschar I30[5] = { cpu_to_le16('$'), cpu_to_le16('I'),\n\t\tcpu_to_le16('3'),\tcpu_to_le16('0'), 0 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Corrupt directory.  Aborting lookup.\""
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_MREF",
          "args": [
            "err"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "dir_ni"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "page"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entry not found.\""
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Negative child node vcn in directory inode \"\n\t\t\t\t\"0x%lx.\"",
            "dir_ni->mft_no"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sle64_to_cpup",
          "args": [
            "(sle64*)((u8*)ie +\n\t\t\t\tle16_to_cpu(ie->length) - 8)"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ie->length"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_collate_names",
          "args": [
            "uname",
            "uname_len",
            "(ntfschar*)&ie->key.file_name.file_name",
            "ie->key.file_name.file_name_length",
            "1",
            "CASE_SENSITIVE",
            "vol->upcase",
            "vol->upcase_len"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_collate_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
          "lines": "97-133",
          "snippet": "int ntfs_collate_names(const ntfschar *name1, const u32 name1_len,\n\t\tconst ntfschar *name2, const u32 name2_len,\n\t\tconst int err_val, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_len)\n{\n\tu32 cnt, min_len;\n\tu16 c1, c2;\n\n\tmin_len = name1_len;\n\tif (name1_len > name2_len)\n\t\tmin_len = name2_len;\n\tfor (cnt = 0; cnt < min_len; ++cnt) {\n\t\tc1 = le16_to_cpu(*name1++);\n\t\tc2 = le16_to_cpu(*name2++);\n\t\tif (ic) {\n\t\t\tif (c1 < upcase_len)\n\t\t\t\tc1 = le16_to_cpu(upcase[c1]);\n\t\t\tif (c2 < upcase_len)\n\t\t\t\tc2 = le16_to_cpu(upcase[c2]);\n\t\t}\n\t\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\t\treturn err_val;\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t}\n\tif (name1_len < name2_len)\n\t\treturn -1;\n\tif (name1_len == name2_len)\n\t\treturn 0;\n\t/* name1_len > name2_len */\n\tc1 = le16_to_cpu(*name1);\n\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\treturn err_val;\n\treturn 1;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"types.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const u8 legal_ansi_char_array[0x40] = {\n\t0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x17, 0x07, 0x18, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x18, 0x16, 0x16, 0x17, 0x07, 0x00,\n\n\t0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x04, 0x16, 0x18, 0x16, 0x18, 0x18,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nstatic const u8 legal_ansi_char_array[0x40] = {\n\t0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\t0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,\n\n\t0x17, 0x07, 0x18, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x18, 0x16, 0x16, 0x17, 0x07, 0x00,\n\n\t0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,\n\t0x17, 0x17, 0x04, 0x16, 0x18, 0x16, 0x18, 0x18,\n};\n\nint ntfs_collate_names(const ntfschar *name1, const u32 name1_len,\n\t\tconst ntfschar *name2, const u32 name2_len,\n\t\tconst int err_val, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_len)\n{\n\tu32 cnt, min_len;\n\tu16 c1, c2;\n\n\tmin_len = name1_len;\n\tif (name1_len > name2_len)\n\t\tmin_len = name2_len;\n\tfor (cnt = 0; cnt < min_len; ++cnt) {\n\t\tc1 = le16_to_cpu(*name1++);\n\t\tc2 = le16_to_cpu(*name2++);\n\t\tif (ic) {\n\t\t\tif (c1 < upcase_len)\n\t\t\t\tc1 = le16_to_cpu(upcase[c1]);\n\t\t\tif (c2 < upcase_len)\n\t\t\t\tc2 = le16_to_cpu(upcase[c2]);\n\t\t}\n\t\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\t\treturn err_val;\n\t\tif (c1 < c2)\n\t\t\treturn -1;\n\t\tif (c1 > c2)\n\t\t\treturn 1;\n\t}\n\tif (name1_len < name2_len)\n\t\treturn -1;\n\tif (name1_len == name2_len)\n\t\treturn 0;\n\t/* name1_len > name2_len */\n\tc1 = le16_to_cpu(*name1);\n\tif (c1 < 64 && legal_ansi_char_array[c1] & 8)\n\t\treturn err_val;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "name->name",
            "ie->key.file_name.file_name",
            "len * sizeof(ntfschar)"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "name_size",
            "GFP_NOFS"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 2. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\""
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_are_names_equal",
          "args": [
            "uname",
            "uname_len",
            "(ntfschar*)&ie->key.file_name.file_name",
            "ie->key.file_name.file_name_length",
            "IGNORE_CASE",
            "vol->upcase",
            "vol->upcase_len"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_are_names_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/unistr.c",
          "lines": "68-77",
          "snippet": "bool ntfs_are_names_equal(const ntfschar *s1, size_t s1_len,\n\t\tconst ntfschar *s2, size_t s2_len, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_size)\n{\n\tif (s1_len != s2_len)\n\t\treturn false;\n\tif (ic == CASE_SENSITIVE)\n\t\treturn !ntfs_ucsncmp(s1, s2, s1_len);\n\treturn !ntfs_ucsncasecmp(s1, s2, s1_len, upcase, upcase_size);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"debug.h\"",
            "#include \"types.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"types.h\"\n#include <linux/slab.h>\n\nbool ntfs_are_names_equal(const ntfschar *s1, size_t s1_len,\n\t\tconst ntfschar *s2, size_t s2_len, const IGNORE_CASE_BOOL ic,\n\t\tconst ntfschar *upcase, const u32 upcase_size)\n{\n\tif (s1_len != s2_len)\n\t\treturn false;\n\tif (ic == CASE_SENSITIVE)\n\t\treturn !ntfs_ucsncmp(s1, s2, s1_len);\n\treturn !ntfs_ucsncasecmp(s1, s2, s1_len, upcase, upcase_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolCaseSensitive",
          "args": [
            "vol"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ia->index.entries_offset"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ntfs_is_indx_record(ia->magic)"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_is_indx_record",
          "args": [
            "ia->magic"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_page",
          "args": [
            "ia_mapping",
            "vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "86-99",
          "snippet": "static inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "dir_ni"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "245-248",
          "snippet": "static inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoIndexAllocPresent",
          "args": [
            "dir_ni"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "name->name",
            "ie->key.file_name.file_name",
            "len * sizeof(ntfschar)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 1. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolCaseSensitive",
          "args": [
            "vol"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "AT_INDEX_ROOT",
            "I30",
            "4",
            "CASE_SENSITIVE",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "dir_ni",
            "m"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_MREF",
          "args": [
            "PTR_ERR(m)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NInoAttr(dir_ni)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "dir_ni"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!S_ISDIR(VFS_I(dir_ni)->i_mode)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "VFS_I(dir_ni)->i_mode"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include \"dir.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nntfschar I30[5] = { cpu_to_le16('$'), cpu_to_le16('I'),\n\t\tcpu_to_le16('3'),\tcpu_to_le16('0'), 0 };\n\nMFT_REF ntfs_lookup_inode_by_name(ntfs_inode *dir_ni, const ntfschar *uname,\n\t\tconst int uname_len, ntfs_name **res)\n{\n\tntfs_volume *vol = dir_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\tMFT_RECORD *m;\n\tINDEX_ROOT *ir;\n\tINDEX_ENTRY *ie;\n\tINDEX_ALLOCATION *ia;\n\tu8 *index_end;\n\tu64 mref;\n\tntfs_attr_search_ctx *ctx;\n\tint err, rc;\n\tVCN vcn, old_vcn;\n\tstruct address_space *ia_mapping;\n\tstruct page *page;\n\tu8 *kaddr;\n\tntfs_name *name = NULL;\n\n\tBUG_ON(!S_ISDIR(VFS_I(dir_ni)->i_mode));\n\tBUG_ON(NInoAttr(dir_ni));\n\t/* Get hold of the mft record for the directory. */\n\tm = map_mft_record(dir_ni);\n\tif (IS_ERR(m)) {\n\t\tntfs_error(sb, \"map_mft_record() failed with error code %ld.\",\n\t\t\t\t-PTR_ERR(m));\n\t\treturn ERR_MREF(PTR_ERR(m));\n\t}\n\tctx = ntfs_attr_get_search_ctx(dir_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\t/* Find the index root attribute in the mft record. */\n\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE, 0, NULL,\n\t\t\t0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\tntfs_error(sb, \"Index root attribute missing in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto err_out;\n\t}\n\t/* Get to the index root value (it's been verified in read_inode). */\n\tir = (INDEX_ROOT*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\tindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ir->index +\n\t\t\tle32_to_cpu(ir->index.entries_offset));\n\t/*\n\t * Loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds checks. */\n\t\tif ((u8*)ie < (u8*)ctx->mrec || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end)\n\t\t\tgoto dir_err_out;\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 1. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it;\n\t}\n\t/*\n\t * We have finished with this index without success. Check for the\n\t * presence of a child node and if not present return -ENOENT, unless\n\t * we have got a matching name cached in name in which case return the\n\t * mft reference associated with it.\n\t */\n\tif (!(ie->flags & INDEX_ENTRY_NODE)) {\n\t\tif (name) {\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(dir_ni);\n\t\t\treturn name->mref;\n\t\t}\n\t\tntfs_debug(\"Entry not found.\");\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t} /* Child node present, descend into it. */\n\t/* Consistency check: Verify that an index allocation exists. */\n\tif (!NInoIndexAllocPresent(dir_ni)) {\n\t\tntfs_error(sb, \"No index allocation attribute but index entry \"\n\t\t\t\t\"requires one. Directory inode 0x%lx is \"\n\t\t\t\t\"corrupt or driver bug.\", dir_ni->mft_no);\n\t\tgoto err_out;\n\t}\n\t/* Get the starting vcn of the index_block holding the child node. */\n\tvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\n\tia_mapping = VFS_I(dir_ni)->i_mapping;\n\t/*\n\t * We are done with the index root and the mft record. Release them,\n\t * otherwise we deadlock with ntfs_map_page().\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(dir_ni);\n\tm = NULL;\n\tctx = NULL;\ndescend_into_child_node:\n\t/*\n\t * Convert vcn to index into the index allocation attribute in units\n\t * of PAGE_CACHE_SIZE and map the page cache page, reading it from\n\t * disk if necessary.\n\t */\n\tpage = ntfs_map_page(ia_mapping, vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT);\n\tif (IS_ERR(page)) {\n\t\tntfs_error(sb, \"Failed to map directory index page, error %ld.\",\n\t\t\t\t-PTR_ERR(page));\n\t\terr = PTR_ERR(page);\n\t\tgoto err_out;\n\t}\n\tlock_page(page);\n\tkaddr = (u8*)page_address(page);\nfast_descend_into_child_node:\n\t/* Get to the index allocation block. */\n\tia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\n\t\t\tdir_ni->itype.index.vcn_size_bits) & ~PAGE_CACHE_MASK));\n\t/* Bounds checks. */\n\tif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Out of bounds check failed. Corrupt directory \"\n\t\t\t\t\"inode 0x%lx or driver bug.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* Catch multi sector transfer fixup errors. */\n\tif (unlikely(!ntfs_is_indx_record(ia->magic))) {\n\t\tntfs_error(sb, \"Directory index record with vcn 0x%llx is \"\n\t\t\t\t\"corrupt.  Corrupt inode 0x%lx.  Run chkdsk.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\n\t\tntfs_error(sb, \"Actual VCN (0x%llx) of index buffer is \"\n\t\t\t\t\"different from expected VCN (0x%llx). \"\n\t\t\t\t\"Directory inode 0x%lx is corrupt or driver \"\n\t\t\t\t\"bug.\", (unsigned long long)\n\t\t\t\tsle64_to_cpu(ia->index_block_vcn),\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\n\t\t\tdir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx has a size (%u) differing from the \"\n\t\t\t\t\"directory specified size (%u). Directory \"\n\t\t\t\t\"inode is corrupt or driver bug.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no,\n\t\t\t\tle32_to_cpu(ia->index.allocated_size) + 0x18,\n\t\t\t\tdir_ni->itype.index.block_size);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)ia + dir_ni->itype.index.block_size;\n\tif (index_end > kaddr + PAGE_CACHE_SIZE) {\n\t\tntfs_error(sb, \"Index buffer (VCN 0x%llx) of directory inode \"\n\t\t\t\t\"0x%lx crosses page boundary. Impossible! \"\n\t\t\t\t\"Cannot access! This is probably a bug in the \"\n\t\t\t\t\"driver.\", (unsigned long long)vcn,\n\t\t\t\tdir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\tindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\n\tif (index_end > (u8*)ia + dir_ni->itype.index.block_size) {\n\t\tntfs_error(sb, \"Size of index buffer (VCN 0x%llx) of directory \"\n\t\t\t\t\"inode 0x%lx exceeds maximum size.\",\n\t\t\t\t(unsigned long long)vcn, dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/* The first index entry. */\n\tie = (INDEX_ENTRY*)((u8*)&ia->index +\n\t\t\tle32_to_cpu(ia->index.entries_offset));\n\t/*\n\t * Iterate similar to above big loop but applied to index buffer, thus\n\t * loop until we exceed valid memory (corruption case) or until we\n\t * reach the last entry.\n\t */\n\tfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\n\t\t/* Bounds check. */\n\t\tif ((u8*)ie < (u8*)ia || (u8*)ie +\n\t\t\t\tsizeof(INDEX_ENTRY_HEADER) > index_end ||\n\t\t\t\t(u8*)ie + le16_to_cpu(ie->key_length) >\n\t\t\t\tindex_end) {\n\t\t\tntfs_error(sb, \"Index entry out of bounds in \"\n\t\t\t\t\t\"directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * The last entry cannot contain a name. It can however contain\n\t\t * a pointer to a child node in the B+tree so we just break out.\n\t\t */\n\t\tif (ie->flags & INDEX_ENTRY_END)\n\t\t\tbreak;\n\t\t/*\n\t\t * We perform a case sensitive comparison and if that matches\n\t\t * we are done and return the mft reference of the inode (i.e.\n\t\t * the inode number together with the sequence number for\n\t\t * consistency checking). We convert it to cpu format before\n\t\t * returning.\n\t\t */\n\t\tif (ntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len)) {\nfound_it2:\n\t\t\t/*\n\t\t\t * We have a perfect match, so we don't need to care\n\t\t\t * about having matched imperfectly before, so we can\n\t\t\t * free name and set *res to NULL.\n\t\t\t * However, if the perfect match is a short file name,\n\t\t\t * we need to signal this through *res, so that\n\t\t\t * ntfs_lookup() can fix dcache aliasing issues.\n\t\t\t * As an optimization we just reuse an existing\n\t\t\t * allocation of *res.\n\t\t\t */\n\t\t\tif (ie->key.file_name.file_name_type == FILE_NAME_DOS) {\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = kmalloc(sizeof(ntfs_name),\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tname->mref = le64_to_cpu(\n\t\t\t\t\t\tie->data.dir.indexed_file);\n\t\t\t\tname->type = FILE_NAME_DOS;\n\t\t\t\tname->len = 0;\n\t\t\t\t*res = name;\n\t\t\t} else {\n\t\t\t\tkfree(name);\n\t\t\t\t*res = NULL;\n\t\t\t}\n\t\t\tmref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\treturn mref;\n\t\t}\n\t\t/*\n\t\t * For a case insensitive mount, we also perform a case\n\t\t * insensitive comparison (provided the file name is not in the\n\t\t * POSIX namespace). If the comparison matches, and the name is\n\t\t * in the WIN32 namespace, we cache the filename in *res so\n\t\t * that the caller, ntfs_lookup(), can work on it. If the\n\t\t * comparison matches, and the name is in the DOS namespace, we\n\t\t * only cache the mft reference and the file name type (we set\n\t\t * the name length to zero for simplicity).\n\t\t */\n\t\tif (!NVolCaseSensitive(vol) &&\n\t\t\t\tie->key.file_name.file_name_type &&\n\t\t\t\tntfs_are_names_equal(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len)) {\n\t\t\tint name_size = sizeof(ntfs_name);\n\t\t\tu8 type = ie->key.file_name.file_name_type;\n\t\t\tu8 len = ie->key.file_name.file_name_length;\n\n\t\t\t/* Only one case insensitive matching name allowed. */\n\t\t\tif (name) {\n\t\t\t\tntfs_error(sb, \"Found already allocated name \"\n\t\t\t\t\t\t\"in phase 2. Please run chkdsk \"\n\t\t\t\t\t\t\"and if that doesn't find any \"\n\t\t\t\t\t\t\"errors please report you saw \"\n\t\t\t\t\t\t\"this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net.\");\n\t\t\t\tunlock_page(page);\n\t\t\t\tntfs_unmap_page(page);\n\t\t\t\tgoto dir_err_out;\n\t\t\t}\n\n\t\t\tif (type != FILE_NAME_DOS)\n\t\t\t\tname_size += len * sizeof(ntfschar);\n\t\t\tname = kmalloc(name_size, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tname->mref = le64_to_cpu(ie->data.dir.indexed_file);\n\t\t\tname->type = type;\n\t\t\tif (type != FILE_NAME_DOS) {\n\t\t\t\tname->len = len;\n\t\t\t\tmemcpy(name->name, ie->key.file_name.file_name,\n\t\t\t\t\t\tlen * sizeof(ntfschar));\n\t\t\t} else\n\t\t\t\tname->len = 0;\n\t\t\t*res = name;\n\t\t}\n\t\t/*\n\t\t * Not a perfect match, need to do full blown collation so we\n\t\t * know which way in the B+tree we have to go.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tIGNORE_CASE, vol->upcase, vol->upcase_len);\n\t\t/*\n\t\t * If uname collates before the name of the current entry, there\n\t\t * is definitely no such name in this index but we might need to\n\t\t * descend into the B+tree so we just break out of the loop.\n\t\t */\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\t/* The names are not equal, continue the search. */\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Names match with case insensitive comparison, now try the\n\t\t * case sensitive comparison, which is required for proper\n\t\t * collation.\n\t\t */\n\t\trc = ntfs_collate_names(uname, uname_len,\n\t\t\t\t(ntfschar*)&ie->key.file_name.file_name,\n\t\t\t\tie->key.file_name.file_name_length, 1,\n\t\t\t\tCASE_SENSITIVE, vol->upcase, vol->upcase_len);\n\t\tif (rc == -1)\n\t\t\tbreak;\n\t\tif (rc)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Perfect match, this will never happen as the\n\t\t * ntfs_are_names_equal() call will have gotten a match but we\n\t\t * still treat it correctly.\n\t\t */\n\t\tgoto found_it2;\n\t}\n\t/*\n\t * We have finished with this index buffer without success. Check for\n\t * the presence of a child node.\n\t */\n\tif (ie->flags & INDEX_ENTRY_NODE) {\n\t\tif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\n\t\t\tntfs_error(sb, \"Index entry with child node found in \"\n\t\t\t\t\t\"a leaf node in directory inode 0x%lx.\",\n\t\t\t\t\tdir_ni->mft_no);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Child node present, descend into it. */\n\t\told_vcn = vcn;\n\t\tvcn = sle64_to_cpup((sle64*)((u8*)ie +\n\t\t\t\tle16_to_cpu(ie->length) - 8));\n\t\tif (vcn >= 0) {\n\t\t\t/* If vcn is in the same page cache page as old_vcn we\n\t\t\t * recycle the mapped page. */\n\t\t\tif (old_vcn << vol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT == vcn <<\n\t\t\t\t\tvol->cluster_size_bits >>\n\t\t\t\t\tPAGE_CACHE_SHIFT)\n\t\t\t\tgoto fast_descend_into_child_node;\n\t\t\tunlock_page(page);\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto descend_into_child_node;\n\t\t}\n\t\tntfs_error(sb, \"Negative child node vcn in directory inode \"\n\t\t\t\t\"0x%lx.\", dir_ni->mft_no);\n\t\tgoto unm_err_out;\n\t}\n\t/*\n\t * No child node present, return -ENOENT, unless we have got a matching\n\t * name cached in name in which case return the mft reference\n\t * associated with it.\n\t */\n\tif (name) {\n\t\tunlock_page(page);\n\t\tntfs_unmap_page(page);\n\t\treturn name->mref;\n\t}\n\tntfs_debug(\"Entry not found.\");\n\terr = -ENOENT;\nunm_err_out:\n\tunlock_page(page);\n\tntfs_unmap_page(page);\nerr_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(dir_ni);\n\tif (name) {\n\t\tkfree(name);\n\t\t*res = NULL;\n\t}\n\treturn ERR_MREF(err);\ndir_err_out:\n\tntfs_error(sb, \"Corrupt directory.  Aborting lookup.\");\n\tgoto err_out;\n}"
  }
]