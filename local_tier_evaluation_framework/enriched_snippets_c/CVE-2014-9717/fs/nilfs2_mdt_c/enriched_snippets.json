[
  {
    "function_name": "nilfs_mdt_clear_shadow_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
    "lines": "588-598",
    "snippet": "void nilfs_mdt_clear_shadow_map(struct inode *inode)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\tstruct nilfs_shadow_map *shadow = mi->mi_shadow;\n\n\tdown_write(&mi->mi_sem);\n\tnilfs_release_frozen_buffers(shadow);\n\ttruncate_inode_pages(&shadow->frozen_data, 0);\n\ttruncate_inode_pages(&shadow->frozen_btnodes, 0);\n\tup_write(&mi->mi_sem);\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mi->mi_sem"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "&shadow->frozen_btnodes",
            "0"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "&shadow->frozen_data",
            "0"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_release_frozen_buffers",
          "args": [
            "shadow"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_release_frozen_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
          "lines": "545-556",
          "snippet": "static void nilfs_release_frozen_buffers(struct nilfs_shadow_map *shadow)\n{\n\tstruct list_head *head = &shadow->frozen_buffers;\n\tstruct buffer_head *bh;\n\n\twhile (!list_empty(head)) {\n\t\tbh = list_first_entry(head, struct buffer_head,\n\t\t\t\t      b_assoc_buffers);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh); /* drop ref-count to make it releasable */\n\t}\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nstatic void nilfs_release_frozen_buffers(struct nilfs_shadow_map *shadow)\n{\n\tstruct list_head *head = &shadow->frozen_buffers;\n\tstruct buffer_head *bh;\n\n\twhile (!list_empty(head)) {\n\t\tbh = list_first_entry(head, struct buffer_head,\n\t\t\t\t      b_assoc_buffers);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh); /* drop ref-count to make it releasable */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mi->mi_sem"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "inode"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_mdt_clear_shadow_map(struct inode *inode)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\tstruct nilfs_shadow_map *shadow = mi->mi_shadow;\n\n\tdown_write(&mi->mi_sem);\n\tnilfs_release_frozen_buffers(shadow);\n\ttruncate_inode_pages(&shadow->frozen_data, 0);\n\ttruncate_inode_pages(&shadow->frozen_btnodes, 0);\n\tup_write(&mi->mi_sem);\n}"
  },
  {
    "function_name": "nilfs_mdt_restore_from_shadow_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
    "lines": "562-582",
    "snippet": "void nilfs_mdt_restore_from_shadow_map(struct inode *inode)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct nilfs_shadow_map *shadow = mi->mi_shadow;\n\n\tdown_write(&mi->mi_sem);\n\n\tif (mi->mi_palloc_cache)\n\t\tnilfs_palloc_clear_cache(inode);\n\n\tnilfs_clear_dirty_pages(inode->i_mapping, true);\n\tnilfs_copy_back_pages(inode->i_mapping, &shadow->frozen_data);\n\n\tnilfs_clear_dirty_pages(&ii->i_btnode_cache, true);\n\tnilfs_copy_back_pages(&ii->i_btnode_cache, &shadow->frozen_btnodes);\n\n\tnilfs_bmap_restore(ii->i_bmap, &shadow->bmap_store);\n\n\tup_write(&mi->mi_sem);\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mi->mi_sem"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_restore",
          "args": [
            "ii->i_bmap",
            "&shadow->bmap_store"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "560-567",
          "snippet": "void nilfs_bmap_restore(struct nilfs_bmap *bmap,\n\t\t\tconst struct nilfs_bmap_store *store)\n{\n\tmemcpy(bmap->b_u.u_data, store->data, sizeof(store->data));\n\tbmap->b_last_allocated_key = store->last_allocated_key;\n\tbmap->b_last_allocated_ptr = store->last_allocated_ptr;\n\tbmap->b_state = store->state;\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid nilfs_bmap_restore(struct nilfs_bmap *bmap,\n\t\t\tconst struct nilfs_bmap_store *store)\n{\n\tmemcpy(bmap->b_u.u_data, store->data, sizeof(store->data));\n\tbmap->b_last_allocated_key = store->last_allocated_key;\n\tbmap->b_last_allocated_ptr = store->last_allocated_ptr;\n\tbmap->b_state = store->state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_copy_back_pages",
          "args": [
            "&ii->i_btnode_cache",
            "&shadow->frozen_btnodes"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_copy_back_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "312-372",
          "snippet": "void nilfs_copy_back_pages(struct address_space *dmap,\n\t\t\t   struct address_space *smap)\n{\n\tstruct pagevec pvec;\n\tunsigned int i, n;\n\tpgoff_t index = 0;\n\tint err;\n\n\tpagevec_init(&pvec, 0);\nrepeat:\n\tn = pagevec_lookup(&pvec, smap, index, PAGEVEC_SIZE);\n\tif (!n)\n\t\treturn;\n\tindex = pvec.pages[n - 1]->index + 1;\n\n\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\tstruct page *page = pvec.pages[i], *dpage;\n\t\tpgoff_t offset = page->index;\n\n\t\tlock_page(page);\n\t\tdpage = find_lock_page(dmap, offset);\n\t\tif (dpage) {\n\t\t\t/* override existing page on the destination cache */\n\t\t\tWARN_ON(PageDirty(dpage));\n\t\t\tnilfs_copy_page(dpage, page, 0);\n\t\t\tunlock_page(dpage);\n\t\t\tpage_cache_release(dpage);\n\t\t} else {\n\t\t\tstruct page *page2;\n\n\t\t\t/* move the page to the destination cache */\n\t\t\tspin_lock_irq(&smap->tree_lock);\n\t\t\tpage2 = radix_tree_delete(&smap->page_tree, offset);\n\t\t\tWARN_ON(page2 != page);\n\n\t\t\tsmap->nrpages--;\n\t\t\tspin_unlock_irq(&smap->tree_lock);\n\n\t\t\tspin_lock_irq(&dmap->tree_lock);\n\t\t\terr = radix_tree_insert(&dmap->page_tree, offset, page);\n\t\t\tif (unlikely(err < 0)) {\n\t\t\t\tWARN_ON(err == -EEXIST);\n\t\t\t\tpage->mapping = NULL;\n\t\t\t\tpage_cache_release(page); /* for cache */\n\t\t\t} else {\n\t\t\t\tpage->mapping = dmap;\n\t\t\t\tdmap->nrpages++;\n\t\t\t\tif (PageDirty(page))\n\t\t\t\t\tradix_tree_tag_set(&dmap->page_tree,\n\t\t\t\t\t\t\t   offset,\n\t\t\t\t\t\t\t   PAGECACHE_TAG_DIRTY);\n\t\t\t}\n\t\t\tspin_unlock_irq(&dmap->tree_lock);\n\t\t}\n\t\tunlock_page(page);\n\t}\n\tpagevec_release(&pvec);\n\tcond_resched();\n\n\tgoto repeat;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_copy_back_pages(struct address_space *dmap,\n\t\t\t   struct address_space *smap)\n{\n\tstruct pagevec pvec;\n\tunsigned int i, n;\n\tpgoff_t index = 0;\n\tint err;\n\n\tpagevec_init(&pvec, 0);\nrepeat:\n\tn = pagevec_lookup(&pvec, smap, index, PAGEVEC_SIZE);\n\tif (!n)\n\t\treturn;\n\tindex = pvec.pages[n - 1]->index + 1;\n\n\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\tstruct page *page = pvec.pages[i], *dpage;\n\t\tpgoff_t offset = page->index;\n\n\t\tlock_page(page);\n\t\tdpage = find_lock_page(dmap, offset);\n\t\tif (dpage) {\n\t\t\t/* override existing page on the destination cache */\n\t\t\tWARN_ON(PageDirty(dpage));\n\t\t\tnilfs_copy_page(dpage, page, 0);\n\t\t\tunlock_page(dpage);\n\t\t\tpage_cache_release(dpage);\n\t\t} else {\n\t\t\tstruct page *page2;\n\n\t\t\t/* move the page to the destination cache */\n\t\t\tspin_lock_irq(&smap->tree_lock);\n\t\t\tpage2 = radix_tree_delete(&smap->page_tree, offset);\n\t\t\tWARN_ON(page2 != page);\n\n\t\t\tsmap->nrpages--;\n\t\t\tspin_unlock_irq(&smap->tree_lock);\n\n\t\t\tspin_lock_irq(&dmap->tree_lock);\n\t\t\terr = radix_tree_insert(&dmap->page_tree, offset, page);\n\t\t\tif (unlikely(err < 0)) {\n\t\t\t\tWARN_ON(err == -EEXIST);\n\t\t\t\tpage->mapping = NULL;\n\t\t\t\tpage_cache_release(page); /* for cache */\n\t\t\t} else {\n\t\t\t\tpage->mapping = dmap;\n\t\t\t\tdmap->nrpages++;\n\t\t\t\tif (PageDirty(page))\n\t\t\t\t\tradix_tree_tag_set(&dmap->page_tree,\n\t\t\t\t\t\t\t   offset,\n\t\t\t\t\t\t\t   PAGECACHE_TAG_DIRTY);\n\t\t\t}\n\t\t\tspin_unlock_irq(&dmap->tree_lock);\n\t\t}\n\t\tunlock_page(page);\n\t}\n\tpagevec_release(&pvec);\n\tcond_resched();\n\n\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_clear_dirty_pages",
          "args": [
            "&ii->i_btnode_cache",
            "true"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_clear_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "379-399",
          "snippet": "void nilfs_clear_dirty_pages(struct address_space *mapping, bool silent)\n{\n\tstruct pagevec pvec;\n\tunsigned int i;\n\tpgoff_t index = 0;\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (pagevec_lookup_tag(&pvec, mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\t  PAGEVEC_SIZE)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\t\t\tnilfs_clear_dirty_page(page, silent);\n\t\t\tunlock_page(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_clear_dirty_pages(struct address_space *mapping, bool silent)\n{\n\tstruct pagevec pvec;\n\tunsigned int i;\n\tpgoff_t index = 0;\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (pagevec_lookup_tag(&pvec, mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\t  PAGEVEC_SIZE)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\t\t\tnilfs_clear_dirty_page(page, silent);\n\t\t\tunlock_page(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_palloc_clear_cache",
          "args": [
            "inode"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_palloc_clear_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/alloc.c",
          "lines": "766-778",
          "snippet": "void nilfs_palloc_clear_cache(struct inode *inode)\n{\n\tstruct nilfs_palloc_cache *cache = NILFS_MDT(inode)->mi_palloc_cache;\n\n\tspin_lock(&cache->lock);\n\tbrelse(cache->prev_desc.bh);\n\tbrelse(cache->prev_bitmap.bh);\n\tbrelse(cache->prev_entry.bh);\n\tcache->prev_desc.bh = NULL;\n\tcache->prev_bitmap.bh = NULL;\n\tcache->prev_entry.bh = NULL;\n\tspin_unlock(&cache->lock);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nvoid nilfs_palloc_clear_cache(struct inode *inode)\n{\n\tstruct nilfs_palloc_cache *cache = NILFS_MDT(inode)->mi_palloc_cache;\n\n\tspin_lock(&cache->lock);\n\tbrelse(cache->prev_desc.bh);\n\tbrelse(cache->prev_bitmap.bh);\n\tbrelse(cache->prev_entry.bh);\n\tcache->prev_desc.bh = NULL;\n\tcache->prev_bitmap.bh = NULL;\n\tcache->prev_entry.bh = NULL;\n\tspin_unlock(&cache->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mi->mi_sem"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "inode"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_mdt_restore_from_shadow_map(struct inode *inode)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct nilfs_shadow_map *shadow = mi->mi_shadow;\n\n\tdown_write(&mi->mi_sem);\n\n\tif (mi->mi_palloc_cache)\n\t\tnilfs_palloc_clear_cache(inode);\n\n\tnilfs_clear_dirty_pages(inode->i_mapping, true);\n\tnilfs_copy_back_pages(inode->i_mapping, &shadow->frozen_data);\n\n\tnilfs_clear_dirty_pages(&ii->i_btnode_cache, true);\n\tnilfs_copy_back_pages(&ii->i_btnode_cache, &shadow->frozen_btnodes);\n\n\tnilfs_bmap_restore(ii->i_bmap, &shadow->bmap_store);\n\n\tup_write(&mi->mi_sem);\n}"
  },
  {
    "function_name": "nilfs_release_frozen_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
    "lines": "545-556",
    "snippet": "static void nilfs_release_frozen_buffers(struct nilfs_shadow_map *shadow)\n{\n\tstruct list_head *head = &shadow->frozen_buffers;\n\tstruct buffer_head *bh;\n\n\twhile (!list_empty(head)) {\n\t\tbh = list_first_entry(head, struct buffer_head,\n\t\t\t\t      b_assoc_buffers);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh); /* drop ref-count to make it releasable */\n\t}\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bh->b_assoc_buffers"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "head",
            "structbuffer_head",
            "b_assoc_buffers"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nstatic void nilfs_release_frozen_buffers(struct nilfs_shadow_map *shadow)\n{\n\tstruct list_head *head = &shadow->frozen_buffers;\n\tstruct buffer_head *bh;\n\n\twhile (!list_empty(head)) {\n\t\tbh = list_first_entry(head, struct buffer_head,\n\t\t\t\t      b_assoc_buffers);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh); /* drop ref-count to make it releasable */\n\t}\n}"
  },
  {
    "function_name": "nilfs_mdt_get_frozen_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
    "lines": "525-543",
    "snippet": "struct buffer_head *\nnilfs_mdt_get_frozen_buffer(struct inode *inode, struct buffer_head *bh)\n{\n\tstruct nilfs_shadow_map *shadow = NILFS_MDT(inode)->mi_shadow;\n\tstruct buffer_head *bh_frozen = NULL;\n\tstruct page *page;\n\tint n;\n\n\tpage = find_lock_page(&shadow->frozen_data, bh->b_page->index);\n\tif (page) {\n\t\tif (page_has_buffers(page)) {\n\t\t\tn = bh_offset(bh) >> inode->i_blkbits;\n\t\t\tbh_frozen = nilfs_page_get_nth_block(page, n);\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\treturn bh_frozen;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_page_get_nth_block",
          "args": [
            "page",
            "n"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_page_get_nth_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.h",
          "lines": "69-78",
          "snippet": "static inline struct buffer_head *\nnilfs_page_get_nth_block(struct page *page, unsigned int count)\n{\n\tstruct buffer_head *bh = page_buffers(page);\n\n\twhile (count-- > 0)\n\t\tbh = bh->b_this_page;\n\tget_bh(bh);\n\treturn bh;\n}",
          "includes": [
            "#include \"nilfs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nilfs.h\"\n#include <linux/buffer_head.h>\n\nstatic inline struct buffer_head *\nnilfs_page_get_nth_block(struct page *page, unsigned int count)\n{\n\tstruct buffer_head *bh = page_buffers(page);\n\n\twhile (count-- > 0)\n\t\tbh = bh->b_this_page;\n\tget_bh(bh);\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_page",
          "args": [
            "&shadow->frozen_data",
            "bh->b_page->index"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "inode"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nstruct buffer_head *\nnilfs_mdt_get_frozen_buffer(struct inode *inode, struct buffer_head *bh)\n{\n\tstruct nilfs_shadow_map *shadow = NILFS_MDT(inode)->mi_shadow;\n\tstruct buffer_head *bh_frozen = NULL;\n\tstruct page *page;\n\tint n;\n\n\tpage = find_lock_page(&shadow->frozen_data, bh->b_page->index);\n\tif (page) {\n\t\tif (page_has_buffers(page)) {\n\t\t\tn = bh_offset(bh) >> inode->i_blkbits;\n\t\t\tbh_frozen = nilfs_page_get_nth_block(page, n);\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\treturn bh_frozen;\n}"
  },
  {
    "function_name": "nilfs_mdt_freeze_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
    "lines": "494-523",
    "snippet": "int nilfs_mdt_freeze_buffer(struct inode *inode, struct buffer_head *bh)\n{\n\tstruct nilfs_shadow_map *shadow = NILFS_MDT(inode)->mi_shadow;\n\tstruct buffer_head *bh_frozen;\n\tstruct page *page;\n\tint blkbits = inode->i_blkbits;\n\n\tpage = grab_cache_page(&shadow->frozen_data, bh->b_page->index);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << blkbits, 0);\n\n\tbh_frozen = nilfs_page_get_nth_block(page, bh_offset(bh) >> blkbits);\n\n\tif (!buffer_uptodate(bh_frozen))\n\t\tnilfs_copy_buffer(bh_frozen, bh);\n\tif (list_empty(&bh_frozen->b_assoc_buffers)) {\n\t\tlist_add_tail(&bh_frozen->b_assoc_buffers,\n\t\t\t      &shadow->frozen_buffers);\n\t\tset_buffer_nilfs_redirected(bh);\n\t} else {\n\t\tbrelse(bh_frozen); /* already frozen */\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn 0;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh_frozen"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_nilfs_redirected",
          "args": [
            "bh"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&bh_frozen->b_assoc_buffers",
            "&shadow->frozen_buffers"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&bh_frozen->b_assoc_buffers"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_copy_buffer",
          "args": [
            "bh_frozen",
            "bh"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_copy_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "116-148",
          "snippet": "void nilfs_copy_buffer(struct buffer_head *dbh, struct buffer_head *sbh)\n{\n\tvoid *kaddr0, *kaddr1;\n\tunsigned long bits;\n\tstruct page *spage = sbh->b_page, *dpage = dbh->b_page;\n\tstruct buffer_head *bh;\n\n\tkaddr0 = kmap_atomic(spage);\n\tkaddr1 = kmap_atomic(dpage);\n\tmemcpy(kaddr1 + bh_offset(dbh), kaddr0 + bh_offset(sbh), sbh->b_size);\n\tkunmap_atomic(kaddr1);\n\tkunmap_atomic(kaddr0);\n\n\tdbh->b_state = sbh->b_state & NILFS_BUFFER_INHERENT_BITS;\n\tdbh->b_blocknr = sbh->b_blocknr;\n\tdbh->b_bdev = sbh->b_bdev;\n\n\tbh = dbh;\n\tbits = sbh->b_state & ((1UL << BH_Uptodate) | (1UL << BH_Mapped));\n\twhile ((bh = bh->b_this_page) != dbh) {\n\t\tlock_buffer(bh);\n\t\tbits &= bh->b_state;\n\t\tunlock_buffer(bh);\n\t}\n\tif (bits & (1UL << BH_Uptodate))\n\t\tSetPageUptodate(dpage);\n\telse\n\t\tClearPageUptodate(dpage);\n\tif (bits & (1UL << BH_Mapped))\n\t\tSetPageMappedToDisk(dpage);\n\telse\n\t\tClearPageMappedToDisk(dpage);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define NILFS_BUFFER_INHERENT_BITS  \\\n\t((1UL << BH_Uptodate) | (1UL << BH_Mapped) | (1UL << BH_NILFS_Node) | \\\n\t (1UL << BH_NILFS_Volatile) | (1UL << BH_NILFS_Checked))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\n#define NILFS_BUFFER_INHERENT_BITS  \\\n\t((1UL << BH_Uptodate) | (1UL << BH_Mapped) | (1UL << BH_NILFS_Node) | \\\n\t (1UL << BH_NILFS_Volatile) | (1UL << BH_NILFS_Checked))\n\nvoid nilfs_copy_buffer(struct buffer_head *dbh, struct buffer_head *sbh)\n{\n\tvoid *kaddr0, *kaddr1;\n\tunsigned long bits;\n\tstruct page *spage = sbh->b_page, *dpage = dbh->b_page;\n\tstruct buffer_head *bh;\n\n\tkaddr0 = kmap_atomic(spage);\n\tkaddr1 = kmap_atomic(dpage);\n\tmemcpy(kaddr1 + bh_offset(dbh), kaddr0 + bh_offset(sbh), sbh->b_size);\n\tkunmap_atomic(kaddr1);\n\tkunmap_atomic(kaddr0);\n\n\tdbh->b_state = sbh->b_state & NILFS_BUFFER_INHERENT_BITS;\n\tdbh->b_blocknr = sbh->b_blocknr;\n\tdbh->b_bdev = sbh->b_bdev;\n\n\tbh = dbh;\n\tbits = sbh->b_state & ((1UL << BH_Uptodate) | (1UL << BH_Mapped));\n\twhile ((bh = bh->b_this_page) != dbh) {\n\t\tlock_buffer(bh);\n\t\tbits &= bh->b_state;\n\t\tunlock_buffer(bh);\n\t}\n\tif (bits & (1UL << BH_Uptodate))\n\t\tSetPageUptodate(dpage);\n\telse\n\t\tClearPageUptodate(dpage);\n\tif (bits & (1UL << BH_Mapped))\n\t\tSetPageMappedToDisk(dpage);\n\telse\n\t\tClearPageMappedToDisk(dpage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh_frozen"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_page_get_nth_block",
          "args": [
            "page",
            "bh_offset(bh) >> blkbits"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_page_get_nth_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.h",
          "lines": "69-78",
          "snippet": "static inline struct buffer_head *\nnilfs_page_get_nth_block(struct page *page, unsigned int count)\n{\n\tstruct buffer_head *bh = page_buffers(page);\n\n\twhile (count-- > 0)\n\t\tbh = bh->b_this_page;\n\tget_bh(bh);\n\treturn bh;\n}",
          "includes": [
            "#include \"nilfs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nilfs.h\"\n#include <linux/buffer_head.h>\n\nstatic inline struct buffer_head *\nnilfs_page_get_nth_block(struct page *page, unsigned int count)\n{\n\tstruct buffer_head *bh = page_buffers(page);\n\n\twhile (count-- > 0)\n\t\tbh = bh->b_this_page;\n\tget_bh(bh);\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "1 << blkbits",
            "0"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1564-1591",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "&shadow->frozen_data",
            "bh->b_page->index"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "inode"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_mdt_freeze_buffer(struct inode *inode, struct buffer_head *bh)\n{\n\tstruct nilfs_shadow_map *shadow = NILFS_MDT(inode)->mi_shadow;\n\tstruct buffer_head *bh_frozen;\n\tstruct page *page;\n\tint blkbits = inode->i_blkbits;\n\n\tpage = grab_cache_page(&shadow->frozen_data, bh->b_page->index);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << blkbits, 0);\n\n\tbh_frozen = nilfs_page_get_nth_block(page, bh_offset(bh) >> blkbits);\n\n\tif (!buffer_uptodate(bh_frozen))\n\t\tnilfs_copy_buffer(bh_frozen, bh);\n\tif (list_empty(&bh_frozen->b_assoc_buffers)) {\n\t\tlist_add_tail(&bh_frozen->b_assoc_buffers,\n\t\t\t      &shadow->frozen_buffers);\n\t\tset_buffer_nilfs_redirected(bh);\n\t} else {\n\t\tbrelse(bh_frozen); /* already frozen */\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_mdt_save_to_shadow_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
    "lines": "473-492",
    "snippet": "int nilfs_mdt_save_to_shadow_map(struct inode *inode)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct nilfs_shadow_map *shadow = mi->mi_shadow;\n\tint ret;\n\n\tret = nilfs_copy_dirty_pages(&shadow->frozen_data, inode->i_mapping);\n\tif (ret)\n\t\tgoto out;\n\n\tret = nilfs_copy_dirty_pages(&shadow->frozen_btnodes,\n\t\t\t\t     &ii->i_btnode_cache);\n\tif (ret)\n\t\tgoto out;\n\n\tnilfs_bmap_save(ii->i_bmap, &shadow->bmap_store);\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_bmap_save",
          "args": [
            "ii->i_bmap",
            "&shadow->bmap_store"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_save",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "551-558",
          "snippet": "void nilfs_bmap_save(const struct nilfs_bmap *bmap,\n\t\t     struct nilfs_bmap_store *store)\n{\n\tmemcpy(store->data, bmap->b_u.u_data, sizeof(store->data));\n\tstore->last_allocated_key = bmap->b_last_allocated_key;\n\tstore->last_allocated_ptr = bmap->b_last_allocated_ptr;\n\tstore->state = bmap->b_state;\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid nilfs_bmap_save(const struct nilfs_bmap *bmap,\n\t\t     struct nilfs_bmap_store *store)\n{\n\tmemcpy(store->data, bmap->b_u.u_data, sizeof(store->data));\n\tstore->last_allocated_key = bmap->b_last_allocated_key;\n\tstore->last_allocated_ptr = bmap->b_last_allocated_ptr;\n\tstore->state = bmap->b_state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_copy_dirty_pages",
          "args": [
            "&shadow->frozen_btnodes",
            "&ii->i_btnode_cache"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_copy_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "257-302",
          "snippet": "int nilfs_copy_dirty_pages(struct address_space *dmap,\n\t\t\t   struct address_space *smap)\n{\n\tstruct pagevec pvec;\n\tunsigned int i;\n\tpgoff_t index = 0;\n\tint err = 0;\n\n\tpagevec_init(&pvec, 0);\nrepeat:\n\tif (!pagevec_lookup_tag(&pvec, smap, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\tPAGEVEC_SIZE))\n\t\treturn 0;\n\n\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\tstruct page *page = pvec.pages[i], *dpage;\n\n\t\tlock_page(page);\n\t\tif (unlikely(!PageDirty(page)))\n\t\t\tNILFS_PAGE_BUG(page, \"inconsistent dirty state\");\n\n\t\tdpage = grab_cache_page(dmap, page->index);\n\t\tif (unlikely(!dpage)) {\n\t\t\t/* No empty page is added to the page cache */\n\t\t\terr = -ENOMEM;\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(!page_has_buffers(page)))\n\t\t\tNILFS_PAGE_BUG(page,\n\t\t\t\t       \"found empty page in dat page cache\");\n\n\t\tnilfs_copy_page(dpage, page, 1);\n\t\t__set_page_dirty_nobuffers(dpage);\n\n\t\tunlock_page(dpage);\n\t\tpage_cache_release(dpage);\n\t\tunlock_page(page);\n\t}\n\tpagevec_release(&pvec);\n\tcond_resched();\n\n\tif (likely(!err))\n\t\tgoto repeat;\n\treturn err;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint nilfs_copy_dirty_pages(struct address_space *dmap,\n\t\t\t   struct address_space *smap)\n{\n\tstruct pagevec pvec;\n\tunsigned int i;\n\tpgoff_t index = 0;\n\tint err = 0;\n\n\tpagevec_init(&pvec, 0);\nrepeat:\n\tif (!pagevec_lookup_tag(&pvec, smap, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\tPAGEVEC_SIZE))\n\t\treturn 0;\n\n\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\tstruct page *page = pvec.pages[i], *dpage;\n\n\t\tlock_page(page);\n\t\tif (unlikely(!PageDirty(page)))\n\t\t\tNILFS_PAGE_BUG(page, \"inconsistent dirty state\");\n\n\t\tdpage = grab_cache_page(dmap, page->index);\n\t\tif (unlikely(!dpage)) {\n\t\t\t/* No empty page is added to the page cache */\n\t\t\terr = -ENOMEM;\n\t\t\tunlock_page(page);\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(!page_has_buffers(page)))\n\t\t\tNILFS_PAGE_BUG(page,\n\t\t\t\t       \"found empty page in dat page cache\");\n\n\t\tnilfs_copy_page(dpage, page, 1);\n\t\t__set_page_dirty_nobuffers(dpage);\n\n\t\tunlock_page(dpage);\n\t\tpage_cache_release(dpage);\n\t\tunlock_page(page);\n\t}\n\tpagevec_release(&pvec);\n\tcond_resched();\n\n\tif (likely(!err))\n\t\tgoto repeat;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "inode"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_mdt_save_to_shadow_map(struct inode *inode)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct nilfs_shadow_map *shadow = mi->mi_shadow;\n\tint ret;\n\n\tret = nilfs_copy_dirty_pages(&shadow->frozen_data, inode->i_mapping);\n\tif (ret)\n\t\tgoto out;\n\n\tret = nilfs_copy_dirty_pages(&shadow->frozen_btnodes,\n\t\t\t\t     &ii->i_btnode_cache);\n\tif (ret)\n\t\tgoto out;\n\n\tnilfs_bmap_save(ii->i_bmap, &shadow->bmap_store);\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_mdt_setup_shadow_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
    "lines": "455-467",
    "snippet": "int nilfs_mdt_setup_shadow_map(struct inode *inode,\n\t\t\t       struct nilfs_shadow_map *shadow)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\n\tINIT_LIST_HEAD(&shadow->frozen_buffers);\n\taddress_space_init_once(&shadow->frozen_data);\n\tnilfs_mapping_init(&shadow->frozen_data, inode);\n\taddress_space_init_once(&shadow->frozen_btnodes);\n\tnilfs_mapping_init(&shadow->frozen_btnodes, inode);\n\tmi->mi_shadow = shadow;\n\treturn 0;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_mapping_init",
          "args": [
            "&shadow->frozen_btnodes",
            "inode"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mapping_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "464-471",
          "snippet": "void nilfs_mapping_init(struct address_space *mapping, struct inode *inode)\n{\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\tmapping->private_data = NULL;\n\tmapping->a_ops = &empty_aops;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_mapping_init(struct address_space *mapping, struct inode *inode)\n{\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\tmapping->private_data = NULL;\n\tmapping->a_ops = &empty_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "address_space_init_once",
          "args": [
            "&shadow->frozen_btnodes"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "address_space_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "338-347",
          "snippet": "void address_space_init_once(struct address_space *mapping)\n{\n\tmemset(mapping, 0, sizeof(*mapping));\n\tINIT_RADIX_TREE(&mapping->page_tree, GFP_ATOMIC);\n\tspin_lock_init(&mapping->tree_lock);\n\tinit_rwsem(&mapping->i_mmap_rwsem);\n\tINIT_LIST_HEAD(&mapping->private_list);\n\tspin_lock_init(&mapping->private_lock);\n\tmapping->i_mmap = RB_ROOT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid address_space_init_once(struct address_space *mapping)\n{\n\tmemset(mapping, 0, sizeof(*mapping));\n\tINIT_RADIX_TREE(&mapping->page_tree, GFP_ATOMIC);\n\tspin_lock_init(&mapping->tree_lock);\n\tinit_rwsem(&mapping->i_mmap_rwsem);\n\tINIT_LIST_HEAD(&mapping->private_list);\n\tspin_lock_init(&mapping->private_lock);\n\tmapping->i_mmap = RB_ROOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&shadow->frozen_buffers"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "inode"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_mdt_setup_shadow_map(struct inode *inode,\n\t\t\t       struct nilfs_shadow_map *shadow)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\n\tINIT_LIST_HEAD(&shadow->frozen_buffers);\n\taddress_space_init_once(&shadow->frozen_data);\n\tnilfs_mapping_init(&shadow->frozen_data, inode);\n\taddress_space_init_once(&shadow->frozen_btnodes);\n\tnilfs_mapping_init(&shadow->frozen_btnodes, inode);\n\tmi->mi_shadow = shadow;\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_mdt_set_entry_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
    "lines": "440-448",
    "snippet": "void nilfs_mdt_set_entry_size(struct inode *inode, unsigned entry_size,\n\t\t\t      unsigned header_size)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\n\tmi->mi_entry_size = entry_size;\n\tmi->mi_entries_per_block = (1 << inode->i_blkbits) / entry_size;\n\tmi->mi_first_entry_offset = DIV_ROUND_UP(header_size, entry_size);\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "header_size",
            "entry_size"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "inode"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_mdt_set_entry_size(struct inode *inode, unsigned entry_size,\n\t\t\t      unsigned header_size)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\n\tmi->mi_entry_size = entry_size;\n\tmi->mi_entries_per_block = (1 << inode->i_blkbits) / entry_size;\n\tmi->mi_first_entry_offset = DIV_ROUND_UP(header_size, entry_size);\n}"
  },
  {
    "function_name": "nilfs_mdt_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
    "lines": "419-438",
    "snippet": "int nilfs_mdt_init(struct inode *inode, gfp_t gfp_mask, size_t objsz)\n{\n\tstruct nilfs_mdt_info *mi;\n\n\tmi = kzalloc(max(sizeof(*mi), objsz), GFP_NOFS);\n\tif (!mi)\n\t\treturn -ENOMEM;\n\n\tinit_rwsem(&mi->mi_sem);\n\tinode->i_private = mi;\n\n\tinode->i_mode = S_IFREG;\n\tmapping_set_gfp_mask(inode->i_mapping, gfp_mask);\n\n\tinode->i_op = &def_mdt_iops;\n\tinode->i_fop = &def_mdt_fops;\n\tinode->i_mapping->a_ops = &def_mdt_aops;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct address_space_operations def_mdt_aops = {\n\t.writepage\t\t= nilfs_mdt_write_page,\n};",
      "static const struct inode_operations def_mdt_iops;",
      "static const struct file_operations def_mdt_fops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "inode->i_mapping",
            "gfp_mask"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&mi->mi_sem"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "max(sizeof(*mi), objsz)",
            "GFP_NOFS"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "sizeof(*mi)",
            "objsz"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "342-382",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nstatic const struct address_space_operations def_mdt_aops = {\n\t.writepage\t\t= nilfs_mdt_write_page,\n};\nstatic const struct inode_operations def_mdt_iops;\nstatic const struct file_operations def_mdt_fops;\n\nint nilfs_mdt_init(struct inode *inode, gfp_t gfp_mask, size_t objsz)\n{\n\tstruct nilfs_mdt_info *mi;\n\n\tmi = kzalloc(max(sizeof(*mi), objsz), GFP_NOFS);\n\tif (!mi)\n\t\treturn -ENOMEM;\n\n\tinit_rwsem(&mi->mi_sem);\n\tinode->i_private = mi;\n\n\tinode->i_mode = S_IFREG;\n\tmapping_set_gfp_mask(inode->i_mapping, gfp_mask);\n\n\tinode->i_op = &def_mdt_iops;\n\tinode->i_fop = &def_mdt_fops;\n\tinode->i_mapping->a_ops = &def_mdt_aops;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_mdt_write_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
    "lines": "375-408",
    "snippet": "static int\nnilfs_mdt_write_page(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb;\n\tint err = 0;\n\n\tif (inode && (inode->i_sb->s_flags & MS_RDONLY)) {\n\t\t/*\n\t\t * It means that filesystem was remounted in read-only\n\t\t * mode because of error or metadata corruption. But we\n\t\t * have dirty pages that try to be flushed in background.\n\t\t * So, here we simply discard this dirty page.\n\t\t */\n\t\tnilfs_clear_dirty_page(page, false);\n\t\tunlock_page(page);\n\t\treturn -EROFS;\n\t}\n\n\tredirty_page_for_writepage(wbc, page);\n\tunlock_page(page);\n\n\tif (!inode)\n\t\treturn 0;\n\n\tsb = inode->i_sb;\n\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\terr = nilfs_construct_segment(sb);\n\telse if (wbc->for_reclaim)\n\t\tnilfs_flush_segment(sb, inode->i_ino);\n\n\treturn err;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_flush_segment",
          "args": [
            "sb",
            "inode->i_ino"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_flush_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2078-2087",
          "snippet": "void nilfs_flush_segment(struct super_block *sb, ino_t ino)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tif (!sci || nilfs_doing_construction())\n\t\treturn;\n\tnilfs_segctor_do_flush(sci, NILFS_MDT_INODE(sb, ino) ? ino : 0);\n\t\t\t\t\t/* assign bit 0 to data files */\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nvoid nilfs_flush_segment(struct super_block *sb, ino_t ino)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tif (!sci || nilfs_doing_construction())\n\t\treturn;\n\tnilfs_segctor_do_flush(sci, NILFS_MDT_INODE(sb, ino) ? ino : 0);\n\t\t\t\t\t/* assign bit 0 to data files */\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_construct_segment",
          "args": [
            "sb"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_construct_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2168-2183",
          "snippet": "int nilfs_construct_segment(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info *ti;\n\tint err;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\t/* A call inside transactions causes a deadlock. */\n\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);\n\n\terr = nilfs_segctor_sync(sci);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_construct_segment(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info *ti;\n\tint err;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\t/* A call inside transactions causes a deadlock. */\n\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);\n\n\terr = nilfs_segctor_sync(sci);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_clear_dirty_page",
          "args": [
            "page",
            "false"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_clear_dirty_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "406-445",
          "snippet": "void nilfs_clear_dirty_page(struct page *page, bool silent)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!silent) {\n\t\tnilfs_warning(sb, __func__,\n\t\t\t\t\"discard page: offset %lld, ino %lu\",\n\t\t\t\tpage_offset(page), inode->i_ino);\n\t}\n\n\tClearPageUptodate(page);\n\tClearPageMappedToDisk(page);\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *bh, *head;\n\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tlock_buffer(bh);\n\t\t\tif (!silent) {\n\t\t\t\tnilfs_warning(sb, __func__,\n\t\t\t\t\t\"discard block %llu, size %zu\",\n\t\t\t\t\t(u64)bh->b_blocknr, bh->b_size);\n\t\t\t}\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_nilfs_volatile(bh);\n\t\t\tclear_buffer_nilfs_checked(bh);\n\t\t\tclear_buffer_nilfs_redirected(bh);\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tclear_buffer_mapped(bh);\n\t\t\tunlock_buffer(bh);\n\t\t} while (bh = bh->b_this_page, bh != head);\n\t}\n\n\t__nilfs_clear_page_dirty(page);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_clear_dirty_page(struct page *page, bool silent)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb = inode->i_sb;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!silent) {\n\t\tnilfs_warning(sb, __func__,\n\t\t\t\t\"discard page: offset %lld, ino %lu\",\n\t\t\t\tpage_offset(page), inode->i_ino);\n\t}\n\n\tClearPageUptodate(page);\n\tClearPageMappedToDisk(page);\n\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *bh, *head;\n\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tlock_buffer(bh);\n\t\t\tif (!silent) {\n\t\t\t\tnilfs_warning(sb, __func__,\n\t\t\t\t\t\"discard block %llu, size %zu\",\n\t\t\t\t\t(u64)bh->b_blocknr, bh->b_size);\n\t\t\t}\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_nilfs_volatile(bh);\n\t\t\tclear_buffer_nilfs_checked(bh);\n\t\t\tclear_buffer_nilfs_redirected(bh);\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tclear_buffer_mapped(bh);\n\t\t\tunlock_buffer(bh);\n\t\t} while (bh = bh->b_this_page, bh != head);\n\t}\n\n\t__nilfs_clear_page_dirty(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nstatic int\nnilfs_mdt_write_page(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct super_block *sb;\n\tint err = 0;\n\n\tif (inode && (inode->i_sb->s_flags & MS_RDONLY)) {\n\t\t/*\n\t\t * It means that filesystem was remounted in read-only\n\t\t * mode because of error or metadata corruption. But we\n\t\t * have dirty pages that try to be flushed in background.\n\t\t * So, here we simply discard this dirty page.\n\t\t */\n\t\tnilfs_clear_dirty_page(page, false);\n\t\tunlock_page(page);\n\t\treturn -EROFS;\n\t}\n\n\tredirty_page_for_writepage(wbc, page);\n\tunlock_page(page);\n\n\tif (!inode)\n\t\treturn 0;\n\n\tsb = inode->i_sb;\n\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\terr = nilfs_construct_segment(sb);\n\telse if (wbc->for_reclaim)\n\t\tnilfs_flush_segment(sb, inode->i_ino);\n\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_mdt_fetch_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
    "lines": "364-373",
    "snippet": "int nilfs_mdt_fetch_dirty(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\tif (nilfs_bmap_test_and_clear_dirty(ii->i_bmap)) {\n\t\tset_bit(NILFS_I_DIRTY, &ii->i_state);\n\t\treturn 1;\n\t}\n\treturn test_bit(NILFS_I_DIRTY, &ii->i_state);\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_I_DIRTY",
            "&ii->i_state"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NILFS_I_DIRTY",
            "&ii->i_state"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_test_and_clear_dirty",
          "args": [
            "ii->i_bmap"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_test_and_clear_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "414-423",
          "snippet": "int nilfs_bmap_test_and_clear_dirty(struct nilfs_bmap *bmap)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = nilfs_bmap_dirty(bmap);\n\tnilfs_bmap_clear_dirty(bmap);\n\tup_write(&bmap->b_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nint nilfs_bmap_test_and_clear_dirty(struct nilfs_bmap *bmap)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = nilfs_bmap_dirty(bmap);\n\tnilfs_bmap_clear_dirty(bmap);\n\tup_write(&bmap->b_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_mdt_fetch_dirty(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\tif (nilfs_bmap_test_and_clear_dirty(ii->i_bmap)) {\n\t\tset_bit(NILFS_I_DIRTY, &ii->i_state);\n\t\treturn 1;\n\t}\n\treturn test_bit(NILFS_I_DIRTY, &ii->i_state);\n}"
  },
  {
    "function_name": "nilfs_mdt_mark_block_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
    "lines": "350-362",
    "snippet": "int nilfs_mdt_mark_block_dirty(struct inode *inode, unsigned long block)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\terr = nilfs_mdt_read_block(inode, block, 0, &bh);\n\tif (unlikely(err))\n\t\treturn err;\n\tmark_buffer_dirty(bh);\n\tnilfs_mdt_mark_dirty(inode);\n\tbrelse(bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_mark_dirty",
          "args": [
            "inode"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "98-102",
          "snippet": "static inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_read_block",
          "args": [
            "inode",
            "block",
            "0",
            "&bh"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_read_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
          "lines": "173-216",
          "snippet": "static int nilfs_mdt_read_block(struct inode *inode, unsigned long block,\n\t\t\t\tint readahead, struct buffer_head **out_bh)\n{\n\tstruct buffer_head *first_bh, *bh;\n\tunsigned long blkoff;\n\tint i, nr_ra_blocks = NILFS_MDT_MAX_RA_BLOCKS;\n\tint err;\n\n\terr = nilfs_mdt_submit_block(inode, block, READ, &first_bh);\n\tif (err == -EEXIST) /* internal code */\n\t\tgoto out;\n\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tif (readahead) {\n\t\tblkoff = block + 1;\n\t\tfor (i = 0; i < nr_ra_blocks; i++, blkoff++) {\n\t\t\terr = nilfs_mdt_submit_block(inode, blkoff, READA, &bh);\n\t\t\tif (likely(!err || err == -EEXIST))\n\t\t\t\tbrelse(bh);\n\t\t\telse if (err != -EBUSY)\n\t\t\t\tbreak;\n\t\t\t\t/* abort readahead if bmap lookup failed */\n\t\t\tif (!buffer_locked(first_bh))\n\t\t\t\tgoto out_no_wait;\n\t\t}\n\t}\n\n\twait_on_buffer(first_bh);\n\n out_no_wait:\n\terr = -EIO;\n\tif (!buffer_uptodate(first_bh))\n\t\tgoto failed_bh;\n out:\n\t*out_bh = first_bh;\n\treturn 0;\n\n failed_bh:\n\tbrelse(first_bh);\n failed:\n\treturn err;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [
            "#define NILFS_MDT_MAX_RA_BLOCKS\t\t(16 - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\n#define NILFS_MDT_MAX_RA_BLOCKS\t\t(16 - 1)\n\nstatic int nilfs_mdt_read_block(struct inode *inode, unsigned long block,\n\t\t\t\tint readahead, struct buffer_head **out_bh)\n{\n\tstruct buffer_head *first_bh, *bh;\n\tunsigned long blkoff;\n\tint i, nr_ra_blocks = NILFS_MDT_MAX_RA_BLOCKS;\n\tint err;\n\n\terr = nilfs_mdt_submit_block(inode, block, READ, &first_bh);\n\tif (err == -EEXIST) /* internal code */\n\t\tgoto out;\n\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tif (readahead) {\n\t\tblkoff = block + 1;\n\t\tfor (i = 0; i < nr_ra_blocks; i++, blkoff++) {\n\t\t\terr = nilfs_mdt_submit_block(inode, blkoff, READA, &bh);\n\t\t\tif (likely(!err || err == -EEXIST))\n\t\t\t\tbrelse(bh);\n\t\t\telse if (err != -EBUSY)\n\t\t\t\tbreak;\n\t\t\t\t/* abort readahead if bmap lookup failed */\n\t\t\tif (!buffer_locked(first_bh))\n\t\t\t\tgoto out_no_wait;\n\t\t}\n\t}\n\n\twait_on_buffer(first_bh);\n\n out_no_wait:\n\terr = -EIO;\n\tif (!buffer_uptodate(first_bh))\n\t\tgoto failed_bh;\n out:\n\t*out_bh = first_bh;\n\treturn 0;\n\n failed_bh:\n\tbrelse(first_bh);\n failed:\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_mdt_mark_block_dirty(struct inode *inode, unsigned long block)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\terr = nilfs_mdt_read_block(inode, block, 0, &bh);\n\tif (unlikely(err))\n\t\treturn err;\n\tmark_buffer_dirty(bh);\n\tnilfs_mdt_mark_dirty(inode);\n\tbrelse(bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_mdt_forget_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
    "lines": "303-334",
    "snippet": "int nilfs_mdt_forget_block(struct inode *inode, unsigned long block)\n{\n\tpgoff_t index = (pgoff_t)block >>\n\t\t(PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tstruct page *page;\n\tunsigned long first_block;\n\tint ret = 0;\n\tint still_dirty;\n\n\tpage = find_lock_page(inode->i_mapping, index);\n\tif (!page)\n\t\treturn -ENOENT;\n\n\twait_on_page_writeback(page);\n\n\tfirst_block = (unsigned long)index <<\n\t\t(PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *bh;\n\n\t\tbh = nilfs_page_get_nth_block(page, block - first_block);\n\t\tnilfs_forget_buffer(bh);\n\t}\n\tstill_dirty = PageDirty(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (still_dirty ||\n\t    invalidate_inode_pages2_range(inode->i_mapping, index, index) != 0)\n\t\tret = -EBUSY;\n\treturn ret;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "invalidate_inode_pages2_range",
          "args": [
            "inode->i_mapping",
            "index",
            "index"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_forget_buffer",
          "args": [
            "bh"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_forget_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "89-109",
          "snippet": "void nilfs_forget_buffer(struct buffer_head *bh)\n{\n\tstruct page *page = bh->b_page;\n\n\tlock_buffer(bh);\n\tclear_buffer_nilfs_volatile(bh);\n\tclear_buffer_nilfs_checked(bh);\n\tclear_buffer_nilfs_redirected(bh);\n\tclear_buffer_async_write(bh);\n\tclear_buffer_dirty(bh);\n\tif (nilfs_page_buffers_clean(page))\n\t\t__nilfs_clear_page_dirty(page);\n\n\tclear_buffer_uptodate(bh);\n\tclear_buffer_mapped(bh);\n\tbh->b_blocknr = -1;\n\tClearPageUptodate(page);\n\tClearPageMappedToDisk(page);\n\tunlock_buffer(bh);\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_forget_buffer(struct buffer_head *bh)\n{\n\tstruct page *page = bh->b_page;\n\n\tlock_buffer(bh);\n\tclear_buffer_nilfs_volatile(bh);\n\tclear_buffer_nilfs_checked(bh);\n\tclear_buffer_nilfs_redirected(bh);\n\tclear_buffer_async_write(bh);\n\tclear_buffer_dirty(bh);\n\tif (nilfs_page_buffers_clean(page))\n\t\t__nilfs_clear_page_dirty(page);\n\n\tclear_buffer_uptodate(bh);\n\tclear_buffer_mapped(bh);\n\tbh->b_blocknr = -1;\n\tClearPageUptodate(page);\n\tClearPageMappedToDisk(page);\n\tunlock_buffer(bh);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_page_get_nth_block",
          "args": [
            "page",
            "block - first_block"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_page_get_nth_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.h",
          "lines": "69-78",
          "snippet": "static inline struct buffer_head *\nnilfs_page_get_nth_block(struct page *page, unsigned int count)\n{\n\tstruct buffer_head *bh = page_buffers(page);\n\n\twhile (count-- > 0)\n\t\tbh = bh->b_this_page;\n\tget_bh(bh);\n\treturn bh;\n}",
          "includes": [
            "#include \"nilfs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nilfs.h\"\n#include <linux/buffer_head.h>\n\nstatic inline struct buffer_head *\nnilfs_page_get_nth_block(struct page *page, unsigned int count)\n{\n\tstruct buffer_head *bh = page_buffers(page);\n\n\twhile (count-- > 0)\n\t\tbh = bh->b_this_page;\n\tget_bh(bh);\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_page",
          "args": [
            "inode->i_mapping",
            "index"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_mdt_forget_block(struct inode *inode, unsigned long block)\n{\n\tpgoff_t index = (pgoff_t)block >>\n\t\t(PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tstruct page *page;\n\tunsigned long first_block;\n\tint ret = 0;\n\tint still_dirty;\n\n\tpage = find_lock_page(inode->i_mapping, index);\n\tif (!page)\n\t\treturn -ENOENT;\n\n\twait_on_page_writeback(page);\n\n\tfirst_block = (unsigned long)index <<\n\t\t(PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *bh;\n\n\t\tbh = nilfs_page_get_nth_block(page, block - first_block);\n\t\tnilfs_forget_buffer(bh);\n\t}\n\tstill_dirty = PageDirty(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (still_dirty ||\n\t    invalidate_inode_pages2_range(inode->i_mapping, index, index) != 0)\n\t\tret = -EBUSY;\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_mdt_delete_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
    "lines": "275-286",
    "snippet": "int nilfs_mdt_delete_block(struct inode *inode, unsigned long block)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\terr = nilfs_bmap_delete(ii->i_bmap, block);\n\tif (!err || err == -ENOENT) {\n\t\tnilfs_mdt_mark_dirty(inode);\n\t\tnilfs_mdt_forget_block(inode, block);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_mdt_forget_block",
          "args": [
            "inode",
            "block"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_forget_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
          "lines": "303-334",
          "snippet": "int nilfs_mdt_forget_block(struct inode *inode, unsigned long block)\n{\n\tpgoff_t index = (pgoff_t)block >>\n\t\t(PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tstruct page *page;\n\tunsigned long first_block;\n\tint ret = 0;\n\tint still_dirty;\n\n\tpage = find_lock_page(inode->i_mapping, index);\n\tif (!page)\n\t\treturn -ENOENT;\n\n\twait_on_page_writeback(page);\n\n\tfirst_block = (unsigned long)index <<\n\t\t(PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *bh;\n\n\t\tbh = nilfs_page_get_nth_block(page, block - first_block);\n\t\tnilfs_forget_buffer(bh);\n\t}\n\tstill_dirty = PageDirty(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (still_dirty ||\n\t    invalidate_inode_pages2_range(inode->i_mapping, index, index) != 0)\n\t\tret = -EBUSY;\n\treturn ret;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_mdt_forget_block(struct inode *inode, unsigned long block)\n{\n\tpgoff_t index = (pgoff_t)block >>\n\t\t(PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tstruct page *page;\n\tunsigned long first_block;\n\tint ret = 0;\n\tint still_dirty;\n\n\tpage = find_lock_page(inode->i_mapping, index);\n\tif (!page)\n\t\treturn -ENOENT;\n\n\twait_on_page_writeback(page);\n\n\tfirst_block = (unsigned long)index <<\n\t\t(PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *bh;\n\n\t\tbh = nilfs_page_get_nth_block(page, block - first_block);\n\t\tnilfs_forget_buffer(bh);\n\t}\n\tstill_dirty = PageDirty(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (still_dirty ||\n\t    invalidate_inode_pages2_range(inode->i_mapping, index, index) != 0)\n\t\tret = -EBUSY;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_mark_dirty",
          "args": [
            "inode"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "98-102",
          "snippet": "static inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_delete",
          "args": [
            "ii->i_bmap",
            "block"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "227-236",
          "snippet": "int nilfs_bmap_delete(struct nilfs_bmap *bmap, unsigned long key)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = nilfs_bmap_do_delete(bmap, key);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nint nilfs_bmap_delete(struct nilfs_bmap *bmap, unsigned long key)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = nilfs_bmap_do_delete(bmap, key);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_mdt_delete_block(struct inode *inode, unsigned long block)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\terr = nilfs_bmap_delete(ii->i_bmap, block);\n\tif (!err || err == -ENOENT) {\n\t\tnilfs_mdt_mark_dirty(inode);\n\t\tnilfs_mdt_forget_block(inode, block);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_mdt_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
    "lines": "242-261",
    "snippet": "int nilfs_mdt_get_block(struct inode *inode, unsigned long blkoff, int create,\n\t\t\tvoid (*init_block)(struct inode *,\n\t\t\t\t\t   struct buffer_head *, void *),\n\t\t\tstruct buffer_head **out_bh)\n{\n\tint ret;\n\n\t/* Should be rewritten with merging nilfs_mdt_read_block() */\n retry:\n\tret = nilfs_mdt_read_block(inode, blkoff, !create, out_bh);\n\tif (!create || ret != -ENOENT)\n\t\treturn ret;\n\n\tret = nilfs_mdt_create_block(inode, blkoff, out_bh, init_block);\n\tif (unlikely(ret == -EEXIST)) {\n\t\t/* create = 0; */  /* limit read-create loop retries */\n\t\tgoto retry;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == -EEXIST"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_create_block",
          "args": [
            "inode",
            "blkoff",
            "out_bh",
            "init_block"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_create_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
          "lines": "74-119",
          "snippet": "static int nilfs_mdt_create_block(struct inode *inode, unsigned long block,\n\t\t\t\t  struct buffer_head **out_bh,\n\t\t\t\t  void (*init_block)(struct inode *,\n\t\t\t\t\t\t     struct buffer_head *,\n\t\t\t\t\t\t     void *))\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct nilfs_transaction_info ti;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tnilfs_transaction_begin(sb, &ti, 0);\n\n\terr = -ENOMEM;\n\tbh = nilfs_grab_buffer(inode, inode->i_mapping, block, 0);\n\tif (unlikely(!bh))\n\t\tgoto failed_unlock;\n\n\terr = -EEXIST;\n\tif (buffer_uptodate(bh))\n\t\tgoto failed_bh;\n\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\tgoto failed_bh;\n\n\tbh->b_bdev = sb->s_bdev;\n\terr = nilfs_mdt_insert_new_block(inode, block, bh, init_block);\n\tif (likely(!err)) {\n\t\tget_bh(bh);\n\t\t*out_bh = bh;\n\t}\n\n failed_bh:\n\tunlock_page(bh->b_page);\n\tpage_cache_release(bh->b_page);\n\tbrelse(bh);\n\n failed_unlock:\n\tif (likely(!err))\n\t\terr = nilfs_transaction_commit(sb);\n\telse\n\t\tnilfs_transaction_abort(sb);\n\n\treturn err;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_mdt_create_block(struct inode *inode, unsigned long block,\n\t\t\t\t  struct buffer_head **out_bh,\n\t\t\t\t  void (*init_block)(struct inode *,\n\t\t\t\t\t\t     struct buffer_head *,\n\t\t\t\t\t\t     void *))\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct nilfs_transaction_info ti;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tnilfs_transaction_begin(sb, &ti, 0);\n\n\terr = -ENOMEM;\n\tbh = nilfs_grab_buffer(inode, inode->i_mapping, block, 0);\n\tif (unlikely(!bh))\n\t\tgoto failed_unlock;\n\n\terr = -EEXIST;\n\tif (buffer_uptodate(bh))\n\t\tgoto failed_bh;\n\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\tgoto failed_bh;\n\n\tbh->b_bdev = sb->s_bdev;\n\terr = nilfs_mdt_insert_new_block(inode, block, bh, init_block);\n\tif (likely(!err)) {\n\t\tget_bh(bh);\n\t\t*out_bh = bh;\n\t}\n\n failed_bh:\n\tunlock_page(bh->b_page);\n\tpage_cache_release(bh->b_page);\n\tbrelse(bh);\n\n failed_unlock:\n\tif (likely(!err))\n\t\terr = nilfs_transaction_commit(sb);\n\telse\n\t\tnilfs_transaction_abort(sb);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_read_block",
          "args": [
            "inode",
            "blkoff",
            "!create",
            "out_bh"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_read_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
          "lines": "173-216",
          "snippet": "static int nilfs_mdt_read_block(struct inode *inode, unsigned long block,\n\t\t\t\tint readahead, struct buffer_head **out_bh)\n{\n\tstruct buffer_head *first_bh, *bh;\n\tunsigned long blkoff;\n\tint i, nr_ra_blocks = NILFS_MDT_MAX_RA_BLOCKS;\n\tint err;\n\n\terr = nilfs_mdt_submit_block(inode, block, READ, &first_bh);\n\tif (err == -EEXIST) /* internal code */\n\t\tgoto out;\n\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tif (readahead) {\n\t\tblkoff = block + 1;\n\t\tfor (i = 0; i < nr_ra_blocks; i++, blkoff++) {\n\t\t\terr = nilfs_mdt_submit_block(inode, blkoff, READA, &bh);\n\t\t\tif (likely(!err || err == -EEXIST))\n\t\t\t\tbrelse(bh);\n\t\t\telse if (err != -EBUSY)\n\t\t\t\tbreak;\n\t\t\t\t/* abort readahead if bmap lookup failed */\n\t\t\tif (!buffer_locked(first_bh))\n\t\t\t\tgoto out_no_wait;\n\t\t}\n\t}\n\n\twait_on_buffer(first_bh);\n\n out_no_wait:\n\terr = -EIO;\n\tif (!buffer_uptodate(first_bh))\n\t\tgoto failed_bh;\n out:\n\t*out_bh = first_bh;\n\treturn 0;\n\n failed_bh:\n\tbrelse(first_bh);\n failed:\n\treturn err;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [
            "#define NILFS_MDT_MAX_RA_BLOCKS\t\t(16 - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\n#define NILFS_MDT_MAX_RA_BLOCKS\t\t(16 - 1)\n\nstatic int nilfs_mdt_read_block(struct inode *inode, unsigned long block,\n\t\t\t\tint readahead, struct buffer_head **out_bh)\n{\n\tstruct buffer_head *first_bh, *bh;\n\tunsigned long blkoff;\n\tint i, nr_ra_blocks = NILFS_MDT_MAX_RA_BLOCKS;\n\tint err;\n\n\terr = nilfs_mdt_submit_block(inode, block, READ, &first_bh);\n\tif (err == -EEXIST) /* internal code */\n\t\tgoto out;\n\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tif (readahead) {\n\t\tblkoff = block + 1;\n\t\tfor (i = 0; i < nr_ra_blocks; i++, blkoff++) {\n\t\t\terr = nilfs_mdt_submit_block(inode, blkoff, READA, &bh);\n\t\t\tif (likely(!err || err == -EEXIST))\n\t\t\t\tbrelse(bh);\n\t\t\telse if (err != -EBUSY)\n\t\t\t\tbreak;\n\t\t\t\t/* abort readahead if bmap lookup failed */\n\t\t\tif (!buffer_locked(first_bh))\n\t\t\t\tgoto out_no_wait;\n\t\t}\n\t}\n\n\twait_on_buffer(first_bh);\n\n out_no_wait:\n\terr = -EIO;\n\tif (!buffer_uptodate(first_bh))\n\t\tgoto failed_bh;\n out:\n\t*out_bh = first_bh;\n\treturn 0;\n\n failed_bh:\n\tbrelse(first_bh);\n failed:\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_mdt_get_block(struct inode *inode, unsigned long blkoff, int create,\n\t\t\tvoid (*init_block)(struct inode *,\n\t\t\t\t\t   struct buffer_head *, void *),\n\t\t\tstruct buffer_head **out_bh)\n{\n\tint ret;\n\n\t/* Should be rewritten with merging nilfs_mdt_read_block() */\n retry:\n\tret = nilfs_mdt_read_block(inode, blkoff, !create, out_bh);\n\tif (!create || ret != -ENOENT)\n\t\treturn ret;\n\n\tret = nilfs_mdt_create_block(inode, blkoff, out_bh, init_block);\n\tif (unlikely(ret == -EEXIST)) {\n\t\t/* create = 0; */  /* limit read-create loop retries */\n\t\tgoto retry;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_mdt_read_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
    "lines": "173-216",
    "snippet": "static int nilfs_mdt_read_block(struct inode *inode, unsigned long block,\n\t\t\t\tint readahead, struct buffer_head **out_bh)\n{\n\tstruct buffer_head *first_bh, *bh;\n\tunsigned long blkoff;\n\tint i, nr_ra_blocks = NILFS_MDT_MAX_RA_BLOCKS;\n\tint err;\n\n\terr = nilfs_mdt_submit_block(inode, block, READ, &first_bh);\n\tif (err == -EEXIST) /* internal code */\n\t\tgoto out;\n\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tif (readahead) {\n\t\tblkoff = block + 1;\n\t\tfor (i = 0; i < nr_ra_blocks; i++, blkoff++) {\n\t\t\terr = nilfs_mdt_submit_block(inode, blkoff, READA, &bh);\n\t\t\tif (likely(!err || err == -EEXIST))\n\t\t\t\tbrelse(bh);\n\t\t\telse if (err != -EBUSY)\n\t\t\t\tbreak;\n\t\t\t\t/* abort readahead if bmap lookup failed */\n\t\t\tif (!buffer_locked(first_bh))\n\t\t\t\tgoto out_no_wait;\n\t\t}\n\t}\n\n\twait_on_buffer(first_bh);\n\n out_no_wait:\n\terr = -EIO;\n\tif (!buffer_uptodate(first_bh))\n\t\tgoto failed_bh;\n out:\n\t*out_bh = first_bh;\n\treturn 0;\n\n failed_bh:\n\tbrelse(first_bh);\n failed:\n\treturn err;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [
      "#define NILFS_MDT_MAX_RA_BLOCKS\t\t(16 - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "first_bh"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "first_bh"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "first_bh"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "first_bh"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err || err == -EEXIST"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_submit_block",
          "args": [
            "inode",
            "blkoff",
            "READA",
            "&bh"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_submit_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
          "lines": "121-171",
          "snippet": "static int\nnilfs_mdt_submit_block(struct inode *inode, unsigned long blkoff,\n\t\t       int mode, struct buffer_head **out_bh)\n{\n\tstruct buffer_head *bh;\n\t__u64 blknum = 0;\n\tint ret = -ENOMEM;\n\n\tbh = nilfs_grab_buffer(inode, inode->i_mapping, blkoff, 0);\n\tif (unlikely(!bh))\n\t\tgoto failed;\n\n\tret = -EEXIST; /* internal code */\n\tif (buffer_uptodate(bh))\n\t\tgoto out;\n\n\tif (mode == READA) {\n\t\tif (!trylock_buffer(bh)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto failed_bh;\n\t\t}\n\t} else /* mode == READ */\n\t\tlock_buffer(bh);\n\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto out;\n\t}\n\n\tret = nilfs_bmap_lookup(NILFS_I(inode)->i_bmap, blkoff, &blknum);\n\tif (unlikely(ret)) {\n\t\tunlock_buffer(bh);\n\t\tgoto failed_bh;\n\t}\n\tmap_bh(bh, inode->i_sb, (sector_t)blknum);\n\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(mode, bh);\n\tret = 0;\n out:\n\tget_bh(bh);\n\t*out_bh = bh;\n\n failed_bh:\n\tunlock_page(bh->b_page);\n\tpage_cache_release(bh->b_page);\n\tbrelse(bh);\n failed:\n\treturn ret;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nstatic int\nnilfs_mdt_submit_block(struct inode *inode, unsigned long blkoff,\n\t\t       int mode, struct buffer_head **out_bh)\n{\n\tstruct buffer_head *bh;\n\t__u64 blknum = 0;\n\tint ret = -ENOMEM;\n\n\tbh = nilfs_grab_buffer(inode, inode->i_mapping, blkoff, 0);\n\tif (unlikely(!bh))\n\t\tgoto failed;\n\n\tret = -EEXIST; /* internal code */\n\tif (buffer_uptodate(bh))\n\t\tgoto out;\n\n\tif (mode == READA) {\n\t\tif (!trylock_buffer(bh)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto failed_bh;\n\t\t}\n\t} else /* mode == READ */\n\t\tlock_buffer(bh);\n\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto out;\n\t}\n\n\tret = nilfs_bmap_lookup(NILFS_I(inode)->i_bmap, blkoff, &blknum);\n\tif (unlikely(ret)) {\n\t\tunlock_buffer(bh);\n\t\tgoto failed_bh;\n\t}\n\tmap_bh(bh, inode->i_sb, (sector_t)blknum);\n\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(mode, bh);\n\tret = 0;\n out:\n\tget_bh(bh);\n\t*out_bh = bh;\n\n failed_bh:\n\tunlock_page(bh->b_page);\n\tpage_cache_release(bh->b_page);\n\tbrelse(bh);\n failed:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\n#define NILFS_MDT_MAX_RA_BLOCKS\t\t(16 - 1)\n\nstatic int nilfs_mdt_read_block(struct inode *inode, unsigned long block,\n\t\t\t\tint readahead, struct buffer_head **out_bh)\n{\n\tstruct buffer_head *first_bh, *bh;\n\tunsigned long blkoff;\n\tint i, nr_ra_blocks = NILFS_MDT_MAX_RA_BLOCKS;\n\tint err;\n\n\terr = nilfs_mdt_submit_block(inode, block, READ, &first_bh);\n\tif (err == -EEXIST) /* internal code */\n\t\tgoto out;\n\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\tif (readahead) {\n\t\tblkoff = block + 1;\n\t\tfor (i = 0; i < nr_ra_blocks; i++, blkoff++) {\n\t\t\terr = nilfs_mdt_submit_block(inode, blkoff, READA, &bh);\n\t\t\tif (likely(!err || err == -EEXIST))\n\t\t\t\tbrelse(bh);\n\t\t\telse if (err != -EBUSY)\n\t\t\t\tbreak;\n\t\t\t\t/* abort readahead if bmap lookup failed */\n\t\t\tif (!buffer_locked(first_bh))\n\t\t\t\tgoto out_no_wait;\n\t\t}\n\t}\n\n\twait_on_buffer(first_bh);\n\n out_no_wait:\n\terr = -EIO;\n\tif (!buffer_uptodate(first_bh))\n\t\tgoto failed_bh;\n out:\n\t*out_bh = first_bh;\n\treturn 0;\n\n failed_bh:\n\tbrelse(first_bh);\n failed:\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_mdt_submit_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
    "lines": "121-171",
    "snippet": "static int\nnilfs_mdt_submit_block(struct inode *inode, unsigned long blkoff,\n\t\t       int mode, struct buffer_head **out_bh)\n{\n\tstruct buffer_head *bh;\n\t__u64 blknum = 0;\n\tint ret = -ENOMEM;\n\n\tbh = nilfs_grab_buffer(inode, inode->i_mapping, blkoff, 0);\n\tif (unlikely(!bh))\n\t\tgoto failed;\n\n\tret = -EEXIST; /* internal code */\n\tif (buffer_uptodate(bh))\n\t\tgoto out;\n\n\tif (mode == READA) {\n\t\tif (!trylock_buffer(bh)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto failed_bh;\n\t\t}\n\t} else /* mode == READ */\n\t\tlock_buffer(bh);\n\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto out;\n\t}\n\n\tret = nilfs_bmap_lookup(NILFS_I(inode)->i_bmap, blkoff, &blknum);\n\tif (unlikely(ret)) {\n\t\tunlock_buffer(bh);\n\t\tgoto failed_bh;\n\t}\n\tmap_bh(bh, inode->i_sb, (sector_t)blknum);\n\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(mode, bh);\n\tret = 0;\n out:\n\tget_bh(bh);\n\t*out_bh = bh;\n\n failed_bh:\n\tunlock_page(bh->b_page);\n\tpage_cache_release(bh->b_page);\n\tbrelse(bh);\n failed:\n\treturn ret;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "bh->b_page"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "bh->b_page"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "mode",
            "bh"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh",
            "inode->i_sb",
            "(sector_t)blknum"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_lookup",
          "args": [
            "NILFS_I(inode)->i_bmap",
            "blkoff",
            "&blknum"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.h",
          "lines": "173-177",
          "snippet": "static inline int nilfs_bmap_lookup(struct nilfs_bmap *bmap, __u64 key,\n\t\t\t\t    __u64 *ptr)\n{\n\treturn nilfs_bmap_lookup_at_level(bmap, key, 1, ptr);\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"alloc.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"alloc.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nstatic inline int nilfs_bmap_lookup(struct nilfs_bmap *bmap, __u64 key,\n\t\t\t\t    __u64 *ptr)\n{\n\treturn nilfs_bmap_lookup_at_level(bmap, key, 1, ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_buffer",
          "args": [
            "bh"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_grab_buffer",
          "args": [
            "inode",
            "inode->i_mapping",
            "blkoff",
            "0"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_grab_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "61-82",
          "snippet": "struct buffer_head *nilfs_grab_buffer(struct inode *inode,\n\t\t\t\t      struct address_space *mapping,\n\t\t\t\t      unsigned long blkoff,\n\t\t\t\t      unsigned long b_state)\n{\n\tint blkbits = inode->i_blkbits;\n\tpgoff_t index = blkoff >> (PAGE_CACHE_SHIFT - blkbits);\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\n\tpage = grab_cache_page(mapping, index);\n\tif (unlikely(!page))\n\t\treturn NULL;\n\n\tbh = __nilfs_get_page_block(page, blkoff, index, blkbits, b_state);\n\tif (unlikely(!bh)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstruct buffer_head *nilfs_grab_buffer(struct inode *inode,\n\t\t\t\t      struct address_space *mapping,\n\t\t\t\t      unsigned long blkoff,\n\t\t\t\t      unsigned long b_state)\n{\n\tint blkbits = inode->i_blkbits;\n\tpgoff_t index = blkoff >> (PAGE_CACHE_SHIFT - blkbits);\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\n\tpage = grab_cache_page(mapping, index);\n\tif (unlikely(!page))\n\t\treturn NULL;\n\n\tbh = __nilfs_get_page_block(page, blkoff, index, blkbits, b_state);\n\tif (unlikely(!bh)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nstatic int\nnilfs_mdt_submit_block(struct inode *inode, unsigned long blkoff,\n\t\t       int mode, struct buffer_head **out_bh)\n{\n\tstruct buffer_head *bh;\n\t__u64 blknum = 0;\n\tint ret = -ENOMEM;\n\n\tbh = nilfs_grab_buffer(inode, inode->i_mapping, blkoff, 0);\n\tif (unlikely(!bh))\n\t\tgoto failed;\n\n\tret = -EEXIST; /* internal code */\n\tif (buffer_uptodate(bh))\n\t\tgoto out;\n\n\tif (mode == READA) {\n\t\tif (!trylock_buffer(bh)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto failed_bh;\n\t\t}\n\t} else /* mode == READ */\n\t\tlock_buffer(bh);\n\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto out;\n\t}\n\n\tret = nilfs_bmap_lookup(NILFS_I(inode)->i_bmap, blkoff, &blknum);\n\tif (unlikely(ret)) {\n\t\tunlock_buffer(bh);\n\t\tgoto failed_bh;\n\t}\n\tmap_bh(bh, inode->i_sb, (sector_t)blknum);\n\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(mode, bh);\n\tret = 0;\n out:\n\tget_bh(bh);\n\t*out_bh = bh;\n\n failed_bh:\n\tunlock_page(bh->b_page);\n\tpage_cache_release(bh->b_page);\n\tbrelse(bh);\n failed:\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_mdt_create_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
    "lines": "74-119",
    "snippet": "static int nilfs_mdt_create_block(struct inode *inode, unsigned long block,\n\t\t\t\t  struct buffer_head **out_bh,\n\t\t\t\t  void (*init_block)(struct inode *,\n\t\t\t\t\t\t     struct buffer_head *,\n\t\t\t\t\t\t     void *))\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct nilfs_transaction_info ti;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tnilfs_transaction_begin(sb, &ti, 0);\n\n\terr = -ENOMEM;\n\tbh = nilfs_grab_buffer(inode, inode->i_mapping, block, 0);\n\tif (unlikely(!bh))\n\t\tgoto failed_unlock;\n\n\terr = -EEXIST;\n\tif (buffer_uptodate(bh))\n\t\tgoto failed_bh;\n\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\tgoto failed_bh;\n\n\tbh->b_bdev = sb->s_bdev;\n\terr = nilfs_mdt_insert_new_block(inode, block, bh, init_block);\n\tif (likely(!err)) {\n\t\tget_bh(bh);\n\t\t*out_bh = bh;\n\t}\n\n failed_bh:\n\tunlock_page(bh->b_page);\n\tpage_cache_release(bh->b_page);\n\tbrelse(bh);\n\n failed_unlock:\n\tif (likely(!err))\n\t\terr = nilfs_transaction_commit(sb);\n\telse\n\t\tnilfs_transaction_abort(sb);\n\n\treturn err;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_transaction_abort",
          "args": [
            "sb"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "254-270",
          "snippet": "void nilfs_transaction_abort(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn;\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_transaction_abort(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn;\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_commit",
          "args": [
            "sb"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "223-252",
          "snippet": "int nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "bh->b_page"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "bh->b_page"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_insert_new_block",
          "args": [
            "inode",
            "block",
            "bh",
            "init_block"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_insert_new_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
          "lines": "40-72",
          "snippet": "static int\nnilfs_mdt_insert_new_block(struct inode *inode, unsigned long block,\n\t\t\t   struct buffer_head *bh,\n\t\t\t   void (*init_block)(struct inode *,\n\t\t\t\t\t      struct buffer_head *, void *))\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tvoid *kaddr;\n\tint ret;\n\n\t/* Caller exclude read accesses using page lock */\n\n\t/* set_buffer_new(bh); */\n\tbh->b_blocknr = 0;\n\n\tret = nilfs_bmap_insert(ii->i_bmap, block, (unsigned long)bh);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tset_buffer_mapped(bh);\n\n\tkaddr = kmap_atomic(bh->b_page);\n\tmemset(kaddr + bh_offset(bh), 0, 1 << inode->i_blkbits);\n\tif (init_block)\n\t\tinit_block(inode, bh, kaddr);\n\tflush_dcache_page(bh->b_page);\n\tkunmap_atomic(kaddr);\n\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\tnilfs_mdt_mark_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nstatic int\nnilfs_mdt_insert_new_block(struct inode *inode, unsigned long block,\n\t\t\t   struct buffer_head *bh,\n\t\t\t   void (*init_block)(struct inode *,\n\t\t\t\t\t      struct buffer_head *, void *))\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tvoid *kaddr;\n\tint ret;\n\n\t/* Caller exclude read accesses using page lock */\n\n\t/* set_buffer_new(bh); */\n\tbh->b_blocknr = 0;\n\n\tret = nilfs_bmap_insert(ii->i_bmap, block, (unsigned long)bh);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tset_buffer_mapped(bh);\n\n\tkaddr = kmap_atomic(bh->b_page);\n\tmemset(kaddr + bh_offset(bh), 0, 1 << inode->i_blkbits);\n\tif (init_block)\n\t\tinit_block(inode, bh, kaddr);\n\tflush_dcache_page(bh->b_page);\n\tkunmap_atomic(kaddr);\n\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\tnilfs_mdt_mark_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_grab_buffer",
          "args": [
            "inode",
            "inode->i_mapping",
            "block",
            "0"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_grab_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "61-82",
          "snippet": "struct buffer_head *nilfs_grab_buffer(struct inode *inode,\n\t\t\t\t      struct address_space *mapping,\n\t\t\t\t      unsigned long blkoff,\n\t\t\t\t      unsigned long b_state)\n{\n\tint blkbits = inode->i_blkbits;\n\tpgoff_t index = blkoff >> (PAGE_CACHE_SHIFT - blkbits);\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\n\tpage = grab_cache_page(mapping, index);\n\tif (unlikely(!page))\n\t\treturn NULL;\n\n\tbh = __nilfs_get_page_block(page, blkoff, index, blkbits, b_state);\n\tif (unlikely(!bh)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstruct buffer_head *nilfs_grab_buffer(struct inode *inode,\n\t\t\t\t      struct address_space *mapping,\n\t\t\t\t      unsigned long blkoff,\n\t\t\t\t      unsigned long b_state)\n{\n\tint blkbits = inode->i_blkbits;\n\tpgoff_t index = blkoff >> (PAGE_CACHE_SHIFT - blkbits);\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\n\tpage = grab_cache_page(mapping, index);\n\tif (unlikely(!page))\n\t\treturn NULL;\n\n\tbh = __nilfs_get_page_block(page, blkoff, index, blkbits, b_state);\n\tif (unlikely(!bh)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_begin",
          "args": [
            "sb",
            "&ti",
            "0"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "180-210",
          "snippet": "int nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nint nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_mdt_create_block(struct inode *inode, unsigned long block,\n\t\t\t\t  struct buffer_head **out_bh,\n\t\t\t\t  void (*init_block)(struct inode *,\n\t\t\t\t\t\t     struct buffer_head *,\n\t\t\t\t\t\t     void *))\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct nilfs_transaction_info ti;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tnilfs_transaction_begin(sb, &ti, 0);\n\n\terr = -ENOMEM;\n\tbh = nilfs_grab_buffer(inode, inode->i_mapping, block, 0);\n\tif (unlikely(!bh))\n\t\tgoto failed_unlock;\n\n\terr = -EEXIST;\n\tif (buffer_uptodate(bh))\n\t\tgoto failed_bh;\n\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\tgoto failed_bh;\n\n\tbh->b_bdev = sb->s_bdev;\n\terr = nilfs_mdt_insert_new_block(inode, block, bh, init_block);\n\tif (likely(!err)) {\n\t\tget_bh(bh);\n\t\t*out_bh = bh;\n\t}\n\n failed_bh:\n\tunlock_page(bh->b_page);\n\tpage_cache_release(bh->b_page);\n\tbrelse(bh);\n\n failed_unlock:\n\tif (likely(!err))\n\t\terr = nilfs_transaction_commit(sb);\n\telse\n\t\tnilfs_transaction_abort(sb);\n\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_mdt_insert_new_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
    "lines": "40-72",
    "snippet": "static int\nnilfs_mdt_insert_new_block(struct inode *inode, unsigned long block,\n\t\t\t   struct buffer_head *bh,\n\t\t\t   void (*init_block)(struct inode *,\n\t\t\t\t\t      struct buffer_head *, void *))\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tvoid *kaddr;\n\tint ret;\n\n\t/* Caller exclude read accesses using page lock */\n\n\t/* set_buffer_new(bh); */\n\tbh->b_blocknr = 0;\n\n\tret = nilfs_bmap_insert(ii->i_bmap, block, (unsigned long)bh);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tset_buffer_mapped(bh);\n\n\tkaddr = kmap_atomic(bh->b_page);\n\tmemset(kaddr + bh_offset(bh), 0, 1 << inode->i_blkbits);\n\tif (init_block)\n\t\tinit_block(inode, bh, kaddr);\n\tflush_dcache_page(bh->b_page);\n\tkunmap_atomic(kaddr);\n\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\tnilfs_mdt_mark_dirty(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"mdt.h\"",
      "#include \"page.h\"",
      "#include \"segment.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mm.h>",
      "#include <linux/mpage.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_mdt_mark_dirty",
          "args": [
            "inode"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "98-102",
          "snippet": "static inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "bh->b_page"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_block",
          "args": [
            "inode",
            "bh",
            "kaddr"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr + bh_offset(bh)",
            "0",
            "1 << inode->i_blkbits"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "bh->b_page"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_insert",
          "args": [
            "ii->i_bmap",
            "block",
            "(unsigned long)bh"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "155-166",
          "snippet": "int nilfs_bmap_insert(struct nilfs_bmap *bmap,\n\t\t      unsigned long key,\n\t\t      unsigned long rec)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = nilfs_bmap_do_insert(bmap, key, rec);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nint nilfs_bmap_insert(struct nilfs_bmap *bmap,\n\t\t      unsigned long key,\n\t\t      unsigned long rec)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = nilfs_bmap_do_insert(bmap, key, rec);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nstatic int\nnilfs_mdt_insert_new_block(struct inode *inode, unsigned long block,\n\t\t\t   struct buffer_head *bh,\n\t\t\t   void (*init_block)(struct inode *,\n\t\t\t\t\t      struct buffer_head *, void *))\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tvoid *kaddr;\n\tint ret;\n\n\t/* Caller exclude read accesses using page lock */\n\n\t/* set_buffer_new(bh); */\n\tbh->b_blocknr = 0;\n\n\tret = nilfs_bmap_insert(ii->i_bmap, block, (unsigned long)bh);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tset_buffer_mapped(bh);\n\n\tkaddr = kmap_atomic(bh->b_page);\n\tmemset(kaddr + bh_offset(bh), 0, 1 << inode->i_blkbits);\n\tif (init_block)\n\t\tinit_block(inode, bh, kaddr);\n\tflush_dcache_page(bh->b_page);\n\tkunmap_atomic(kaddr);\n\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\tnilfs_mdt_mark_dirty(inode);\n\treturn 0;\n}"
  }
]