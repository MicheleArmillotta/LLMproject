[
  {
    "function_name": "btrfs_ioctl_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "5708-6003",
    "snippet": "long btrfs_ioctl_send(struct file *mnt_file, void __user *arg_)\n{\n\tint ret = 0;\n\tstruct btrfs_root *send_root;\n\tstruct btrfs_root *clone_root;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_ioctl_send_args *arg = NULL;\n\tstruct btrfs_key key;\n\tstruct send_ctx *sctx = NULL;\n\tu32 i;\n\tu64 *clone_sources_tmp = NULL;\n\tint clone_sources_to_rollback = 0;\n\tint sort_clone_roots = 0;\n\tint index;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tsend_root = BTRFS_I(file_inode(mnt_file))->root;\n\tfs_info = send_root->fs_info;\n\n\t/*\n\t * The subvolume must remain read-only during send, protect against\n\t * making it RW. This also protects against deletion.\n\t */\n\tspin_lock(&send_root->root_item_lock);\n\tsend_root->send_in_progress++;\n\tspin_unlock(&send_root->root_item_lock);\n\n\t/*\n\t * This is done when we lookup the root, it should already be complete\n\t * by the time we get here.\n\t */\n\tWARN_ON(send_root->orphan_cleanup_state != ORPHAN_CLEANUP_DONE);\n\n\t/*\n\t * Userspace tools do the checks and warn the user if it's\n\t * not RO.\n\t */\n\tif (!btrfs_root_readonly(send_root)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\targ = memdup_user(arg_, sizeof(*arg));\n\tif (IS_ERR(arg)) {\n\t\tret = PTR_ERR(arg);\n\t\targ = NULL;\n\t\tgoto out;\n\t}\n\n\tif (!access_ok(VERIFY_READ, arg->clone_sources,\n\t\t\tsizeof(*arg->clone_sources) *\n\t\t\targ->clone_sources_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (arg->flags & ~BTRFS_SEND_FLAG_MASK) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsctx = kzalloc(sizeof(struct send_ctx), GFP_NOFS);\n\tif (!sctx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tINIT_LIST_HEAD(&sctx->new_refs);\n\tINIT_LIST_HEAD(&sctx->deleted_refs);\n\tINIT_RADIX_TREE(&sctx->name_cache, GFP_NOFS);\n\tINIT_LIST_HEAD(&sctx->name_cache_list);\n\n\tsctx->flags = arg->flags;\n\n\tsctx->send_filp = fget(arg->send_fd);\n\tif (!sctx->send_filp) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tsctx->send_root = send_root;\n\t/*\n\t * Unlikely but possible, if the subvolume is marked for deletion but\n\t * is slow to remove the directory entry, send can still be started\n\t */\n\tif (btrfs_root_dead(sctx->send_root)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tsctx->clone_roots_cnt = arg->clone_sources_count;\n\n\tsctx->send_max_size = BTRFS_SEND_BUF_SIZE;\n\tsctx->send_buf = vmalloc(sctx->send_max_size);\n\tif (!sctx->send_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsctx->read_buf = vmalloc(BTRFS_SEND_READ_SIZE);\n\tif (!sctx->read_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsctx->pending_dir_moves = RB_ROOT;\n\tsctx->waiting_dir_moves = RB_ROOT;\n\tsctx->orphan_dirs = RB_ROOT;\n\n\tsctx->clone_roots = vzalloc(sizeof(struct clone_root) *\n\t\t\t(arg->clone_sources_count + 1));\n\tif (!sctx->clone_roots) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (arg->clone_sources_count) {\n\t\tclone_sources_tmp = vmalloc(arg->clone_sources_count *\n\t\t\t\tsizeof(*arg->clone_sources));\n\t\tif (!clone_sources_tmp) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = copy_from_user(clone_sources_tmp, arg->clone_sources,\n\t\t\t\targ->clone_sources_count *\n\t\t\t\tsizeof(*arg->clone_sources));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < arg->clone_sources_count; i++) {\n\t\t\tkey.objectid = clone_sources_tmp[i];\n\t\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\t\tkey.offset = (u64)-1;\n\n\t\t\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\n\t\t\tclone_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\t\t\tif (IS_ERR(clone_root)) {\n\t\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\t\tret = PTR_ERR(clone_root);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tclone_sources_to_rollback = i + 1;\n\t\t\tspin_lock(&clone_root->root_item_lock);\n\t\t\tclone_root->send_in_progress++;\n\t\t\tif (!btrfs_root_readonly(clone_root)) {\n\t\t\t\tspin_unlock(&clone_root->root_item_lock);\n\t\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\t\tret = -EPERM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tspin_unlock(&clone_root->root_item_lock);\n\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\n\t\t\tsctx->clone_roots[i].root = clone_root;\n\t\t}\n\t\tvfree(clone_sources_tmp);\n\t\tclone_sources_tmp = NULL;\n\t}\n\n\tif (arg->parent_root) {\n\t\tkey.objectid = arg->parent_root;\n\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\tkey.offset = (u64)-1;\n\n\t\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\n\t\tsctx->parent_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\t\tif (IS_ERR(sctx->parent_root)) {\n\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\tret = PTR_ERR(sctx->parent_root);\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock(&sctx->parent_root->root_item_lock);\n\t\tsctx->parent_root->send_in_progress++;\n\t\tif (!btrfs_root_readonly(sctx->parent_root) ||\n\t\t\t\tbtrfs_root_dead(sctx->parent_root)) {\n\t\t\tspin_unlock(&sctx->parent_root->root_item_lock);\n\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&sctx->parent_root->root_item_lock);\n\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t}\n\n\t/*\n\t * Clones from send_root are allowed, but only if the clone source\n\t * is behind the current send position. This is checked while searching\n\t * for possible clone sources.\n\t */\n\tsctx->clone_roots[sctx->clone_roots_cnt++].root = sctx->send_root;\n\n\t/* We do a bsearch later */\n\tsort(sctx->clone_roots, sctx->clone_roots_cnt,\n\t\t\tsizeof(*sctx->clone_roots), __clone_root_cmp_sort,\n\t\t\tNULL);\n\tsort_clone_roots = 1;\n\n\tret = ensure_commit_roots_uptodate(sctx);\n\tif (ret)\n\t\tgoto out;\n\n\tcurrent->journal_info = BTRFS_SEND_TRANS_STUB;\n\tret = send_subvol(sctx);\n\tcurrent->journal_info = NULL;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!(sctx->flags & BTRFS_SEND_FLAG_OMIT_END_CMD)) {\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_END);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = send_cmd(sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tWARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->pending_dir_moves));\n\twhile (sctx && !RB_EMPTY_ROOT(&sctx->pending_dir_moves)) {\n\t\tstruct rb_node *n;\n\t\tstruct pending_dir_move *pm;\n\n\t\tn = rb_first(&sctx->pending_dir_moves);\n\t\tpm = rb_entry(n, struct pending_dir_move, node);\n\t\twhile (!list_empty(&pm->list)) {\n\t\t\tstruct pending_dir_move *pm2;\n\n\t\t\tpm2 = list_first_entry(&pm->list,\n\t\t\t\t\t       struct pending_dir_move, list);\n\t\t\tfree_pending_move(sctx, pm2);\n\t\t}\n\t\tfree_pending_move(sctx, pm);\n\t}\n\n\tWARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->waiting_dir_moves));\n\twhile (sctx && !RB_EMPTY_ROOT(&sctx->waiting_dir_moves)) {\n\t\tstruct rb_node *n;\n\t\tstruct waiting_dir_move *dm;\n\n\t\tn = rb_first(&sctx->waiting_dir_moves);\n\t\tdm = rb_entry(n, struct waiting_dir_move, node);\n\t\trb_erase(&dm->node, &sctx->waiting_dir_moves);\n\t\tkfree(dm);\n\t}\n\n\tWARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->orphan_dirs));\n\twhile (sctx && !RB_EMPTY_ROOT(&sctx->orphan_dirs)) {\n\t\tstruct rb_node *n;\n\t\tstruct orphan_dir_info *odi;\n\n\t\tn = rb_first(&sctx->orphan_dirs);\n\t\todi = rb_entry(n, struct orphan_dir_info, node);\n\t\tfree_orphan_dir_info(sctx, odi);\n\t}\n\n\tif (sort_clone_roots) {\n\t\tfor (i = 0; i < sctx->clone_roots_cnt; i++)\n\t\t\tbtrfs_root_dec_send_in_progress(\n\t\t\t\t\tsctx->clone_roots[i].root);\n\t} else {\n\t\tfor (i = 0; sctx && i < clone_sources_to_rollback; i++)\n\t\t\tbtrfs_root_dec_send_in_progress(\n\t\t\t\t\tsctx->clone_roots[i].root);\n\n\t\tbtrfs_root_dec_send_in_progress(send_root);\n\t}\n\tif (sctx && !IS_ERR_OR_NULL(sctx->parent_root))\n\t\tbtrfs_root_dec_send_in_progress(sctx->parent_root);\n\n\tkfree(arg);\n\tvfree(clone_sources_tmp);\n\n\tif (sctx) {\n\t\tif (sctx->send_filp)\n\t\t\tfput(sctx->send_filp);\n\n\t\tvfree(sctx->clone_roots);\n\t\tvfree(sctx->send_buf);\n\t\tvfree(sctx->read_buf);\n\n\t\tname_cache_free(sctx);\n\n\t\tkfree(sctx);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sctx"
          ],
          "line": 5999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_cache_free",
          "args": [
            "sctx"
          ],
          "line": 5997
        },
        "resolved": true,
        "details": {
          "function_name": "name_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2051-2061",
          "snippet": "static void name_cache_free(struct send_ctx *sctx)\n{\n\tstruct name_cache_entry *nce;\n\n\twhile (!list_empty(&sctx->name_cache_list)) {\n\t\tnce = list_entry(sctx->name_cache_list.next,\n\t\t\t\tstruct name_cache_entry, list);\n\t\tname_cache_delete(sctx, nce);\n\t\tkfree(nce);\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void name_cache_free(struct send_ctx *sctx)\n{\n\tstruct name_cache_entry *nce;\n\n\twhile (!list_empty(&sctx->name_cache_list)) {\n\t\tnce = list_entry(sctx->name_cache_list.next,\n\t\t\t\tstruct name_cache_entry, list);\n\t\tname_cache_delete(sctx, nce);\n\t\tkfree(nce);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "sctx->read_buf"
          ],
          "line": 5995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "sctx->send_buf"
          ],
          "line": 5994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "sctx->clone_roots"
          ],
          "line": 5993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "sctx->send_filp"
          ],
          "line": 5991
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "clone_sources_tmp"
          ],
          "line": 5987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "arg"
          ],
          "line": 5986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_dec_send_in_progress",
          "args": [
            "sctx->parent_root"
          ],
          "line": 5984
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_dec_send_in_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "5693-5706",
          "snippet": "static void btrfs_root_dec_send_in_progress(struct btrfs_root* root)\n{\n\tspin_lock(&root->root_item_lock);\n\troot->send_in_progress--;\n\t/*\n\t * Not much left to do, we don't know why it's unbalanced and\n\t * can't blindly reset it to 0.\n\t */\n\tif (root->send_in_progress < 0)\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"send_in_progres unbalanced %d root %llu\",\n\t\t\troot->send_in_progress, root->root_key.objectid);\n\tspin_unlock(&root->root_item_lock);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void btrfs_root_dec_send_in_progress(struct btrfs_root* root)\n{\n\tspin_lock(&root->root_item_lock);\n\troot->send_in_progress--;\n\t/*\n\t * Not much left to do, we don't know why it's unbalanced and\n\t * can't blindly reset it to 0.\n\t */\n\tif (root->send_in_progress < 0)\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"send_in_progres unbalanced %d root %llu\",\n\t\t\troot->send_in_progress, root->root_key.objectid);\n\tspin_unlock(&root->root_item_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "sctx->parent_root"
          ],
          "line": 5983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_orphan_dir_info",
          "args": [
            "sctx",
            "odi"
          ],
          "line": 5969
        },
        "resolved": true,
        "details": {
          "function_name": "free_orphan_dir_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2826-2833",
          "snippet": "static void free_orphan_dir_info(struct send_ctx *sctx,\n\t\t\t\t struct orphan_dir_info *odi)\n{\n\tif (!odi)\n\t\treturn;\n\trb_erase(&odi->node, &sctx->orphan_dirs);\n\tkfree(odi);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void free_orphan_dir_info(struct send_ctx *sctx,\n\t\t\t\t struct orphan_dir_info *odi)\n{\n\tif (!odi)\n\t\treturn;\n\trb_erase(&odi->node, &sctx->orphan_dirs);\n\tkfree(odi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structorphan_dir_info",
            "node"
          ],
          "line": 5968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&sctx->orphan_dirs"
          ],
          "line": 5967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&sctx->orphan_dirs"
          ],
          "line": 5963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sctx && !ret && !RB_EMPTY_ROOT(&sctx->orphan_dirs)"
          ],
          "line": 5962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&sctx->orphan_dirs"
          ],
          "line": 5962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dm"
          ],
          "line": 5959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&dm->node",
            "&sctx->waiting_dir_moves"
          ],
          "line": 5958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structwaiting_dir_move",
            "node"
          ],
          "line": 5957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&sctx->waiting_dir_moves"
          ],
          "line": 5956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&sctx->waiting_dir_moves"
          ],
          "line": 5952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sctx && !ret && !RB_EMPTY_ROOT(&sctx->waiting_dir_moves)"
          ],
          "line": 5951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&sctx->waiting_dir_moves"
          ],
          "line": 5951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pending_move",
          "args": [
            "sctx",
            "pm"
          ],
          "line": 5948
        },
        "resolved": true,
        "details": {
          "function_name": "free_pending_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3236-3244",
          "snippet": "static void free_pending_move(struct send_ctx *sctx, struct pending_dir_move *m)\n{\n\tif (!list_empty(&m->list))\n\t\tlist_del(&m->list);\n\tif (!RB_EMPTY_NODE(&m->node))\n\t\trb_erase(&m->node, &sctx->pending_dir_moves);\n\t__free_recorded_refs(&m->update_refs);\n\tkfree(m);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void free_pending_move(struct send_ctx *sctx, struct pending_dir_move *m)\n{\n\tif (!list_empty(&m->list))\n\t\tlist_del(&m->list);\n\tif (!RB_EMPTY_NODE(&m->node))\n\t\trb_erase(&m->node, &sctx->pending_dir_moves);\n\t__free_recorded_refs(&m->update_refs);\n\tkfree(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&pm->list",
            "structpending_dir_move",
            "list"
          ],
          "line": 5944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pm->list"
          ],
          "line": 5941
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structpending_dir_move",
            "node"
          ],
          "line": 5940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&sctx->pending_dir_moves"
          ],
          "line": 5939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&sctx->pending_dir_moves"
          ],
          "line": 5935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sctx && !ret && !RB_EMPTY_ROOT(&sctx->pending_dir_moves)"
          ],
          "line": 5934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&sctx->pending_dir_moves"
          ],
          "line": 5934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_cmd",
          "args": [
            "sctx"
          ],
          "line": 5928
        },
        "resolved": true,
        "details": {
          "function_name": "send_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "667-688",
          "snippet": "static int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_cmd",
          "args": [
            "sctx",
            "BTRFS_SEND_C_END"
          ],
          "line": 5925
        },
        "resolved": true,
        "details": {
          "function_name": "begin_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "651-665",
          "snippet": "static int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_subvol",
          "args": [
            "sctx"
          ],
          "line": 5919
        },
        "resolved": true,
        "details": {
          "function_name": "send_subvol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "5615-5646",
          "snippet": "static int send_subvol(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tif (!(sctx->flags & BTRFS_SEND_FLAG_OMIT_STREAM_HEADER)) {\n\t\tret = send_header(sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = send_subvol_begin(sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (sctx->parent_root) {\n\t\tret = btrfs_compare_trees(sctx->send_root, sctx->parent_root,\n\t\t\t\tchanged_cb, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = finish_inode_if_needed(sctx, 1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tret = full_send_tree(sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tfree_recorded_refs(sctx);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_subvol(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tif (!(sctx->flags & BTRFS_SEND_FLAG_OMIT_STREAM_HEADER)) {\n\t\tret = send_header(sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = send_subvol_begin(sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (sctx->parent_root) {\n\t\tret = btrfs_compare_trees(sctx->send_root, sctx->parent_root,\n\t\t\t\tchanged_cb, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = finish_inode_if_needed(sctx, 1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tret = full_send_tree(sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tfree_recorded_refs(sctx);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensure_commit_roots_uptodate",
          "args": [
            "sctx"
          ],
          "line": 5914
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_commit_roots_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "5661-5691",
          "snippet": "static int ensure_commit_roots_uptodate(struct send_ctx *sctx)\n{\n\tint i;\n\tstruct btrfs_trans_handle *trans = NULL;\n\nagain:\n\tif (sctx->parent_root &&\n\t    sctx->parent_root->node != sctx->parent_root->commit_root)\n\t\tgoto commit_trans;\n\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++)\n\t\tif (sctx->clone_roots[i].root->node !=\n\t\t    sctx->clone_roots[i].root->commit_root)\n\t\t\tgoto commit_trans;\n\n\tif (trans)\n\t\treturn btrfs_end_transaction(trans, sctx->send_root);\n\n\treturn 0;\n\ncommit_trans:\n\t/* Use any root, all fs roots will get their commit roots updated. */\n\tif (!trans) {\n\t\ttrans = btrfs_join_transaction(sctx->send_root);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t\tgoto again;\n\t}\n\n\treturn btrfs_commit_transaction(trans, sctx->send_root);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int ensure_commit_roots_uptodate(struct send_ctx *sctx)\n{\n\tint i;\n\tstruct btrfs_trans_handle *trans = NULL;\n\nagain:\n\tif (sctx->parent_root &&\n\t    sctx->parent_root->node != sctx->parent_root->commit_root)\n\t\tgoto commit_trans;\n\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++)\n\t\tif (sctx->clone_roots[i].root->node !=\n\t\t    sctx->clone_roots[i].root->commit_root)\n\t\t\tgoto commit_trans;\n\n\tif (trans)\n\t\treturn btrfs_end_transaction(trans, sctx->send_root);\n\n\treturn 0;\n\ncommit_trans:\n\t/* Use any root, all fs roots will get their commit roots updated. */\n\tif (!trans) {\n\t\ttrans = btrfs_join_transaction(sctx->send_root);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t\tgoto again;\n\t}\n\n\treturn btrfs_commit_transaction(trans, sctx->send_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "sctx->clone_roots",
            "sctx->clone_roots_cnt",
            "sizeof(*sctx->clone_roots)",
            "__clone_root_cmp_sort",
            "NULL"
          ],
          "line": 5909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&fs_info->subvol_srcu",
            "index"
          ],
          "line": 5898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sctx->parent_root->root_item_lock"
          ],
          "line": 5896
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&fs_info->subvol_srcu",
            "index"
          ],
          "line": 5892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_dead",
          "args": [
            "sctx->parent_root"
          ],
          "line": 5890
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2881-2884",
          "snippet": "static inline bool btrfs_root_dead(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_DEAD)) != 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_ROOT_SUBVOL_DEAD\t\t(1ULL << 48)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_ROOT_SUBVOL_DEAD\t\t(1ULL << 48)\n\nstatic inline bool btrfs_root_dead(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_DEAD)) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_readonly",
          "args": [
            "sctx->parent_root"
          ],
          "line": 5889
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2876-2879",
          "snippet": "static inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)\n\nstatic inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sctx->parent_root->root_item_lock"
          ],
          "line": 5887
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sctx->parent_root"
          ],
          "line": 5883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&fs_info->subvol_srcu",
            "index"
          ],
          "line": 5882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sctx->parent_root"
          ],
          "line": 5881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_fs_root_no_name",
          "args": [
            "fs_info",
            "&key"
          ],
          "line": 5880
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_fs_root_no_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "76-81",
          "snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&fs_info->subvol_srcu"
          ],
          "line": 5878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "clone_sources_tmp"
          ],
          "line": 5869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&fs_info->subvol_srcu",
            "index"
          ],
          "line": 5865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&fs_info->subvol_srcu",
            "index"
          ],
          "line": 5860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "clone_root"
          ],
          "line": 5852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&fs_info->subvol_srcu",
            "index"
          ],
          "line": 5851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "clone_root"
          ],
          "line": 5850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&fs_info->subvol_srcu"
          ],
          "line": 5847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "clone_sources_tmp",
            "arg->clone_sources",
            "arg->clone_sources_count *\n\t\t\t\tsizeof(*arg->clone_sources)"
          ],
          "line": 5834
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "arg->clone_sources_count *\n\t\t\t\tsizeof(*arg->clone_sources)"
          ],
          "line": 5827
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "sizeof(struct clone_root) *\n\t\t\t(arg->clone_sources_count + 1)"
          ],
          "line": 5819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fget",
          "args": [
            "arg->send_fd"
          ],
          "line": 5784
        },
        "resolved": true,
        "details": {
          "function_name": "fget_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "656-659",
          "snippet": "struct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sctx->name_cache_list"
          ],
          "line": 5780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&sctx->name_cache",
            "GFP_NOFS"
          ],
          "line": 5779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sctx->deleted_refs"
          ],
          "line": 5778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sctx->new_refs"
          ],
          "line": 5777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct send_ctx)",
            "GFP_NOFS"
          ],
          "line": 5771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "arg->clone_sources",
            "sizeof(*arg->clone_sources) *\n\t\t\targ->clone_sources_count"
          ],
          "line": 5759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "arg"
          ],
          "line": 5754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "arg"
          ],
          "line": 5753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg_",
            "sizeof(*arg)"
          ],
          "line": 5752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "send_root->orphan_cleanup_state != ORPHAN_CLEANUP_DONE"
          ],
          "line": 5741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "file_inode(mnt_file)"
          ],
          "line": 5726
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "mnt_file"
          ],
          "line": 5726
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 5723
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nlong btrfs_ioctl_send(struct file *mnt_file, void __user *arg_)\n{\n\tint ret = 0;\n\tstruct btrfs_root *send_root;\n\tstruct btrfs_root *clone_root;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_ioctl_send_args *arg = NULL;\n\tstruct btrfs_key key;\n\tstruct send_ctx *sctx = NULL;\n\tu32 i;\n\tu64 *clone_sources_tmp = NULL;\n\tint clone_sources_to_rollback = 0;\n\tint sort_clone_roots = 0;\n\tint index;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tsend_root = BTRFS_I(file_inode(mnt_file))->root;\n\tfs_info = send_root->fs_info;\n\n\t/*\n\t * The subvolume must remain read-only during send, protect against\n\t * making it RW. This also protects against deletion.\n\t */\n\tspin_lock(&send_root->root_item_lock);\n\tsend_root->send_in_progress++;\n\tspin_unlock(&send_root->root_item_lock);\n\n\t/*\n\t * This is done when we lookup the root, it should already be complete\n\t * by the time we get here.\n\t */\n\tWARN_ON(send_root->orphan_cleanup_state != ORPHAN_CLEANUP_DONE);\n\n\t/*\n\t * Userspace tools do the checks and warn the user if it's\n\t * not RO.\n\t */\n\tif (!btrfs_root_readonly(send_root)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\targ = memdup_user(arg_, sizeof(*arg));\n\tif (IS_ERR(arg)) {\n\t\tret = PTR_ERR(arg);\n\t\targ = NULL;\n\t\tgoto out;\n\t}\n\n\tif (!access_ok(VERIFY_READ, arg->clone_sources,\n\t\t\tsizeof(*arg->clone_sources) *\n\t\t\targ->clone_sources_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (arg->flags & ~BTRFS_SEND_FLAG_MASK) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsctx = kzalloc(sizeof(struct send_ctx), GFP_NOFS);\n\tif (!sctx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tINIT_LIST_HEAD(&sctx->new_refs);\n\tINIT_LIST_HEAD(&sctx->deleted_refs);\n\tINIT_RADIX_TREE(&sctx->name_cache, GFP_NOFS);\n\tINIT_LIST_HEAD(&sctx->name_cache_list);\n\n\tsctx->flags = arg->flags;\n\n\tsctx->send_filp = fget(arg->send_fd);\n\tif (!sctx->send_filp) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tsctx->send_root = send_root;\n\t/*\n\t * Unlikely but possible, if the subvolume is marked for deletion but\n\t * is slow to remove the directory entry, send can still be started\n\t */\n\tif (btrfs_root_dead(sctx->send_root)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tsctx->clone_roots_cnt = arg->clone_sources_count;\n\n\tsctx->send_max_size = BTRFS_SEND_BUF_SIZE;\n\tsctx->send_buf = vmalloc(sctx->send_max_size);\n\tif (!sctx->send_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsctx->read_buf = vmalloc(BTRFS_SEND_READ_SIZE);\n\tif (!sctx->read_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsctx->pending_dir_moves = RB_ROOT;\n\tsctx->waiting_dir_moves = RB_ROOT;\n\tsctx->orphan_dirs = RB_ROOT;\n\n\tsctx->clone_roots = vzalloc(sizeof(struct clone_root) *\n\t\t\t(arg->clone_sources_count + 1));\n\tif (!sctx->clone_roots) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (arg->clone_sources_count) {\n\t\tclone_sources_tmp = vmalloc(arg->clone_sources_count *\n\t\t\t\tsizeof(*arg->clone_sources));\n\t\tif (!clone_sources_tmp) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = copy_from_user(clone_sources_tmp, arg->clone_sources,\n\t\t\t\targ->clone_sources_count *\n\t\t\t\tsizeof(*arg->clone_sources));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < arg->clone_sources_count; i++) {\n\t\t\tkey.objectid = clone_sources_tmp[i];\n\t\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\t\tkey.offset = (u64)-1;\n\n\t\t\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\n\t\t\tclone_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\t\t\tif (IS_ERR(clone_root)) {\n\t\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\t\tret = PTR_ERR(clone_root);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tclone_sources_to_rollback = i + 1;\n\t\t\tspin_lock(&clone_root->root_item_lock);\n\t\t\tclone_root->send_in_progress++;\n\t\t\tif (!btrfs_root_readonly(clone_root)) {\n\t\t\t\tspin_unlock(&clone_root->root_item_lock);\n\t\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\t\tret = -EPERM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tspin_unlock(&clone_root->root_item_lock);\n\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\n\t\t\tsctx->clone_roots[i].root = clone_root;\n\t\t}\n\t\tvfree(clone_sources_tmp);\n\t\tclone_sources_tmp = NULL;\n\t}\n\n\tif (arg->parent_root) {\n\t\tkey.objectid = arg->parent_root;\n\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\tkey.offset = (u64)-1;\n\n\t\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\n\t\tsctx->parent_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\t\tif (IS_ERR(sctx->parent_root)) {\n\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\tret = PTR_ERR(sctx->parent_root);\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock(&sctx->parent_root->root_item_lock);\n\t\tsctx->parent_root->send_in_progress++;\n\t\tif (!btrfs_root_readonly(sctx->parent_root) ||\n\t\t\t\tbtrfs_root_dead(sctx->parent_root)) {\n\t\t\tspin_unlock(&sctx->parent_root->root_item_lock);\n\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&sctx->parent_root->root_item_lock);\n\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t}\n\n\t/*\n\t * Clones from send_root are allowed, but only if the clone source\n\t * is behind the current send position. This is checked while searching\n\t * for possible clone sources.\n\t */\n\tsctx->clone_roots[sctx->clone_roots_cnt++].root = sctx->send_root;\n\n\t/* We do a bsearch later */\n\tsort(sctx->clone_roots, sctx->clone_roots_cnt,\n\t\t\tsizeof(*sctx->clone_roots), __clone_root_cmp_sort,\n\t\t\tNULL);\n\tsort_clone_roots = 1;\n\n\tret = ensure_commit_roots_uptodate(sctx);\n\tif (ret)\n\t\tgoto out;\n\n\tcurrent->journal_info = BTRFS_SEND_TRANS_STUB;\n\tret = send_subvol(sctx);\n\tcurrent->journal_info = NULL;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!(sctx->flags & BTRFS_SEND_FLAG_OMIT_END_CMD)) {\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_END);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = send_cmd(sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tWARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->pending_dir_moves));\n\twhile (sctx && !RB_EMPTY_ROOT(&sctx->pending_dir_moves)) {\n\t\tstruct rb_node *n;\n\t\tstruct pending_dir_move *pm;\n\n\t\tn = rb_first(&sctx->pending_dir_moves);\n\t\tpm = rb_entry(n, struct pending_dir_move, node);\n\t\twhile (!list_empty(&pm->list)) {\n\t\t\tstruct pending_dir_move *pm2;\n\n\t\t\tpm2 = list_first_entry(&pm->list,\n\t\t\t\t\t       struct pending_dir_move, list);\n\t\t\tfree_pending_move(sctx, pm2);\n\t\t}\n\t\tfree_pending_move(sctx, pm);\n\t}\n\n\tWARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->waiting_dir_moves));\n\twhile (sctx && !RB_EMPTY_ROOT(&sctx->waiting_dir_moves)) {\n\t\tstruct rb_node *n;\n\t\tstruct waiting_dir_move *dm;\n\n\t\tn = rb_first(&sctx->waiting_dir_moves);\n\t\tdm = rb_entry(n, struct waiting_dir_move, node);\n\t\trb_erase(&dm->node, &sctx->waiting_dir_moves);\n\t\tkfree(dm);\n\t}\n\n\tWARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->orphan_dirs));\n\twhile (sctx && !RB_EMPTY_ROOT(&sctx->orphan_dirs)) {\n\t\tstruct rb_node *n;\n\t\tstruct orphan_dir_info *odi;\n\n\t\tn = rb_first(&sctx->orphan_dirs);\n\t\todi = rb_entry(n, struct orphan_dir_info, node);\n\t\tfree_orphan_dir_info(sctx, odi);\n\t}\n\n\tif (sort_clone_roots) {\n\t\tfor (i = 0; i < sctx->clone_roots_cnt; i++)\n\t\t\tbtrfs_root_dec_send_in_progress(\n\t\t\t\t\tsctx->clone_roots[i].root);\n\t} else {\n\t\tfor (i = 0; sctx && i < clone_sources_to_rollback; i++)\n\t\t\tbtrfs_root_dec_send_in_progress(\n\t\t\t\t\tsctx->clone_roots[i].root);\n\n\t\tbtrfs_root_dec_send_in_progress(send_root);\n\t}\n\tif (sctx && !IS_ERR_OR_NULL(sctx->parent_root))\n\t\tbtrfs_root_dec_send_in_progress(sctx->parent_root);\n\n\tkfree(arg);\n\tvfree(clone_sources_tmp);\n\n\tif (sctx) {\n\t\tif (sctx->send_filp)\n\t\t\tfput(sctx->send_filp);\n\n\t\tvfree(sctx->clone_roots);\n\t\tvfree(sctx->send_buf);\n\t\tvfree(sctx->read_buf);\n\n\t\tname_cache_free(sctx);\n\n\t\tkfree(sctx);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_root_dec_send_in_progress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "5693-5706",
    "snippet": "static void btrfs_root_dec_send_in_progress(struct btrfs_root* root)\n{\n\tspin_lock(&root->root_item_lock);\n\troot->send_in_progress--;\n\t/*\n\t * Not much left to do, we don't know why it's unbalanced and\n\t * can't blindly reset it to 0.\n\t */\n\tif (root->send_in_progress < 0)\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"send_in_progres unbalanced %d root %llu\",\n\t\t\troot->send_in_progress, root->root_key.objectid);\n\tspin_unlock(&root->root_item_lock);\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->root_item_lock"
          ],
          "line": 5705
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "root->fs_info",
            "\"send_in_progres unbalanced %d root %llu\"",
            "root->send_in_progress",
            "root->root_key.objectid"
          ],
          "line": 5702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->root_item_lock"
          ],
          "line": 5695
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void btrfs_root_dec_send_in_progress(struct btrfs_root* root)\n{\n\tspin_lock(&root->root_item_lock);\n\troot->send_in_progress--;\n\t/*\n\t * Not much left to do, we don't know why it's unbalanced and\n\t * can't blindly reset it to 0.\n\t */\n\tif (root->send_in_progress < 0)\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"send_in_progres unbalanced %d root %llu\",\n\t\t\troot->send_in_progress, root->root_key.objectid);\n\tspin_unlock(&root->root_item_lock);\n}"
  },
  {
    "function_name": "ensure_commit_roots_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "5661-5691",
    "snippet": "static int ensure_commit_roots_uptodate(struct send_ctx *sctx)\n{\n\tint i;\n\tstruct btrfs_trans_handle *trans = NULL;\n\nagain:\n\tif (sctx->parent_root &&\n\t    sctx->parent_root->node != sctx->parent_root->commit_root)\n\t\tgoto commit_trans;\n\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++)\n\t\tif (sctx->clone_roots[i].root->node !=\n\t\t    sctx->clone_roots[i].root->commit_root)\n\t\t\tgoto commit_trans;\n\n\tif (trans)\n\t\treturn btrfs_end_transaction(trans, sctx->send_root);\n\n\treturn 0;\n\ncommit_trans:\n\t/* Use any root, all fs roots will get their commit roots updated. */\n\tif (!trans) {\n\t\ttrans = btrfs_join_transaction(sctx->send_root);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t\tgoto again;\n\t}\n\n\treturn btrfs_commit_transaction(trans, sctx->send_root);\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "sctx->send_root"
          ],
          "line": 5690
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 5686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 5685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_join_transaction",
          "args": [
            "sctx->send_root"
          ],
          "line": 5684
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_join_transaction_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "581-584",
          "snippet": "struct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "sctx->send_root"
          ],
          "line": 5677
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int ensure_commit_roots_uptodate(struct send_ctx *sctx)\n{\n\tint i;\n\tstruct btrfs_trans_handle *trans = NULL;\n\nagain:\n\tif (sctx->parent_root &&\n\t    sctx->parent_root->node != sctx->parent_root->commit_root)\n\t\tgoto commit_trans;\n\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++)\n\t\tif (sctx->clone_roots[i].root->node !=\n\t\t    sctx->clone_roots[i].root->commit_root)\n\t\t\tgoto commit_trans;\n\n\tif (trans)\n\t\treturn btrfs_end_transaction(trans, sctx->send_root);\n\n\treturn 0;\n\ncommit_trans:\n\t/* Use any root, all fs roots will get their commit roots updated. */\n\tif (!trans) {\n\t\ttrans = btrfs_join_transaction(sctx->send_root);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t\tgoto again;\n\t}\n\n\treturn btrfs_commit_transaction(trans, sctx->send_root);\n}"
  },
  {
    "function_name": "send_subvol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "5615-5646",
    "snippet": "static int send_subvol(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tif (!(sctx->flags & BTRFS_SEND_FLAG_OMIT_STREAM_HEADER)) {\n\t\tret = send_header(sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = send_subvol_begin(sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (sctx->parent_root) {\n\t\tret = btrfs_compare_trees(sctx->send_root, sctx->parent_root,\n\t\t\t\tchanged_cb, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = finish_inode_if_needed(sctx, 1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tret = full_send_tree(sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tfree_recorded_refs(sctx);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_recorded_refs",
          "args": [
            "sctx"
          ],
          "line": 5644
        },
        "resolved": true,
        "details": {
          "function_name": "free_recorded_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2738-2742",
          "snippet": "static void free_recorded_refs(struct send_ctx *sctx)\n{\n\t__free_recorded_refs(&sctx->new_refs);\n\t__free_recorded_refs(&sctx->deleted_refs);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void free_recorded_refs(struct send_ctx *sctx)\n{\n\t__free_recorded_refs(&sctx->new_refs);\n\t__free_recorded_refs(&sctx->deleted_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "full_send_tree",
          "args": [
            "sctx"
          ],
          "line": 5638
        },
        "resolved": true,
        "details": {
          "function_name": "full_send_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "5560-5613",
          "snippet": "static int full_send_tree(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *send_root = sctx->send_root;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(send_root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret)\n\t\tgoto out_finish;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\n\t\tret = changed_cb(send_root, NULL, path, NULL,\n\t\t\t\t&found_key, BTRFS_COMPARE_TREE_NEW, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tkey.objectid = found_key.objectid;\n\t\tkey.type = found_key.type;\n\t\tkey.offset = found_key.offset + 1;\n\n\t\tret = btrfs_next_item(send_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret  = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout_finish:\n\tret = finish_inode_if_needed(sctx, 1);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int full_send_tree(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *send_root = sctx->send_root;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(send_root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret)\n\t\tgoto out_finish;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\n\t\tret = changed_cb(send_root, NULL, path, NULL,\n\t\t\t\t&found_key, BTRFS_COMPARE_TREE_NEW, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tkey.objectid = found_key.objectid;\n\t\tkey.type = found_key.type;\n\t\tkey.offset = found_key.offset + 1;\n\n\t\tret = btrfs_next_item(send_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret  = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout_finish:\n\tret = finish_inode_if_needed(sctx, 1);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_inode_if_needed",
          "args": [
            "sctx",
            "1"
          ],
          "line": 5634
        },
        "resolved": true,
        "details": {
          "function_name": "finish_inode_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "5099-5218",
          "snippet": "static int finish_inode_if_needed(struct send_ctx *sctx, int at_end)\n{\n\tint ret = 0;\n\tu64 left_mode;\n\tu64 left_uid;\n\tu64 left_gid;\n\tu64 right_mode;\n\tu64 right_uid;\n\tu64 right_gid;\n\tint need_chmod = 0;\n\tint need_chown = 0;\n\tint pending_move = 0;\n\tint refs_processed = 0;\n\n\tret = process_recorded_refs_if_needed(sctx, at_end, &pending_move,\n\t\t\t\t\t      &refs_processed);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * We have processed the refs and thus need to advance send_progress.\n\t * Now, calls to get_cur_xxx will take the updated refs of the current\n\t * inode into account.\n\t *\n\t * On the other hand, if our current inode is a directory and couldn't\n\t * be moved/renamed because its parent was renamed/moved too and it has\n\t * a higher inode number, we can only move/rename our current inode\n\t * after we moved/renamed its parent. Therefore in this case operate on\n\t * the old path (pre move/rename) of our current inode, and the\n\t * move/rename will be performed later.\n\t */\n\tif (refs_processed && !pending_move)\n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\n\tif (sctx->cur_ino == 0 || sctx->cur_inode_deleted)\n\t\tgoto out;\n\tif (!at_end && sctx->cmp_key->objectid == sctx->cur_ino)\n\t\tgoto out;\n\n\tret = get_inode_info(sctx->send_root, sctx->cur_ino, NULL, NULL,\n\t\t\t&left_mode, &left_uid, &left_gid, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!sctx->parent_root || sctx->cur_inode_new) {\n\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode))\n\t\t\tneed_chmod = 1;\n\t} else {\n\t\tret = get_inode_info(sctx->parent_root, sctx->cur_ino,\n\t\t\t\tNULL, NULL, &right_mode, &right_uid,\n\t\t\t\t&right_gid, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (left_uid != right_uid || left_gid != right_gid)\n\t\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode) && left_mode != right_mode)\n\t\t\tneed_chmod = 1;\n\t}\n\n\tif (S_ISREG(sctx->cur_inode_mode)) {\n\t\tif (need_send_hole(sctx)) {\n\t\t\tif (sctx->cur_inode_last_extent == (u64)-1 ||\n\t\t\t    sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = get_last_extent(sctx, (u64)-1);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = send_hole(sctx, sctx->cur_inode_size);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = send_truncate(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tsctx->cur_inode_size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (need_chown) {\n\t\tret = send_chown(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_uid, left_gid);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tif (need_chmod) {\n\t\tret = send_chmod(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_mode);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * If other directory inodes depended on our current directory\n\t * inode's move/rename, now do their move/rename operations.\n\t */\n\tif (!is_waiting_for_move(sctx, sctx->cur_ino)) {\n\t\tret = apply_children_dir_moves(sctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Need to send that every time, no matter if it actually\n\t\t * changed between the two trees as we have done changes to\n\t\t * the inode before. If our inode is a directory and it's\n\t\t * waiting to be moved/renamed, we will send its utimes when\n\t\t * it's moved/renamed, therefore we don't need to do it here.\n\t\t */\n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\t\tret = send_utimes(sctx, sctx->cur_ino, sctx->cur_inode_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int finish_inode_if_needed(struct send_ctx *sctx, int at_end)\n{\n\tint ret = 0;\n\tu64 left_mode;\n\tu64 left_uid;\n\tu64 left_gid;\n\tu64 right_mode;\n\tu64 right_uid;\n\tu64 right_gid;\n\tint need_chmod = 0;\n\tint need_chown = 0;\n\tint pending_move = 0;\n\tint refs_processed = 0;\n\n\tret = process_recorded_refs_if_needed(sctx, at_end, &pending_move,\n\t\t\t\t\t      &refs_processed);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * We have processed the refs and thus need to advance send_progress.\n\t * Now, calls to get_cur_xxx will take the updated refs of the current\n\t * inode into account.\n\t *\n\t * On the other hand, if our current inode is a directory and couldn't\n\t * be moved/renamed because its parent was renamed/moved too and it has\n\t * a higher inode number, we can only move/rename our current inode\n\t * after we moved/renamed its parent. Therefore in this case operate on\n\t * the old path (pre move/rename) of our current inode, and the\n\t * move/rename will be performed later.\n\t */\n\tif (refs_processed && !pending_move)\n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\n\tif (sctx->cur_ino == 0 || sctx->cur_inode_deleted)\n\t\tgoto out;\n\tif (!at_end && sctx->cmp_key->objectid == sctx->cur_ino)\n\t\tgoto out;\n\n\tret = get_inode_info(sctx->send_root, sctx->cur_ino, NULL, NULL,\n\t\t\t&left_mode, &left_uid, &left_gid, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!sctx->parent_root || sctx->cur_inode_new) {\n\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode))\n\t\t\tneed_chmod = 1;\n\t} else {\n\t\tret = get_inode_info(sctx->parent_root, sctx->cur_ino,\n\t\t\t\tNULL, NULL, &right_mode, &right_uid,\n\t\t\t\t&right_gid, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (left_uid != right_uid || left_gid != right_gid)\n\t\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode) && left_mode != right_mode)\n\t\t\tneed_chmod = 1;\n\t}\n\n\tif (S_ISREG(sctx->cur_inode_mode)) {\n\t\tif (need_send_hole(sctx)) {\n\t\t\tif (sctx->cur_inode_last_extent == (u64)-1 ||\n\t\t\t    sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = get_last_extent(sctx, (u64)-1);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = send_hole(sctx, sctx->cur_inode_size);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = send_truncate(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tsctx->cur_inode_size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (need_chown) {\n\t\tret = send_chown(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_uid, left_gid);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tif (need_chmod) {\n\t\tret = send_chmod(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_mode);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * If other directory inodes depended on our current directory\n\t * inode's move/rename, now do their move/rename operations.\n\t */\n\tif (!is_waiting_for_move(sctx, sctx->cur_ino)) {\n\t\tret = apply_children_dir_moves(sctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Need to send that every time, no matter if it actually\n\t\t * changed between the two trees as we have done changes to\n\t\t * the inode before. If our inode is a directory and it's\n\t\t * waiting to be moved/renamed, we will send its utimes when\n\t\t * it's moved/renamed, therefore we don't need to do it here.\n\t\t */\n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\t\tret = send_utimes(sctx, sctx->cur_ino, sctx->cur_inode_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_compare_trees",
          "args": [
            "sctx->send_root",
            "sctx->parent_root",
            "changed_cb",
            "sctx"
          ],
          "line": 5630
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_compare_trees",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5322-5563",
          "snippet": "int btrfs_compare_trees(struct btrfs_root *left_root,\n\t\t\tstruct btrfs_root *right_root,\n\t\t\tbtrfs_changed_cb_t changed_cb, void *ctx)\n{\n\tint ret;\n\tint cmp;\n\tstruct btrfs_path *left_path = NULL;\n\tstruct btrfs_path *right_path = NULL;\n\tstruct btrfs_key left_key;\n\tstruct btrfs_key right_key;\n\tchar *tmp_buf = NULL;\n\tint left_root_level;\n\tint right_root_level;\n\tint left_level;\n\tint right_level;\n\tint left_end_reached;\n\tint right_end_reached;\n\tint advance_left;\n\tint advance_right;\n\tu64 left_blockptr;\n\tu64 right_blockptr;\n\tu64 left_gen;\n\tu64 right_gen;\n\n\tleft_path = btrfs_alloc_path();\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tright_path = btrfs_alloc_path();\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttmp_buf = kmalloc(left_root->nodesize, GFP_NOFS);\n\tif (!tmp_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tleft_path->search_commit_root = 1;\n\tleft_path->skip_locking = 1;\n\tright_path->search_commit_root = 1;\n\tright_path->skip_locking = 1;\n\n\t/*\n\t * Strategy: Go to the first items of both trees. Then do\n\t *\n\t * If both trees are at level 0\n\t *   Compare keys of current items\n\t *     If left < right treat left item as new, advance left tree\n\t *       and repeat\n\t *     If left > right treat right item as deleted, advance right tree\n\t *       and repeat\n\t *     If left == right do deep compare of items, treat as changed if\n\t *       needed, advance both trees and repeat\n\t * If both trees are at the same level but not at level 0\n\t *   Compare keys of current nodes/leafs\n\t *     If left < right advance left tree and repeat\n\t *     If left > right advance right tree and repeat\n\t *     If left == right compare blockptrs of the next nodes/leafs\n\t *       If they match advance both trees but stay at the same level\n\t *         and repeat\n\t *       If they don't match advance both trees while allowing to go\n\t *         deeper and repeat\n\t * If tree levels are different\n\t *   Advance the tree that needs it and repeat\n\t *\n\t * Advancing a tree means:\n\t *   If we are at level 0, try to go to the next slot. If that's not\n\t *   possible, go one level up and repeat. Stop when we found a level\n\t *   where we could go to the next slot. We may at this point be on a\n\t *   node or a leaf.\n\t *\n\t *   If we are not at level 0 and not on shared tree blocks, go one\n\t *   level deeper.\n\t *\n\t *   If we are not at level 0 and on shared tree blocks, go one slot to\n\t *   the right if possible or go up and right.\n\t */\n\n\tdown_read(&left_root->fs_info->commit_root_sem);\n\tleft_level = btrfs_header_level(left_root->commit_root);\n\tleft_root_level = left_level;\n\tleft_path->nodes[left_level] = left_root->commit_root;\n\textent_buffer_get(left_path->nodes[left_level]);\n\n\tright_level = btrfs_header_level(right_root->commit_root);\n\tright_root_level = right_level;\n\tright_path->nodes[right_level] = right_root->commit_root;\n\textent_buffer_get(right_path->nodes[right_level]);\n\tup_read(&left_root->fs_info->commit_root_sem);\n\n\tif (left_level == 0)\n\t\tbtrfs_item_key_to_cpu(left_path->nodes[left_level],\n\t\t\t\t&left_key, left_path->slots[left_level]);\n\telse\n\t\tbtrfs_node_key_to_cpu(left_path->nodes[left_level],\n\t\t\t\t&left_key, left_path->slots[left_level]);\n\tif (right_level == 0)\n\t\tbtrfs_item_key_to_cpu(right_path->nodes[right_level],\n\t\t\t\t&right_key, right_path->slots[right_level]);\n\telse\n\t\tbtrfs_node_key_to_cpu(right_path->nodes[right_level],\n\t\t\t\t&right_key, right_path->slots[right_level]);\n\n\tleft_end_reached = right_end_reached = 0;\n\tadvance_left = advance_right = 0;\n\n\twhile (1) {\n\t\tif (advance_left && !left_end_reached) {\n\t\t\tret = tree_advance(left_root, left_path, &left_level,\n\t\t\t\t\tleft_root_level,\n\t\t\t\t\tadvance_left != ADVANCE_ONLY_NEXT,\n\t\t\t\t\t&left_key);\n\t\t\tif (ret < 0)\n\t\t\t\tleft_end_reached = ADVANCE;\n\t\t\tadvance_left = 0;\n\t\t}\n\t\tif (advance_right && !right_end_reached) {\n\t\t\tret = tree_advance(right_root, right_path, &right_level,\n\t\t\t\t\tright_root_level,\n\t\t\t\t\tadvance_right != ADVANCE_ONLY_NEXT,\n\t\t\t\t\t&right_key);\n\t\t\tif (ret < 0)\n\t\t\t\tright_end_reached = ADVANCE;\n\t\t\tadvance_right = 0;\n\t\t}\n\n\t\tif (left_end_reached && right_end_reached) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t} else if (left_end_reached) {\n\t\t\tif (right_level == 0) {\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\tleft_path, right_path,\n\t\t\t\t\t\t&right_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_DELETED,\n\t\t\t\t\t\tctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tadvance_right = ADVANCE;\n\t\t\tcontinue;\n\t\t} else if (right_end_reached) {\n\t\t\tif (left_level == 0) {\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\tleft_path, right_path,\n\t\t\t\t\t\t&left_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_NEW,\n\t\t\t\t\t\tctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tadvance_left = ADVANCE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (left_level == 0 && right_level == 0) {\n\t\t\tcmp = btrfs_comp_cpu_keys(&left_key, &right_key);\n\t\t\tif (cmp < 0) {\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\tleft_path, right_path,\n\t\t\t\t\t\t&left_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_NEW,\n\t\t\t\t\t\tctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tadvance_left = ADVANCE;\n\t\t\t} else if (cmp > 0) {\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\tleft_path, right_path,\n\t\t\t\t\t\t&right_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_DELETED,\n\t\t\t\t\t\tctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tadvance_right = ADVANCE;\n\t\t\t} else {\n\t\t\t\tenum btrfs_compare_tree_result result;\n\n\t\t\t\tWARN_ON(!extent_buffer_uptodate(left_path->nodes[0]));\n\t\t\t\tret = tree_compare_item(left_root, left_path,\n\t\t\t\t\t\tright_path, tmp_buf);\n\t\t\t\tif (ret)\n\t\t\t\t\tresult = BTRFS_COMPARE_TREE_CHANGED;\n\t\t\t\telse\n\t\t\t\t\tresult = BTRFS_COMPARE_TREE_SAME;\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\t left_path, right_path,\n\t\t\t\t\t\t &left_key, result, ctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tadvance_left = ADVANCE;\n\t\t\t\tadvance_right = ADVANCE;\n\t\t\t}\n\t\t} else if (left_level == right_level) {\n\t\t\tcmp = btrfs_comp_cpu_keys(&left_key, &right_key);\n\t\t\tif (cmp < 0) {\n\t\t\t\tadvance_left = ADVANCE;\n\t\t\t} else if (cmp > 0) {\n\t\t\t\tadvance_right = ADVANCE;\n\t\t\t} else {\n\t\t\t\tleft_blockptr = btrfs_node_blockptr(\n\t\t\t\t\t\tleft_path->nodes[left_level],\n\t\t\t\t\t\tleft_path->slots[left_level]);\n\t\t\t\tright_blockptr = btrfs_node_blockptr(\n\t\t\t\t\t\tright_path->nodes[right_level],\n\t\t\t\t\t\tright_path->slots[right_level]);\n\t\t\t\tleft_gen = btrfs_node_ptr_generation(\n\t\t\t\t\t\tleft_path->nodes[left_level],\n\t\t\t\t\t\tleft_path->slots[left_level]);\n\t\t\t\tright_gen = btrfs_node_ptr_generation(\n\t\t\t\t\t\tright_path->nodes[right_level],\n\t\t\t\t\t\tright_path->slots[right_level]);\n\t\t\t\tif (left_blockptr == right_blockptr &&\n\t\t\t\t    left_gen == right_gen) {\n\t\t\t\t\t/*\n\t\t\t\t\t * As we're on a shared block, don't\n\t\t\t\t\t * allow to go deeper.\n\t\t\t\t\t */\n\t\t\t\t\tadvance_left = ADVANCE_ONLY_NEXT;\n\t\t\t\t\tadvance_right = ADVANCE_ONLY_NEXT;\n\t\t\t\t} else {\n\t\t\t\t\tadvance_left = ADVANCE;\n\t\t\t\t\tadvance_right = ADVANCE;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (left_level < right_level) {\n\t\t\tadvance_right = ADVANCE;\n\t\t} else {\n\t\t\tadvance_left = ADVANCE;\n\t\t}\n\t}\n\nout:\n\tbtrfs_free_path(left_path);\n\tbtrfs_free_path(right_path);\n\tkfree(tmp_buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define ADVANCE_ONLY_NEXT -1",
            "#define ADVANCE 1"
          ],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define ADVANCE_ONLY_NEXT -1\n#define ADVANCE 1\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_compare_trees(struct btrfs_root *left_root,\n\t\t\tstruct btrfs_root *right_root,\n\t\t\tbtrfs_changed_cb_t changed_cb, void *ctx)\n{\n\tint ret;\n\tint cmp;\n\tstruct btrfs_path *left_path = NULL;\n\tstruct btrfs_path *right_path = NULL;\n\tstruct btrfs_key left_key;\n\tstruct btrfs_key right_key;\n\tchar *tmp_buf = NULL;\n\tint left_root_level;\n\tint right_root_level;\n\tint left_level;\n\tint right_level;\n\tint left_end_reached;\n\tint right_end_reached;\n\tint advance_left;\n\tint advance_right;\n\tu64 left_blockptr;\n\tu64 right_blockptr;\n\tu64 left_gen;\n\tu64 right_gen;\n\n\tleft_path = btrfs_alloc_path();\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tright_path = btrfs_alloc_path();\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttmp_buf = kmalloc(left_root->nodesize, GFP_NOFS);\n\tif (!tmp_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tleft_path->search_commit_root = 1;\n\tleft_path->skip_locking = 1;\n\tright_path->search_commit_root = 1;\n\tright_path->skip_locking = 1;\n\n\t/*\n\t * Strategy: Go to the first items of both trees. Then do\n\t *\n\t * If both trees are at level 0\n\t *   Compare keys of current items\n\t *     If left < right treat left item as new, advance left tree\n\t *       and repeat\n\t *     If left > right treat right item as deleted, advance right tree\n\t *       and repeat\n\t *     If left == right do deep compare of items, treat as changed if\n\t *       needed, advance both trees and repeat\n\t * If both trees are at the same level but not at level 0\n\t *   Compare keys of current nodes/leafs\n\t *     If left < right advance left tree and repeat\n\t *     If left > right advance right tree and repeat\n\t *     If left == right compare blockptrs of the next nodes/leafs\n\t *       If they match advance both trees but stay at the same level\n\t *         and repeat\n\t *       If they don't match advance both trees while allowing to go\n\t *         deeper and repeat\n\t * If tree levels are different\n\t *   Advance the tree that needs it and repeat\n\t *\n\t * Advancing a tree means:\n\t *   If we are at level 0, try to go to the next slot. If that's not\n\t *   possible, go one level up and repeat. Stop when we found a level\n\t *   where we could go to the next slot. We may at this point be on a\n\t *   node or a leaf.\n\t *\n\t *   If we are not at level 0 and not on shared tree blocks, go one\n\t *   level deeper.\n\t *\n\t *   If we are not at level 0 and on shared tree blocks, go one slot to\n\t *   the right if possible or go up and right.\n\t */\n\n\tdown_read(&left_root->fs_info->commit_root_sem);\n\tleft_level = btrfs_header_level(left_root->commit_root);\n\tleft_root_level = left_level;\n\tleft_path->nodes[left_level] = left_root->commit_root;\n\textent_buffer_get(left_path->nodes[left_level]);\n\n\tright_level = btrfs_header_level(right_root->commit_root);\n\tright_root_level = right_level;\n\tright_path->nodes[right_level] = right_root->commit_root;\n\textent_buffer_get(right_path->nodes[right_level]);\n\tup_read(&left_root->fs_info->commit_root_sem);\n\n\tif (left_level == 0)\n\t\tbtrfs_item_key_to_cpu(left_path->nodes[left_level],\n\t\t\t\t&left_key, left_path->slots[left_level]);\n\telse\n\t\tbtrfs_node_key_to_cpu(left_path->nodes[left_level],\n\t\t\t\t&left_key, left_path->slots[left_level]);\n\tif (right_level == 0)\n\t\tbtrfs_item_key_to_cpu(right_path->nodes[right_level],\n\t\t\t\t&right_key, right_path->slots[right_level]);\n\telse\n\t\tbtrfs_node_key_to_cpu(right_path->nodes[right_level],\n\t\t\t\t&right_key, right_path->slots[right_level]);\n\n\tleft_end_reached = right_end_reached = 0;\n\tadvance_left = advance_right = 0;\n\n\twhile (1) {\n\t\tif (advance_left && !left_end_reached) {\n\t\t\tret = tree_advance(left_root, left_path, &left_level,\n\t\t\t\t\tleft_root_level,\n\t\t\t\t\tadvance_left != ADVANCE_ONLY_NEXT,\n\t\t\t\t\t&left_key);\n\t\t\tif (ret < 0)\n\t\t\t\tleft_end_reached = ADVANCE;\n\t\t\tadvance_left = 0;\n\t\t}\n\t\tif (advance_right && !right_end_reached) {\n\t\t\tret = tree_advance(right_root, right_path, &right_level,\n\t\t\t\t\tright_root_level,\n\t\t\t\t\tadvance_right != ADVANCE_ONLY_NEXT,\n\t\t\t\t\t&right_key);\n\t\t\tif (ret < 0)\n\t\t\t\tright_end_reached = ADVANCE;\n\t\t\tadvance_right = 0;\n\t\t}\n\n\t\tif (left_end_reached && right_end_reached) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t} else if (left_end_reached) {\n\t\t\tif (right_level == 0) {\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\tleft_path, right_path,\n\t\t\t\t\t\t&right_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_DELETED,\n\t\t\t\t\t\tctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tadvance_right = ADVANCE;\n\t\t\tcontinue;\n\t\t} else if (right_end_reached) {\n\t\t\tif (left_level == 0) {\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\tleft_path, right_path,\n\t\t\t\t\t\t&left_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_NEW,\n\t\t\t\t\t\tctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tadvance_left = ADVANCE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (left_level == 0 && right_level == 0) {\n\t\t\tcmp = btrfs_comp_cpu_keys(&left_key, &right_key);\n\t\t\tif (cmp < 0) {\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\tleft_path, right_path,\n\t\t\t\t\t\t&left_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_NEW,\n\t\t\t\t\t\tctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tadvance_left = ADVANCE;\n\t\t\t} else if (cmp > 0) {\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\tleft_path, right_path,\n\t\t\t\t\t\t&right_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_DELETED,\n\t\t\t\t\t\tctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tadvance_right = ADVANCE;\n\t\t\t} else {\n\t\t\t\tenum btrfs_compare_tree_result result;\n\n\t\t\t\tWARN_ON(!extent_buffer_uptodate(left_path->nodes[0]));\n\t\t\t\tret = tree_compare_item(left_root, left_path,\n\t\t\t\t\t\tright_path, tmp_buf);\n\t\t\t\tif (ret)\n\t\t\t\t\tresult = BTRFS_COMPARE_TREE_CHANGED;\n\t\t\t\telse\n\t\t\t\t\tresult = BTRFS_COMPARE_TREE_SAME;\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\t left_path, right_path,\n\t\t\t\t\t\t &left_key, result, ctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tadvance_left = ADVANCE;\n\t\t\t\tadvance_right = ADVANCE;\n\t\t\t}\n\t\t} else if (left_level == right_level) {\n\t\t\tcmp = btrfs_comp_cpu_keys(&left_key, &right_key);\n\t\t\tif (cmp < 0) {\n\t\t\t\tadvance_left = ADVANCE;\n\t\t\t} else if (cmp > 0) {\n\t\t\t\tadvance_right = ADVANCE;\n\t\t\t} else {\n\t\t\t\tleft_blockptr = btrfs_node_blockptr(\n\t\t\t\t\t\tleft_path->nodes[left_level],\n\t\t\t\t\t\tleft_path->slots[left_level]);\n\t\t\t\tright_blockptr = btrfs_node_blockptr(\n\t\t\t\t\t\tright_path->nodes[right_level],\n\t\t\t\t\t\tright_path->slots[right_level]);\n\t\t\t\tleft_gen = btrfs_node_ptr_generation(\n\t\t\t\t\t\tleft_path->nodes[left_level],\n\t\t\t\t\t\tleft_path->slots[left_level]);\n\t\t\t\tright_gen = btrfs_node_ptr_generation(\n\t\t\t\t\t\tright_path->nodes[right_level],\n\t\t\t\t\t\tright_path->slots[right_level]);\n\t\t\t\tif (left_blockptr == right_blockptr &&\n\t\t\t\t    left_gen == right_gen) {\n\t\t\t\t\t/*\n\t\t\t\t\t * As we're on a shared block, don't\n\t\t\t\t\t * allow to go deeper.\n\t\t\t\t\t */\n\t\t\t\t\tadvance_left = ADVANCE_ONLY_NEXT;\n\t\t\t\t\tadvance_right = ADVANCE_ONLY_NEXT;\n\t\t\t\t} else {\n\t\t\t\t\tadvance_left = ADVANCE;\n\t\t\t\t\tadvance_right = ADVANCE;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (left_level < right_level) {\n\t\t\tadvance_right = ADVANCE;\n\t\t} else {\n\t\t\tadvance_left = ADVANCE;\n\t\t}\n\t}\n\nout:\n\tbtrfs_free_path(left_path);\n\tbtrfs_free_path(right_path);\n\tkfree(tmp_buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_subvol_begin",
          "args": [
            "sctx"
          ],
          "line": 5625
        },
        "resolved": true,
        "details": {
          "function_name": "send_subvol_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2268-2344",
          "snippet": "static int send_subvol_begin(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *send_root = sctx->send_root;\n\tstruct btrfs_root *parent_root = sctx->parent_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_root_ref *ref;\n\tstruct extent_buffer *leaf;\n\tchar *name = NULL;\n\tint namelen;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tname = kmalloc(BTRFS_PATH_NAME_MAX, GFP_NOFS);\n\tif (!name) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\tkey.objectid = send_root->objectid;\n\tkey.type = BTRFS_ROOT_BACKREF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(send_root->fs_info->tree_root,\n\t\t\t\t&key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tif (key.type != BTRFS_ROOT_BACKREF_KEY ||\n\t    key.objectid != send_root->objectid) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tref = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_root_ref);\n\tnamelen = btrfs_root_ref_name_len(leaf, ref);\n\tread_extent_buffer(leaf, name, (unsigned long)(ref + 1), namelen);\n\tbtrfs_release_path(path);\n\n\tif (parent_root) {\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_SNAPSHOT);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_SUBVOL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tTLV_PUT_STRING(sctx, BTRFS_SEND_A_PATH, name, namelen);\n\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_UUID,\n\t\t\tsctx->send_root->root_item.uuid);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CTRANSID,\n\t\t    le64_to_cpu(sctx->send_root->root_item.ctransid));\n\tif (parent_root) {\n\t\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_CLONE_UUID,\n\t\t\t\tsctx->parent_root->root_item.uuid);\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_CTRANSID,\n\t\t\t    le64_to_cpu(sctx->parent_root->root_item.ctransid));\n\t}\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tbtrfs_free_path(path);\n\tkfree(name);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_subvol_begin(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *send_root = sctx->send_root;\n\tstruct btrfs_root *parent_root = sctx->parent_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_root_ref *ref;\n\tstruct extent_buffer *leaf;\n\tchar *name = NULL;\n\tint namelen;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tname = kmalloc(BTRFS_PATH_NAME_MAX, GFP_NOFS);\n\tif (!name) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\tkey.objectid = send_root->objectid;\n\tkey.type = BTRFS_ROOT_BACKREF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(send_root->fs_info->tree_root,\n\t\t\t\t&key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tif (key.type != BTRFS_ROOT_BACKREF_KEY ||\n\t    key.objectid != send_root->objectid) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tref = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_root_ref);\n\tnamelen = btrfs_root_ref_name_len(leaf, ref);\n\tread_extent_buffer(leaf, name, (unsigned long)(ref + 1), namelen);\n\tbtrfs_release_path(path);\n\n\tif (parent_root) {\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_SNAPSHOT);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_SUBVOL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tTLV_PUT_STRING(sctx, BTRFS_SEND_A_PATH, name, namelen);\n\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_UUID,\n\t\t\tsctx->send_root->root_item.uuid);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CTRANSID,\n\t\t    le64_to_cpu(sctx->send_root->root_item.ctransid));\n\tif (parent_root) {\n\t\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_CLONE_UUID,\n\t\t\t\tsctx->parent_root->root_item.uuid);\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_CTRANSID,\n\t\t\t    le64_to_cpu(sctx->parent_root->root_item.ctransid));\n\t}\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tbtrfs_free_path(path);\n\tkfree(name);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_header",
          "args": [
            "sctx"
          ],
          "line": 5620
        },
        "resolved": true,
        "details": {
          "function_name": "send_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "637-646",
          "snippet": "static int send_header(struct send_ctx *sctx)\n{\n\tstruct btrfs_stream_header hdr;\n\n\tstrcpy(hdr.magic, BTRFS_SEND_STREAM_MAGIC);\n\thdr.version = cpu_to_le32(BTRFS_SEND_STREAM_VERSION);\n\n\treturn write_buf(sctx->send_filp, &hdr, sizeof(hdr),\n\t\t\t\t\t&sctx->send_off);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_header(struct send_ctx *sctx)\n{\n\tstruct btrfs_stream_header hdr;\n\n\tstrcpy(hdr.magic, BTRFS_SEND_STREAM_MAGIC);\n\thdr.version = cpu_to_le32(BTRFS_SEND_STREAM_VERSION);\n\n\treturn write_buf(sctx->send_filp, &hdr, sizeof(hdr),\n\t\t\t\t\t&sctx->send_off);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_subvol(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tif (!(sctx->flags & BTRFS_SEND_FLAG_OMIT_STREAM_HEADER)) {\n\t\tret = send_header(sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = send_subvol_begin(sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (sctx->parent_root) {\n\t\tret = btrfs_compare_trees(sctx->send_root, sctx->parent_root,\n\t\t\t\tchanged_cb, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = finish_inode_if_needed(sctx, 1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tret = full_send_tree(sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tfree_recorded_refs(sctx);\n\treturn ret;\n}"
  },
  {
    "function_name": "full_send_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "5560-5613",
    "snippet": "static int full_send_tree(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *send_root = sctx->send_root;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(send_root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret)\n\t\tgoto out_finish;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\n\t\tret = changed_cb(send_root, NULL, path, NULL,\n\t\t\t\t&found_key, BTRFS_COMPARE_TREE_NEW, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tkey.objectid = found_key.objectid;\n\t\tkey.type = found_key.type;\n\t\tkey.offset = found_key.offset + 1;\n\n\t\tret = btrfs_next_item(send_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret  = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout_finish:\n\tret = finish_inode_if_needed(sctx, 1);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 5611
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_inode_if_needed",
          "args": [
            "sctx",
            "1"
          ],
          "line": 5608
        },
        "resolved": true,
        "details": {
          "function_name": "finish_inode_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "5099-5218",
          "snippet": "static int finish_inode_if_needed(struct send_ctx *sctx, int at_end)\n{\n\tint ret = 0;\n\tu64 left_mode;\n\tu64 left_uid;\n\tu64 left_gid;\n\tu64 right_mode;\n\tu64 right_uid;\n\tu64 right_gid;\n\tint need_chmod = 0;\n\tint need_chown = 0;\n\tint pending_move = 0;\n\tint refs_processed = 0;\n\n\tret = process_recorded_refs_if_needed(sctx, at_end, &pending_move,\n\t\t\t\t\t      &refs_processed);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * We have processed the refs and thus need to advance send_progress.\n\t * Now, calls to get_cur_xxx will take the updated refs of the current\n\t * inode into account.\n\t *\n\t * On the other hand, if our current inode is a directory and couldn't\n\t * be moved/renamed because its parent was renamed/moved too and it has\n\t * a higher inode number, we can only move/rename our current inode\n\t * after we moved/renamed its parent. Therefore in this case operate on\n\t * the old path (pre move/rename) of our current inode, and the\n\t * move/rename will be performed later.\n\t */\n\tif (refs_processed && !pending_move)\n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\n\tif (sctx->cur_ino == 0 || sctx->cur_inode_deleted)\n\t\tgoto out;\n\tif (!at_end && sctx->cmp_key->objectid == sctx->cur_ino)\n\t\tgoto out;\n\n\tret = get_inode_info(sctx->send_root, sctx->cur_ino, NULL, NULL,\n\t\t\t&left_mode, &left_uid, &left_gid, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!sctx->parent_root || sctx->cur_inode_new) {\n\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode))\n\t\t\tneed_chmod = 1;\n\t} else {\n\t\tret = get_inode_info(sctx->parent_root, sctx->cur_ino,\n\t\t\t\tNULL, NULL, &right_mode, &right_uid,\n\t\t\t\t&right_gid, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (left_uid != right_uid || left_gid != right_gid)\n\t\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode) && left_mode != right_mode)\n\t\t\tneed_chmod = 1;\n\t}\n\n\tif (S_ISREG(sctx->cur_inode_mode)) {\n\t\tif (need_send_hole(sctx)) {\n\t\t\tif (sctx->cur_inode_last_extent == (u64)-1 ||\n\t\t\t    sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = get_last_extent(sctx, (u64)-1);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = send_hole(sctx, sctx->cur_inode_size);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = send_truncate(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tsctx->cur_inode_size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (need_chown) {\n\t\tret = send_chown(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_uid, left_gid);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tif (need_chmod) {\n\t\tret = send_chmod(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_mode);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * If other directory inodes depended on our current directory\n\t * inode's move/rename, now do their move/rename operations.\n\t */\n\tif (!is_waiting_for_move(sctx, sctx->cur_ino)) {\n\t\tret = apply_children_dir_moves(sctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Need to send that every time, no matter if it actually\n\t\t * changed between the two trees as we have done changes to\n\t\t * the inode before. If our inode is a directory and it's\n\t\t * waiting to be moved/renamed, we will send its utimes when\n\t\t * it's moved/renamed, therefore we don't need to do it here.\n\t\t */\n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\t\tret = send_utimes(sctx, sctx->cur_ino, sctx->cur_inode_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int finish_inode_if_needed(struct send_ctx *sctx, int at_end)\n{\n\tint ret = 0;\n\tu64 left_mode;\n\tu64 left_uid;\n\tu64 left_gid;\n\tu64 right_mode;\n\tu64 right_uid;\n\tu64 right_gid;\n\tint need_chmod = 0;\n\tint need_chown = 0;\n\tint pending_move = 0;\n\tint refs_processed = 0;\n\n\tret = process_recorded_refs_if_needed(sctx, at_end, &pending_move,\n\t\t\t\t\t      &refs_processed);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * We have processed the refs and thus need to advance send_progress.\n\t * Now, calls to get_cur_xxx will take the updated refs of the current\n\t * inode into account.\n\t *\n\t * On the other hand, if our current inode is a directory and couldn't\n\t * be moved/renamed because its parent was renamed/moved too and it has\n\t * a higher inode number, we can only move/rename our current inode\n\t * after we moved/renamed its parent. Therefore in this case operate on\n\t * the old path (pre move/rename) of our current inode, and the\n\t * move/rename will be performed later.\n\t */\n\tif (refs_processed && !pending_move)\n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\n\tif (sctx->cur_ino == 0 || sctx->cur_inode_deleted)\n\t\tgoto out;\n\tif (!at_end && sctx->cmp_key->objectid == sctx->cur_ino)\n\t\tgoto out;\n\n\tret = get_inode_info(sctx->send_root, sctx->cur_ino, NULL, NULL,\n\t\t\t&left_mode, &left_uid, &left_gid, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!sctx->parent_root || sctx->cur_inode_new) {\n\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode))\n\t\t\tneed_chmod = 1;\n\t} else {\n\t\tret = get_inode_info(sctx->parent_root, sctx->cur_ino,\n\t\t\t\tNULL, NULL, &right_mode, &right_uid,\n\t\t\t\t&right_gid, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (left_uid != right_uid || left_gid != right_gid)\n\t\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode) && left_mode != right_mode)\n\t\t\tneed_chmod = 1;\n\t}\n\n\tif (S_ISREG(sctx->cur_inode_mode)) {\n\t\tif (need_send_hole(sctx)) {\n\t\t\tif (sctx->cur_inode_last_extent == (u64)-1 ||\n\t\t\t    sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = get_last_extent(sctx, (u64)-1);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = send_hole(sctx, sctx->cur_inode_size);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = send_truncate(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tsctx->cur_inode_size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (need_chown) {\n\t\tret = send_chown(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_uid, left_gid);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tif (need_chmod) {\n\t\tret = send_chmod(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_mode);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * If other directory inodes depended on our current directory\n\t * inode's move/rename, now do their move/rename operations.\n\t */\n\tif (!is_waiting_for_move(sctx, sctx->cur_ino)) {\n\t\tret = apply_children_dir_moves(sctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Need to send that every time, no matter if it actually\n\t\t * changed between the two trees as we have done changes to\n\t\t * the inode before. If our inode is a directory and it's\n\t\t * waiting to be moved/renamed, we will send its utimes when\n\t\t * it's moved/renamed, therefore we don't need to do it here.\n\t\t */\n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\t\tret = send_utimes(sctx, sctx->cur_ino, sctx->cur_inode_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_item",
          "args": [
            "send_root",
            "path"
          ],
          "line": 5598
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3600-3603",
          "snippet": "static inline int btrfs_next_item(struct btrfs_root *root, struct btrfs_path *p)\n{\n\treturn btrfs_next_old_item(root, p, 0);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_next_item(struct btrfs_root *root, struct btrfs_path *p)\n{\n\treturn btrfs_next_old_item(root, p, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "changed_cb",
          "args": [
            "send_root",
            "NULL",
            "path",
            "NULL",
            "&found_key",
            "BTRFS_COMPARE_TREE_NEW",
            "sctx"
          ],
          "line": 5589
        },
        "resolved": true,
        "details": {
          "function_name": "changed_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "5505-5558",
          "snippet": "static int changed_cb(struct btrfs_root *left_root,\n\t\t      struct btrfs_root *right_root,\n\t\t      struct btrfs_path *left_path,\n\t\t      struct btrfs_path *right_path,\n\t\t      struct btrfs_key *key,\n\t\t      enum btrfs_compare_tree_result result,\n\t\t      void *ctx)\n{\n\tint ret = 0;\n\tstruct send_ctx *sctx = ctx;\n\n\tif (result == BTRFS_COMPARE_TREE_SAME) {\n\t\tif (key->type == BTRFS_INODE_REF_KEY ||\n\t\t    key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\tret = compare_refs(sctx, left_path, key);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t} else if (key->type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\treturn maybe_send_hole(sctx, left_path, key);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\tresult = BTRFS_COMPARE_TREE_CHANGED;\n\t\tret = 0;\n\t}\n\n\tsctx->left_path = left_path;\n\tsctx->right_path = right_path;\n\tsctx->cmp_key = key;\n\n\tret = finish_inode_if_needed(sctx, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Ignore non-FS objects */\n\tif (key->objectid == BTRFS_FREE_INO_OBJECTID ||\n\t    key->objectid == BTRFS_FREE_SPACE_OBJECTID)\n\t\tgoto out;\n\n\tif (key->type == BTRFS_INODE_ITEM_KEY)\n\t\tret = changed_inode(sctx, result);\n\telse if (key->type == BTRFS_INODE_REF_KEY ||\n\t\t key->type == BTRFS_INODE_EXTREF_KEY)\n\t\tret = changed_ref(sctx, result);\n\telse if (key->type == BTRFS_XATTR_ITEM_KEY)\n\t\tret = changed_xattr(sctx, result);\n\telse if (key->type == BTRFS_EXTENT_DATA_KEY)\n\t\tret = changed_extent(sctx, result);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int changed_cb(struct btrfs_root *left_root,\n\t\t      struct btrfs_root *right_root,\n\t\t      struct btrfs_path *left_path,\n\t\t      struct btrfs_path *right_path,\n\t\t      struct btrfs_key *key,\n\t\t      enum btrfs_compare_tree_result result,\n\t\t      void *ctx)\n{\n\tint ret = 0;\n\tstruct send_ctx *sctx = ctx;\n\n\tif (result == BTRFS_COMPARE_TREE_SAME) {\n\t\tif (key->type == BTRFS_INODE_REF_KEY ||\n\t\t    key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\tret = compare_refs(sctx, left_path, key);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t} else if (key->type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\treturn maybe_send_hole(sctx, left_path, key);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\tresult = BTRFS_COMPARE_TREE_CHANGED;\n\t\tret = 0;\n\t}\n\n\tsctx->left_path = left_path;\n\tsctx->right_path = right_path;\n\tsctx->cmp_key = key;\n\n\tret = finish_inode_if_needed(sctx, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Ignore non-FS objects */\n\tif (key->objectid == BTRFS_FREE_INO_OBJECTID ||\n\t    key->objectid == BTRFS_FREE_SPACE_OBJECTID)\n\t\tgoto out;\n\n\tif (key->type == BTRFS_INODE_ITEM_KEY)\n\t\tret = changed_inode(sctx, result);\n\telse if (key->type == BTRFS_INODE_REF_KEY ||\n\t\t key->type == BTRFS_INODE_EXTREF_KEY)\n\t\tret = changed_ref(sctx, result);\n\telse if (key->type == BTRFS_XATTR_ITEM_KEY)\n\t\tret = changed_xattr(sctx, result);\n\telse if (key->type == BTRFS_EXTENT_DATA_KEY)\n\t\tret = changed_extent(sctx, result);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "eb",
            "&found_key",
            "slot"
          ],
          "line": 5587
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot_for_read",
          "args": [
            "send_root",
            "&key",
            "path",
            "1",
            "0"
          ],
          "line": 5578
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot_for_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3057-3119",
          "snippet": "int btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_path_for_send",
          "args": [],
          "line": 5570
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_path_for_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "496-507",
          "snippet": "static struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int full_send_tree(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *send_root = sctx->send_root;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(send_root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret)\n\t\tgoto out_finish;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\n\t\tret = changed_cb(send_root, NULL, path, NULL,\n\t\t\t\t&found_key, BTRFS_COMPARE_TREE_NEW, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tkey.objectid = found_key.objectid;\n\t\tkey.type = found_key.type;\n\t\tkey.offset = found_key.offset + 1;\n\n\t\tret = btrfs_next_item(send_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret  = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout_finish:\n\tret = finish_inode_if_needed(sctx, 1);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "changed_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "5505-5558",
    "snippet": "static int changed_cb(struct btrfs_root *left_root,\n\t\t      struct btrfs_root *right_root,\n\t\t      struct btrfs_path *left_path,\n\t\t      struct btrfs_path *right_path,\n\t\t      struct btrfs_key *key,\n\t\t      enum btrfs_compare_tree_result result,\n\t\t      void *ctx)\n{\n\tint ret = 0;\n\tstruct send_ctx *sctx = ctx;\n\n\tif (result == BTRFS_COMPARE_TREE_SAME) {\n\t\tif (key->type == BTRFS_INODE_REF_KEY ||\n\t\t    key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\tret = compare_refs(sctx, left_path, key);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t} else if (key->type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\treturn maybe_send_hole(sctx, left_path, key);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\tresult = BTRFS_COMPARE_TREE_CHANGED;\n\t\tret = 0;\n\t}\n\n\tsctx->left_path = left_path;\n\tsctx->right_path = right_path;\n\tsctx->cmp_key = key;\n\n\tret = finish_inode_if_needed(sctx, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Ignore non-FS objects */\n\tif (key->objectid == BTRFS_FREE_INO_OBJECTID ||\n\t    key->objectid == BTRFS_FREE_SPACE_OBJECTID)\n\t\tgoto out;\n\n\tif (key->type == BTRFS_INODE_ITEM_KEY)\n\t\tret = changed_inode(sctx, result);\n\telse if (key->type == BTRFS_INODE_REF_KEY ||\n\t\t key->type == BTRFS_INODE_EXTREF_KEY)\n\t\tret = changed_ref(sctx, result);\n\telse if (key->type == BTRFS_XATTR_ITEM_KEY)\n\t\tret = changed_xattr(sctx, result);\n\telse if (key->type == BTRFS_EXTENT_DATA_KEY)\n\t\tret = changed_extent(sctx, result);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "changed_extent",
          "args": [
            "sctx",
            "result"
          ],
          "line": 5554
        },
        "resolved": true,
        "details": {
          "function_name": "changed_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "5427-5441",
          "snippet": "static int changed_extent(struct send_ctx *sctx,\n\t\t\t  enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\n\tBUG_ON(sctx->cur_ino != sctx->cmp_key->objectid);\n\n\tif (!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted) {\n\t\tif (result != BTRFS_COMPARE_TREE_DELETED)\n\t\t\tret = process_extent(sctx, sctx->left_path,\n\t\t\t\t\tsctx->cmp_key);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int changed_extent(struct send_ctx *sctx,\n\t\t\t  enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\n\tBUG_ON(sctx->cur_ino != sctx->cmp_key->objectid);\n\n\tif (!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted) {\n\t\tif (result != BTRFS_COMPARE_TREE_DELETED)\n\t\t\tret = process_extent(sctx, sctx->left_path,\n\t\t\t\t\tsctx->cmp_key);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "changed_xattr",
          "args": [
            "sctx",
            "result"
          ],
          "line": 5552
        },
        "resolved": true,
        "details": {
          "function_name": "changed_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "5403-5420",
          "snippet": "static int changed_xattr(struct send_ctx *sctx,\n\t\t\t enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\n\tBUG_ON(sctx->cur_ino != sctx->cmp_key->objectid);\n\n\tif (!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted) {\n\t\tif (result == BTRFS_COMPARE_TREE_NEW)\n\t\t\tret = process_new_xattr(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_DELETED)\n\t\t\tret = process_deleted_xattr(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_CHANGED)\n\t\t\tret = process_changed_xattr(sctx);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int changed_xattr(struct send_ctx *sctx,\n\t\t\t enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\n\tBUG_ON(sctx->cur_ino != sctx->cmp_key->objectid);\n\n\tif (!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted) {\n\t\tif (result == BTRFS_COMPARE_TREE_NEW)\n\t\t\tret = process_new_xattr(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_DELETED)\n\t\t\tret = process_deleted_xattr(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_CHANGED)\n\t\t\tret = process_changed_xattr(sctx);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "changed_ref",
          "args": [
            "sctx",
            "result"
          ],
          "line": 5550
        },
        "resolved": true,
        "details": {
          "function_name": "changed_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "5378-5396",
          "snippet": "static int changed_ref(struct send_ctx *sctx,\n\t\t       enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\n\tBUG_ON(sctx->cur_ino != sctx->cmp_key->objectid);\n\n\tif (!sctx->cur_inode_new_gen &&\n\t    sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tif (result == BTRFS_COMPARE_TREE_NEW)\n\t\t\tret = record_new_ref(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_DELETED)\n\t\t\tret = record_deleted_ref(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_CHANGED)\n\t\t\tret = record_changed_ref(sctx);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int changed_ref(struct send_ctx *sctx,\n\t\t       enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\n\tBUG_ON(sctx->cur_ino != sctx->cmp_key->objectid);\n\n\tif (!sctx->cur_inode_new_gen &&\n\t    sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tif (result == BTRFS_COMPARE_TREE_NEW)\n\t\t\tret = record_new_ref(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_DELETED)\n\t\t\tret = record_deleted_ref(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_CHANGED)\n\t\t\tret = record_changed_ref(sctx);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "changed_inode",
          "args": [
            "sctx",
            "result"
          ],
          "line": 5547
        },
        "resolved": true,
        "details": {
          "function_name": "changed_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "5220-5366",
          "snippet": "static int changed_inode(struct send_ctx *sctx,\n\t\t\t enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\tstruct btrfs_key *key = sctx->cmp_key;\n\tstruct btrfs_inode_item *left_ii = NULL;\n\tstruct btrfs_inode_item *right_ii = NULL;\n\tu64 left_gen = 0;\n\tu64 right_gen = 0;\n\n\tsctx->cur_ino = key->objectid;\n\tsctx->cur_inode_new_gen = 0;\n\tsctx->cur_inode_last_extent = (u64)-1;\n\n\t/*\n\t * Set send_progress to current inode. This will tell all get_cur_xxx\n\t * functions that the current inode's refs are not updated yet. Later,\n\t * when process_recorded_refs is finished, it is set to cur_ino + 1.\n\t */\n\tsctx->send_progress = sctx->cur_ino;\n\n\tif (result == BTRFS_COMPARE_TREE_NEW ||\n\t    result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\tleft_ii = btrfs_item_ptr(sctx->left_path->nodes[0],\n\t\t\t\tsctx->left_path->slots[0],\n\t\t\t\tstruct btrfs_inode_item);\n\t\tleft_gen = btrfs_inode_generation(sctx->left_path->nodes[0],\n\t\t\t\tleft_ii);\n\t} else {\n\t\tright_ii = btrfs_item_ptr(sctx->right_path->nodes[0],\n\t\t\t\tsctx->right_path->slots[0],\n\t\t\t\tstruct btrfs_inode_item);\n\t\tright_gen = btrfs_inode_generation(sctx->right_path->nodes[0],\n\t\t\t\tright_ii);\n\t}\n\tif (result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\tright_ii = btrfs_item_ptr(sctx->right_path->nodes[0],\n\t\t\t\tsctx->right_path->slots[0],\n\t\t\t\tstruct btrfs_inode_item);\n\n\t\tright_gen = btrfs_inode_generation(sctx->right_path->nodes[0],\n\t\t\t\tright_ii);\n\n\t\t/*\n\t\t * The cur_ino = root dir case is special here. We can't treat\n\t\t * the inode as deleted+reused because it would generate a\n\t\t * stream that tries to delete/mkdir the root dir.\n\t\t */\n\t\tif (left_gen != right_gen &&\n\t\t    sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID)\n\t\t\tsctx->cur_inode_new_gen = 1;\n\t}\n\n\tif (result == BTRFS_COMPARE_TREE_NEW) {\n\t\tsctx->cur_inode_gen = left_gen;\n\t\tsctx->cur_inode_new = 1;\n\t\tsctx->cur_inode_deleted = 0;\n\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\tsctx->cur_inode_rdev = btrfs_inode_rdev(\n\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\tif (sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID)\n\t\t\tret = send_create_inode_if_needed(sctx);\n\t} else if (result == BTRFS_COMPARE_TREE_DELETED) {\n\t\tsctx->cur_inode_gen = right_gen;\n\t\tsctx->cur_inode_new = 0;\n\t\tsctx->cur_inode_deleted = 1;\n\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t} else if (result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\t/*\n\t\t * We need to do some special handling in case the inode was\n\t\t * reported as changed with a changed generation number. This\n\t\t * means that the original inode was deleted and new inode\n\t\t * reused the same inum. So we have to treat the old inode as\n\t\t * deleted and the new one as new.\n\t\t */\n\t\tif (sctx->cur_inode_new_gen) {\n\t\t\t/*\n\t\t\t * First, process the inode as if it was deleted.\n\t\t\t */\n\t\t\tsctx->cur_inode_gen = right_gen;\n\t\t\tsctx->cur_inode_new = 0;\n\t\t\tsctx->cur_inode_deleted = 1;\n\t\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t\t\tret = process_all_refs(sctx,\n\t\t\t\t\tBTRFS_COMPARE_TREE_DELETED);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Now process the inode as if it was new.\n\t\t\t */\n\t\t\tsctx->cur_inode_gen = left_gen;\n\t\t\tsctx->cur_inode_new = 1;\n\t\t\tsctx->cur_inode_deleted = 0;\n\t\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tsctx->cur_inode_rdev = btrfs_inode_rdev(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tret = send_create_inode_if_needed(sctx);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tret = process_all_refs(sctx, BTRFS_COMPARE_TREE_NEW);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Advance send_progress now as we did not get into\n\t\t\t * process_recorded_refs_if_needed in the new_gen case.\n\t\t\t */\n\t\t\tsctx->send_progress = sctx->cur_ino + 1;\n\n\t\t\t/*\n\t\t\t * Now process all extents and xattrs of the inode as if\n\t\t\t * they were all new.\n\t\t\t */\n\t\t\tret = process_all_extents(sctx);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = process_all_new_xattrs(sctx);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tsctx->cur_inode_gen = left_gen;\n\t\t\tsctx->cur_inode_new = 0;\n\t\t\tsctx->cur_inode_new_gen = 0;\n\t\t\tsctx->cur_inode_deleted = 0;\n\t\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int changed_inode(struct send_ctx *sctx,\n\t\t\t enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\tstruct btrfs_key *key = sctx->cmp_key;\n\tstruct btrfs_inode_item *left_ii = NULL;\n\tstruct btrfs_inode_item *right_ii = NULL;\n\tu64 left_gen = 0;\n\tu64 right_gen = 0;\n\n\tsctx->cur_ino = key->objectid;\n\tsctx->cur_inode_new_gen = 0;\n\tsctx->cur_inode_last_extent = (u64)-1;\n\n\t/*\n\t * Set send_progress to current inode. This will tell all get_cur_xxx\n\t * functions that the current inode's refs are not updated yet. Later,\n\t * when process_recorded_refs is finished, it is set to cur_ino + 1.\n\t */\n\tsctx->send_progress = sctx->cur_ino;\n\n\tif (result == BTRFS_COMPARE_TREE_NEW ||\n\t    result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\tleft_ii = btrfs_item_ptr(sctx->left_path->nodes[0],\n\t\t\t\tsctx->left_path->slots[0],\n\t\t\t\tstruct btrfs_inode_item);\n\t\tleft_gen = btrfs_inode_generation(sctx->left_path->nodes[0],\n\t\t\t\tleft_ii);\n\t} else {\n\t\tright_ii = btrfs_item_ptr(sctx->right_path->nodes[0],\n\t\t\t\tsctx->right_path->slots[0],\n\t\t\t\tstruct btrfs_inode_item);\n\t\tright_gen = btrfs_inode_generation(sctx->right_path->nodes[0],\n\t\t\t\tright_ii);\n\t}\n\tif (result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\tright_ii = btrfs_item_ptr(sctx->right_path->nodes[0],\n\t\t\t\tsctx->right_path->slots[0],\n\t\t\t\tstruct btrfs_inode_item);\n\n\t\tright_gen = btrfs_inode_generation(sctx->right_path->nodes[0],\n\t\t\t\tright_ii);\n\n\t\t/*\n\t\t * The cur_ino = root dir case is special here. We can't treat\n\t\t * the inode as deleted+reused because it would generate a\n\t\t * stream that tries to delete/mkdir the root dir.\n\t\t */\n\t\tif (left_gen != right_gen &&\n\t\t    sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID)\n\t\t\tsctx->cur_inode_new_gen = 1;\n\t}\n\n\tif (result == BTRFS_COMPARE_TREE_NEW) {\n\t\tsctx->cur_inode_gen = left_gen;\n\t\tsctx->cur_inode_new = 1;\n\t\tsctx->cur_inode_deleted = 0;\n\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\tsctx->cur_inode_rdev = btrfs_inode_rdev(\n\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\tif (sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID)\n\t\t\tret = send_create_inode_if_needed(sctx);\n\t} else if (result == BTRFS_COMPARE_TREE_DELETED) {\n\t\tsctx->cur_inode_gen = right_gen;\n\t\tsctx->cur_inode_new = 0;\n\t\tsctx->cur_inode_deleted = 1;\n\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t} else if (result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\t/*\n\t\t * We need to do some special handling in case the inode was\n\t\t * reported as changed with a changed generation number. This\n\t\t * means that the original inode was deleted and new inode\n\t\t * reused the same inum. So we have to treat the old inode as\n\t\t * deleted and the new one as new.\n\t\t */\n\t\tif (sctx->cur_inode_new_gen) {\n\t\t\t/*\n\t\t\t * First, process the inode as if it was deleted.\n\t\t\t */\n\t\t\tsctx->cur_inode_gen = right_gen;\n\t\t\tsctx->cur_inode_new = 0;\n\t\t\tsctx->cur_inode_deleted = 1;\n\t\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t\t\tret = process_all_refs(sctx,\n\t\t\t\t\tBTRFS_COMPARE_TREE_DELETED);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Now process the inode as if it was new.\n\t\t\t */\n\t\t\tsctx->cur_inode_gen = left_gen;\n\t\t\tsctx->cur_inode_new = 1;\n\t\t\tsctx->cur_inode_deleted = 0;\n\t\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tsctx->cur_inode_rdev = btrfs_inode_rdev(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tret = send_create_inode_if_needed(sctx);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tret = process_all_refs(sctx, BTRFS_COMPARE_TREE_NEW);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Advance send_progress now as we did not get into\n\t\t\t * process_recorded_refs_if_needed in the new_gen case.\n\t\t\t */\n\t\t\tsctx->send_progress = sctx->cur_ino + 1;\n\n\t\t\t/*\n\t\t\t * Now process all extents and xattrs of the inode as if\n\t\t\t * they were all new.\n\t\t\t */\n\t\t\tret = process_all_extents(sctx);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = process_all_new_xattrs(sctx);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tsctx->cur_inode_gen = left_gen;\n\t\t\tsctx->cur_inode_new = 0;\n\t\t\tsctx->cur_inode_new_gen = 0;\n\t\t\tsctx->cur_inode_deleted = 0;\n\t\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_inode_if_needed",
          "args": [
            "sctx",
            "0"
          ],
          "line": 5537
        },
        "resolved": true,
        "details": {
          "function_name": "finish_inode_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "5099-5218",
          "snippet": "static int finish_inode_if_needed(struct send_ctx *sctx, int at_end)\n{\n\tint ret = 0;\n\tu64 left_mode;\n\tu64 left_uid;\n\tu64 left_gid;\n\tu64 right_mode;\n\tu64 right_uid;\n\tu64 right_gid;\n\tint need_chmod = 0;\n\tint need_chown = 0;\n\tint pending_move = 0;\n\tint refs_processed = 0;\n\n\tret = process_recorded_refs_if_needed(sctx, at_end, &pending_move,\n\t\t\t\t\t      &refs_processed);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * We have processed the refs and thus need to advance send_progress.\n\t * Now, calls to get_cur_xxx will take the updated refs of the current\n\t * inode into account.\n\t *\n\t * On the other hand, if our current inode is a directory and couldn't\n\t * be moved/renamed because its parent was renamed/moved too and it has\n\t * a higher inode number, we can only move/rename our current inode\n\t * after we moved/renamed its parent. Therefore in this case operate on\n\t * the old path (pre move/rename) of our current inode, and the\n\t * move/rename will be performed later.\n\t */\n\tif (refs_processed && !pending_move)\n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\n\tif (sctx->cur_ino == 0 || sctx->cur_inode_deleted)\n\t\tgoto out;\n\tif (!at_end && sctx->cmp_key->objectid == sctx->cur_ino)\n\t\tgoto out;\n\n\tret = get_inode_info(sctx->send_root, sctx->cur_ino, NULL, NULL,\n\t\t\t&left_mode, &left_uid, &left_gid, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!sctx->parent_root || sctx->cur_inode_new) {\n\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode))\n\t\t\tneed_chmod = 1;\n\t} else {\n\t\tret = get_inode_info(sctx->parent_root, sctx->cur_ino,\n\t\t\t\tNULL, NULL, &right_mode, &right_uid,\n\t\t\t\t&right_gid, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (left_uid != right_uid || left_gid != right_gid)\n\t\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode) && left_mode != right_mode)\n\t\t\tneed_chmod = 1;\n\t}\n\n\tif (S_ISREG(sctx->cur_inode_mode)) {\n\t\tif (need_send_hole(sctx)) {\n\t\t\tif (sctx->cur_inode_last_extent == (u64)-1 ||\n\t\t\t    sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = get_last_extent(sctx, (u64)-1);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = send_hole(sctx, sctx->cur_inode_size);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = send_truncate(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tsctx->cur_inode_size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (need_chown) {\n\t\tret = send_chown(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_uid, left_gid);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tif (need_chmod) {\n\t\tret = send_chmod(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_mode);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * If other directory inodes depended on our current directory\n\t * inode's move/rename, now do their move/rename operations.\n\t */\n\tif (!is_waiting_for_move(sctx, sctx->cur_ino)) {\n\t\tret = apply_children_dir_moves(sctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Need to send that every time, no matter if it actually\n\t\t * changed between the two trees as we have done changes to\n\t\t * the inode before. If our inode is a directory and it's\n\t\t * waiting to be moved/renamed, we will send its utimes when\n\t\t * it's moved/renamed, therefore we don't need to do it here.\n\t\t */\n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\t\tret = send_utimes(sctx, sctx->cur_ino, sctx->cur_inode_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int finish_inode_if_needed(struct send_ctx *sctx, int at_end)\n{\n\tint ret = 0;\n\tu64 left_mode;\n\tu64 left_uid;\n\tu64 left_gid;\n\tu64 right_mode;\n\tu64 right_uid;\n\tu64 right_gid;\n\tint need_chmod = 0;\n\tint need_chown = 0;\n\tint pending_move = 0;\n\tint refs_processed = 0;\n\n\tret = process_recorded_refs_if_needed(sctx, at_end, &pending_move,\n\t\t\t\t\t      &refs_processed);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * We have processed the refs and thus need to advance send_progress.\n\t * Now, calls to get_cur_xxx will take the updated refs of the current\n\t * inode into account.\n\t *\n\t * On the other hand, if our current inode is a directory and couldn't\n\t * be moved/renamed because its parent was renamed/moved too and it has\n\t * a higher inode number, we can only move/rename our current inode\n\t * after we moved/renamed its parent. Therefore in this case operate on\n\t * the old path (pre move/rename) of our current inode, and the\n\t * move/rename will be performed later.\n\t */\n\tif (refs_processed && !pending_move)\n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\n\tif (sctx->cur_ino == 0 || sctx->cur_inode_deleted)\n\t\tgoto out;\n\tif (!at_end && sctx->cmp_key->objectid == sctx->cur_ino)\n\t\tgoto out;\n\n\tret = get_inode_info(sctx->send_root, sctx->cur_ino, NULL, NULL,\n\t\t\t&left_mode, &left_uid, &left_gid, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!sctx->parent_root || sctx->cur_inode_new) {\n\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode))\n\t\t\tneed_chmod = 1;\n\t} else {\n\t\tret = get_inode_info(sctx->parent_root, sctx->cur_ino,\n\t\t\t\tNULL, NULL, &right_mode, &right_uid,\n\t\t\t\t&right_gid, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (left_uid != right_uid || left_gid != right_gid)\n\t\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode) && left_mode != right_mode)\n\t\t\tneed_chmod = 1;\n\t}\n\n\tif (S_ISREG(sctx->cur_inode_mode)) {\n\t\tif (need_send_hole(sctx)) {\n\t\t\tif (sctx->cur_inode_last_extent == (u64)-1 ||\n\t\t\t    sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = get_last_extent(sctx, (u64)-1);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = send_hole(sctx, sctx->cur_inode_size);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = send_truncate(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tsctx->cur_inode_size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (need_chown) {\n\t\tret = send_chown(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_uid, left_gid);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tif (need_chmod) {\n\t\tret = send_chmod(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_mode);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * If other directory inodes depended on our current directory\n\t * inode's move/rename, now do their move/rename operations.\n\t */\n\tif (!is_waiting_for_move(sctx, sctx->cur_ino)) {\n\t\tret = apply_children_dir_moves(sctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Need to send that every time, no matter if it actually\n\t\t * changed between the two trees as we have done changes to\n\t\t * the inode before. If our inode is a directory and it's\n\t\t * waiting to be moved/renamed, we will send its utimes when\n\t\t * it's moved/renamed, therefore we don't need to do it here.\n\t\t */\n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\t\tret = send_utimes(sctx, sctx->cur_ino, sctx->cur_inode_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybe_send_hole",
          "args": [
            "sctx",
            "left_path",
            "key"
          ],
          "line": 5525
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_send_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4909-4957",
          "snippet": "static int maybe_send_hole(struct send_ctx *sctx, struct btrfs_path *path,\n\t\t\t   struct btrfs_key *key)\n{\n\tstruct btrfs_file_extent_item *fi;\n\tu64 extent_end;\n\tu8 type;\n\tint ret = 0;\n\n\tif (sctx->cur_ino != key->objectid || !need_send_hole(sctx))\n\t\treturn 0;\n\n\tif (sctx->cur_inode_last_extent == (u64)-1) {\n\t\tret = get_last_extent(sctx, key->offset - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], fi);\n\tif (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tu64 size = btrfs_file_extent_inline_len(path->nodes[0],\n\t\t\t\t\t\t\tpath->slots[0], fi);\n\t\textent_end = ALIGN(key->offset + size,\n\t\t\t\t   sctx->send_root->sectorsize);\n\t} else {\n\t\textent_end = key->offset +\n\t\t\tbtrfs_file_extent_num_bytes(path->nodes[0], fi);\n\t}\n\n\tif (path->slots[0] == 0 &&\n\t    sctx->cur_inode_last_extent < key->offset) {\n\t\t/*\n\t\t * We might have skipped entire leafs that contained only\n\t\t * file extent items for our current inode. These leafs have\n\t\t * a generation number smaller (older) than the one in the\n\t\t * current leaf and the leaf our last extent came from, and\n\t\t * are located between these 2 leafs.\n\t\t */\n\t\tret = get_last_extent(sctx, key->offset - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (sctx->cur_inode_last_extent < key->offset)\n\t\tret = send_hole(sctx, key->offset);\n\tsctx->cur_inode_last_extent = extent_end;\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int maybe_send_hole(struct send_ctx *sctx, struct btrfs_path *path,\n\t\t\t   struct btrfs_key *key)\n{\n\tstruct btrfs_file_extent_item *fi;\n\tu64 extent_end;\n\tu8 type;\n\tint ret = 0;\n\n\tif (sctx->cur_ino != key->objectid || !need_send_hole(sctx))\n\t\treturn 0;\n\n\tif (sctx->cur_inode_last_extent == (u64)-1) {\n\t\tret = get_last_extent(sctx, key->offset - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], fi);\n\tif (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tu64 size = btrfs_file_extent_inline_len(path->nodes[0],\n\t\t\t\t\t\t\tpath->slots[0], fi);\n\t\textent_end = ALIGN(key->offset + size,\n\t\t\t\t   sctx->send_root->sectorsize);\n\t} else {\n\t\textent_end = key->offset +\n\t\t\tbtrfs_file_extent_num_bytes(path->nodes[0], fi);\n\t}\n\n\tif (path->slots[0] == 0 &&\n\t    sctx->cur_inode_last_extent < key->offset) {\n\t\t/*\n\t\t * We might have skipped entire leafs that contained only\n\t\t * file extent items for our current inode. These leafs have\n\t\t * a generation number smaller (older) than the one in the\n\t\t * current leaf and the leaf our last extent came from, and\n\t\t * are located between these 2 leafs.\n\t\t */\n\t\tret = get_last_extent(sctx, key->offset - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (sctx->cur_inode_last_extent < key->offset)\n\t\tret = send_hole(sctx, key->offset);\n\tsctx->cur_inode_last_extent = extent_end;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compare_refs",
          "args": [
            "sctx",
            "left_path",
            "key"
          ],
          "line": 5519
        },
        "resolved": true,
        "details": {
          "function_name": "compare_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "5461-5499",
          "snippet": "static int compare_refs(struct send_ctx *sctx, struct btrfs_path *path,\n\t\t\tstruct btrfs_key *key)\n{\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\tu64 dirid = 0, last_dirid = 0;\n\tunsigned long ptr;\n\tu32 item_size;\n\tu32 cur_offset = 0;\n\tint ref_name_len;\n\tint ret = 0;\n\n\t/* Easy case, just check this one dirid */\n\tif (key->type == BTRFS_INODE_REF_KEY) {\n\t\tdirid = key->offset;\n\n\t\tret = dir_changed(sctx, dirid);\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\twhile (cur_offset < item_size) {\n\t\textref = (struct btrfs_inode_extref *)(ptr +\n\t\t\t\t\t\t       cur_offset);\n\t\tdirid = btrfs_inode_extref_parent(leaf, extref);\n\t\tref_name_len = btrfs_inode_extref_name_len(leaf, extref);\n\t\tcur_offset += ref_name_len + sizeof(*extref);\n\t\tif (dirid == last_dirid)\n\t\t\tcontinue;\n\t\tret = dir_changed(sctx, dirid);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tlast_dirid = dirid;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int compare_refs(struct send_ctx *sctx, struct btrfs_path *path,\n\t\t\tstruct btrfs_key *key)\n{\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\tu64 dirid = 0, last_dirid = 0;\n\tunsigned long ptr;\n\tu32 item_size;\n\tu32 cur_offset = 0;\n\tint ref_name_len;\n\tint ret = 0;\n\n\t/* Easy case, just check this one dirid */\n\tif (key->type == BTRFS_INODE_REF_KEY) {\n\t\tdirid = key->offset;\n\n\t\tret = dir_changed(sctx, dirid);\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\twhile (cur_offset < item_size) {\n\t\textref = (struct btrfs_inode_extref *)(ptr +\n\t\t\t\t\t\t       cur_offset);\n\t\tdirid = btrfs_inode_extref_parent(leaf, extref);\n\t\tref_name_len = btrfs_inode_extref_name_len(leaf, extref);\n\t\tcur_offset += ref_name_len + sizeof(*extref);\n\t\tif (dirid == last_dirid)\n\t\t\tcontinue;\n\t\tret = dir_changed(sctx, dirid);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tlast_dirid = dirid;\n\t}\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int changed_cb(struct btrfs_root *left_root,\n\t\t      struct btrfs_root *right_root,\n\t\t      struct btrfs_path *left_path,\n\t\t      struct btrfs_path *right_path,\n\t\t      struct btrfs_key *key,\n\t\t      enum btrfs_compare_tree_result result,\n\t\t      void *ctx)\n{\n\tint ret = 0;\n\tstruct send_ctx *sctx = ctx;\n\n\tif (result == BTRFS_COMPARE_TREE_SAME) {\n\t\tif (key->type == BTRFS_INODE_REF_KEY ||\n\t\t    key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\tret = compare_refs(sctx, left_path, key);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t} else if (key->type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\treturn maybe_send_hole(sctx, left_path, key);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\tresult = BTRFS_COMPARE_TREE_CHANGED;\n\t\tret = 0;\n\t}\n\n\tsctx->left_path = left_path;\n\tsctx->right_path = right_path;\n\tsctx->cmp_key = key;\n\n\tret = finish_inode_if_needed(sctx, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Ignore non-FS objects */\n\tif (key->objectid == BTRFS_FREE_INO_OBJECTID ||\n\t    key->objectid == BTRFS_FREE_SPACE_OBJECTID)\n\t\tgoto out;\n\n\tif (key->type == BTRFS_INODE_ITEM_KEY)\n\t\tret = changed_inode(sctx, result);\n\telse if (key->type == BTRFS_INODE_REF_KEY ||\n\t\t key->type == BTRFS_INODE_EXTREF_KEY)\n\t\tret = changed_ref(sctx, result);\n\telse if (key->type == BTRFS_XATTR_ITEM_KEY)\n\t\tret = changed_xattr(sctx, result);\n\telse if (key->type == BTRFS_EXTENT_DATA_KEY)\n\t\tret = changed_extent(sctx, result);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "compare_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "5461-5499",
    "snippet": "static int compare_refs(struct send_ctx *sctx, struct btrfs_path *path,\n\t\t\tstruct btrfs_key *key)\n{\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\tu64 dirid = 0, last_dirid = 0;\n\tunsigned long ptr;\n\tu32 item_size;\n\tu32 cur_offset = 0;\n\tint ref_name_len;\n\tint ret = 0;\n\n\t/* Easy case, just check this one dirid */\n\tif (key->type == BTRFS_INODE_REF_KEY) {\n\t\tdirid = key->offset;\n\n\t\tret = dir_changed(sctx, dirid);\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\twhile (cur_offset < item_size) {\n\t\textref = (struct btrfs_inode_extref *)(ptr +\n\t\t\t\t\t\t       cur_offset);\n\t\tdirid = btrfs_inode_extref_parent(leaf, extref);\n\t\tref_name_len = btrfs_inode_extref_name_len(leaf, extref);\n\t\tcur_offset += ref_name_len + sizeof(*extref);\n\t\tif (dirid == last_dirid)\n\t\t\tcontinue;\n\t\tret = dir_changed(sctx, dirid);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tlast_dirid = dirid;\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_changed",
          "args": [
            "sctx",
            "dirid"
          ],
          "line": 5492
        },
        "resolved": true,
        "details": {
          "function_name": "dir_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "5443-5459",
          "snippet": "static int dir_changed(struct send_ctx *sctx, u64 dir)\n{\n\tu64 orig_gen, new_gen;\n\tint ret;\n\n\tret = get_inode_info(sctx->send_root, dir, NULL, &new_gen, NULL, NULL,\n\t\t\t     NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = get_inode_info(sctx->parent_root, dir, NULL, &orig_gen, NULL,\n\t\t\t     NULL, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (orig_gen != new_gen) ? 1 : 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int dir_changed(struct send_ctx *sctx, u64 dir)\n{\n\tu64 orig_gen, new_gen;\n\tint ret;\n\n\tret = get_inode_info(sctx->send_root, dir, NULL, &new_gen, NULL, NULL,\n\t\t\t     NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = get_inode_info(sctx->parent_root, dir, NULL, &orig_gen, NULL,\n\t\t\t     NULL, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (orig_gen != new_gen) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_extref_name_len",
          "args": [
            "leaf",
            "extref"
          ],
          "line": 5488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_extref_parent",
          "args": [
            "leaf",
            "extref"
          ],
          "line": 5487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 5483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 5482
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int compare_refs(struct send_ctx *sctx, struct btrfs_path *path,\n\t\t\tstruct btrfs_key *key)\n{\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\tu64 dirid = 0, last_dirid = 0;\n\tunsigned long ptr;\n\tu32 item_size;\n\tu32 cur_offset = 0;\n\tint ref_name_len;\n\tint ret = 0;\n\n\t/* Easy case, just check this one dirid */\n\tif (key->type == BTRFS_INODE_REF_KEY) {\n\t\tdirid = key->offset;\n\n\t\tret = dir_changed(sctx, dirid);\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\twhile (cur_offset < item_size) {\n\t\textref = (struct btrfs_inode_extref *)(ptr +\n\t\t\t\t\t\t       cur_offset);\n\t\tdirid = btrfs_inode_extref_parent(leaf, extref);\n\t\tref_name_len = btrfs_inode_extref_name_len(leaf, extref);\n\t\tcur_offset += ref_name_len + sizeof(*extref);\n\t\tif (dirid == last_dirid)\n\t\t\tcontinue;\n\t\tret = dir_changed(sctx, dirid);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tlast_dirid = dirid;\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "dir_changed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "5443-5459",
    "snippet": "static int dir_changed(struct send_ctx *sctx, u64 dir)\n{\n\tu64 orig_gen, new_gen;\n\tint ret;\n\n\tret = get_inode_info(sctx->send_root, dir, NULL, &new_gen, NULL, NULL,\n\t\t\t     NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = get_inode_info(sctx->parent_root, dir, NULL, &orig_gen, NULL,\n\t\t\t     NULL, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (orig_gen != new_gen) ? 1 : 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_inode_info",
          "args": [
            "sctx->parent_root",
            "dir",
            "NULL",
            "&orig_gen",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 5453
        },
        "resolved": true,
        "details": {
          "function_name": "get_inode_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "821-836",
          "snippet": "static int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int dir_changed(struct send_ctx *sctx, u64 dir)\n{\n\tu64 orig_gen, new_gen;\n\tint ret;\n\n\tret = get_inode_info(sctx->send_root, dir, NULL, &new_gen, NULL, NULL,\n\t\t\t     NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = get_inode_info(sctx->parent_root, dir, NULL, &orig_gen, NULL,\n\t\t\t     NULL, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (orig_gen != new_gen) ? 1 : 0;\n}"
  },
  {
    "function_name": "changed_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "5427-5441",
    "snippet": "static int changed_extent(struct send_ctx *sctx,\n\t\t\t  enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\n\tBUG_ON(sctx->cur_ino != sctx->cmp_key->objectid);\n\n\tif (!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted) {\n\t\tif (result != BTRFS_COMPARE_TREE_DELETED)\n\t\t\tret = process_extent(sctx, sctx->left_path,\n\t\t\t\t\tsctx->cmp_key);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_extent",
          "args": [
            "sctx",
            "sctx->left_path",
            "sctx->cmp_key"
          ],
          "line": 5436
        },
        "resolved": true,
        "details": {
          "function_name": "process_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4959-5017",
          "snippet": "static int process_extent(struct send_ctx *sctx,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_key *key)\n{\n\tstruct clone_root *found_clone = NULL;\n\tint ret = 0;\n\n\tif (S_ISLNK(sctx->cur_inode_mode))\n\t\treturn 0;\n\n\tif (sctx->parent_root && !sctx->cur_inode_new) {\n\t\tret = is_extent_unchanged(sctx, path, key);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out_hole;\n\t\t}\n\t} else {\n\t\tstruct btrfs_file_extent_item *ei;\n\t\tu8 type;\n\n\t\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\ttype = btrfs_file_extent_type(path->nodes[0], ei);\n\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC ||\n\t\t    type == BTRFS_FILE_EXTENT_REG) {\n\t\t\t/*\n\t\t\t * The send spec does not have a prealloc command yet,\n\t\t\t * so just leave a hole for prealloc'ed extents until\n\t\t\t * we have enough commands queued up to justify rev'ing\n\t\t\t * the send spec.\n\t\t\t */\n\t\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Have a hole, just skip it. */\n\t\t\tif (btrfs_file_extent_disk_bytenr(path->nodes[0], ei) == 0) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = find_extent_clone(sctx, path, key->objectid, key->offset,\n\t\t\tsctx->cur_inode_size, &found_clone);\n\tif (ret != -ENOENT && ret < 0)\n\t\tgoto out;\n\n\tret = send_write_or_clone(sctx, path, key, found_clone);\n\tif (ret)\n\t\tgoto out;\nout_hole:\n\tret = maybe_send_hole(sctx, path, key);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_extent(struct send_ctx *sctx,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_key *key)\n{\n\tstruct clone_root *found_clone = NULL;\n\tint ret = 0;\n\n\tif (S_ISLNK(sctx->cur_inode_mode))\n\t\treturn 0;\n\n\tif (sctx->parent_root && !sctx->cur_inode_new) {\n\t\tret = is_extent_unchanged(sctx, path, key);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out_hole;\n\t\t}\n\t} else {\n\t\tstruct btrfs_file_extent_item *ei;\n\t\tu8 type;\n\n\t\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\ttype = btrfs_file_extent_type(path->nodes[0], ei);\n\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC ||\n\t\t    type == BTRFS_FILE_EXTENT_REG) {\n\t\t\t/*\n\t\t\t * The send spec does not have a prealloc command yet,\n\t\t\t * so just leave a hole for prealloc'ed extents until\n\t\t\t * we have enough commands queued up to justify rev'ing\n\t\t\t * the send spec.\n\t\t\t */\n\t\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Have a hole, just skip it. */\n\t\t\tif (btrfs_file_extent_disk_bytenr(path->nodes[0], ei) == 0) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = find_extent_clone(sctx, path, key->objectid, key->offset,\n\t\t\tsctx->cur_inode_size, &found_clone);\n\tif (ret != -ENOENT && ret < 0)\n\t\tgoto out;\n\n\tret = send_write_or_clone(sctx, path, key, found_clone);\n\tif (ret)\n\t\tgoto out;\nout_hole:\n\tret = maybe_send_hole(sctx, path, key);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sctx->cur_ino != sctx->cmp_key->objectid"
          ],
          "line": 5432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int changed_extent(struct send_ctx *sctx,\n\t\t\t  enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\n\tBUG_ON(sctx->cur_ino != sctx->cmp_key->objectid);\n\n\tif (!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted) {\n\t\tif (result != BTRFS_COMPARE_TREE_DELETED)\n\t\t\tret = process_extent(sctx, sctx->left_path,\n\t\t\t\t\tsctx->cmp_key);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "changed_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "5403-5420",
    "snippet": "static int changed_xattr(struct send_ctx *sctx,\n\t\t\t enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\n\tBUG_ON(sctx->cur_ino != sctx->cmp_key->objectid);\n\n\tif (!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted) {\n\t\tif (result == BTRFS_COMPARE_TREE_NEW)\n\t\t\tret = process_new_xattr(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_DELETED)\n\t\t\tret = process_deleted_xattr(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_CHANGED)\n\t\t\tret = process_changed_xattr(sctx);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_changed_xattr",
          "args": [
            "sctx"
          ],
          "line": 5416
        },
        "resolved": true,
        "details": {
          "function_name": "process_changed_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4319-4332",
          "snippet": "static int process_changed_xattr(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\tret = iterate_dir_item(sctx->send_root, sctx->left_path,\n\t\t\tsctx->cmp_key, __process_changed_new_xattr, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = iterate_dir_item(sctx->parent_root, sctx->right_path,\n\t\t\tsctx->cmp_key, __process_changed_deleted_xattr, sctx);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_changed_xattr(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\tret = iterate_dir_item(sctx->send_root, sctx->left_path,\n\t\t\tsctx->cmp_key, __process_changed_new_xattr, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = iterate_dir_item(sctx->parent_root, sctx->right_path,\n\t\t\tsctx->cmp_key, __process_changed_deleted_xattr, sctx);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_deleted_xattr",
          "args": [
            "sctx"
          ],
          "line": 5414
        },
        "resolved": true,
        "details": {
          "function_name": "process_deleted_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4202-4210",
          "snippet": "static int process_deleted_xattr(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tret = iterate_dir_item(sctx->parent_root, sctx->right_path,\n\t\t\t       sctx->cmp_key, __process_deleted_xattr, sctx);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_deleted_xattr(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tret = iterate_dir_item(sctx->parent_root, sctx->right_path,\n\t\t\t       sctx->cmp_key, __process_deleted_xattr, sctx);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_new_xattr",
          "args": [
            "sctx"
          ],
          "line": 5412
        },
        "resolved": true,
        "details": {
          "function_name": "process_new_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4192-4200",
          "snippet": "static int process_new_xattr(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\tret = iterate_dir_item(sctx->send_root, sctx->left_path,\n\t\t\t       sctx->cmp_key, __process_new_xattr, sctx);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_new_xattr(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\tret = iterate_dir_item(sctx->send_root, sctx->left_path,\n\t\t\t       sctx->cmp_key, __process_new_xattr, sctx);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sctx->cur_ino != sctx->cmp_key->objectid"
          ],
          "line": 5408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int changed_xattr(struct send_ctx *sctx,\n\t\t\t enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\n\tBUG_ON(sctx->cur_ino != sctx->cmp_key->objectid);\n\n\tif (!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted) {\n\t\tif (result == BTRFS_COMPARE_TREE_NEW)\n\t\t\tret = process_new_xattr(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_DELETED)\n\t\t\tret = process_deleted_xattr(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_CHANGED)\n\t\t\tret = process_changed_xattr(sctx);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "changed_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "5378-5396",
    "snippet": "static int changed_ref(struct send_ctx *sctx,\n\t\t       enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\n\tBUG_ON(sctx->cur_ino != sctx->cmp_key->objectid);\n\n\tif (!sctx->cur_inode_new_gen &&\n\t    sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tif (result == BTRFS_COMPARE_TREE_NEW)\n\t\t\tret = record_new_ref(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_DELETED)\n\t\t\tret = record_deleted_ref(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_CHANGED)\n\t\t\tret = record_changed_ref(sctx);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "record_changed_ref",
          "args": [
            "sctx"
          ],
          "line": 5392
        },
        "resolved": true,
        "details": {
          "function_name": "record_changed_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3990-4006",
          "snippet": "static int record_changed_ref(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\tret = iterate_inode_ref(sctx->send_root, sctx->left_path,\n\t\t\tsctx->cmp_key, 0, __record_changed_new_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = iterate_inode_ref(sctx->parent_root, sctx->right_path,\n\t\t\tsctx->cmp_key, 0, __record_changed_deleted_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int record_changed_ref(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\tret = iterate_inode_ref(sctx->send_root, sctx->left_path,\n\t\t\tsctx->cmp_key, 0, __record_changed_new_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = iterate_inode_ref(sctx->parent_root, sctx->right_path,\n\t\t\tsctx->cmp_key, 0, __record_changed_deleted_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "record_deleted_ref",
          "args": [
            "sctx"
          ],
          "line": 5390
        },
        "resolved": true,
        "details": {
          "function_name": "record_deleted_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3872-3884",
          "snippet": "static int record_deleted_ref(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tret = iterate_inode_ref(sctx->parent_root, sctx->right_path,\n\t\t\t\tsctx->cmp_key, 0, __record_deleted_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int record_deleted_ref(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tret = iterate_inode_ref(sctx->parent_root, sctx->right_path,\n\t\t\t\tsctx->cmp_key, 0, __record_deleted_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "record_new_ref",
          "args": [
            "sctx"
          ],
          "line": 5388
        },
        "resolved": true,
        "details": {
          "function_name": "record_new_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3858-3870",
          "snippet": "static int record_new_ref(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tret = iterate_inode_ref(sctx->send_root, sctx->left_path,\n\t\t\t\tsctx->cmp_key, 0, __record_new_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int record_new_ref(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tret = iterate_inode_ref(sctx->send_root, sctx->left_path,\n\t\t\t\tsctx->cmp_key, 0, __record_new_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sctx->cur_ino != sctx->cmp_key->objectid"
          ],
          "line": 5383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int changed_ref(struct send_ctx *sctx,\n\t\t       enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\n\tBUG_ON(sctx->cur_ino != sctx->cmp_key->objectid);\n\n\tif (!sctx->cur_inode_new_gen &&\n\t    sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tif (result == BTRFS_COMPARE_TREE_NEW)\n\t\t\tret = record_new_ref(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_DELETED)\n\t\t\tret = record_deleted_ref(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_CHANGED)\n\t\t\tret = record_changed_ref(sctx);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "changed_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "5220-5366",
    "snippet": "static int changed_inode(struct send_ctx *sctx,\n\t\t\t enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\tstruct btrfs_key *key = sctx->cmp_key;\n\tstruct btrfs_inode_item *left_ii = NULL;\n\tstruct btrfs_inode_item *right_ii = NULL;\n\tu64 left_gen = 0;\n\tu64 right_gen = 0;\n\n\tsctx->cur_ino = key->objectid;\n\tsctx->cur_inode_new_gen = 0;\n\tsctx->cur_inode_last_extent = (u64)-1;\n\n\t/*\n\t * Set send_progress to current inode. This will tell all get_cur_xxx\n\t * functions that the current inode's refs are not updated yet. Later,\n\t * when process_recorded_refs is finished, it is set to cur_ino + 1.\n\t */\n\tsctx->send_progress = sctx->cur_ino;\n\n\tif (result == BTRFS_COMPARE_TREE_NEW ||\n\t    result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\tleft_ii = btrfs_item_ptr(sctx->left_path->nodes[0],\n\t\t\t\tsctx->left_path->slots[0],\n\t\t\t\tstruct btrfs_inode_item);\n\t\tleft_gen = btrfs_inode_generation(sctx->left_path->nodes[0],\n\t\t\t\tleft_ii);\n\t} else {\n\t\tright_ii = btrfs_item_ptr(sctx->right_path->nodes[0],\n\t\t\t\tsctx->right_path->slots[0],\n\t\t\t\tstruct btrfs_inode_item);\n\t\tright_gen = btrfs_inode_generation(sctx->right_path->nodes[0],\n\t\t\t\tright_ii);\n\t}\n\tif (result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\tright_ii = btrfs_item_ptr(sctx->right_path->nodes[0],\n\t\t\t\tsctx->right_path->slots[0],\n\t\t\t\tstruct btrfs_inode_item);\n\n\t\tright_gen = btrfs_inode_generation(sctx->right_path->nodes[0],\n\t\t\t\tright_ii);\n\n\t\t/*\n\t\t * The cur_ino = root dir case is special here. We can't treat\n\t\t * the inode as deleted+reused because it would generate a\n\t\t * stream that tries to delete/mkdir the root dir.\n\t\t */\n\t\tif (left_gen != right_gen &&\n\t\t    sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID)\n\t\t\tsctx->cur_inode_new_gen = 1;\n\t}\n\n\tif (result == BTRFS_COMPARE_TREE_NEW) {\n\t\tsctx->cur_inode_gen = left_gen;\n\t\tsctx->cur_inode_new = 1;\n\t\tsctx->cur_inode_deleted = 0;\n\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\tsctx->cur_inode_rdev = btrfs_inode_rdev(\n\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\tif (sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID)\n\t\t\tret = send_create_inode_if_needed(sctx);\n\t} else if (result == BTRFS_COMPARE_TREE_DELETED) {\n\t\tsctx->cur_inode_gen = right_gen;\n\t\tsctx->cur_inode_new = 0;\n\t\tsctx->cur_inode_deleted = 1;\n\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t} else if (result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\t/*\n\t\t * We need to do some special handling in case the inode was\n\t\t * reported as changed with a changed generation number. This\n\t\t * means that the original inode was deleted and new inode\n\t\t * reused the same inum. So we have to treat the old inode as\n\t\t * deleted and the new one as new.\n\t\t */\n\t\tif (sctx->cur_inode_new_gen) {\n\t\t\t/*\n\t\t\t * First, process the inode as if it was deleted.\n\t\t\t */\n\t\t\tsctx->cur_inode_gen = right_gen;\n\t\t\tsctx->cur_inode_new = 0;\n\t\t\tsctx->cur_inode_deleted = 1;\n\t\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t\t\tret = process_all_refs(sctx,\n\t\t\t\t\tBTRFS_COMPARE_TREE_DELETED);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Now process the inode as if it was new.\n\t\t\t */\n\t\t\tsctx->cur_inode_gen = left_gen;\n\t\t\tsctx->cur_inode_new = 1;\n\t\t\tsctx->cur_inode_deleted = 0;\n\t\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tsctx->cur_inode_rdev = btrfs_inode_rdev(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tret = send_create_inode_if_needed(sctx);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tret = process_all_refs(sctx, BTRFS_COMPARE_TREE_NEW);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Advance send_progress now as we did not get into\n\t\t\t * process_recorded_refs_if_needed in the new_gen case.\n\t\t\t */\n\t\t\tsctx->send_progress = sctx->cur_ino + 1;\n\n\t\t\t/*\n\t\t\t * Now process all extents and xattrs of the inode as if\n\t\t\t * they were all new.\n\t\t\t */\n\t\t\tret = process_all_extents(sctx);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = process_all_new_xattrs(sctx);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tsctx->cur_inode_gen = left_gen;\n\t\t\tsctx->cur_inode_new = 0;\n\t\t\tsctx->cur_inode_new_gen = 0;\n\t\t\tsctx->cur_inode_deleted = 0;\n\t\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_inode_mode",
          "args": [
            "sctx->left_path->nodes[0]",
            "left_ii"
          ],
          "line": 5359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_size",
          "args": [
            "sctx->left_path->nodes[0]",
            "left_ii"
          ],
          "line": 5357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_all_new_xattrs",
          "args": [
            "sctx"
          ],
          "line": 5349
        },
        "resolved": true,
        "details": {
          "function_name": "process_all_new_xattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4334-4389",
          "snippet": "static int process_all_new_xattrs(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\troot = sctx->send_root;\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = iterate_dir_item(root, path, &found_key,\n\t\t\t\t       __process_new_xattr, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tpath->slots[0]++;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_all_new_xattrs(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\troot = sctx->send_root;\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = iterate_dir_item(root, path, &found_key,\n\t\t\t\t       __process_new_xattr, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tpath->slots[0]++;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_all_extents",
          "args": [
            "sctx"
          ],
          "line": 5346
        },
        "resolved": true,
        "details": {
          "function_name": "process_all_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "5019-5074",
          "snippet": "static int process_all_extents(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\troot = sctx->send_root;\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = process_extent(sctx, path, &found_key);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tpath->slots[0]++;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_all_extents(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\troot = sctx->send_root;\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = process_extent(sctx, path, &found_key);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tpath->slots[0]++;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_all_refs",
          "args": [
            "sctx",
            "BTRFS_COMPARE_TREE_NEW"
          ],
          "line": 5333
        },
        "resolved": true,
        "details": {
          "function_name": "process_all_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4012-4083",
          "snippet": "static int process_all_refs(struct send_ctx *sctx,\n\t\t\t    enum btrfs_compare_tree_result cmd)\n{\n\tint ret;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\titerate_inode_ref_t cb;\n\tint pending_move = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (cmd == BTRFS_COMPARE_TREE_NEW) {\n\t\troot = sctx->send_root;\n\t\tcb = __record_new_ref;\n\t} else if (cmd == BTRFS_COMPARE_TREE_DELETED) {\n\t\troot = sctx->parent_root;\n\t\tcb = __record_deleted_ref;\n\t} else {\n\t\tbtrfs_err(sctx->send_root->fs_info,\n\t\t\t\t\"Wrong command %d in process_all_refs\", cmd);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t\t     found_key.type != BTRFS_INODE_EXTREF_KEY))\n\t\t\tbreak;\n\n\t\tret = iterate_inode_ref(root, path, &found_key, 0, cb, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tpath->slots[0]++;\n\t}\n\tbtrfs_release_path(path);\n\n\tret = process_recorded_refs(sctx, &pending_move);\n\t/* Only applicable to an incremental send. */\n\tASSERT(pending_move == 0);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_all_refs(struct send_ctx *sctx,\n\t\t\t    enum btrfs_compare_tree_result cmd)\n{\n\tint ret;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\titerate_inode_ref_t cb;\n\tint pending_move = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (cmd == BTRFS_COMPARE_TREE_NEW) {\n\t\troot = sctx->send_root;\n\t\tcb = __record_new_ref;\n\t} else if (cmd == BTRFS_COMPARE_TREE_DELETED) {\n\t\troot = sctx->parent_root;\n\t\tcb = __record_deleted_ref;\n\t} else {\n\t\tbtrfs_err(sctx->send_root->fs_info,\n\t\t\t\t\"Wrong command %d in process_all_refs\", cmd);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t\t     found_key.type != BTRFS_INODE_EXTREF_KEY))\n\t\t\tbreak;\n\n\t\tret = iterate_inode_ref(root, path, &found_key, 0, cb, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tpath->slots[0]++;\n\t}\n\tbtrfs_release_path(path);\n\n\tret = process_recorded_refs(sctx, &pending_move);\n\t/* Only applicable to an incremental send. */\n\tASSERT(pending_move == 0);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_create_inode_if_needed",
          "args": [
            "sctx"
          ],
          "line": 5329
        },
        "resolved": true,
        "details": {
          "function_name": "send_create_inode_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2646-2666",
          "snippet": "static int send_create_inode_if_needed(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tif (S_ISDIR(sctx->cur_inode_mode)) {\n\t\tret = did_create_dir(sctx, sctx->cur_ino);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = send_create_inode(sctx, sctx->cur_ino);\n\tif (ret < 0)\n\t\tgoto out;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_create_inode_if_needed(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tif (S_ISDIR(sctx->cur_inode_mode)) {\n\t\tret = did_create_dir(sctx, sctx->cur_ino);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = send_create_inode(sctx, sctx->cur_ino);\n\tif (ret < 0)\n\t\tgoto out;\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_rdev",
          "args": [
            "sctx->left_path->nodes[0]",
            "left_ii"
          ],
          "line": 5327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_mode",
          "args": [
            "sctx->left_path->nodes[0]",
            "left_ii"
          ],
          "line": 5325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_size",
          "args": [
            "sctx->left_path->nodes[0]",
            "left_ii"
          ],
          "line": 5323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_mode",
          "args": [
            "sctx->right_path->nodes[0]",
            "right_ii"
          ],
          "line": 5310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_size",
          "args": [
            "sctx->right_path->nodes[0]",
            "right_ii"
          ],
          "line": 5308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_mode",
          "args": [
            "sctx->right_path->nodes[0]",
            "right_ii"
          ],
          "line": 5291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_size",
          "args": [
            "sctx->right_path->nodes[0]",
            "right_ii"
          ],
          "line": 5289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_rdev",
          "args": [
            "sctx->left_path->nodes[0]",
            "left_ii"
          ],
          "line": 5281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_mode",
          "args": [
            "sctx->left_path->nodes[0]",
            "left_ii"
          ],
          "line": 5279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_size",
          "args": [
            "sctx->left_path->nodes[0]",
            "left_ii"
          ],
          "line": 5277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_generation",
          "args": [
            "sctx->right_path->nodes[0]",
            "right_ii"
          ],
          "line": 5260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "sctx->right_path->nodes[0]",
            "sctx->right_path->slots[0]",
            "structbtrfs_inode_item"
          ],
          "line": 5256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_generation",
          "args": [
            "sctx->right_path->nodes[0]",
            "right_ii"
          ],
          "line": 5252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "sctx->right_path->nodes[0]",
            "sctx->right_path->slots[0]",
            "structbtrfs_inode_item"
          ],
          "line": 5249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_generation",
          "args": [
            "sctx->left_path->nodes[0]",
            "left_ii"
          ],
          "line": 5246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "sctx->left_path->nodes[0]",
            "sctx->left_path->slots[0]",
            "structbtrfs_inode_item"
          ],
          "line": 5243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int changed_inode(struct send_ctx *sctx,\n\t\t\t enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\tstruct btrfs_key *key = sctx->cmp_key;\n\tstruct btrfs_inode_item *left_ii = NULL;\n\tstruct btrfs_inode_item *right_ii = NULL;\n\tu64 left_gen = 0;\n\tu64 right_gen = 0;\n\n\tsctx->cur_ino = key->objectid;\n\tsctx->cur_inode_new_gen = 0;\n\tsctx->cur_inode_last_extent = (u64)-1;\n\n\t/*\n\t * Set send_progress to current inode. This will tell all get_cur_xxx\n\t * functions that the current inode's refs are not updated yet. Later,\n\t * when process_recorded_refs is finished, it is set to cur_ino + 1.\n\t */\n\tsctx->send_progress = sctx->cur_ino;\n\n\tif (result == BTRFS_COMPARE_TREE_NEW ||\n\t    result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\tleft_ii = btrfs_item_ptr(sctx->left_path->nodes[0],\n\t\t\t\tsctx->left_path->slots[0],\n\t\t\t\tstruct btrfs_inode_item);\n\t\tleft_gen = btrfs_inode_generation(sctx->left_path->nodes[0],\n\t\t\t\tleft_ii);\n\t} else {\n\t\tright_ii = btrfs_item_ptr(sctx->right_path->nodes[0],\n\t\t\t\tsctx->right_path->slots[0],\n\t\t\t\tstruct btrfs_inode_item);\n\t\tright_gen = btrfs_inode_generation(sctx->right_path->nodes[0],\n\t\t\t\tright_ii);\n\t}\n\tif (result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\tright_ii = btrfs_item_ptr(sctx->right_path->nodes[0],\n\t\t\t\tsctx->right_path->slots[0],\n\t\t\t\tstruct btrfs_inode_item);\n\n\t\tright_gen = btrfs_inode_generation(sctx->right_path->nodes[0],\n\t\t\t\tright_ii);\n\n\t\t/*\n\t\t * The cur_ino = root dir case is special here. We can't treat\n\t\t * the inode as deleted+reused because it would generate a\n\t\t * stream that tries to delete/mkdir the root dir.\n\t\t */\n\t\tif (left_gen != right_gen &&\n\t\t    sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID)\n\t\t\tsctx->cur_inode_new_gen = 1;\n\t}\n\n\tif (result == BTRFS_COMPARE_TREE_NEW) {\n\t\tsctx->cur_inode_gen = left_gen;\n\t\tsctx->cur_inode_new = 1;\n\t\tsctx->cur_inode_deleted = 0;\n\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\tsctx->cur_inode_rdev = btrfs_inode_rdev(\n\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\tif (sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID)\n\t\t\tret = send_create_inode_if_needed(sctx);\n\t} else if (result == BTRFS_COMPARE_TREE_DELETED) {\n\t\tsctx->cur_inode_gen = right_gen;\n\t\tsctx->cur_inode_new = 0;\n\t\tsctx->cur_inode_deleted = 1;\n\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t} else if (result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\t/*\n\t\t * We need to do some special handling in case the inode was\n\t\t * reported as changed with a changed generation number. This\n\t\t * means that the original inode was deleted and new inode\n\t\t * reused the same inum. So we have to treat the old inode as\n\t\t * deleted and the new one as new.\n\t\t */\n\t\tif (sctx->cur_inode_new_gen) {\n\t\t\t/*\n\t\t\t * First, process the inode as if it was deleted.\n\t\t\t */\n\t\t\tsctx->cur_inode_gen = right_gen;\n\t\t\tsctx->cur_inode_new = 0;\n\t\t\tsctx->cur_inode_deleted = 1;\n\t\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t\t\tret = process_all_refs(sctx,\n\t\t\t\t\tBTRFS_COMPARE_TREE_DELETED);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Now process the inode as if it was new.\n\t\t\t */\n\t\t\tsctx->cur_inode_gen = left_gen;\n\t\t\tsctx->cur_inode_new = 1;\n\t\t\tsctx->cur_inode_deleted = 0;\n\t\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tsctx->cur_inode_rdev = btrfs_inode_rdev(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tret = send_create_inode_if_needed(sctx);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tret = process_all_refs(sctx, BTRFS_COMPARE_TREE_NEW);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Advance send_progress now as we did not get into\n\t\t\t * process_recorded_refs_if_needed in the new_gen case.\n\t\t\t */\n\t\t\tsctx->send_progress = sctx->cur_ino + 1;\n\n\t\t\t/*\n\t\t\t * Now process all extents and xattrs of the inode as if\n\t\t\t * they were all new.\n\t\t\t */\n\t\t\tret = process_all_extents(sctx);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = process_all_new_xattrs(sctx);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tsctx->cur_inode_gen = left_gen;\n\t\t\tsctx->cur_inode_new = 0;\n\t\t\tsctx->cur_inode_new_gen = 0;\n\t\t\tsctx->cur_inode_deleted = 0;\n\t\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "finish_inode_if_needed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "5099-5218",
    "snippet": "static int finish_inode_if_needed(struct send_ctx *sctx, int at_end)\n{\n\tint ret = 0;\n\tu64 left_mode;\n\tu64 left_uid;\n\tu64 left_gid;\n\tu64 right_mode;\n\tu64 right_uid;\n\tu64 right_gid;\n\tint need_chmod = 0;\n\tint need_chown = 0;\n\tint pending_move = 0;\n\tint refs_processed = 0;\n\n\tret = process_recorded_refs_if_needed(sctx, at_end, &pending_move,\n\t\t\t\t\t      &refs_processed);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * We have processed the refs and thus need to advance send_progress.\n\t * Now, calls to get_cur_xxx will take the updated refs of the current\n\t * inode into account.\n\t *\n\t * On the other hand, if our current inode is a directory and couldn't\n\t * be moved/renamed because its parent was renamed/moved too and it has\n\t * a higher inode number, we can only move/rename our current inode\n\t * after we moved/renamed its parent. Therefore in this case operate on\n\t * the old path (pre move/rename) of our current inode, and the\n\t * move/rename will be performed later.\n\t */\n\tif (refs_processed && !pending_move)\n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\n\tif (sctx->cur_ino == 0 || sctx->cur_inode_deleted)\n\t\tgoto out;\n\tif (!at_end && sctx->cmp_key->objectid == sctx->cur_ino)\n\t\tgoto out;\n\n\tret = get_inode_info(sctx->send_root, sctx->cur_ino, NULL, NULL,\n\t\t\t&left_mode, &left_uid, &left_gid, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!sctx->parent_root || sctx->cur_inode_new) {\n\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode))\n\t\t\tneed_chmod = 1;\n\t} else {\n\t\tret = get_inode_info(sctx->parent_root, sctx->cur_ino,\n\t\t\t\tNULL, NULL, &right_mode, &right_uid,\n\t\t\t\t&right_gid, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (left_uid != right_uid || left_gid != right_gid)\n\t\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode) && left_mode != right_mode)\n\t\t\tneed_chmod = 1;\n\t}\n\n\tif (S_ISREG(sctx->cur_inode_mode)) {\n\t\tif (need_send_hole(sctx)) {\n\t\t\tif (sctx->cur_inode_last_extent == (u64)-1 ||\n\t\t\t    sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = get_last_extent(sctx, (u64)-1);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = send_hole(sctx, sctx->cur_inode_size);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = send_truncate(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tsctx->cur_inode_size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (need_chown) {\n\t\tret = send_chown(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_uid, left_gid);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tif (need_chmod) {\n\t\tret = send_chmod(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_mode);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * If other directory inodes depended on our current directory\n\t * inode's move/rename, now do their move/rename operations.\n\t */\n\tif (!is_waiting_for_move(sctx, sctx->cur_ino)) {\n\t\tret = apply_children_dir_moves(sctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Need to send that every time, no matter if it actually\n\t\t * changed between the two trees as we have done changes to\n\t\t * the inode before. If our inode is a directory and it's\n\t\t * waiting to be moved/renamed, we will send its utimes when\n\t\t * it's moved/renamed, therefore we don't need to do it here.\n\t\t */\n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\t\tret = send_utimes(sctx, sctx->cur_ino, sctx->cur_inode_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_utimes",
          "args": [
            "sctx",
            "sctx->cur_ino",
            "sctx->cur_inode_gen"
          ],
          "line": 5211
        },
        "resolved": true,
        "details": {
          "function_name": "send_utimes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2434-2487",
          "snippet": "static int send_utimes(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret = 0;\n\tstruct fs_path *p = NULL;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_key key;\n\tint slot;\n\nverbose_printk(\"btrfs: send_utimes %llu\\n\", ino);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpath = alloc_path_for_send();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, sctx->send_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tii = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UTIMES);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_ATIME, eb, &ii->atime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_MTIME, eb, &ii->mtime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_CTIME, eb, &ii->ctime);\n\t/* TODO Add otime support when the otime patches get into upstream */\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int send_utimes(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret = 0;\n\tstruct fs_path *p = NULL;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_key key;\n\tint slot;\n\nverbose_printk(\"btrfs: send_utimes %llu\\n\", ino);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpath = alloc_path_for_send();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, sctx->send_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tii = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UTIMES);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_ATIME, eb, &ii->atime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_MTIME, eb, &ii->mtime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_CTIME, eb, &ii->ctime);\n\t/* TODO Add otime support when the otime patches get into upstream */\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_children_dir_moves",
          "args": [
            "sctx"
          ],
          "line": 5200
        },
        "resolved": true,
        "details": {
          "function_name": "apply_children_dir_moves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3259-3292",
          "snippet": "static int apply_children_dir_moves(struct send_ctx *sctx)\n{\n\tstruct pending_dir_move *pm;\n\tstruct list_head stack;\n\tu64 parent_ino = sctx->cur_ino;\n\tint ret = 0;\n\n\tpm = get_pending_dir_moves(sctx, parent_ino);\n\tif (!pm)\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&stack);\n\ttail_append_pending_moves(pm, &stack);\n\n\twhile (!list_empty(&stack)) {\n\t\tpm = list_first_entry(&stack, struct pending_dir_move, list);\n\t\tparent_ino = pm->ino;\n\t\tret = apply_dir_move(sctx, pm);\n\t\tfree_pending_move(sctx, pm);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tpm = get_pending_dir_moves(sctx, parent_ino);\n\t\tif (pm)\n\t\t\ttail_append_pending_moves(pm, &stack);\n\t}\n\treturn 0;\n\nout:\n\twhile (!list_empty(&stack)) {\n\t\tpm = list_first_entry(&stack, struct pending_dir_move, list);\n\t\tfree_pending_move(sctx, pm);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int apply_children_dir_moves(struct send_ctx *sctx)\n{\n\tstruct pending_dir_move *pm;\n\tstruct list_head stack;\n\tu64 parent_ino = sctx->cur_ino;\n\tint ret = 0;\n\n\tpm = get_pending_dir_moves(sctx, parent_ino);\n\tif (!pm)\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&stack);\n\ttail_append_pending_moves(pm, &stack);\n\n\twhile (!list_empty(&stack)) {\n\t\tpm = list_first_entry(&stack, struct pending_dir_move, list);\n\t\tparent_ino = pm->ino;\n\t\tret = apply_dir_move(sctx, pm);\n\t\tfree_pending_move(sctx, pm);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tpm = get_pending_dir_moves(sctx, parent_ino);\n\t\tif (pm)\n\t\t\ttail_append_pending_moves(pm, &stack);\n\t}\n\treturn 0;\n\nout:\n\twhile (!list_empty(&stack)) {\n\t\tpm = list_first_entry(&stack, struct pending_dir_move, list);\n\t\tfree_pending_move(sctx, pm);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_waiting_for_move",
          "args": [
            "sctx",
            "sctx->cur_ino"
          ],
          "line": 5199
        },
        "resolved": true,
        "details": {
          "function_name": "is_waiting_for_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2919-2924",
          "snippet": "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct waiting_dir_move *entry = get_waiting_dir_move(sctx, ino);\n\n\treturn entry != NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct waiting_dir_move *entry = get_waiting_dir_move(sctx, ino);\n\n\treturn entry != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_chmod",
          "args": [
            "sctx",
            "sctx->cur_ino",
            "sctx->cur_inode_gen",
            "left_mode"
          ],
          "line": 5189
        },
        "resolved": true,
        "details": {
          "function_name": "send_chmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2375-2402",
          "snippet": "static int send_chmod(struct send_ctx *sctx, u64 ino, u64 gen, u64 mode)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\nverbose_printk(\"btrfs: send_chmod %llu mode=%llu\\n\", ino, mode);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CHMOD);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_MODE, mode & 07777);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int send_chmod(struct send_ctx *sctx, u64 ino, u64 gen, u64 mode)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\nverbose_printk(\"btrfs: send_chmod %llu mode=%llu\\n\", ino, mode);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CHMOD);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_MODE, mode & 07777);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_chown",
          "args": [
            "sctx",
            "sctx->cur_ino",
            "sctx->cur_inode_gen",
            "left_uid",
            "left_gid"
          ],
          "line": 5183
        },
        "resolved": true,
        "details": {
          "function_name": "send_chown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2404-2432",
          "snippet": "static int send_chown(struct send_ctx *sctx, u64 ino, u64 gen, u64 uid, u64 gid)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\nverbose_printk(\"btrfs: send_chown %llu uid=%llu, gid=%llu\\n\", ino, uid, gid);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CHOWN);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_UID, uid);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_GID, gid);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int send_chown(struct send_ctx *sctx, u64 ino, u64 gen, u64 uid, u64 gid)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\nverbose_printk(\"btrfs: send_chown %llu uid=%llu, gid=%llu\\n\", ino, uid, gid);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CHOWN);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_UID, uid);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_GID, gid);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_truncate",
          "args": [
            "sctx",
            "sctx->cur_ino",
            "sctx->cur_inode_gen",
            "sctx->cur_inode_size"
          ],
          "line": 5176
        },
        "resolved": true,
        "details": {
          "function_name": "send_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2346-2373",
          "snippet": "static int send_truncate(struct send_ctx *sctx, u64 ino, u64 gen, u64 size)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\nverbose_printk(\"btrfs: send_truncate %llu size=%llu\\n\", ino, size);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_TRUNCATE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_SIZE, size);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int send_truncate(struct send_ctx *sctx, u64 ino, u64 gen, u64 size)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\nverbose_printk(\"btrfs: send_truncate %llu size=%llu\\n\", ino, size);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_TRUNCATE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_SIZE, size);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_hole",
          "args": [
            "sctx",
            "sctx->cur_inode_size"
          ],
          "line": 5171
        },
        "resolved": true,
        "details": {
          "function_name": "send_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4602-4633",
          "snippet": "static int send_hole(struct send_ctx *sctx, u64 end)\n{\n\tstruct fs_path *p = NULL;\n\tu64 offset = sctx->cur_inode_last_extent;\n\tu64 len;\n\tint ret = 0;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto tlv_put_failure;\n\tmemset(sctx->read_buf, 0, BTRFS_SEND_READ_SIZE);\n\twhile (offset < end) {\n\t\tlen = min_t(u64, end - offset, BTRFS_SEND_READ_SIZE);\n\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_WRITE);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\t\tTLV_PUT(sctx, BTRFS_SEND_A_DATA, sctx->read_buf, len);\n\t\tret = send_cmd(sctx);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\toffset += len;\n\t}\ntlv_put_failure:\n\tfs_path_free(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_hole(struct send_ctx *sctx, u64 end)\n{\n\tstruct fs_path *p = NULL;\n\tu64 offset = sctx->cur_inode_last_extent;\n\tu64 len;\n\tint ret = 0;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto tlv_put_failure;\n\tmemset(sctx->read_buf, 0, BTRFS_SEND_READ_SIZE);\n\twhile (offset < end) {\n\t\tlen = min_t(u64, end - offset, BTRFS_SEND_READ_SIZE);\n\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_WRITE);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\t\tTLV_PUT(sctx, BTRFS_SEND_A_DATA, sctx->read_buf, len);\n\t\tret = send_cmd(sctx);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\toffset += len;\n\t}\ntlv_put_failure:\n\tfs_path_free(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_last_extent",
          "args": [
            "sctx",
            "(u64)-1"
          ],
          "line": 5165
        },
        "resolved": true,
        "details": {
          "function_name": "get_last_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4864-4907",
          "snippet": "static int get_last_extent(struct send_ctx *sctx, u64 offset)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = sctx->send_root;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tu64 extent_end;\n\tu8 type;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tsctx->cur_inode_last_extent = 0;\n\n\tkey.objectid = sctx->cur_ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = offset;\n\tret = btrfs_search_slot_for_read(root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\tif (key.objectid != sctx->cur_ino || key.type != BTRFS_EXTENT_DATA_KEY)\n\t\tgoto out;\n\n\tfi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], fi);\n\tif (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tu64 size = btrfs_file_extent_inline_len(path->nodes[0],\n\t\t\t\t\t\t\tpath->slots[0], fi);\n\t\textent_end = ALIGN(key.offset + size,\n\t\t\t\t   sctx->send_root->sectorsize);\n\t} else {\n\t\textent_end = key.offset +\n\t\t\tbtrfs_file_extent_num_bytes(path->nodes[0], fi);\n\t}\n\tsctx->cur_inode_last_extent = extent_end;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int get_last_extent(struct send_ctx *sctx, u64 offset)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = sctx->send_root;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tu64 extent_end;\n\tu8 type;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tsctx->cur_inode_last_extent = 0;\n\n\tkey.objectid = sctx->cur_ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = offset;\n\tret = btrfs_search_slot_for_read(root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\tif (key.objectid != sctx->cur_ino || key.type != BTRFS_EXTENT_DATA_KEY)\n\t\tgoto out;\n\n\tfi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], fi);\n\tif (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tu64 size = btrfs_file_extent_inline_len(path->nodes[0],\n\t\t\t\t\t\t\tpath->slots[0], fi);\n\t\textent_end = ALIGN(key.offset + size,\n\t\t\t\t   sctx->send_root->sectorsize);\n\t} else {\n\t\textent_end = key.offset +\n\t\t\tbtrfs_file_extent_num_bytes(path->nodes[0], fi);\n\t}\n\tsctx->cur_inode_last_extent = extent_end;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_send_hole",
          "args": [
            "sctx"
          ],
          "line": 5161
        },
        "resolved": true,
        "details": {
          "function_name": "need_send_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "282-287",
          "snippet": "static int need_send_hole(struct send_ctx *sctx)\n{\n\treturn (sctx->parent_root && !sctx->cur_inode_new &&\n\t\t!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted &&\n\t\tS_ISREG(sctx->cur_inode_mode));\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int need_send_hole(struct send_ctx *sctx)\n{\n\treturn (sctx->parent_root && !sctx->cur_inode_new &&\n\t\t!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted &&\n\t\tS_ISREG(sctx->cur_inode_mode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "sctx->cur_inode_mode"
          ],
          "line": 5160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "sctx->cur_inode_mode"
          ],
          "line": 5156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_inode_info",
          "args": [
            "sctx->parent_root",
            "sctx->cur_ino",
            "NULL",
            "NULL",
            "&right_mode",
            "&right_uid",
            "&right_gid",
            "NULL"
          ],
          "line": 5148
        },
        "resolved": true,
        "details": {
          "function_name": "get_inode_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "821-836",
          "snippet": "static int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "sctx->cur_inode_mode"
          ],
          "line": 5145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_recorded_refs_if_needed",
          "args": [
            "sctx",
            "at_end",
            "&pending_move",
            "&refs_processed"
          ],
          "line": 5113
        },
        "resolved": true,
        "details": {
          "function_name": "process_recorded_refs_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "5076-5097",
          "snippet": "static int process_recorded_refs_if_needed(struct send_ctx *sctx, int at_end,\n\t\t\t\t\t   int *pending_move,\n\t\t\t\t\t   int *refs_processed)\n{\n\tint ret = 0;\n\n\tif (sctx->cur_ino == 0)\n\t\tgoto out;\n\tif (!at_end && sctx->cur_ino == sctx->cmp_key->objectid &&\n\t    sctx->cmp_key->type <= BTRFS_INODE_EXTREF_KEY)\n\t\tgoto out;\n\tif (list_empty(&sctx->new_refs) && list_empty(&sctx->deleted_refs))\n\t\tgoto out;\n\n\tret = process_recorded_refs(sctx, pending_move);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*refs_processed = 1;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_recorded_refs_if_needed(struct send_ctx *sctx, int at_end,\n\t\t\t\t\t   int *pending_move,\n\t\t\t\t\t   int *refs_processed)\n{\n\tint ret = 0;\n\n\tif (sctx->cur_ino == 0)\n\t\tgoto out;\n\tif (!at_end && sctx->cur_ino == sctx->cmp_key->objectid &&\n\t    sctx->cmp_key->type <= BTRFS_INODE_EXTREF_KEY)\n\t\tgoto out;\n\tif (list_empty(&sctx->new_refs) && list_empty(&sctx->deleted_refs))\n\t\tgoto out;\n\n\tret = process_recorded_refs(sctx, pending_move);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*refs_processed = 1;\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int finish_inode_if_needed(struct send_ctx *sctx, int at_end)\n{\n\tint ret = 0;\n\tu64 left_mode;\n\tu64 left_uid;\n\tu64 left_gid;\n\tu64 right_mode;\n\tu64 right_uid;\n\tu64 right_gid;\n\tint need_chmod = 0;\n\tint need_chown = 0;\n\tint pending_move = 0;\n\tint refs_processed = 0;\n\n\tret = process_recorded_refs_if_needed(sctx, at_end, &pending_move,\n\t\t\t\t\t      &refs_processed);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * We have processed the refs and thus need to advance send_progress.\n\t * Now, calls to get_cur_xxx will take the updated refs of the current\n\t * inode into account.\n\t *\n\t * On the other hand, if our current inode is a directory and couldn't\n\t * be moved/renamed because its parent was renamed/moved too and it has\n\t * a higher inode number, we can only move/rename our current inode\n\t * after we moved/renamed its parent. Therefore in this case operate on\n\t * the old path (pre move/rename) of our current inode, and the\n\t * move/rename will be performed later.\n\t */\n\tif (refs_processed && !pending_move)\n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\n\tif (sctx->cur_ino == 0 || sctx->cur_inode_deleted)\n\t\tgoto out;\n\tif (!at_end && sctx->cmp_key->objectid == sctx->cur_ino)\n\t\tgoto out;\n\n\tret = get_inode_info(sctx->send_root, sctx->cur_ino, NULL, NULL,\n\t\t\t&left_mode, &left_uid, &left_gid, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!sctx->parent_root || sctx->cur_inode_new) {\n\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode))\n\t\t\tneed_chmod = 1;\n\t} else {\n\t\tret = get_inode_info(sctx->parent_root, sctx->cur_ino,\n\t\t\t\tNULL, NULL, &right_mode, &right_uid,\n\t\t\t\t&right_gid, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (left_uid != right_uid || left_gid != right_gid)\n\t\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode) && left_mode != right_mode)\n\t\t\tneed_chmod = 1;\n\t}\n\n\tif (S_ISREG(sctx->cur_inode_mode)) {\n\t\tif (need_send_hole(sctx)) {\n\t\t\tif (sctx->cur_inode_last_extent == (u64)-1 ||\n\t\t\t    sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = get_last_extent(sctx, (u64)-1);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = send_hole(sctx, sctx->cur_inode_size);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = send_truncate(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tsctx->cur_inode_size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (need_chown) {\n\t\tret = send_chown(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_uid, left_gid);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tif (need_chmod) {\n\t\tret = send_chmod(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_mode);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * If other directory inodes depended on our current directory\n\t * inode's move/rename, now do their move/rename operations.\n\t */\n\tif (!is_waiting_for_move(sctx, sctx->cur_ino)) {\n\t\tret = apply_children_dir_moves(sctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Need to send that every time, no matter if it actually\n\t\t * changed between the two trees as we have done changes to\n\t\t * the inode before. If our inode is a directory and it's\n\t\t * waiting to be moved/renamed, we will send its utimes when\n\t\t * it's moved/renamed, therefore we don't need to do it here.\n\t\t */\n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\t\tret = send_utimes(sctx, sctx->cur_ino, sctx->cur_inode_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "process_recorded_refs_if_needed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "5076-5097",
    "snippet": "static int process_recorded_refs_if_needed(struct send_ctx *sctx, int at_end,\n\t\t\t\t\t   int *pending_move,\n\t\t\t\t\t   int *refs_processed)\n{\n\tint ret = 0;\n\n\tif (sctx->cur_ino == 0)\n\t\tgoto out;\n\tif (!at_end && sctx->cur_ino == sctx->cmp_key->objectid &&\n\t    sctx->cmp_key->type <= BTRFS_INODE_EXTREF_KEY)\n\t\tgoto out;\n\tif (list_empty(&sctx->new_refs) && list_empty(&sctx->deleted_refs))\n\t\tgoto out;\n\n\tret = process_recorded_refs(sctx, pending_move);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*refs_processed = 1;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_recorded_refs",
          "args": [
            "sctx",
            "pending_move"
          ],
          "line": 5090
        },
        "resolved": true,
        "details": {
          "function_name": "process_recorded_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3493-3805",
          "snippet": "static int process_recorded_refs(struct send_ctx *sctx, int *pending_move)\n{\n\tint ret = 0;\n\tstruct recorded_ref *cur;\n\tstruct recorded_ref *cur2;\n\tstruct list_head check_dirs;\n\tstruct fs_path *valid_path = NULL;\n\tu64 ow_inode = 0;\n\tu64 ow_gen;\n\tint did_overwrite = 0;\n\tint is_orphan = 0;\n\tu64 last_dir_ino_rm = 0;\n\tbool can_rename = true;\n\nverbose_printk(\"btrfs: process_recorded_refs %llu\\n\", sctx->cur_ino);\n\n\t/*\n\t * This should never happen as the root dir always has the same ref\n\t * which is always '..'\n\t */\n\tBUG_ON(sctx->cur_ino <= BTRFS_FIRST_FREE_OBJECTID);\n\tINIT_LIST_HEAD(&check_dirs);\n\n\tvalid_path = fs_path_alloc();\n\tif (!valid_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First, check if the first ref of the current inode was overwritten\n\t * before. If yes, we know that the current inode was already orphanized\n\t * and thus use the orphan name. If not, we can use get_cur_path to\n\t * get the path of the first ref as it would like while receiving at\n\t * this point in time.\n\t * New inodes are always orphan at the beginning, so force to use the\n\t * orphan name in this case.\n\t * The first ref is stored in valid_path and will be updated if it\n\t * gets moved around.\n\t */\n\tif (!sctx->cur_inode_new) {\n\t\tret = did_overwrite_first_ref(sctx, sctx->cur_ino,\n\t\t\t\tsctx->cur_inode_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret)\n\t\t\tdid_overwrite = 1;\n\t}\n\tif (sctx->cur_inode_new || did_overwrite) {\n\t\tret = gen_unique_name(sctx, sctx->cur_ino,\n\t\t\t\tsctx->cur_inode_gen, valid_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tis_orphan = 1;\n\t} else {\n\t\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tvalid_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(cur, &sctx->new_refs, list) {\n\t\t/*\n\t\t * We may have refs where the parent directory does not exist\n\t\t * yet. This happens if the parent directories inum is higher\n\t\t * the the current inum. To handle this case, we create the\n\t\t * parent directory out of order. But we need to check if this\n\t\t * did already happen before due to other refs in the same dir.\n\t\t */\n\t\tret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret == inode_state_will_create) {\n\t\t\tret = 0;\n\t\t\t/*\n\t\t\t * First check if any of the current inodes refs did\n\t\t\t * already create the dir.\n\t\t\t */\n\t\t\tlist_for_each_entry(cur2, &sctx->new_refs, list) {\n\t\t\t\tif (cur == cur2)\n\t\t\t\t\tbreak;\n\t\t\t\tif (cur2->dir == cur->dir) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If that did not happen, check if a previous inode\n\t\t\t * did already create the dir.\n\t\t\t */\n\t\t\tif (!ret)\n\t\t\t\tret = did_create_dir(sctx, cur->dir);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret) {\n\t\t\t\tret = send_create_inode(sctx, cur->dir);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Check if this new ref would overwrite the first ref of\n\t\t * another unprocessed inode. If yes, orphanize the\n\t\t * overwritten inode. If we find an overwritten ref that is\n\t\t * not the first ref, simply unlink it.\n\t\t */\n\t\tret = will_overwrite_ref(sctx, cur->dir, cur->dir_gen,\n\t\t\t\tcur->name, cur->name_len,\n\t\t\t\t&ow_inode, &ow_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = is_first_ref(sctx->parent_root,\n\t\t\t\t\t   ow_inode, cur->dir, cur->name,\n\t\t\t\t\t   cur->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret) {\n\t\t\t\tret = orphanize_inode(sctx, ow_inode, ow_gen,\n\t\t\t\t\t\tcur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tret = send_unlink(sctx, cur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (S_ISDIR(sctx->cur_inode_mode) && sctx->parent_root) {\n\t\t\tret = wait_for_dest_dir_move(sctx, cur, is_orphan);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 1) {\n\t\t\t\tcan_rename = false;\n\t\t\t\t*pending_move = 1;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * link/move the ref to the new place. If we have an orphan\n\t\t * inode, move it and update valid_path. If not, link or move\n\t\t * it depending on the inode mode.\n\t\t */\n\t\tif (is_orphan && can_rename) {\n\t\t\tret = send_rename(sctx, valid_path, cur->full_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tis_orphan = 0;\n\t\t\tret = fs_path_copy(valid_path, cur->full_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (can_rename) {\n\t\t\tif (S_ISDIR(sctx->cur_inode_mode)) {\n\t\t\t\t/*\n\t\t\t\t * Dirs can't be linked, so move it. For moved\n\t\t\t\t * dirs, we always have one new and one deleted\n\t\t\t\t * ref. The deleted ref is ignored later.\n\t\t\t\t */\n\t\t\t\tret = wait_for_parent_move(sctx, cur);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (ret) {\n\t\t\t\t\t*pending_move = 1;\n\t\t\t\t} else {\n\t\t\t\t\tret = send_rename(sctx, valid_path,\n\t\t\t\t\t\t\t  cur->full_path);\n\t\t\t\t\tif (!ret)\n\t\t\t\t\t\tret = fs_path_copy(valid_path,\n\t\t\t\t\t\t\t       cur->full_path);\n\t\t\t\t}\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tret = send_link(sctx, cur->full_path,\n\t\t\t\t\t\tvalid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = dup_ref(cur, &check_dirs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (S_ISDIR(sctx->cur_inode_mode) && sctx->cur_inode_deleted) {\n\t\t/*\n\t\t * Check if we can already rmdir the directory. If not,\n\t\t * orphanize it. For every dir item inside that gets deleted\n\t\t * later, we do this check again and rmdir it then if possible.\n\t\t * See the use of check_dirs for more details.\n\t\t */\n\t\tret = can_rmdir(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tsctx->cur_ino);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = send_rmdir(sctx, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (!is_orphan) {\n\t\t\tret = orphanize_inode(sctx, sctx->cur_ino,\n\t\t\t\t\tsctx->cur_inode_gen, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tis_orphan = 1;\n\t\t}\n\n\t\tlist_for_each_entry(cur, &sctx->deleted_refs, list) {\n\t\t\tret = dup_ref(cur, &check_dirs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t} else if (S_ISDIR(sctx->cur_inode_mode) &&\n\t\t   !list_empty(&sctx->deleted_refs)) {\n\t\t/*\n\t\t * We have a moved dir. Add the old parent to check_dirs\n\t\t */\n\t\tcur = list_entry(sctx->deleted_refs.next, struct recorded_ref,\n\t\t\t\tlist);\n\t\tret = dup_ref(cur, &check_dirs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else if (!S_ISDIR(sctx->cur_inode_mode)) {\n\t\t/*\n\t\t * We have a non dir inode. Go through all deleted refs and\n\t\t * unlink them if they were not already overwritten by other\n\t\t * inodes.\n\t\t */\n\t\tlist_for_each_entry(cur, &sctx->deleted_refs, list) {\n\t\t\tret = did_overwrite_ref(sctx, cur->dir, cur->dir_gen,\n\t\t\t\t\tsctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\t\tcur->name, cur->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret) {\n\t\t\t\tret = send_unlink(sctx, cur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = dup_ref(cur, &check_dirs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * If the inode is still orphan, unlink the orphan. This may\n\t\t * happen when a previous inode did overwrite the first ref\n\t\t * of this inode and no new refs were added for the current\n\t\t * inode. Unlinking does not mean that the inode is deleted in\n\t\t * all cases. There may still be links to this inode in other\n\t\t * places.\n\t\t */\n\t\tif (is_orphan) {\n\t\t\tret = send_unlink(sctx, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We did collect all parent dirs where cur_inode was once located. We\n\t * now go through all these dirs and check if they are pending for\n\t * deletion and if it's finally possible to perform the rmdir now.\n\t * We also update the inode stats of the parent dirs here.\n\t */\n\tlist_for_each_entry(cur, &check_dirs, list) {\n\t\t/*\n\t\t * In case we had refs into dirs that were not processed yet,\n\t\t * we don't need to do the utime and rmdir logic for these dirs.\n\t\t * The dir will be processed later.\n\t\t */\n\t\tif (cur->dir > sctx->cur_ino)\n\t\t\tcontinue;\n\n\t\tret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ret == inode_state_did_create ||\n\t\t    ret == inode_state_no_change) {\n\t\t\t/* TODO delayed utimes */\n\t\t\tret = send_utimes(sctx, cur->dir, cur->dir_gen);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (ret == inode_state_did_delete &&\n\t\t\t   cur->dir != last_dir_ino_rm) {\n\t\t\tret = can_rmdir(sctx, cur->dir, cur->dir_gen,\n\t\t\t\t\tsctx->cur_ino);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret) {\n\t\t\t\tret = get_cur_path(sctx, cur->dir,\n\t\t\t\t\t\t   cur->dir_gen, valid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tret = send_rmdir(sctx, valid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tlast_dir_ino_rm = cur->dir;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = 0;\n\nout:\n\t__free_recorded_refs(&check_dirs);\n\tfree_recorded_refs(sctx);\n\tfs_path_free(valid_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_recorded_refs(struct send_ctx *sctx, int *pending_move)\n{\n\tint ret = 0;\n\tstruct recorded_ref *cur;\n\tstruct recorded_ref *cur2;\n\tstruct list_head check_dirs;\n\tstruct fs_path *valid_path = NULL;\n\tu64 ow_inode = 0;\n\tu64 ow_gen;\n\tint did_overwrite = 0;\n\tint is_orphan = 0;\n\tu64 last_dir_ino_rm = 0;\n\tbool can_rename = true;\n\nverbose_printk(\"btrfs: process_recorded_refs %llu\\n\", sctx->cur_ino);\n\n\t/*\n\t * This should never happen as the root dir always has the same ref\n\t * which is always '..'\n\t */\n\tBUG_ON(sctx->cur_ino <= BTRFS_FIRST_FREE_OBJECTID);\n\tINIT_LIST_HEAD(&check_dirs);\n\n\tvalid_path = fs_path_alloc();\n\tif (!valid_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First, check if the first ref of the current inode was overwritten\n\t * before. If yes, we know that the current inode was already orphanized\n\t * and thus use the orphan name. If not, we can use get_cur_path to\n\t * get the path of the first ref as it would like while receiving at\n\t * this point in time.\n\t * New inodes are always orphan at the beginning, so force to use the\n\t * orphan name in this case.\n\t * The first ref is stored in valid_path and will be updated if it\n\t * gets moved around.\n\t */\n\tif (!sctx->cur_inode_new) {\n\t\tret = did_overwrite_first_ref(sctx, sctx->cur_ino,\n\t\t\t\tsctx->cur_inode_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret)\n\t\t\tdid_overwrite = 1;\n\t}\n\tif (sctx->cur_inode_new || did_overwrite) {\n\t\tret = gen_unique_name(sctx, sctx->cur_ino,\n\t\t\t\tsctx->cur_inode_gen, valid_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tis_orphan = 1;\n\t} else {\n\t\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tvalid_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(cur, &sctx->new_refs, list) {\n\t\t/*\n\t\t * We may have refs where the parent directory does not exist\n\t\t * yet. This happens if the parent directories inum is higher\n\t\t * the the current inum. To handle this case, we create the\n\t\t * parent directory out of order. But we need to check if this\n\t\t * did already happen before due to other refs in the same dir.\n\t\t */\n\t\tret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret == inode_state_will_create) {\n\t\t\tret = 0;\n\t\t\t/*\n\t\t\t * First check if any of the current inodes refs did\n\t\t\t * already create the dir.\n\t\t\t */\n\t\t\tlist_for_each_entry(cur2, &sctx->new_refs, list) {\n\t\t\t\tif (cur == cur2)\n\t\t\t\t\tbreak;\n\t\t\t\tif (cur2->dir == cur->dir) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If that did not happen, check if a previous inode\n\t\t\t * did already create the dir.\n\t\t\t */\n\t\t\tif (!ret)\n\t\t\t\tret = did_create_dir(sctx, cur->dir);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret) {\n\t\t\t\tret = send_create_inode(sctx, cur->dir);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Check if this new ref would overwrite the first ref of\n\t\t * another unprocessed inode. If yes, orphanize the\n\t\t * overwritten inode. If we find an overwritten ref that is\n\t\t * not the first ref, simply unlink it.\n\t\t */\n\t\tret = will_overwrite_ref(sctx, cur->dir, cur->dir_gen,\n\t\t\t\tcur->name, cur->name_len,\n\t\t\t\t&ow_inode, &ow_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = is_first_ref(sctx->parent_root,\n\t\t\t\t\t   ow_inode, cur->dir, cur->name,\n\t\t\t\t\t   cur->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret) {\n\t\t\t\tret = orphanize_inode(sctx, ow_inode, ow_gen,\n\t\t\t\t\t\tcur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tret = send_unlink(sctx, cur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (S_ISDIR(sctx->cur_inode_mode) && sctx->parent_root) {\n\t\t\tret = wait_for_dest_dir_move(sctx, cur, is_orphan);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 1) {\n\t\t\t\tcan_rename = false;\n\t\t\t\t*pending_move = 1;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * link/move the ref to the new place. If we have an orphan\n\t\t * inode, move it and update valid_path. If not, link or move\n\t\t * it depending on the inode mode.\n\t\t */\n\t\tif (is_orphan && can_rename) {\n\t\t\tret = send_rename(sctx, valid_path, cur->full_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tis_orphan = 0;\n\t\t\tret = fs_path_copy(valid_path, cur->full_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (can_rename) {\n\t\t\tif (S_ISDIR(sctx->cur_inode_mode)) {\n\t\t\t\t/*\n\t\t\t\t * Dirs can't be linked, so move it. For moved\n\t\t\t\t * dirs, we always have one new and one deleted\n\t\t\t\t * ref. The deleted ref is ignored later.\n\t\t\t\t */\n\t\t\t\tret = wait_for_parent_move(sctx, cur);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (ret) {\n\t\t\t\t\t*pending_move = 1;\n\t\t\t\t} else {\n\t\t\t\t\tret = send_rename(sctx, valid_path,\n\t\t\t\t\t\t\t  cur->full_path);\n\t\t\t\t\tif (!ret)\n\t\t\t\t\t\tret = fs_path_copy(valid_path,\n\t\t\t\t\t\t\t       cur->full_path);\n\t\t\t\t}\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tret = send_link(sctx, cur->full_path,\n\t\t\t\t\t\tvalid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = dup_ref(cur, &check_dirs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (S_ISDIR(sctx->cur_inode_mode) && sctx->cur_inode_deleted) {\n\t\t/*\n\t\t * Check if we can already rmdir the directory. If not,\n\t\t * orphanize it. For every dir item inside that gets deleted\n\t\t * later, we do this check again and rmdir it then if possible.\n\t\t * See the use of check_dirs for more details.\n\t\t */\n\t\tret = can_rmdir(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tsctx->cur_ino);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = send_rmdir(sctx, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (!is_orphan) {\n\t\t\tret = orphanize_inode(sctx, sctx->cur_ino,\n\t\t\t\t\tsctx->cur_inode_gen, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tis_orphan = 1;\n\t\t}\n\n\t\tlist_for_each_entry(cur, &sctx->deleted_refs, list) {\n\t\t\tret = dup_ref(cur, &check_dirs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t} else if (S_ISDIR(sctx->cur_inode_mode) &&\n\t\t   !list_empty(&sctx->deleted_refs)) {\n\t\t/*\n\t\t * We have a moved dir. Add the old parent to check_dirs\n\t\t */\n\t\tcur = list_entry(sctx->deleted_refs.next, struct recorded_ref,\n\t\t\t\tlist);\n\t\tret = dup_ref(cur, &check_dirs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else if (!S_ISDIR(sctx->cur_inode_mode)) {\n\t\t/*\n\t\t * We have a non dir inode. Go through all deleted refs and\n\t\t * unlink them if they were not already overwritten by other\n\t\t * inodes.\n\t\t */\n\t\tlist_for_each_entry(cur, &sctx->deleted_refs, list) {\n\t\t\tret = did_overwrite_ref(sctx, cur->dir, cur->dir_gen,\n\t\t\t\t\tsctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\t\tcur->name, cur->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret) {\n\t\t\t\tret = send_unlink(sctx, cur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = dup_ref(cur, &check_dirs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * If the inode is still orphan, unlink the orphan. This may\n\t\t * happen when a previous inode did overwrite the first ref\n\t\t * of this inode and no new refs were added for the current\n\t\t * inode. Unlinking does not mean that the inode is deleted in\n\t\t * all cases. There may still be links to this inode in other\n\t\t * places.\n\t\t */\n\t\tif (is_orphan) {\n\t\t\tret = send_unlink(sctx, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We did collect all parent dirs where cur_inode was once located. We\n\t * now go through all these dirs and check if they are pending for\n\t * deletion and if it's finally possible to perform the rmdir now.\n\t * We also update the inode stats of the parent dirs here.\n\t */\n\tlist_for_each_entry(cur, &check_dirs, list) {\n\t\t/*\n\t\t * In case we had refs into dirs that were not processed yet,\n\t\t * we don't need to do the utime and rmdir logic for these dirs.\n\t\t * The dir will be processed later.\n\t\t */\n\t\tif (cur->dir > sctx->cur_ino)\n\t\t\tcontinue;\n\n\t\tret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ret == inode_state_did_create ||\n\t\t    ret == inode_state_no_change) {\n\t\t\t/* TODO delayed utimes */\n\t\t\tret = send_utimes(sctx, cur->dir, cur->dir_gen);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (ret == inode_state_did_delete &&\n\t\t\t   cur->dir != last_dir_ino_rm) {\n\t\t\tret = can_rmdir(sctx, cur->dir, cur->dir_gen,\n\t\t\t\t\tsctx->cur_ino);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret) {\n\t\t\t\tret = get_cur_path(sctx, cur->dir,\n\t\t\t\t\t\t   cur->dir_gen, valid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tret = send_rmdir(sctx, valid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tlast_dir_ino_rm = cur->dir;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = 0;\n\nout:\n\t__free_recorded_refs(&check_dirs);\n\tfree_recorded_refs(sctx);\n\tfs_path_free(valid_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sctx->deleted_refs"
          ],
          "line": 5087
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_recorded_refs_if_needed(struct send_ctx *sctx, int at_end,\n\t\t\t\t\t   int *pending_move,\n\t\t\t\t\t   int *refs_processed)\n{\n\tint ret = 0;\n\n\tif (sctx->cur_ino == 0)\n\t\tgoto out;\n\tif (!at_end && sctx->cur_ino == sctx->cmp_key->objectid &&\n\t    sctx->cmp_key->type <= BTRFS_INODE_EXTREF_KEY)\n\t\tgoto out;\n\tif (list_empty(&sctx->new_refs) && list_empty(&sctx->deleted_refs))\n\t\tgoto out;\n\n\tret = process_recorded_refs(sctx, pending_move);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*refs_processed = 1;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "process_all_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "5019-5074",
    "snippet": "static int process_all_extents(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\troot = sctx->send_root;\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = process_extent(sctx, path, &found_key);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tpath->slots[0]++;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 5072
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_extent",
          "args": [
            "sctx",
            "path",
            "&found_key"
          ],
          "line": 5064
        },
        "resolved": true,
        "details": {
          "function_name": "process_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4959-5017",
          "snippet": "static int process_extent(struct send_ctx *sctx,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_key *key)\n{\n\tstruct clone_root *found_clone = NULL;\n\tint ret = 0;\n\n\tif (S_ISLNK(sctx->cur_inode_mode))\n\t\treturn 0;\n\n\tif (sctx->parent_root && !sctx->cur_inode_new) {\n\t\tret = is_extent_unchanged(sctx, path, key);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out_hole;\n\t\t}\n\t} else {\n\t\tstruct btrfs_file_extent_item *ei;\n\t\tu8 type;\n\n\t\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\ttype = btrfs_file_extent_type(path->nodes[0], ei);\n\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC ||\n\t\t    type == BTRFS_FILE_EXTENT_REG) {\n\t\t\t/*\n\t\t\t * The send spec does not have a prealloc command yet,\n\t\t\t * so just leave a hole for prealloc'ed extents until\n\t\t\t * we have enough commands queued up to justify rev'ing\n\t\t\t * the send spec.\n\t\t\t */\n\t\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Have a hole, just skip it. */\n\t\t\tif (btrfs_file_extent_disk_bytenr(path->nodes[0], ei) == 0) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = find_extent_clone(sctx, path, key->objectid, key->offset,\n\t\t\tsctx->cur_inode_size, &found_clone);\n\tif (ret != -ENOENT && ret < 0)\n\t\tgoto out;\n\n\tret = send_write_or_clone(sctx, path, key, found_clone);\n\tif (ret)\n\t\tgoto out;\nout_hole:\n\tret = maybe_send_hole(sctx, path, key);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_extent(struct send_ctx *sctx,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_key *key)\n{\n\tstruct clone_root *found_clone = NULL;\n\tint ret = 0;\n\n\tif (S_ISLNK(sctx->cur_inode_mode))\n\t\treturn 0;\n\n\tif (sctx->parent_root && !sctx->cur_inode_new) {\n\t\tret = is_extent_unchanged(sctx, path, key);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out_hole;\n\t\t}\n\t} else {\n\t\tstruct btrfs_file_extent_item *ei;\n\t\tu8 type;\n\n\t\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\ttype = btrfs_file_extent_type(path->nodes[0], ei);\n\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC ||\n\t\t    type == BTRFS_FILE_EXTENT_REG) {\n\t\t\t/*\n\t\t\t * The send spec does not have a prealloc command yet,\n\t\t\t * so just leave a hole for prealloc'ed extents until\n\t\t\t * we have enough commands queued up to justify rev'ing\n\t\t\t * the send spec.\n\t\t\t */\n\t\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Have a hole, just skip it. */\n\t\t\tif (btrfs_file_extent_disk_bytenr(path->nodes[0], ei) == 0) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = find_extent_clone(sctx, path, key->objectid, key->offset,\n\t\t\tsctx->cur_inode_size, &found_clone);\n\tif (ret != -ENOENT && ret < 0)\n\t\tgoto out;\n\n\tret = send_write_or_clone(sctx, path, key, found_clone);\n\tif (ret)\n\t\tgoto out;\nout_hole:\n\tret = maybe_send_hole(sctx, path, key);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "eb",
            "&found_key",
            "slot"
          ],
          "line": 5056
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 5046
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "eb"
          ],
          "line": 5045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 5037
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_path_for_send",
          "args": [],
          "line": 5030
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_path_for_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "496-507",
          "snippet": "static struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_all_extents(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\troot = sctx->send_root;\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = process_extent(sctx, path, &found_key);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tpath->slots[0]++;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "process_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4959-5017",
    "snippet": "static int process_extent(struct send_ctx *sctx,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_key *key)\n{\n\tstruct clone_root *found_clone = NULL;\n\tint ret = 0;\n\n\tif (S_ISLNK(sctx->cur_inode_mode))\n\t\treturn 0;\n\n\tif (sctx->parent_root && !sctx->cur_inode_new) {\n\t\tret = is_extent_unchanged(sctx, path, key);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out_hole;\n\t\t}\n\t} else {\n\t\tstruct btrfs_file_extent_item *ei;\n\t\tu8 type;\n\n\t\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\ttype = btrfs_file_extent_type(path->nodes[0], ei);\n\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC ||\n\t\t    type == BTRFS_FILE_EXTENT_REG) {\n\t\t\t/*\n\t\t\t * The send spec does not have a prealloc command yet,\n\t\t\t * so just leave a hole for prealloc'ed extents until\n\t\t\t * we have enough commands queued up to justify rev'ing\n\t\t\t * the send spec.\n\t\t\t */\n\t\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Have a hole, just skip it. */\n\t\t\tif (btrfs_file_extent_disk_bytenr(path->nodes[0], ei) == 0) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = find_extent_clone(sctx, path, key->objectid, key->offset,\n\t\t\tsctx->cur_inode_size, &found_clone);\n\tif (ret != -ENOENT && ret < 0)\n\t\tgoto out;\n\n\tret = send_write_or_clone(sctx, path, key, found_clone);\n\tif (ret)\n\t\tgoto out;\nout_hole:\n\tret = maybe_send_hole(sctx, path, key);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "maybe_send_hole",
          "args": [
            "sctx",
            "path",
            "key"
          ],
          "line": 5014
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_send_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4909-4957",
          "snippet": "static int maybe_send_hole(struct send_ctx *sctx, struct btrfs_path *path,\n\t\t\t   struct btrfs_key *key)\n{\n\tstruct btrfs_file_extent_item *fi;\n\tu64 extent_end;\n\tu8 type;\n\tint ret = 0;\n\n\tif (sctx->cur_ino != key->objectid || !need_send_hole(sctx))\n\t\treturn 0;\n\n\tif (sctx->cur_inode_last_extent == (u64)-1) {\n\t\tret = get_last_extent(sctx, key->offset - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], fi);\n\tif (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tu64 size = btrfs_file_extent_inline_len(path->nodes[0],\n\t\t\t\t\t\t\tpath->slots[0], fi);\n\t\textent_end = ALIGN(key->offset + size,\n\t\t\t\t   sctx->send_root->sectorsize);\n\t} else {\n\t\textent_end = key->offset +\n\t\t\tbtrfs_file_extent_num_bytes(path->nodes[0], fi);\n\t}\n\n\tif (path->slots[0] == 0 &&\n\t    sctx->cur_inode_last_extent < key->offset) {\n\t\t/*\n\t\t * We might have skipped entire leafs that contained only\n\t\t * file extent items for our current inode. These leafs have\n\t\t * a generation number smaller (older) than the one in the\n\t\t * current leaf and the leaf our last extent came from, and\n\t\t * are located between these 2 leafs.\n\t\t */\n\t\tret = get_last_extent(sctx, key->offset - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (sctx->cur_inode_last_extent < key->offset)\n\t\tret = send_hole(sctx, key->offset);\n\tsctx->cur_inode_last_extent = extent_end;\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int maybe_send_hole(struct send_ctx *sctx, struct btrfs_path *path,\n\t\t\t   struct btrfs_key *key)\n{\n\tstruct btrfs_file_extent_item *fi;\n\tu64 extent_end;\n\tu8 type;\n\tint ret = 0;\n\n\tif (sctx->cur_ino != key->objectid || !need_send_hole(sctx))\n\t\treturn 0;\n\n\tif (sctx->cur_inode_last_extent == (u64)-1) {\n\t\tret = get_last_extent(sctx, key->offset - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], fi);\n\tif (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tu64 size = btrfs_file_extent_inline_len(path->nodes[0],\n\t\t\t\t\t\t\tpath->slots[0], fi);\n\t\textent_end = ALIGN(key->offset + size,\n\t\t\t\t   sctx->send_root->sectorsize);\n\t} else {\n\t\textent_end = key->offset +\n\t\t\tbtrfs_file_extent_num_bytes(path->nodes[0], fi);\n\t}\n\n\tif (path->slots[0] == 0 &&\n\t    sctx->cur_inode_last_extent < key->offset) {\n\t\t/*\n\t\t * We might have skipped entire leafs that contained only\n\t\t * file extent items for our current inode. These leafs have\n\t\t * a generation number smaller (older) than the one in the\n\t\t * current leaf and the leaf our last extent came from, and\n\t\t * are located between these 2 leafs.\n\t\t */\n\t\tret = get_last_extent(sctx, key->offset - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (sctx->cur_inode_last_extent < key->offset)\n\t\tret = send_hole(sctx, key->offset);\n\tsctx->cur_inode_last_extent = extent_end;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_write_or_clone",
          "args": [
            "sctx",
            "path",
            "key",
            "found_clone"
          ],
          "line": 5010
        },
        "resolved": true,
        "details": {
          "function_name": "send_write_or_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4635-4692",
          "snippet": "static int send_write_or_clone(struct send_ctx *sctx,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       struct btrfs_key *key,\n\t\t\t       struct clone_root *clone_root)\n{\n\tint ret = 0;\n\tstruct btrfs_file_extent_item *ei;\n\tu64 offset = key->offset;\n\tu64 pos = 0;\n\tu64 len;\n\tu32 l;\n\tu8 type;\n\tu64 bs = sctx->send_root->fs_info->sb->s_blocksize;\n\n\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\tstruct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], ei);\n\tif (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tlen = btrfs_file_extent_inline_len(path->nodes[0],\n\t\t\t\t\t\t   path->slots[0], ei);\n\t\t/*\n\t\t * it is possible the inline item won't cover the whole page,\n\t\t * but there may be items after this page.  Make\n\t\t * sure to send the whole thing\n\t\t */\n\t\tlen = PAGE_CACHE_ALIGN(len);\n\t} else {\n\t\tlen = btrfs_file_extent_num_bytes(path->nodes[0], ei);\n\t}\n\n\tif (offset + len > sctx->cur_inode_size)\n\t\tlen = sctx->cur_inode_size - offset;\n\tif (len == 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (clone_root && IS_ALIGNED(offset + len, bs)) {\n\t\tret = send_clone(sctx, offset, len, clone_root);\n\t} else if (sctx->flags & BTRFS_SEND_FLAG_NO_FILE_DATA) {\n\t\tret = send_update_extent(sctx, offset, len);\n\t} else {\n\t\twhile (pos < len) {\n\t\t\tl = len - pos;\n\t\t\tif (l > BTRFS_SEND_READ_SIZE)\n\t\t\t\tl = BTRFS_SEND_READ_SIZE;\n\t\t\tret = send_write(sctx, pos + offset, l);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret)\n\t\t\t\tbreak;\n\t\t\tpos += ret;\n\t\t}\n\t\tret = 0;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_write_or_clone(struct send_ctx *sctx,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       struct btrfs_key *key,\n\t\t\t       struct clone_root *clone_root)\n{\n\tint ret = 0;\n\tstruct btrfs_file_extent_item *ei;\n\tu64 offset = key->offset;\n\tu64 pos = 0;\n\tu64 len;\n\tu32 l;\n\tu8 type;\n\tu64 bs = sctx->send_root->fs_info->sb->s_blocksize;\n\n\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\tstruct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], ei);\n\tif (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tlen = btrfs_file_extent_inline_len(path->nodes[0],\n\t\t\t\t\t\t   path->slots[0], ei);\n\t\t/*\n\t\t * it is possible the inline item won't cover the whole page,\n\t\t * but there may be items after this page.  Make\n\t\t * sure to send the whole thing\n\t\t */\n\t\tlen = PAGE_CACHE_ALIGN(len);\n\t} else {\n\t\tlen = btrfs_file_extent_num_bytes(path->nodes[0], ei);\n\t}\n\n\tif (offset + len > sctx->cur_inode_size)\n\t\tlen = sctx->cur_inode_size - offset;\n\tif (len == 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (clone_root && IS_ALIGNED(offset + len, bs)) {\n\t\tret = send_clone(sctx, offset, len, clone_root);\n\t} else if (sctx->flags & BTRFS_SEND_FLAG_NO_FILE_DATA) {\n\t\tret = send_update_extent(sctx, offset, len);\n\t} else {\n\t\twhile (pos < len) {\n\t\t\tl = len - pos;\n\t\t\tif (l > BTRFS_SEND_READ_SIZE)\n\t\t\t\tl = BTRFS_SEND_READ_SIZE;\n\t\t\tret = send_write(sctx, pos + offset, l);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret)\n\t\t\t\tbreak;\n\t\t\tpos += ret;\n\t\t}\n\t\tret = 0;\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_extent_clone",
          "args": [
            "sctx",
            "path",
            "key->objectid",
            "key->offset",
            "sctx->cur_inode_size",
            "&found_clone"
          ],
          "line": 5005
        },
        "resolved": true,
        "details": {
          "function_name": "find_extent_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1273-1440",
          "snippet": "static int find_extent_clone(struct send_ctx *sctx,\n\t\t\t     struct btrfs_path *path,\n\t\t\t     u64 ino, u64 data_offset,\n\t\t\t     u64 ino_size,\n\t\t\t     struct clone_root **found)\n{\n\tint ret;\n\tint extent_type;\n\tu64 logical;\n\tu64 disk_byte;\n\tu64 num_bytes;\n\tu64 extent_item_pos;\n\tu64 flags = 0;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct backref_ctx *backref_ctx = NULL;\n\tstruct clone_root *cur_clone_root;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *tmp_path;\n\tint compressed;\n\tu32 i;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path)\n\t\treturn -ENOMEM;\n\n\t/* We only use this path under the commit sem */\n\ttmp_path->need_commit_sem = 0;\n\n\tbackref_ctx = kmalloc(sizeof(*backref_ctx), GFP_NOFS);\n\tif (!backref_ctx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbackref_ctx->path = tmp_path;\n\n\tif (data_offset >= ino_size) {\n\t\t/*\n\t\t * There may be extents that lie behind the file's size.\n\t\t * I at least had this in combination with snapshotting while\n\t\t * writing large files.\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tfi = btrfs_item_ptr(eb, path->slots[0],\n\t\t\tstruct btrfs_file_extent_item);\n\textent_type = btrfs_file_extent_type(eb, fi);\n\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tcompressed = btrfs_file_extent_compression(eb, fi);\n\n\tnum_bytes = btrfs_file_extent_num_bytes(eb, fi);\n\tdisk_byte = btrfs_file_extent_disk_bytenr(eb, fi);\n\tif (disk_byte == 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tlogical = disk_byte + btrfs_file_extent_offset(eb, fi);\n\n\tdown_read(&sctx->send_root->fs_info->commit_root_sem);\n\tret = extent_from_logical(sctx->send_root->fs_info, disk_byte, tmp_path,\n\t\t\t\t  &found_key, &flags);\n\tup_read(&sctx->send_root->fs_info->commit_root_sem);\n\tbtrfs_release_path(tmp_path);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Setup the clone roots.\n\t */\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++) {\n\t\tcur_clone_root = sctx->clone_roots + i;\n\t\tcur_clone_root->ino = (u64)-1;\n\t\tcur_clone_root->offset = 0;\n\t\tcur_clone_root->found_refs = 0;\n\t}\n\n\tbackref_ctx->sctx = sctx;\n\tbackref_ctx->found = 0;\n\tbackref_ctx->cur_objectid = ino;\n\tbackref_ctx->cur_offset = data_offset;\n\tbackref_ctx->found_itself = 0;\n\tbackref_ctx->extent_len = num_bytes;\n\n\t/*\n\t * The last extent of a file may be too large due to page alignment.\n\t * We need to adjust extent_len in this case so that the checks in\n\t * __iterate_backrefs work.\n\t */\n\tif (data_offset + num_bytes >= ino_size)\n\t\tbackref_ctx->extent_len = ino_size - data_offset;\n\n\t/*\n\t * Now collect all backrefs.\n\t */\n\tif (compressed == BTRFS_COMPRESS_NONE)\n\t\textent_item_pos = logical - found_key.objectid;\n\telse\n\t\textent_item_pos = 0;\n\tret = iterate_extent_inodes(sctx->send_root->fs_info,\n\t\t\t\t\tfound_key.objectid, extent_item_pos, 1,\n\t\t\t\t\t__iterate_backrefs, backref_ctx);\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!backref_ctx->found_itself) {\n\t\t/* found a bug in backref code? */\n\t\tret = -EIO;\n\t\tbtrfs_err(sctx->send_root->fs_info, \"did not find backref in \"\n\t\t\t\t\"send_root. inode=%llu, offset=%llu, \"\n\t\t\t\t\"disk_byte=%llu found extent=%llu\",\n\t\t\t\tino, data_offset, disk_byte, found_key.objectid);\n\t\tgoto out;\n\t}\n\nverbose_printk(KERN_DEBUG \"btrfs: find_extent_clone: data_offset=%llu, \"\n\t\t\"ino=%llu, \"\n\t\t\"num_bytes=%llu, logical=%llu\\n\",\n\t\tdata_offset, ino, num_bytes, logical);\n\n\tif (!backref_ctx->found)\n\t\tverbose_printk(\"btrfs:    no clones found\\n\");\n\n\tcur_clone_root = NULL;\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++) {\n\t\tif (sctx->clone_roots[i].found_refs) {\n\t\t\tif (!cur_clone_root)\n\t\t\t\tcur_clone_root = sctx->clone_roots + i;\n\t\t\telse if (sctx->clone_roots[i].root == sctx->send_root)\n\t\t\t\t/* prefer clones from send_root over others */\n\t\t\t\tcur_clone_root = sctx->clone_roots + i;\n\t\t}\n\n\t}\n\n\tif (cur_clone_root) {\n\t\tif (compressed != BTRFS_COMPRESS_NONE) {\n\t\t\t/*\n\t\t\t * Offsets given by iterate_extent_inodes() are relative\n\t\t\t * to the start of the extent, we need to add logical\n\t\t\t * offset from the file extent item.\n\t\t\t * (See why at backref.c:check_extent_in_eb())\n\t\t\t */\n\t\t\tcur_clone_root->offset += btrfs_file_extent_offset(eb,\n\t\t\t\t\t\t\t\t\t   fi);\n\t\t}\n\t\t*found = cur_clone_root;\n\t\tret = 0;\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tkfree(backref_ctx);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int find_extent_clone(struct send_ctx *sctx,\n\t\t\t     struct btrfs_path *path,\n\t\t\t     u64 ino, u64 data_offset,\n\t\t\t     u64 ino_size,\n\t\t\t     struct clone_root **found)\n{\n\tint ret;\n\tint extent_type;\n\tu64 logical;\n\tu64 disk_byte;\n\tu64 num_bytes;\n\tu64 extent_item_pos;\n\tu64 flags = 0;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct backref_ctx *backref_ctx = NULL;\n\tstruct clone_root *cur_clone_root;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *tmp_path;\n\tint compressed;\n\tu32 i;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path)\n\t\treturn -ENOMEM;\n\n\t/* We only use this path under the commit sem */\n\ttmp_path->need_commit_sem = 0;\n\n\tbackref_ctx = kmalloc(sizeof(*backref_ctx), GFP_NOFS);\n\tif (!backref_ctx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbackref_ctx->path = tmp_path;\n\n\tif (data_offset >= ino_size) {\n\t\t/*\n\t\t * There may be extents that lie behind the file's size.\n\t\t * I at least had this in combination with snapshotting while\n\t\t * writing large files.\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tfi = btrfs_item_ptr(eb, path->slots[0],\n\t\t\tstruct btrfs_file_extent_item);\n\textent_type = btrfs_file_extent_type(eb, fi);\n\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tcompressed = btrfs_file_extent_compression(eb, fi);\n\n\tnum_bytes = btrfs_file_extent_num_bytes(eb, fi);\n\tdisk_byte = btrfs_file_extent_disk_bytenr(eb, fi);\n\tif (disk_byte == 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tlogical = disk_byte + btrfs_file_extent_offset(eb, fi);\n\n\tdown_read(&sctx->send_root->fs_info->commit_root_sem);\n\tret = extent_from_logical(sctx->send_root->fs_info, disk_byte, tmp_path,\n\t\t\t\t  &found_key, &flags);\n\tup_read(&sctx->send_root->fs_info->commit_root_sem);\n\tbtrfs_release_path(tmp_path);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Setup the clone roots.\n\t */\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++) {\n\t\tcur_clone_root = sctx->clone_roots + i;\n\t\tcur_clone_root->ino = (u64)-1;\n\t\tcur_clone_root->offset = 0;\n\t\tcur_clone_root->found_refs = 0;\n\t}\n\n\tbackref_ctx->sctx = sctx;\n\tbackref_ctx->found = 0;\n\tbackref_ctx->cur_objectid = ino;\n\tbackref_ctx->cur_offset = data_offset;\n\tbackref_ctx->found_itself = 0;\n\tbackref_ctx->extent_len = num_bytes;\n\n\t/*\n\t * The last extent of a file may be too large due to page alignment.\n\t * We need to adjust extent_len in this case so that the checks in\n\t * __iterate_backrefs work.\n\t */\n\tif (data_offset + num_bytes >= ino_size)\n\t\tbackref_ctx->extent_len = ino_size - data_offset;\n\n\t/*\n\t * Now collect all backrefs.\n\t */\n\tif (compressed == BTRFS_COMPRESS_NONE)\n\t\textent_item_pos = logical - found_key.objectid;\n\telse\n\t\textent_item_pos = 0;\n\tret = iterate_extent_inodes(sctx->send_root->fs_info,\n\t\t\t\t\tfound_key.objectid, extent_item_pos, 1,\n\t\t\t\t\t__iterate_backrefs, backref_ctx);\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!backref_ctx->found_itself) {\n\t\t/* found a bug in backref code? */\n\t\tret = -EIO;\n\t\tbtrfs_err(sctx->send_root->fs_info, \"did not find backref in \"\n\t\t\t\t\"send_root. inode=%llu, offset=%llu, \"\n\t\t\t\t\"disk_byte=%llu found extent=%llu\",\n\t\t\t\tino, data_offset, disk_byte, found_key.objectid);\n\t\tgoto out;\n\t}\n\nverbose_printk(KERN_DEBUG \"btrfs: find_extent_clone: data_offset=%llu, \"\n\t\t\"ino=%llu, \"\n\t\t\"num_bytes=%llu, logical=%llu\\n\",\n\t\tdata_offset, ino, num_bytes, logical);\n\n\tif (!backref_ctx->found)\n\t\tverbose_printk(\"btrfs:    no clones found\\n\");\n\n\tcur_clone_root = NULL;\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++) {\n\t\tif (sctx->clone_roots[i].found_refs) {\n\t\t\tif (!cur_clone_root)\n\t\t\t\tcur_clone_root = sctx->clone_roots + i;\n\t\t\telse if (sctx->clone_roots[i].root == sctx->send_root)\n\t\t\t\t/* prefer clones from send_root over others */\n\t\t\t\tcur_clone_root = sctx->clone_roots + i;\n\t\t}\n\n\t}\n\n\tif (cur_clone_root) {\n\t\tif (compressed != BTRFS_COMPRESS_NONE) {\n\t\t\t/*\n\t\t\t * Offsets given by iterate_extent_inodes() are relative\n\t\t\t * to the start of the extent, we need to add logical\n\t\t\t * offset from the file extent item.\n\t\t\t * (See why at backref.c:check_extent_in_eb())\n\t\t\t */\n\t\t\tcur_clone_root->offset += btrfs_file_extent_offset(eb,\n\t\t\t\t\t\t\t\t\t   fi);\n\t\t}\n\t\t*found = cur_clone_root;\n\t\tret = 0;\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tkfree(backref_ctx);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_bytenr",
          "args": [
            "path->nodes[0]",
            "ei"
          ],
          "line": 4998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "path->nodes[0]",
            "ei"
          ],
          "line": 4983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 4981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_extent_unchanged",
          "args": [
            "sctx",
            "path",
            "key"
          ],
          "line": 4970
        },
        "resolved": true,
        "details": {
          "function_name": "is_extent_unchanged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4694-4862",
          "snippet": "static int is_extent_unchanged(struct send_ctx *sctx,\n\t\t\t       struct btrfs_path *left_path,\n\t\t\t       struct btrfs_key *ekey)\n{\n\tint ret = 0;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_file_extent_item *ei;\n\tu64 left_disknr;\n\tu64 right_disknr;\n\tu64 left_offset;\n\tu64 right_offset;\n\tu64 left_offset_fixed;\n\tu64 left_len;\n\tu64 right_len;\n\tu64 left_gen;\n\tu64 right_gen;\n\tu8 left_type;\n\tu8 right_type;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\teb = left_path->nodes[0];\n\tslot = left_path->slots[0];\n\tei = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\tleft_type = btrfs_file_extent_type(eb, ei);\n\n\tif (left_type != BTRFS_FILE_EXTENT_REG) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tleft_disknr = btrfs_file_extent_disk_bytenr(eb, ei);\n\tleft_len = btrfs_file_extent_num_bytes(eb, ei);\n\tleft_offset = btrfs_file_extent_offset(eb, ei);\n\tleft_gen = btrfs_file_extent_generation(eb, ei);\n\n\t/*\n\t * Following comments will refer to these graphics. L is the left\n\t * extents which we are checking at the moment. 1-8 are the right\n\t * extents that we iterate.\n\t *\n\t *       |-----L-----|\n\t * |-1-|-2a-|-3-|-4-|-5-|-6-|\n\t *\n\t *       |-----L-----|\n\t * |--1--|-2b-|...(same as above)\n\t *\n\t * Alternative situation. Happens on files where extents got split.\n\t *       |-----L-----|\n\t * |-----------7-----------|-6-|\n\t *\n\t * Alternative situation. Happens on files which got larger.\n\t *       |-----L-----|\n\t * |-8-|\n\t * Nothing follows after 8.\n\t */\n\n\tkey.objectid = ekey->objectid;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = ekey->offset;\n\tret = btrfs_search_slot_for_read(sctx->parent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Handle special case where the right side has no extents at all.\n\t */\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\tif (found_key.objectid != key.objectid ||\n\t    found_key.type != key.type) {\n\t\t/* If we're a hole then just pretend nothing changed */\n\t\tret = (left_disknr) ? 0 : 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We're now on 2a, 2b or 7.\n\t */\n\tkey = found_key;\n\twhile (key.offset < ekey->offset + left_len) {\n\t\tei = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\t\tright_type = btrfs_file_extent_type(eb, ei);\n\t\tif (right_type != BTRFS_FILE_EXTENT_REG) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tright_disknr = btrfs_file_extent_disk_bytenr(eb, ei);\n\t\tright_len = btrfs_file_extent_num_bytes(eb, ei);\n\t\tright_offset = btrfs_file_extent_offset(eb, ei);\n\t\tright_gen = btrfs_file_extent_generation(eb, ei);\n\n\t\t/*\n\t\t * Are we at extent 8? If yes, we know the extent is changed.\n\t\t * This may only happen on the first iteration.\n\t\t */\n\t\tif (found_key.offset + right_len <= ekey->offset) {\n\t\t\t/* If we're a hole just pretend nothing changed */\n\t\t\tret = (left_disknr) ? 0 : 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tleft_offset_fixed = left_offset;\n\t\tif (key.offset < ekey->offset) {\n\t\t\t/* Fix the right offset for 2a and 7. */\n\t\t\tright_offset += ekey->offset - key.offset;\n\t\t} else {\n\t\t\t/* Fix the left offset for all behind 2a and 2b */\n\t\t\tleft_offset_fixed += key.offset - ekey->offset;\n\t\t}\n\n\t\t/*\n\t\t * Check if we have the same extent.\n\t\t */\n\t\tif (left_disknr != right_disknr ||\n\t\t    left_offset_fixed != right_offset ||\n\t\t    left_gen != right_gen) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Go to the next extent.\n\t\t */\n\t\tret = btrfs_next_item(sctx->parent_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (!ret) {\n\t\t\teb = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\t}\n\t\tif (ret || found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tkey.offset += right_len;\n\t\t\tbreak;\n\t\t}\n\t\tif (found_key.offset != key.offset + right_len) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tkey = found_key;\n\t}\n\n\t/*\n\t * We're now behind the left extent (treat as unchanged) or at the end\n\t * of the right side (treat as changed).\n\t */\n\tif (key.offset >= ekey->offset + left_len)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_extent_unchanged(struct send_ctx *sctx,\n\t\t\t       struct btrfs_path *left_path,\n\t\t\t       struct btrfs_key *ekey)\n{\n\tint ret = 0;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_file_extent_item *ei;\n\tu64 left_disknr;\n\tu64 right_disknr;\n\tu64 left_offset;\n\tu64 right_offset;\n\tu64 left_offset_fixed;\n\tu64 left_len;\n\tu64 right_len;\n\tu64 left_gen;\n\tu64 right_gen;\n\tu8 left_type;\n\tu8 right_type;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\teb = left_path->nodes[0];\n\tslot = left_path->slots[0];\n\tei = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\tleft_type = btrfs_file_extent_type(eb, ei);\n\n\tif (left_type != BTRFS_FILE_EXTENT_REG) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tleft_disknr = btrfs_file_extent_disk_bytenr(eb, ei);\n\tleft_len = btrfs_file_extent_num_bytes(eb, ei);\n\tleft_offset = btrfs_file_extent_offset(eb, ei);\n\tleft_gen = btrfs_file_extent_generation(eb, ei);\n\n\t/*\n\t * Following comments will refer to these graphics. L is the left\n\t * extents which we are checking at the moment. 1-8 are the right\n\t * extents that we iterate.\n\t *\n\t *       |-----L-----|\n\t * |-1-|-2a-|-3-|-4-|-5-|-6-|\n\t *\n\t *       |-----L-----|\n\t * |--1--|-2b-|...(same as above)\n\t *\n\t * Alternative situation. Happens on files where extents got split.\n\t *       |-----L-----|\n\t * |-----------7-----------|-6-|\n\t *\n\t * Alternative situation. Happens on files which got larger.\n\t *       |-----L-----|\n\t * |-8-|\n\t * Nothing follows after 8.\n\t */\n\n\tkey.objectid = ekey->objectid;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = ekey->offset;\n\tret = btrfs_search_slot_for_read(sctx->parent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Handle special case where the right side has no extents at all.\n\t */\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\tif (found_key.objectid != key.objectid ||\n\t    found_key.type != key.type) {\n\t\t/* If we're a hole then just pretend nothing changed */\n\t\tret = (left_disknr) ? 0 : 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We're now on 2a, 2b or 7.\n\t */\n\tkey = found_key;\n\twhile (key.offset < ekey->offset + left_len) {\n\t\tei = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\t\tright_type = btrfs_file_extent_type(eb, ei);\n\t\tif (right_type != BTRFS_FILE_EXTENT_REG) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tright_disknr = btrfs_file_extent_disk_bytenr(eb, ei);\n\t\tright_len = btrfs_file_extent_num_bytes(eb, ei);\n\t\tright_offset = btrfs_file_extent_offset(eb, ei);\n\t\tright_gen = btrfs_file_extent_generation(eb, ei);\n\n\t\t/*\n\t\t * Are we at extent 8? If yes, we know the extent is changed.\n\t\t * This may only happen on the first iteration.\n\t\t */\n\t\tif (found_key.offset + right_len <= ekey->offset) {\n\t\t\t/* If we're a hole just pretend nothing changed */\n\t\t\tret = (left_disknr) ? 0 : 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tleft_offset_fixed = left_offset;\n\t\tif (key.offset < ekey->offset) {\n\t\t\t/* Fix the right offset for 2a and 7. */\n\t\t\tright_offset += ekey->offset - key.offset;\n\t\t} else {\n\t\t\t/* Fix the left offset for all behind 2a and 2b */\n\t\t\tleft_offset_fixed += key.offset - ekey->offset;\n\t\t}\n\n\t\t/*\n\t\t * Check if we have the same extent.\n\t\t */\n\t\tif (left_disknr != right_disknr ||\n\t\t    left_offset_fixed != right_offset ||\n\t\t    left_gen != right_gen) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Go to the next extent.\n\t\t */\n\t\tret = btrfs_next_item(sctx->parent_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (!ret) {\n\t\t\teb = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\t}\n\t\tif (ret || found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tkey.offset += right_len;\n\t\t\tbreak;\n\t\t}\n\t\tif (found_key.offset != key.offset + right_len) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tkey = found_key;\n\t}\n\n\t/*\n\t * We're now behind the left extent (treat as unchanged) or at the end\n\t * of the right side (treat as changed).\n\t */\n\tif (key.offset >= ekey->offset + left_len)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "sctx->cur_inode_mode"
          ],
          "line": 4966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_extent(struct send_ctx *sctx,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_key *key)\n{\n\tstruct clone_root *found_clone = NULL;\n\tint ret = 0;\n\n\tif (S_ISLNK(sctx->cur_inode_mode))\n\t\treturn 0;\n\n\tif (sctx->parent_root && !sctx->cur_inode_new) {\n\t\tret = is_extent_unchanged(sctx, path, key);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out_hole;\n\t\t}\n\t} else {\n\t\tstruct btrfs_file_extent_item *ei;\n\t\tu8 type;\n\n\t\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\ttype = btrfs_file_extent_type(path->nodes[0], ei);\n\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC ||\n\t\t    type == BTRFS_FILE_EXTENT_REG) {\n\t\t\t/*\n\t\t\t * The send spec does not have a prealloc command yet,\n\t\t\t * so just leave a hole for prealloc'ed extents until\n\t\t\t * we have enough commands queued up to justify rev'ing\n\t\t\t * the send spec.\n\t\t\t */\n\t\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Have a hole, just skip it. */\n\t\t\tif (btrfs_file_extent_disk_bytenr(path->nodes[0], ei) == 0) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = find_extent_clone(sctx, path, key->objectid, key->offset,\n\t\t\tsctx->cur_inode_size, &found_clone);\n\tif (ret != -ENOENT && ret < 0)\n\t\tgoto out;\n\n\tret = send_write_or_clone(sctx, path, key, found_clone);\n\tif (ret)\n\t\tgoto out;\nout_hole:\n\tret = maybe_send_hole(sctx, path, key);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "maybe_send_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4909-4957",
    "snippet": "static int maybe_send_hole(struct send_ctx *sctx, struct btrfs_path *path,\n\t\t\t   struct btrfs_key *key)\n{\n\tstruct btrfs_file_extent_item *fi;\n\tu64 extent_end;\n\tu8 type;\n\tint ret = 0;\n\n\tif (sctx->cur_ino != key->objectid || !need_send_hole(sctx))\n\t\treturn 0;\n\n\tif (sctx->cur_inode_last_extent == (u64)-1) {\n\t\tret = get_last_extent(sctx, key->offset - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], fi);\n\tif (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tu64 size = btrfs_file_extent_inline_len(path->nodes[0],\n\t\t\t\t\t\t\tpath->slots[0], fi);\n\t\textent_end = ALIGN(key->offset + size,\n\t\t\t\t   sctx->send_root->sectorsize);\n\t} else {\n\t\textent_end = key->offset +\n\t\t\tbtrfs_file_extent_num_bytes(path->nodes[0], fi);\n\t}\n\n\tif (path->slots[0] == 0 &&\n\t    sctx->cur_inode_last_extent < key->offset) {\n\t\t/*\n\t\t * We might have skipped entire leafs that contained only\n\t\t * file extent items for our current inode. These leafs have\n\t\t * a generation number smaller (older) than the one in the\n\t\t * current leaf and the leaf our last extent came from, and\n\t\t * are located between these 2 leafs.\n\t\t */\n\t\tret = get_last_extent(sctx, key->offset - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (sctx->cur_inode_last_extent < key->offset)\n\t\tret = send_hole(sctx, key->offset);\n\tsctx->cur_inode_last_extent = extent_end;\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_hole",
          "args": [
            "sctx",
            "key->offset"
          ],
          "line": 4954
        },
        "resolved": true,
        "details": {
          "function_name": "send_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4602-4633",
          "snippet": "static int send_hole(struct send_ctx *sctx, u64 end)\n{\n\tstruct fs_path *p = NULL;\n\tu64 offset = sctx->cur_inode_last_extent;\n\tu64 len;\n\tint ret = 0;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto tlv_put_failure;\n\tmemset(sctx->read_buf, 0, BTRFS_SEND_READ_SIZE);\n\twhile (offset < end) {\n\t\tlen = min_t(u64, end - offset, BTRFS_SEND_READ_SIZE);\n\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_WRITE);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\t\tTLV_PUT(sctx, BTRFS_SEND_A_DATA, sctx->read_buf, len);\n\t\tret = send_cmd(sctx);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\toffset += len;\n\t}\ntlv_put_failure:\n\tfs_path_free(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_hole(struct send_ctx *sctx, u64 end)\n{\n\tstruct fs_path *p = NULL;\n\tu64 offset = sctx->cur_inode_last_extent;\n\tu64 len;\n\tint ret = 0;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto tlv_put_failure;\n\tmemset(sctx->read_buf, 0, BTRFS_SEND_READ_SIZE);\n\twhile (offset < end) {\n\t\tlen = min_t(u64, end - offset, BTRFS_SEND_READ_SIZE);\n\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_WRITE);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\t\tTLV_PUT(sctx, BTRFS_SEND_A_DATA, sctx->read_buf, len);\n\t\tret = send_cmd(sctx);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\toffset += len;\n\t}\ntlv_put_failure:\n\tfs_path_free(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_last_extent",
          "args": [
            "sctx",
            "key->offset - 1"
          ],
          "line": 4948
        },
        "resolved": true,
        "details": {
          "function_name": "get_last_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4864-4907",
          "snippet": "static int get_last_extent(struct send_ctx *sctx, u64 offset)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = sctx->send_root;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tu64 extent_end;\n\tu8 type;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tsctx->cur_inode_last_extent = 0;\n\n\tkey.objectid = sctx->cur_ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = offset;\n\tret = btrfs_search_slot_for_read(root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\tif (key.objectid != sctx->cur_ino || key.type != BTRFS_EXTENT_DATA_KEY)\n\t\tgoto out;\n\n\tfi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], fi);\n\tif (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tu64 size = btrfs_file_extent_inline_len(path->nodes[0],\n\t\t\t\t\t\t\tpath->slots[0], fi);\n\t\textent_end = ALIGN(key.offset + size,\n\t\t\t\t   sctx->send_root->sectorsize);\n\t} else {\n\t\textent_end = key.offset +\n\t\t\tbtrfs_file_extent_num_bytes(path->nodes[0], fi);\n\t}\n\tsctx->cur_inode_last_extent = extent_end;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int get_last_extent(struct send_ctx *sctx, u64 offset)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = sctx->send_root;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tu64 extent_end;\n\tu8 type;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tsctx->cur_inode_last_extent = 0;\n\n\tkey.objectid = sctx->cur_ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = offset;\n\tret = btrfs_search_slot_for_read(root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\tif (key.objectid != sctx->cur_ino || key.type != BTRFS_EXTENT_DATA_KEY)\n\t\tgoto out;\n\n\tfi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], fi);\n\tif (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tu64 size = btrfs_file_extent_inline_len(path->nodes[0],\n\t\t\t\t\t\t\tpath->slots[0], fi);\n\t\textent_end = ALIGN(key.offset + size,\n\t\t\t\t   sctx->send_root->sectorsize);\n\t} else {\n\t\textent_end = key.offset +\n\t\t\tbtrfs_file_extent_num_bytes(path->nodes[0], fi);\n\t}\n\tsctx->cur_inode_last_extent = extent_end;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "path->nodes[0]",
            "fi"
          ],
          "line": 4936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "key->offset + size",
            "sctx->send_root->sectorsize"
          ],
          "line": 4932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_inline_len",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "fi"
          ],
          "line": 4930
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_file_extent_inline_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3139-3159",
          "snippet": "static inline u32 btrfs_file_extent_inline_len(struct extent_buffer *eb,\n\t\t\t\t\t       int slot,\n\t\t\t\t\t       struct btrfs_file_extent_item *fi)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\t/*\n\t * return the space used on disk if this item isn't\n\t * compressed or encoded\n\t */\n\tif (btrfs_token_file_extent_compression(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_encryption(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_other_encoding(eb, fi, &token) == 0) {\n\t\treturn btrfs_file_extent_inline_item_len(eb,\n\t\t\t\t\t\t\t btrfs_item_nr(slot));\n\t}\n\n\t/* otherwise use the ram bytes field */\n\treturn btrfs_token_file_extent_ram_bytes(eb, fi, &token);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_file_extent_inline_len(struct extent_buffer *eb,\n\t\t\t\t\t       int slot,\n\t\t\t\t\t       struct btrfs_file_extent_item *fi)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\t/*\n\t * return the space used on disk if this item isn't\n\t * compressed or encoded\n\t */\n\tif (btrfs_token_file_extent_compression(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_encryption(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_other_encoding(eb, fi, &token) == 0) {\n\t\treturn btrfs_file_extent_inline_item_len(eb,\n\t\t\t\t\t\t\t btrfs_item_nr(slot));\n\t}\n\n\t/* otherwise use the ram bytes field */\n\treturn btrfs_token_file_extent_ram_bytes(eb, fi, &token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "path->nodes[0]",
            "fi"
          ],
          "line": 4928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 4926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_send_hole",
          "args": [
            "sctx"
          ],
          "line": 4917
        },
        "resolved": true,
        "details": {
          "function_name": "need_send_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "282-287",
          "snippet": "static int need_send_hole(struct send_ctx *sctx)\n{\n\treturn (sctx->parent_root && !sctx->cur_inode_new &&\n\t\t!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted &&\n\t\tS_ISREG(sctx->cur_inode_mode));\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int need_send_hole(struct send_ctx *sctx)\n{\n\treturn (sctx->parent_root && !sctx->cur_inode_new &&\n\t\t!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted &&\n\t\tS_ISREG(sctx->cur_inode_mode));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int maybe_send_hole(struct send_ctx *sctx, struct btrfs_path *path,\n\t\t\t   struct btrfs_key *key)\n{\n\tstruct btrfs_file_extent_item *fi;\n\tu64 extent_end;\n\tu8 type;\n\tint ret = 0;\n\n\tif (sctx->cur_ino != key->objectid || !need_send_hole(sctx))\n\t\treturn 0;\n\n\tif (sctx->cur_inode_last_extent == (u64)-1) {\n\t\tret = get_last_extent(sctx, key->offset - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], fi);\n\tif (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tu64 size = btrfs_file_extent_inline_len(path->nodes[0],\n\t\t\t\t\t\t\tpath->slots[0], fi);\n\t\textent_end = ALIGN(key->offset + size,\n\t\t\t\t   sctx->send_root->sectorsize);\n\t} else {\n\t\textent_end = key->offset +\n\t\t\tbtrfs_file_extent_num_bytes(path->nodes[0], fi);\n\t}\n\n\tif (path->slots[0] == 0 &&\n\t    sctx->cur_inode_last_extent < key->offset) {\n\t\t/*\n\t\t * We might have skipped entire leafs that contained only\n\t\t * file extent items for our current inode. These leafs have\n\t\t * a generation number smaller (older) than the one in the\n\t\t * current leaf and the leaf our last extent came from, and\n\t\t * are located between these 2 leafs.\n\t\t */\n\t\tret = get_last_extent(sctx, key->offset - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (sctx->cur_inode_last_extent < key->offset)\n\t\tret = send_hole(sctx, key->offset);\n\tsctx->cur_inode_last_extent = extent_end;\n\treturn ret;\n}"
  },
  {
    "function_name": "get_last_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4864-4907",
    "snippet": "static int get_last_extent(struct send_ctx *sctx, u64 offset)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = sctx->send_root;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tu64 extent_end;\n\tu8 type;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tsctx->cur_inode_last_extent = 0;\n\n\tkey.objectid = sctx->cur_ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = offset;\n\tret = btrfs_search_slot_for_read(root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\tif (key.objectid != sctx->cur_ino || key.type != BTRFS_EXTENT_DATA_KEY)\n\t\tgoto out;\n\n\tfi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], fi);\n\tif (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tu64 size = btrfs_file_extent_inline_len(path->nodes[0],\n\t\t\t\t\t\t\tpath->slots[0], fi);\n\t\textent_end = ALIGN(key.offset + size,\n\t\t\t\t   sctx->send_root->sectorsize);\n\t} else {\n\t\textent_end = key.offset +\n\t\t\tbtrfs_file_extent_num_bytes(path->nodes[0], fi);\n\t}\n\tsctx->cur_inode_last_extent = extent_end;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 4905
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "path->nodes[0]",
            "fi"
          ],
          "line": 4901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "key.offset + size",
            "sctx->send_root->sectorsize"
          ],
          "line": 4897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_inline_len",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "fi"
          ],
          "line": 4895
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_file_extent_inline_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3139-3159",
          "snippet": "static inline u32 btrfs_file_extent_inline_len(struct extent_buffer *eb,\n\t\t\t\t\t       int slot,\n\t\t\t\t\t       struct btrfs_file_extent_item *fi)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\t/*\n\t * return the space used on disk if this item isn't\n\t * compressed or encoded\n\t */\n\tif (btrfs_token_file_extent_compression(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_encryption(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_other_encoding(eb, fi, &token) == 0) {\n\t\treturn btrfs_file_extent_inline_item_len(eb,\n\t\t\t\t\t\t\t btrfs_item_nr(slot));\n\t}\n\n\t/* otherwise use the ram bytes field */\n\treturn btrfs_token_file_extent_ram_bytes(eb, fi, &token);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_file_extent_inline_len(struct extent_buffer *eb,\n\t\t\t\t\t       int slot,\n\t\t\t\t\t       struct btrfs_file_extent_item *fi)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\t/*\n\t * return the space used on disk if this item isn't\n\t * compressed or encoded\n\t */\n\tif (btrfs_token_file_extent_compression(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_encryption(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_other_encoding(eb, fi, &token) == 0) {\n\t\treturn btrfs_file_extent_inline_item_len(eb,\n\t\t\t\t\t\t\t btrfs_item_nr(slot));\n\t}\n\n\t/* otherwise use the ram bytes field */\n\treturn btrfs_token_file_extent_ram_bytes(eb, fi, &token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "path->nodes[0]",
            "fi"
          ],
          "line": 4893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 4891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "&key",
            "path->slots[0]"
          ],
          "line": 4887
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot_for_read",
          "args": [
            "root",
            "&key",
            "path",
            "0",
            "1"
          ],
          "line": 4883
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot_for_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3057-3119",
          "snippet": "int btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_path_for_send",
          "args": [],
          "line": 4874
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_path_for_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "496-507",
          "snippet": "static struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int get_last_extent(struct send_ctx *sctx, u64 offset)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = sctx->send_root;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tu64 extent_end;\n\tu8 type;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tsctx->cur_inode_last_extent = 0;\n\n\tkey.objectid = sctx->cur_ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = offset;\n\tret = btrfs_search_slot_for_read(root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\tif (key.objectid != sctx->cur_ino || key.type != BTRFS_EXTENT_DATA_KEY)\n\t\tgoto out;\n\n\tfi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], fi);\n\tif (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tu64 size = btrfs_file_extent_inline_len(path->nodes[0],\n\t\t\t\t\t\t\tpath->slots[0], fi);\n\t\textent_end = ALIGN(key.offset + size,\n\t\t\t\t   sctx->send_root->sectorsize);\n\t} else {\n\t\textent_end = key.offset +\n\t\t\tbtrfs_file_extent_num_bytes(path->nodes[0], fi);\n\t}\n\tsctx->cur_inode_last_extent = extent_end;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "is_extent_unchanged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4694-4862",
    "snippet": "static int is_extent_unchanged(struct send_ctx *sctx,\n\t\t\t       struct btrfs_path *left_path,\n\t\t\t       struct btrfs_key *ekey)\n{\n\tint ret = 0;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_file_extent_item *ei;\n\tu64 left_disknr;\n\tu64 right_disknr;\n\tu64 left_offset;\n\tu64 right_offset;\n\tu64 left_offset_fixed;\n\tu64 left_len;\n\tu64 right_len;\n\tu64 left_gen;\n\tu64 right_gen;\n\tu8 left_type;\n\tu8 right_type;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\teb = left_path->nodes[0];\n\tslot = left_path->slots[0];\n\tei = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\tleft_type = btrfs_file_extent_type(eb, ei);\n\n\tif (left_type != BTRFS_FILE_EXTENT_REG) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tleft_disknr = btrfs_file_extent_disk_bytenr(eb, ei);\n\tleft_len = btrfs_file_extent_num_bytes(eb, ei);\n\tleft_offset = btrfs_file_extent_offset(eb, ei);\n\tleft_gen = btrfs_file_extent_generation(eb, ei);\n\n\t/*\n\t * Following comments will refer to these graphics. L is the left\n\t * extents which we are checking at the moment. 1-8 are the right\n\t * extents that we iterate.\n\t *\n\t *       |-----L-----|\n\t * |-1-|-2a-|-3-|-4-|-5-|-6-|\n\t *\n\t *       |-----L-----|\n\t * |--1--|-2b-|...(same as above)\n\t *\n\t * Alternative situation. Happens on files where extents got split.\n\t *       |-----L-----|\n\t * |-----------7-----------|-6-|\n\t *\n\t * Alternative situation. Happens on files which got larger.\n\t *       |-----L-----|\n\t * |-8-|\n\t * Nothing follows after 8.\n\t */\n\n\tkey.objectid = ekey->objectid;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = ekey->offset;\n\tret = btrfs_search_slot_for_read(sctx->parent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Handle special case where the right side has no extents at all.\n\t */\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\tif (found_key.objectid != key.objectid ||\n\t    found_key.type != key.type) {\n\t\t/* If we're a hole then just pretend nothing changed */\n\t\tret = (left_disknr) ? 0 : 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We're now on 2a, 2b or 7.\n\t */\n\tkey = found_key;\n\twhile (key.offset < ekey->offset + left_len) {\n\t\tei = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\t\tright_type = btrfs_file_extent_type(eb, ei);\n\t\tif (right_type != BTRFS_FILE_EXTENT_REG) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tright_disknr = btrfs_file_extent_disk_bytenr(eb, ei);\n\t\tright_len = btrfs_file_extent_num_bytes(eb, ei);\n\t\tright_offset = btrfs_file_extent_offset(eb, ei);\n\t\tright_gen = btrfs_file_extent_generation(eb, ei);\n\n\t\t/*\n\t\t * Are we at extent 8? If yes, we know the extent is changed.\n\t\t * This may only happen on the first iteration.\n\t\t */\n\t\tif (found_key.offset + right_len <= ekey->offset) {\n\t\t\t/* If we're a hole just pretend nothing changed */\n\t\t\tret = (left_disknr) ? 0 : 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tleft_offset_fixed = left_offset;\n\t\tif (key.offset < ekey->offset) {\n\t\t\t/* Fix the right offset for 2a and 7. */\n\t\t\tright_offset += ekey->offset - key.offset;\n\t\t} else {\n\t\t\t/* Fix the left offset for all behind 2a and 2b */\n\t\t\tleft_offset_fixed += key.offset - ekey->offset;\n\t\t}\n\n\t\t/*\n\t\t * Check if we have the same extent.\n\t\t */\n\t\tif (left_disknr != right_disknr ||\n\t\t    left_offset_fixed != right_offset ||\n\t\t    left_gen != right_gen) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Go to the next extent.\n\t\t */\n\t\tret = btrfs_next_item(sctx->parent_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (!ret) {\n\t\t\teb = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\t}\n\t\tif (ret || found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tkey.offset += right_len;\n\t\t\tbreak;\n\t\t}\n\t\tif (found_key.offset != key.offset + right_len) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tkey = found_key;\n\t}\n\n\t/*\n\t * We're now behind the left extent (treat as unchanged) or at the end\n\t * of the right side (treat as changed).\n\t */\n\tif (key.offset >= ekey->offset + left_len)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 4860
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "eb",
            "&found_key",
            "slot"
          ],
          "line": 4835
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_item",
          "args": [
            "sctx->parent_root",
            "path"
          ],
          "line": 4829
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3600-3603",
          "snippet": "static inline int btrfs_next_item(struct btrfs_root *root, struct btrfs_path *p)\n{\n\treturn btrfs_next_old_item(root, p, 0);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_next_item(struct btrfs_root *root, struct btrfs_path *p)\n{\n\treturn btrfs_next_old_item(root, p, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_generation",
          "args": [
            "eb",
            "ei"
          ],
          "line": 4795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_offset",
          "args": [
            "eb",
            "ei"
          ],
          "line": 4794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "eb",
            "ei"
          ],
          "line": 4793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_bytenr",
          "args": [
            "eb",
            "ei"
          ],
          "line": 4792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "eb",
            "ei"
          ],
          "line": 4786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "slot",
            "structbtrfs_file_extent_item"
          ],
          "line": 4785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot_for_read",
          "args": [
            "sctx->parent_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 4759
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot_for_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3057-3119",
          "snippet": "int btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_generation",
          "args": [
            "eb",
            "ei"
          ],
          "line": 4733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_offset",
          "args": [
            "eb",
            "ei"
          ],
          "line": 4732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "eb",
            "ei"
          ],
          "line": 4731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_bytenr",
          "args": [
            "eb",
            "ei"
          ],
          "line": 4730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "eb",
            "ei"
          ],
          "line": 4724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "slot",
            "structbtrfs_file_extent_item"
          ],
          "line": 4723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_path_for_send",
          "args": [],
          "line": 4717
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_path_for_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "496-507",
          "snippet": "static struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_extent_unchanged(struct send_ctx *sctx,\n\t\t\t       struct btrfs_path *left_path,\n\t\t\t       struct btrfs_key *ekey)\n{\n\tint ret = 0;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_file_extent_item *ei;\n\tu64 left_disknr;\n\tu64 right_disknr;\n\tu64 left_offset;\n\tu64 right_offset;\n\tu64 left_offset_fixed;\n\tu64 left_len;\n\tu64 right_len;\n\tu64 left_gen;\n\tu64 right_gen;\n\tu8 left_type;\n\tu8 right_type;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\teb = left_path->nodes[0];\n\tslot = left_path->slots[0];\n\tei = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\tleft_type = btrfs_file_extent_type(eb, ei);\n\n\tif (left_type != BTRFS_FILE_EXTENT_REG) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tleft_disknr = btrfs_file_extent_disk_bytenr(eb, ei);\n\tleft_len = btrfs_file_extent_num_bytes(eb, ei);\n\tleft_offset = btrfs_file_extent_offset(eb, ei);\n\tleft_gen = btrfs_file_extent_generation(eb, ei);\n\n\t/*\n\t * Following comments will refer to these graphics. L is the left\n\t * extents which we are checking at the moment. 1-8 are the right\n\t * extents that we iterate.\n\t *\n\t *       |-----L-----|\n\t * |-1-|-2a-|-3-|-4-|-5-|-6-|\n\t *\n\t *       |-----L-----|\n\t * |--1--|-2b-|...(same as above)\n\t *\n\t * Alternative situation. Happens on files where extents got split.\n\t *       |-----L-----|\n\t * |-----------7-----------|-6-|\n\t *\n\t * Alternative situation. Happens on files which got larger.\n\t *       |-----L-----|\n\t * |-8-|\n\t * Nothing follows after 8.\n\t */\n\n\tkey.objectid = ekey->objectid;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = ekey->offset;\n\tret = btrfs_search_slot_for_read(sctx->parent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Handle special case where the right side has no extents at all.\n\t */\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\tif (found_key.objectid != key.objectid ||\n\t    found_key.type != key.type) {\n\t\t/* If we're a hole then just pretend nothing changed */\n\t\tret = (left_disknr) ? 0 : 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We're now on 2a, 2b or 7.\n\t */\n\tkey = found_key;\n\twhile (key.offset < ekey->offset + left_len) {\n\t\tei = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\t\tright_type = btrfs_file_extent_type(eb, ei);\n\t\tif (right_type != BTRFS_FILE_EXTENT_REG) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tright_disknr = btrfs_file_extent_disk_bytenr(eb, ei);\n\t\tright_len = btrfs_file_extent_num_bytes(eb, ei);\n\t\tright_offset = btrfs_file_extent_offset(eb, ei);\n\t\tright_gen = btrfs_file_extent_generation(eb, ei);\n\n\t\t/*\n\t\t * Are we at extent 8? If yes, we know the extent is changed.\n\t\t * This may only happen on the first iteration.\n\t\t */\n\t\tif (found_key.offset + right_len <= ekey->offset) {\n\t\t\t/* If we're a hole just pretend nothing changed */\n\t\t\tret = (left_disknr) ? 0 : 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tleft_offset_fixed = left_offset;\n\t\tif (key.offset < ekey->offset) {\n\t\t\t/* Fix the right offset for 2a and 7. */\n\t\t\tright_offset += ekey->offset - key.offset;\n\t\t} else {\n\t\t\t/* Fix the left offset for all behind 2a and 2b */\n\t\t\tleft_offset_fixed += key.offset - ekey->offset;\n\t\t}\n\n\t\t/*\n\t\t * Check if we have the same extent.\n\t\t */\n\t\tif (left_disknr != right_disknr ||\n\t\t    left_offset_fixed != right_offset ||\n\t\t    left_gen != right_gen) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Go to the next extent.\n\t\t */\n\t\tret = btrfs_next_item(sctx->parent_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (!ret) {\n\t\t\teb = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\t}\n\t\tif (ret || found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tkey.offset += right_len;\n\t\t\tbreak;\n\t\t}\n\t\tif (found_key.offset != key.offset + right_len) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tkey = found_key;\n\t}\n\n\t/*\n\t * We're now behind the left extent (treat as unchanged) or at the end\n\t * of the right side (treat as changed).\n\t */\n\tif (key.offset >= ekey->offset + left_len)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "send_write_or_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4635-4692",
    "snippet": "static int send_write_or_clone(struct send_ctx *sctx,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       struct btrfs_key *key,\n\t\t\t       struct clone_root *clone_root)\n{\n\tint ret = 0;\n\tstruct btrfs_file_extent_item *ei;\n\tu64 offset = key->offset;\n\tu64 pos = 0;\n\tu64 len;\n\tu32 l;\n\tu8 type;\n\tu64 bs = sctx->send_root->fs_info->sb->s_blocksize;\n\n\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\tstruct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], ei);\n\tif (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tlen = btrfs_file_extent_inline_len(path->nodes[0],\n\t\t\t\t\t\t   path->slots[0], ei);\n\t\t/*\n\t\t * it is possible the inline item won't cover the whole page,\n\t\t * but there may be items after this page.  Make\n\t\t * sure to send the whole thing\n\t\t */\n\t\tlen = PAGE_CACHE_ALIGN(len);\n\t} else {\n\t\tlen = btrfs_file_extent_num_bytes(path->nodes[0], ei);\n\t}\n\n\tif (offset + len > sctx->cur_inode_size)\n\t\tlen = sctx->cur_inode_size - offset;\n\tif (len == 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (clone_root && IS_ALIGNED(offset + len, bs)) {\n\t\tret = send_clone(sctx, offset, len, clone_root);\n\t} else if (sctx->flags & BTRFS_SEND_FLAG_NO_FILE_DATA) {\n\t\tret = send_update_extent(sctx, offset, len);\n\t} else {\n\t\twhile (pos < len) {\n\t\t\tl = len - pos;\n\t\t\tif (l > BTRFS_SEND_READ_SIZE)\n\t\t\t\tl = BTRFS_SEND_READ_SIZE;\n\t\t\tret = send_write(sctx, pos + offset, l);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret)\n\t\t\t\tbreak;\n\t\t\tpos += ret;\n\t\t}\n\t\tret = 0;\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_write",
          "args": [
            "sctx",
            "pos + offset",
            "l"
          ],
          "line": 4681
        },
        "resolved": true,
        "details": {
          "function_name": "send_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4468-4507",
          "snippet": "static int send_write(struct send_ctx *sctx, u64 offset, u32 len)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\tssize_t num_read = 0;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\nverbose_printk(\"btrfs: send_write offset=%llu, len=%d\\n\", offset, len);\n\n\tnum_read = fill_read_buf(sctx, offset, len);\n\tif (num_read <= 0) {\n\t\tif (num_read < 0)\n\t\t\tret = num_read;\n\t\tgoto out;\n\t}\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_WRITE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tTLV_PUT(sctx, BTRFS_SEND_A_DATA, sctx->read_buf, num_read);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn num_read;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_write(struct send_ctx *sctx, u64 offset, u32 len)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\tssize_t num_read = 0;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\nverbose_printk(\"btrfs: send_write offset=%llu, len=%d\\n\", offset, len);\n\n\tnum_read = fill_read_buf(sctx, offset, len);\n\tif (num_read <= 0) {\n\t\tif (num_read < 0)\n\t\t\tret = num_read;\n\t\tgoto out;\n\t}\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_WRITE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tTLV_PUT(sctx, BTRFS_SEND_A_DATA, sctx->read_buf, num_read);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn num_read;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_update_extent",
          "args": [
            "sctx",
            "offset",
            "len"
          ],
          "line": 4675
        },
        "resolved": true,
        "details": {
          "function_name": "send_update_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4572-4600",
          "snippet": "static int send_update_extent(struct send_ctx *sctx,\n\t\t\t      u64 offset, u32 len)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UPDATE_EXTENT);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_SIZE, len);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_update_extent(struct send_ctx *sctx,\n\t\t\t      u64 offset, u32 len)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UPDATE_EXTENT);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_SIZE, len);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_clone",
          "args": [
            "sctx",
            "offset",
            "len",
            "clone_root"
          ],
          "line": 4673
        },
        "resolved": true,
        "details": {
          "function_name": "send_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4512-4567",
          "snippet": "static int send_clone(struct send_ctx *sctx,\n\t\t      u64 offset, u32 len,\n\t\t      struct clone_root *clone_root)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\tu64 gen;\n\nverbose_printk(\"btrfs: send_clone offset=%llu, len=%d, clone_root=%llu, \"\n\t       \"clone_inode=%llu, clone_offset=%llu\\n\", offset, len,\n\t\tclone_root->root->objectid, clone_root->ino,\n\t\tclone_root->offset);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CLONE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_LEN, len);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\n\tif (clone_root->root == sctx->send_root) {\n\t\tret = get_inode_info(sctx->send_root, clone_root->ino, NULL,\n\t\t\t\t&gen, NULL, NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = get_cur_path(sctx, clone_root->ino, gen, p);\n\t} else {\n\t\tret = get_inode_path(clone_root->root, clone_root->ino, p);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_CLONE_UUID,\n\t\t\tclone_root->root->root_item.uuid);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_CTRANSID,\n\t\t    le64_to_cpu(clone_root->root->root_item.ctransid));\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_CLONE_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_OFFSET,\n\t\t\tclone_root->offset);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int send_clone(struct send_ctx *sctx,\n\t\t      u64 offset, u32 len,\n\t\t      struct clone_root *clone_root)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\tu64 gen;\n\nverbose_printk(\"btrfs: send_clone offset=%llu, len=%d, clone_root=%llu, \"\n\t       \"clone_inode=%llu, clone_offset=%llu\\n\", offset, len,\n\t\tclone_root->root->objectid, clone_root->ino,\n\t\tclone_root->offset);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CLONE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_LEN, len);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\n\tif (clone_root->root == sctx->send_root) {\n\t\tret = get_inode_info(sctx->send_root, clone_root->ino, NULL,\n\t\t\t\t&gen, NULL, NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = get_cur_path(sctx, clone_root->ino, gen, p);\n\t} else {\n\t\tret = get_inode_path(clone_root->root, clone_root->ino, p);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_CLONE_UUID,\n\t\t\tclone_root->root->root_item.uuid);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_CTRANSID,\n\t\t    le64_to_cpu(clone_root->root->root_item.ctransid));\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_CLONE_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_OFFSET,\n\t\t\tclone_root->offset);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "offset + len",
            "bs"
          ],
          "line": 4672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "path->nodes[0]",
            "ei"
          ],
          "line": 4662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_CACHE_ALIGN",
          "args": [
            "len"
          ],
          "line": 4660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_inline_len",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "ei"
          ],
          "line": 4653
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_file_extent_inline_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3139-3159",
          "snippet": "static inline u32 btrfs_file_extent_inline_len(struct extent_buffer *eb,\n\t\t\t\t\t       int slot,\n\t\t\t\t\t       struct btrfs_file_extent_item *fi)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\t/*\n\t * return the space used on disk if this item isn't\n\t * compressed or encoded\n\t */\n\tif (btrfs_token_file_extent_compression(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_encryption(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_other_encoding(eb, fi, &token) == 0) {\n\t\treturn btrfs_file_extent_inline_item_len(eb,\n\t\t\t\t\t\t\t btrfs_item_nr(slot));\n\t}\n\n\t/* otherwise use the ram bytes field */\n\treturn btrfs_token_file_extent_ram_bytes(eb, fi, &token);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_file_extent_inline_len(struct extent_buffer *eb,\n\t\t\t\t\t       int slot,\n\t\t\t\t\t       struct btrfs_file_extent_item *fi)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\t/*\n\t * return the space used on disk if this item isn't\n\t * compressed or encoded\n\t */\n\tif (btrfs_token_file_extent_compression(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_encryption(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_other_encoding(eb, fi, &token) == 0) {\n\t\treturn btrfs_file_extent_inline_item_len(eb,\n\t\t\t\t\t\t\t btrfs_item_nr(slot));\n\t}\n\n\t/* otherwise use the ram bytes field */\n\treturn btrfs_token_file_extent_ram_bytes(eb, fi, &token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "path->nodes[0]",
            "ei"
          ],
          "line": 4651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 4649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_write_or_clone(struct send_ctx *sctx,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       struct btrfs_key *key,\n\t\t\t       struct clone_root *clone_root)\n{\n\tint ret = 0;\n\tstruct btrfs_file_extent_item *ei;\n\tu64 offset = key->offset;\n\tu64 pos = 0;\n\tu64 len;\n\tu32 l;\n\tu8 type;\n\tu64 bs = sctx->send_root->fs_info->sb->s_blocksize;\n\n\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\tstruct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], ei);\n\tif (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tlen = btrfs_file_extent_inline_len(path->nodes[0],\n\t\t\t\t\t\t   path->slots[0], ei);\n\t\t/*\n\t\t * it is possible the inline item won't cover the whole page,\n\t\t * but there may be items after this page.  Make\n\t\t * sure to send the whole thing\n\t\t */\n\t\tlen = PAGE_CACHE_ALIGN(len);\n\t} else {\n\t\tlen = btrfs_file_extent_num_bytes(path->nodes[0], ei);\n\t}\n\n\tif (offset + len > sctx->cur_inode_size)\n\t\tlen = sctx->cur_inode_size - offset;\n\tif (len == 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (clone_root && IS_ALIGNED(offset + len, bs)) {\n\t\tret = send_clone(sctx, offset, len, clone_root);\n\t} else if (sctx->flags & BTRFS_SEND_FLAG_NO_FILE_DATA) {\n\t\tret = send_update_extent(sctx, offset, len);\n\t} else {\n\t\twhile (pos < len) {\n\t\t\tl = len - pos;\n\t\t\tif (l > BTRFS_SEND_READ_SIZE)\n\t\t\t\tl = BTRFS_SEND_READ_SIZE;\n\t\t\tret = send_write(sctx, pos + offset, l);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret)\n\t\t\t\tbreak;\n\t\t\tpos += ret;\n\t\t}\n\t\tret = 0;\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "send_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4602-4633",
    "snippet": "static int send_hole(struct send_ctx *sctx, u64 end)\n{\n\tstruct fs_path *p = NULL;\n\tu64 offset = sctx->cur_inode_last_extent;\n\tu64 len;\n\tint ret = 0;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto tlv_put_failure;\n\tmemset(sctx->read_buf, 0, BTRFS_SEND_READ_SIZE);\n\twhile (offset < end) {\n\t\tlen = min_t(u64, end - offset, BTRFS_SEND_READ_SIZE);\n\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_WRITE);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\t\tTLV_PUT(sctx, BTRFS_SEND_A_DATA, sctx->read_buf, len);\n\t\tret = send_cmd(sctx);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\toffset += len;\n\t}\ntlv_put_failure:\n\tfs_path_free(p);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "p"
          ],
          "line": 4631
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_cmd",
          "args": [
            "sctx"
          ],
          "line": 4625
        },
        "resolved": true,
        "details": {
          "function_name": "send_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "667-688",
          "snippet": "static int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TLV_PUT",
          "args": [
            "sctx",
            "BTRFS_SEND_A_DATA",
            "sctx->read_buf",
            "len"
          ],
          "line": 4624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_U64",
          "args": [
            "sctx",
            "BTRFS_SEND_A_FILE_OFFSET",
            "offset"
          ],
          "line": 4623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_PATH",
          "args": [
            "sctx",
            "BTRFS_SEND_A_PATH",
            "p"
          ],
          "line": 4622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_cmd",
          "args": [
            "sctx",
            "BTRFS_SEND_C_WRITE"
          ],
          "line": 4619
        },
        "resolved": true,
        "details": {
          "function_name": "begin_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "651-665",
          "snippet": "static int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "end - offset",
            "BTRFS_SEND_READ_SIZE"
          ],
          "line": 4617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sctx->read_buf",
            "0",
            "BTRFS_SEND_READ_SIZE"
          ],
          "line": 4615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cur_path",
          "args": [
            "sctx",
            "sctx->cur_ino",
            "sctx->cur_inode_gen",
            "p"
          ],
          "line": 4612
        },
        "resolved": true,
        "details": {
          "function_name": "get_cur_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2207-2263",
          "snippet": "static int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 4609
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_hole(struct send_ctx *sctx, u64 end)\n{\n\tstruct fs_path *p = NULL;\n\tu64 offset = sctx->cur_inode_last_extent;\n\tu64 len;\n\tint ret = 0;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto tlv_put_failure;\n\tmemset(sctx->read_buf, 0, BTRFS_SEND_READ_SIZE);\n\twhile (offset < end) {\n\t\tlen = min_t(u64, end - offset, BTRFS_SEND_READ_SIZE);\n\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_WRITE);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\t\tTLV_PUT(sctx, BTRFS_SEND_A_DATA, sctx->read_buf, len);\n\t\tret = send_cmd(sctx);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\toffset += len;\n\t}\ntlv_put_failure:\n\tfs_path_free(p);\n\treturn ret;\n}"
  },
  {
    "function_name": "send_update_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4572-4600",
    "snippet": "static int send_update_extent(struct send_ctx *sctx,\n\t\t\t      u64 offset, u32 len)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UPDATE_EXTENT);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_SIZE, len);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "p"
          ],
          "line": 4598
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_cmd",
          "args": [
            "sctx"
          ],
          "line": 4594
        },
        "resolved": true,
        "details": {
          "function_name": "send_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "667-688",
          "snippet": "static int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TLV_PUT_U64",
          "args": [
            "sctx",
            "BTRFS_SEND_A_SIZE",
            "len"
          ],
          "line": 4592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_U64",
          "args": [
            "sctx",
            "BTRFS_SEND_A_FILE_OFFSET",
            "offset"
          ],
          "line": 4591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_PATH",
          "args": [
            "sctx",
            "BTRFS_SEND_A_PATH",
            "p"
          ],
          "line": 4590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cur_path",
          "args": [
            "sctx",
            "sctx->cur_ino",
            "sctx->cur_inode_gen",
            "p"
          ],
          "line": 4586
        },
        "resolved": true,
        "details": {
          "function_name": "get_cur_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2207-2263",
          "snippet": "static int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_cmd",
          "args": [
            "sctx",
            "BTRFS_SEND_C_UPDATE_EXTENT"
          ],
          "line": 4582
        },
        "resolved": true,
        "details": {
          "function_name": "begin_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "651-665",
          "snippet": "static int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 4578
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_update_extent(struct send_ctx *sctx,\n\t\t\t      u64 offset, u32 len)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UPDATE_EXTENT);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_SIZE, len);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}"
  },
  {
    "function_name": "send_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4512-4567",
    "snippet": "static int send_clone(struct send_ctx *sctx,\n\t\t      u64 offset, u32 len,\n\t\t      struct clone_root *clone_root)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\tu64 gen;\n\nverbose_printk(\"btrfs: send_clone offset=%llu, len=%d, clone_root=%llu, \"\n\t       \"clone_inode=%llu, clone_offset=%llu\\n\", offset, len,\n\t\tclone_root->root->objectid, clone_root->ino,\n\t\tclone_root->offset);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CLONE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_LEN, len);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\n\tif (clone_root->root == sctx->send_root) {\n\t\tret = get_inode_info(sctx->send_root, clone_root->ino, NULL,\n\t\t\t\t&gen, NULL, NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = get_cur_path(sctx, clone_root->ino, gen, p);\n\t} else {\n\t\tret = get_inode_path(clone_root->root, clone_root->ino, p);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_CLONE_UUID,\n\t\t\tclone_root->root->root_item.uuid);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_CTRANSID,\n\t\t    le64_to_cpu(clone_root->root->root_item.ctransid));\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_CLONE_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_OFFSET,\n\t\t\tclone_root->offset);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "p"
          ],
          "line": 4565
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_cmd",
          "args": [
            "sctx"
          ],
          "line": 4561
        },
        "resolved": true,
        "details": {
          "function_name": "send_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "667-688",
          "snippet": "static int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TLV_PUT_U64",
          "args": [
            "sctx",
            "BTRFS_SEND_A_CLONE_OFFSET",
            "clone_root->offset"
          ],
          "line": 4558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_PATH",
          "args": [
            "sctx",
            "BTRFS_SEND_A_CLONE_PATH",
            "p"
          ],
          "line": 4557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_U64",
          "args": [
            "sctx",
            "BTRFS_SEND_A_CLONE_CTRANSID",
            "le64_to_cpu(clone_root->root->root_item.ctransid)"
          ],
          "line": 4555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "clone_root->root->root_item.ctransid"
          ],
          "line": 4556
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TLV_PUT_UUID",
          "args": [
            "sctx",
            "BTRFS_SEND_A_CLONE_UUID",
            "clone_root->root->root_item.uuid"
          ],
          "line": 4553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_inode_path",
          "args": [
            "clone_root->root",
            "clone_root->ino",
            "p"
          ],
          "line": 4548
        },
        "resolved": true,
        "details": {
          "function_name": "get_inode_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1101-1142",
          "snippet": "static int get_inode_path(struct btrfs_root *root,\n\t\t\t  u64 ino, struct fs_path *path)\n{\n\tint ret;\n\tstruct btrfs_key key, found_key;\n\tstruct btrfs_path *p;\n\n\tp = alloc_path_for_send();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tfs_path_reset(path);\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, p, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\tbtrfs_item_key_to_cpu(p->nodes[0], &found_key, p->slots[0]);\n\tif (found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = iterate_inode_ref(root, p, &found_key, 1,\n\t\t\t\t__copy_first_ref, path);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\tbtrfs_free_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_inode_path(struct btrfs_root *root,\n\t\t\t  u64 ino, struct fs_path *path)\n{\n\tint ret;\n\tstruct btrfs_key key, found_key;\n\tstruct btrfs_path *p;\n\n\tp = alloc_path_for_send();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tfs_path_reset(path);\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, p, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\tbtrfs_item_key_to_cpu(p->nodes[0], &found_key, p->slots[0]);\n\tif (found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = iterate_inode_ref(root, p, &found_key, 1,\n\t\t\t\t__copy_first_ref, path);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\tbtrfs_free_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cur_path",
          "args": [
            "sctx",
            "clone_root->ino",
            "gen",
            "p"
          ],
          "line": 4546
        },
        "resolved": true,
        "details": {
          "function_name": "get_cur_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2207-2263",
          "snippet": "static int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode_info",
          "args": [
            "sctx->send_root",
            "clone_root->ino",
            "NULL",
            "&gen",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 4542
        },
        "resolved": true,
        "details": {
          "function_name": "get_inode_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "821-836",
          "snippet": "static int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TLV_PUT_PATH",
          "args": [
            "sctx",
            "BTRFS_SEND_A_PATH",
            "p"
          ],
          "line": 4539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_U64",
          "args": [
            "sctx",
            "BTRFS_SEND_A_CLONE_LEN",
            "len"
          ],
          "line": 4538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_U64",
          "args": [
            "sctx",
            "BTRFS_SEND_A_FILE_OFFSET",
            "offset"
          ],
          "line": 4537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_cmd",
          "args": [
            "sctx",
            "BTRFS_SEND_C_CLONE"
          ],
          "line": 4529
        },
        "resolved": true,
        "details": {
          "function_name": "begin_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "651-665",
          "snippet": "static int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 4525
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose_printk",
          "args": [
            "\"btrfs: send_clone offset=%llu, len=%d, clone_root=%llu, \"\n\t       \"clone_inode=%llu, clone_offset=%llu\\n\"",
            "offset",
            "len",
            "clone_root->root->objectid",
            "clone_root->ino",
            "clone_root->offset"
          ],
          "line": 4520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int send_clone(struct send_ctx *sctx,\n\t\t      u64 offset, u32 len,\n\t\t      struct clone_root *clone_root)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\tu64 gen;\n\nverbose_printk(\"btrfs: send_clone offset=%llu, len=%d, clone_root=%llu, \"\n\t       \"clone_inode=%llu, clone_offset=%llu\\n\", offset, len,\n\t\tclone_root->root->objectid, clone_root->ino,\n\t\tclone_root->offset);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CLONE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_LEN, len);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\n\tif (clone_root->root == sctx->send_root) {\n\t\tret = get_inode_info(sctx->send_root, clone_root->ino, NULL,\n\t\t\t\t&gen, NULL, NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = get_cur_path(sctx, clone_root->ino, gen, p);\n\t} else {\n\t\tret = get_inode_path(clone_root->root, clone_root->ino, p);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_CLONE_UUID,\n\t\t\tclone_root->root->root_item.uuid);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_CTRANSID,\n\t\t    le64_to_cpu(clone_root->root->root_item.ctransid));\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_CLONE_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_OFFSET,\n\t\t\tclone_root->offset);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}"
  },
  {
    "function_name": "send_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4468-4507",
    "snippet": "static int send_write(struct send_ctx *sctx, u64 offset, u32 len)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\tssize_t num_read = 0;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\nverbose_printk(\"btrfs: send_write offset=%llu, len=%d\\n\", offset, len);\n\n\tnum_read = fill_read_buf(sctx, offset, len);\n\tif (num_read <= 0) {\n\t\tif (num_read < 0)\n\t\t\tret = num_read;\n\t\tgoto out;\n\t}\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_WRITE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tTLV_PUT(sctx, BTRFS_SEND_A_DATA, sctx->read_buf, num_read);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn num_read;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "p"
          ],
          "line": 4503
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_cmd",
          "args": [
            "sctx"
          ],
          "line": 4499
        },
        "resolved": true,
        "details": {
          "function_name": "send_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "667-688",
          "snippet": "static int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TLV_PUT",
          "args": [
            "sctx",
            "BTRFS_SEND_A_DATA",
            "sctx->read_buf",
            "num_read"
          ],
          "line": 4497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_U64",
          "args": [
            "sctx",
            "BTRFS_SEND_A_FILE_OFFSET",
            "offset"
          ],
          "line": 4496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_PATH",
          "args": [
            "sctx",
            "BTRFS_SEND_A_PATH",
            "p"
          ],
          "line": 4495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cur_path",
          "args": [
            "sctx",
            "sctx->cur_ino",
            "sctx->cur_inode_gen",
            "p"
          ],
          "line": 4491
        },
        "resolved": true,
        "details": {
          "function_name": "get_cur_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2207-2263",
          "snippet": "static int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_cmd",
          "args": [
            "sctx",
            "BTRFS_SEND_C_WRITE"
          ],
          "line": 4487
        },
        "resolved": true,
        "details": {
          "function_name": "begin_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "651-665",
          "snippet": "static int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_read_buf",
          "args": [
            "sctx",
            "offset",
            "len"
          ],
          "line": 4480
        },
        "resolved": true,
        "details": {
          "function_name": "fill_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4391-4462",
          "snippet": "static ssize_t fill_read_buf(struct send_ctx *sctx, u64 offset, u32 len)\n{\n\tstruct btrfs_root *root = sctx->send_root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct inode *inode;\n\tstruct page *page;\n\tchar *addr;\n\tstruct btrfs_key key;\n\tpgoff_t index = offset >> PAGE_CACHE_SHIFT;\n\tpgoff_t last_index;\n\tunsigned pg_offset = offset & ~PAGE_CACHE_MASK;\n\tssize_t ret = 0;\n\n\tkey.objectid = sctx->cur_ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tinode = btrfs_iget(fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (offset + len > i_size_read(inode)) {\n\t\tif (offset > i_size_read(inode))\n\t\t\tlen = 0;\n\t\telse\n\t\t\tlen = offset - i_size_read(inode);\n\t}\n\tif (len == 0)\n\t\tgoto out;\n\n\tlast_index = (offset + len - 1) >> PAGE_CACHE_SHIFT;\n\n\t/* initial readahead */\n\tmemset(&sctx->ra, 0, sizeof(struct file_ra_state));\n\tfile_ra_state_init(&sctx->ra, inode->i_mapping);\n\tbtrfs_force_ra(inode->i_mapping, &sctx->ra, NULL, index,\n\t\t       last_index - index + 1);\n\n\twhile (index <= last_index) {\n\t\tunsigned cur_len = min_t(unsigned, len,\n\t\t\t\t\t PAGE_CACHE_SIZE - pg_offset);\n\t\tpage = find_or_create_page(inode->i_mapping, index, GFP_NOFS);\n\t\tif (!page) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\taddr = kmap(page);\n\t\tmemcpy(sctx->read_buf + ret, addr + pg_offset, cur_len);\n\t\tkunmap(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tindex++;\n\t\tpg_offset = 0;\n\t\tlen -= cur_len;\n\t\tret += cur_len;\n\t}\nout:\n\tiput(inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic ssize_t fill_read_buf(struct send_ctx *sctx, u64 offset, u32 len)\n{\n\tstruct btrfs_root *root = sctx->send_root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct inode *inode;\n\tstruct page *page;\n\tchar *addr;\n\tstruct btrfs_key key;\n\tpgoff_t index = offset >> PAGE_CACHE_SHIFT;\n\tpgoff_t last_index;\n\tunsigned pg_offset = offset & ~PAGE_CACHE_MASK;\n\tssize_t ret = 0;\n\n\tkey.objectid = sctx->cur_ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tinode = btrfs_iget(fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (offset + len > i_size_read(inode)) {\n\t\tif (offset > i_size_read(inode))\n\t\t\tlen = 0;\n\t\telse\n\t\t\tlen = offset - i_size_read(inode);\n\t}\n\tif (len == 0)\n\t\tgoto out;\n\n\tlast_index = (offset + len - 1) >> PAGE_CACHE_SHIFT;\n\n\t/* initial readahead */\n\tmemset(&sctx->ra, 0, sizeof(struct file_ra_state));\n\tfile_ra_state_init(&sctx->ra, inode->i_mapping);\n\tbtrfs_force_ra(inode->i_mapping, &sctx->ra, NULL, index,\n\t\t       last_index - index + 1);\n\n\twhile (index <= last_index) {\n\t\tunsigned cur_len = min_t(unsigned, len,\n\t\t\t\t\t PAGE_CACHE_SIZE - pg_offset);\n\t\tpage = find_or_create_page(inode->i_mapping, index, GFP_NOFS);\n\t\tif (!page) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\taddr = kmap(page);\n\t\tmemcpy(sctx->read_buf + ret, addr + pg_offset, cur_len);\n\t\tkunmap(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tindex++;\n\t\tpg_offset = 0;\n\t\tlen -= cur_len;\n\t\tret += cur_len;\n\t}\nout:\n\tiput(inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose_printk",
          "args": [
            "\"btrfs: send_write offset=%llu, len=%d\\n\"",
            "offset",
            "len"
          ],
          "line": 4478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 4474
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_write(struct send_ctx *sctx, u64 offset, u32 len)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\tssize_t num_read = 0;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\nverbose_printk(\"btrfs: send_write offset=%llu, len=%d\\n\", offset, len);\n\n\tnum_read = fill_read_buf(sctx, offset, len);\n\tif (num_read <= 0) {\n\t\tif (num_read < 0)\n\t\t\tret = num_read;\n\t\tgoto out;\n\t}\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_WRITE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tTLV_PUT(sctx, BTRFS_SEND_A_DATA, sctx->read_buf, num_read);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn num_read;\n}"
  },
  {
    "function_name": "fill_read_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4391-4462",
    "snippet": "static ssize_t fill_read_buf(struct send_ctx *sctx, u64 offset, u32 len)\n{\n\tstruct btrfs_root *root = sctx->send_root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct inode *inode;\n\tstruct page *page;\n\tchar *addr;\n\tstruct btrfs_key key;\n\tpgoff_t index = offset >> PAGE_CACHE_SHIFT;\n\tpgoff_t last_index;\n\tunsigned pg_offset = offset & ~PAGE_CACHE_MASK;\n\tssize_t ret = 0;\n\n\tkey.objectid = sctx->cur_ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tinode = btrfs_iget(fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (offset + len > i_size_read(inode)) {\n\t\tif (offset > i_size_read(inode))\n\t\t\tlen = 0;\n\t\telse\n\t\t\tlen = offset - i_size_read(inode);\n\t}\n\tif (len == 0)\n\t\tgoto out;\n\n\tlast_index = (offset + len - 1) >> PAGE_CACHE_SHIFT;\n\n\t/* initial readahead */\n\tmemset(&sctx->ra, 0, sizeof(struct file_ra_state));\n\tfile_ra_state_init(&sctx->ra, inode->i_mapping);\n\tbtrfs_force_ra(inode->i_mapping, &sctx->ra, NULL, index,\n\t\t       last_index - index + 1);\n\n\twhile (index <= last_index) {\n\t\tunsigned cur_len = min_t(unsigned, len,\n\t\t\t\t\t PAGE_CACHE_SIZE - pg_offset);\n\t\tpage = find_or_create_page(inode->i_mapping, index, GFP_NOFS);\n\t\tif (!page) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\taddr = kmap(page);\n\t\tmemcpy(sctx->read_buf + ret, addr + pg_offset, cur_len);\n\t\tkunmap(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tindex++;\n\t\tpg_offset = 0;\n\t\tlen -= cur_len;\n\t\tret += cur_len;\n\t}\nout:\n\tiput(inode);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 4460
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 4453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 4452
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 4451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sctx->read_buf + ret",
            "addr + pg_offset",
            "cur_len"
          ],
          "line": 4450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 4449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 4443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 4441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_readpage",
          "args": [
            "NULL",
            "page"
          ],
          "line": 4439
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "8212-8217",
          "snippet": "int btrfs_readpage(struct file *file, struct page *page)\n{\n\tstruct extent_io_tree *tree;\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\treturn extent_read_full_page(tree, page, btrfs_get_extent, 0);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_readpage(struct file *file, struct page *page)\n{\n\tstruct extent_io_tree *tree;\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\treturn extent_read_full_page(tree, page, btrfs_get_extent, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 4438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "inode->i_mapping",
            "index",
            "GFP_NOFS"
          ],
          "line": 4432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsigned",
            "len",
            "PAGE_CACHE_SIZE - pg_offset"
          ],
          "line": 4430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_force_ra",
          "args": [
            "inode->i_mapping",
            "&sctx->ra",
            "NULL",
            "index",
            "last_index - index + 1"
          ],
          "line": 4426
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_force_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3838-3843",
          "snippet": "static inline void btrfs_force_ra(struct address_space *mapping,\n\t\t\t\t  struct file_ra_state *ra, struct file *file,\n\t\t\t\t  pgoff_t offset, unsigned long req_size)\n{\n\tpage_cache_sync_readahead(mapping, ra, file, offset, req_size);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_force_ra(struct address_space *mapping,\n\t\t\t\t  struct file_ra_state *ra, struct file *file,\n\t\t\t\t  pgoff_t offset, unsigned long req_size)\n{\n\tpage_cache_sync_readahead(mapping, ra, file, offset, req_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_ra_state_init",
          "args": [
            "&sctx->ra",
            "inode->i_mapping"
          ],
          "line": 4425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sctx->ra",
            "0",
            "sizeof(struct file_ra_state)"
          ],
          "line": 4424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 4416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 4413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 4412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 4410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 4409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_iget",
          "args": [
            "fs_info->sb",
            "&key",
            "root",
            "NULL"
          ],
          "line": 4408
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "5312-5336",
          "snippet": "struct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic ssize_t fill_read_buf(struct send_ctx *sctx, u64 offset, u32 len)\n{\n\tstruct btrfs_root *root = sctx->send_root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct inode *inode;\n\tstruct page *page;\n\tchar *addr;\n\tstruct btrfs_key key;\n\tpgoff_t index = offset >> PAGE_CACHE_SHIFT;\n\tpgoff_t last_index;\n\tunsigned pg_offset = offset & ~PAGE_CACHE_MASK;\n\tssize_t ret = 0;\n\n\tkey.objectid = sctx->cur_ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tinode = btrfs_iget(fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (offset + len > i_size_read(inode)) {\n\t\tif (offset > i_size_read(inode))\n\t\t\tlen = 0;\n\t\telse\n\t\t\tlen = offset - i_size_read(inode);\n\t}\n\tif (len == 0)\n\t\tgoto out;\n\n\tlast_index = (offset + len - 1) >> PAGE_CACHE_SHIFT;\n\n\t/* initial readahead */\n\tmemset(&sctx->ra, 0, sizeof(struct file_ra_state));\n\tfile_ra_state_init(&sctx->ra, inode->i_mapping);\n\tbtrfs_force_ra(inode->i_mapping, &sctx->ra, NULL, index,\n\t\t       last_index - index + 1);\n\n\twhile (index <= last_index) {\n\t\tunsigned cur_len = min_t(unsigned, len,\n\t\t\t\t\t PAGE_CACHE_SIZE - pg_offset);\n\t\tpage = find_or_create_page(inode->i_mapping, index, GFP_NOFS);\n\t\tif (!page) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\taddr = kmap(page);\n\t\tmemcpy(sctx->read_buf + ret, addr + pg_offset, cur_len);\n\t\tkunmap(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tindex++;\n\t\tpg_offset = 0;\n\t\tlen -= cur_len;\n\t\tret += cur_len;\n\t}\nout:\n\tiput(inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "process_all_new_xattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4334-4389",
    "snippet": "static int process_all_new_xattrs(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\troot = sctx->send_root;\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = iterate_dir_item(root, path, &found_key,\n\t\t\t\t       __process_new_xattr, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tpath->slots[0]++;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 4387
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_dir_item",
          "args": [
            "root",
            "path",
            "&found_key",
            "__process_new_xattr",
            "sctx"
          ],
          "line": 4378
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "970-1081",
          "snippet": "static int iterate_dir_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *found_key,\n\t\t\t    iterate_dir_item_t iterate, void *ctx)\n{\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key di_key;\n\tchar *buf = NULL;\n\tint buf_len;\n\tu32 name_len;\n\tu32 data_len;\n\tu32 cur;\n\tu32 len;\n\tu32 total;\n\tint slot;\n\tint num;\n\tu8 type;\n\n\t/*\n\t * Start with a small buffer (1 page). If later we end up needing more\n\t * space, which can happen for xattrs on a fs with a leaf size greater\n\t * then the page size, attempt to increase the buffer. Typically xattr\n\t * values are small.\n\t */\n\tbuf_len = PATH_MAX;\n\tbuf = kmalloc(buf_len, GFP_NOFS);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem = btrfs_item_nr(slot);\n\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\tcur = 0;\n\tlen = 0;\n\ttotal = btrfs_item_size(eb, item);\n\n\tnum = 0;\n\twhile (cur < total) {\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tdata_len = btrfs_dir_data_len(eb, di);\n\t\ttype = btrfs_dir_type(eb, di);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (type == BTRFS_FT_XATTR) {\n\t\t\tif (name_len > XATTR_NAME_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (name_len + data_len > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Path too long\n\t\t\t */\n\t\t\tif (name_len + data_len > PATH_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (name_len + data_len > buf_len) {\n\t\t\tbuf_len = name_len + data_len;\n\t\t\tif (is_vmalloc_addr(buf)) {\n\t\t\t\tvfree(buf);\n\t\t\t\tbuf = NULL;\n\t\t\t} else {\n\t\t\t\tchar *tmp = krealloc(buf, buf_len,\n\t\t\t\t\t\t     GFP_NOFS | __GFP_NOWARN);\n\n\t\t\t\tif (!tmp)\n\t\t\t\t\tkfree(buf);\n\t\t\t\tbuf = tmp;\n\t\t\t}\n\t\t\tif (!buf) {\n\t\t\t\tbuf = vmalloc(buf_len);\n\t\t\t\tif (!buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tread_extent_buffer(eb, buf, (unsigned long)(di + 1),\n\t\t\t\tname_len + data_len);\n\n\t\tlen = sizeof(*di) + name_len + data_len;\n\t\tdi = (struct btrfs_dir_item *)((char *)di + len);\n\t\tcur += len;\n\n\t\tret = iterate(num, &di_key, buf, name_len, buf + name_len,\n\t\t\t\tdata_len, type, ctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum++;\n\t}\n\nout:\n\tkvfree(buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int iterate_dir_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *found_key,\n\t\t\t    iterate_dir_item_t iterate, void *ctx)\n{\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key di_key;\n\tchar *buf = NULL;\n\tint buf_len;\n\tu32 name_len;\n\tu32 data_len;\n\tu32 cur;\n\tu32 len;\n\tu32 total;\n\tint slot;\n\tint num;\n\tu8 type;\n\n\t/*\n\t * Start with a small buffer (1 page). If later we end up needing more\n\t * space, which can happen for xattrs on a fs with a leaf size greater\n\t * then the page size, attempt to increase the buffer. Typically xattr\n\t * values are small.\n\t */\n\tbuf_len = PATH_MAX;\n\tbuf = kmalloc(buf_len, GFP_NOFS);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem = btrfs_item_nr(slot);\n\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\tcur = 0;\n\tlen = 0;\n\ttotal = btrfs_item_size(eb, item);\n\n\tnum = 0;\n\twhile (cur < total) {\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tdata_len = btrfs_dir_data_len(eb, di);\n\t\ttype = btrfs_dir_type(eb, di);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (type == BTRFS_FT_XATTR) {\n\t\t\tif (name_len > XATTR_NAME_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (name_len + data_len > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Path too long\n\t\t\t */\n\t\t\tif (name_len + data_len > PATH_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (name_len + data_len > buf_len) {\n\t\t\tbuf_len = name_len + data_len;\n\t\t\tif (is_vmalloc_addr(buf)) {\n\t\t\t\tvfree(buf);\n\t\t\t\tbuf = NULL;\n\t\t\t} else {\n\t\t\t\tchar *tmp = krealloc(buf, buf_len,\n\t\t\t\t\t\t     GFP_NOFS | __GFP_NOWARN);\n\n\t\t\t\tif (!tmp)\n\t\t\t\t\tkfree(buf);\n\t\t\t\tbuf = tmp;\n\t\t\t}\n\t\t\tif (!buf) {\n\t\t\t\tbuf = vmalloc(buf_len);\n\t\t\t\tif (!buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tread_extent_buffer(eb, buf, (unsigned long)(di + 1),\n\t\t\t\tname_len + data_len);\n\n\t\tlen = sizeof(*di) + name_len + data_len;\n\t\tdi = (struct btrfs_dir_item *)((char *)di + len);\n\t\tcur += len;\n\n\t\tret = iterate(num, &di_key, buf, name_len, buf + name_len,\n\t\t\t\tdata_len, type, ctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum++;\n\t}\n\nout:\n\tkvfree(buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "eb",
            "&found_key",
            "slot"
          ],
          "line": 4371
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 4361
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "eb"
          ],
          "line": 4360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 4353
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_path_for_send",
          "args": [],
          "line": 4344
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_path_for_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "496-507",
          "snippet": "static struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_all_new_xattrs(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\troot = sctx->send_root;\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = iterate_dir_item(root, path, &found_key,\n\t\t\t\t       __process_new_xattr, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tpath->slots[0]++;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "process_changed_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4319-4332",
    "snippet": "static int process_changed_xattr(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\tret = iterate_dir_item(sctx->send_root, sctx->left_path,\n\t\t\tsctx->cmp_key, __process_changed_new_xattr, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = iterate_dir_item(sctx->parent_root, sctx->right_path,\n\t\t\tsctx->cmp_key, __process_changed_deleted_xattr, sctx);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterate_dir_item",
          "args": [
            "sctx->parent_root",
            "sctx->right_path",
            "sctx->cmp_key",
            "__process_changed_deleted_xattr",
            "sctx"
          ],
          "line": 4327
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "970-1081",
          "snippet": "static int iterate_dir_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *found_key,\n\t\t\t    iterate_dir_item_t iterate, void *ctx)\n{\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key di_key;\n\tchar *buf = NULL;\n\tint buf_len;\n\tu32 name_len;\n\tu32 data_len;\n\tu32 cur;\n\tu32 len;\n\tu32 total;\n\tint slot;\n\tint num;\n\tu8 type;\n\n\t/*\n\t * Start with a small buffer (1 page). If later we end up needing more\n\t * space, which can happen for xattrs on a fs with a leaf size greater\n\t * then the page size, attempt to increase the buffer. Typically xattr\n\t * values are small.\n\t */\n\tbuf_len = PATH_MAX;\n\tbuf = kmalloc(buf_len, GFP_NOFS);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem = btrfs_item_nr(slot);\n\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\tcur = 0;\n\tlen = 0;\n\ttotal = btrfs_item_size(eb, item);\n\n\tnum = 0;\n\twhile (cur < total) {\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tdata_len = btrfs_dir_data_len(eb, di);\n\t\ttype = btrfs_dir_type(eb, di);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (type == BTRFS_FT_XATTR) {\n\t\t\tif (name_len > XATTR_NAME_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (name_len + data_len > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Path too long\n\t\t\t */\n\t\t\tif (name_len + data_len > PATH_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (name_len + data_len > buf_len) {\n\t\t\tbuf_len = name_len + data_len;\n\t\t\tif (is_vmalloc_addr(buf)) {\n\t\t\t\tvfree(buf);\n\t\t\t\tbuf = NULL;\n\t\t\t} else {\n\t\t\t\tchar *tmp = krealloc(buf, buf_len,\n\t\t\t\t\t\t     GFP_NOFS | __GFP_NOWARN);\n\n\t\t\t\tif (!tmp)\n\t\t\t\t\tkfree(buf);\n\t\t\t\tbuf = tmp;\n\t\t\t}\n\t\t\tif (!buf) {\n\t\t\t\tbuf = vmalloc(buf_len);\n\t\t\t\tif (!buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tread_extent_buffer(eb, buf, (unsigned long)(di + 1),\n\t\t\t\tname_len + data_len);\n\n\t\tlen = sizeof(*di) + name_len + data_len;\n\t\tdi = (struct btrfs_dir_item *)((char *)di + len);\n\t\tcur += len;\n\n\t\tret = iterate(num, &di_key, buf, name_len, buf + name_len,\n\t\t\t\tdata_len, type, ctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum++;\n\t}\n\nout:\n\tkvfree(buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int iterate_dir_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *found_key,\n\t\t\t    iterate_dir_item_t iterate, void *ctx)\n{\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key di_key;\n\tchar *buf = NULL;\n\tint buf_len;\n\tu32 name_len;\n\tu32 data_len;\n\tu32 cur;\n\tu32 len;\n\tu32 total;\n\tint slot;\n\tint num;\n\tu8 type;\n\n\t/*\n\t * Start with a small buffer (1 page). If later we end up needing more\n\t * space, which can happen for xattrs on a fs with a leaf size greater\n\t * then the page size, attempt to increase the buffer. Typically xattr\n\t * values are small.\n\t */\n\tbuf_len = PATH_MAX;\n\tbuf = kmalloc(buf_len, GFP_NOFS);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem = btrfs_item_nr(slot);\n\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\tcur = 0;\n\tlen = 0;\n\ttotal = btrfs_item_size(eb, item);\n\n\tnum = 0;\n\twhile (cur < total) {\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tdata_len = btrfs_dir_data_len(eb, di);\n\t\ttype = btrfs_dir_type(eb, di);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (type == BTRFS_FT_XATTR) {\n\t\t\tif (name_len > XATTR_NAME_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (name_len + data_len > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Path too long\n\t\t\t */\n\t\t\tif (name_len + data_len > PATH_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (name_len + data_len > buf_len) {\n\t\t\tbuf_len = name_len + data_len;\n\t\t\tif (is_vmalloc_addr(buf)) {\n\t\t\t\tvfree(buf);\n\t\t\t\tbuf = NULL;\n\t\t\t} else {\n\t\t\t\tchar *tmp = krealloc(buf, buf_len,\n\t\t\t\t\t\t     GFP_NOFS | __GFP_NOWARN);\n\n\t\t\t\tif (!tmp)\n\t\t\t\t\tkfree(buf);\n\t\t\t\tbuf = tmp;\n\t\t\t}\n\t\t\tif (!buf) {\n\t\t\t\tbuf = vmalloc(buf_len);\n\t\t\t\tif (!buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tread_extent_buffer(eb, buf, (unsigned long)(di + 1),\n\t\t\t\tname_len + data_len);\n\n\t\tlen = sizeof(*di) + name_len + data_len;\n\t\tdi = (struct btrfs_dir_item *)((char *)di + len);\n\t\tcur += len;\n\n\t\tret = iterate(num, &di_key, buf, name_len, buf + name_len,\n\t\t\t\tdata_len, type, ctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum++;\n\t}\n\nout:\n\tkvfree(buf);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_changed_xattr(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\tret = iterate_dir_item(sctx->send_root, sctx->left_path,\n\t\t\tsctx->cmp_key, __process_changed_new_xattr, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = iterate_dir_item(sctx->parent_root, sctx->right_path,\n\t\t\tsctx->cmp_key, __process_changed_deleted_xattr, sctx);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "__process_changed_deleted_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4300-4317",
    "snippet": "static int __process_changed_deleted_xattr(int num, struct btrfs_key *di_key,\n\t\t\t\t\t   const char *name, int name_len,\n\t\t\t\t\t   const char *data, int data_len,\n\t\t\t\t\t   u8 type, void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\n\tret = find_xattr(sctx->send_root, sctx->left_path, sctx->cmp_key,\n\t\t\t name, name_len, NULL, NULL);\n\tif (ret == -ENOENT)\n\t\tret = __process_deleted_xattr(num, di_key, name, name_len, data,\n\t\t\t\tdata_len, type, ctx);\n\telse if (ret >= 0)\n\t\tret = 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__process_deleted_xattr",
          "args": [
            "num",
            "di_key",
            "name",
            "name_len",
            "data",
            "data_len",
            "type",
            "ctx"
          ],
          "line": 4311
        },
        "resolved": true,
        "details": {
          "function_name": "__process_deleted_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4168-4190",
          "snippet": "static int __process_deleted_xattr(int num, struct btrfs_key *di_key,\n\t\t\t\t   const char *name, int name_len,\n\t\t\t\t   const char *data, int data_len,\n\t\t\t\t   u8 type, void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_remove_xattr(sctx, p, name, name_len);\n\nout:\n\tfs_path_free(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int __process_deleted_xattr(int num, struct btrfs_key *di_key,\n\t\t\t\t   const char *name, int name_len,\n\t\t\t\t   const char *data, int data_len,\n\t\t\t\t   u8 type, void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_remove_xattr(sctx, p, name, name_len);\n\nout:\n\tfs_path_free(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_xattr",
          "args": [
            "sctx->send_root",
            "sctx->left_path",
            "sctx->cmp_key",
            "name",
            "name_len",
            "NULL",
            "NULL"
          ],
          "line": 4308
        },
        "resolved": true,
        "details": {
          "function_name": "find_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4239-4267",
          "snippet": "static int find_xattr(struct btrfs_root *root,\n\t\t      struct btrfs_path *path,\n\t\t      struct btrfs_key *key,\n\t\t      const char *name, int name_len,\n\t\t      char **data, int *data_len)\n{\n\tint ret;\n\tstruct find_xattr_ctx ctx;\n\n\tctx.name = name;\n\tctx.name_len = name_len;\n\tctx.found_idx = -1;\n\tctx.found_data = NULL;\n\tctx.found_data_len = 0;\n\n\tret = iterate_dir_item(root, path, key, __find_xattr, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ctx.found_idx == -1)\n\t\treturn -ENOENT;\n\tif (data) {\n\t\t*data = ctx.found_data;\n\t\t*data_len = ctx.found_data_len;\n\t} else {\n\t\tkfree(ctx.found_data);\n\t}\n\treturn ctx.found_idx;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int find_xattr(struct btrfs_root *root,\n\t\t      struct btrfs_path *path,\n\t\t      struct btrfs_key *key,\n\t\t      const char *name, int name_len,\n\t\t      char **data, int *data_len)\n{\n\tint ret;\n\tstruct find_xattr_ctx ctx;\n\n\tctx.name = name;\n\tctx.name_len = name_len;\n\tctx.found_idx = -1;\n\tctx.found_data = NULL;\n\tctx.found_data_len = 0;\n\n\tret = iterate_dir_item(root, path, key, __find_xattr, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ctx.found_idx == -1)\n\t\treturn -ENOENT;\n\tif (data) {\n\t\t*data = ctx.found_data;\n\t\t*data_len = ctx.found_data_len;\n\t} else {\n\t\tkfree(ctx.found_data);\n\t}\n\treturn ctx.found_idx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int __process_changed_deleted_xattr(int num, struct btrfs_key *di_key,\n\t\t\t\t\t   const char *name, int name_len,\n\t\t\t\t\t   const char *data, int data_len,\n\t\t\t\t\t   u8 type, void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\n\tret = find_xattr(sctx->send_root, sctx->left_path, sctx->cmp_key,\n\t\t\t name, name_len, NULL, NULL);\n\tif (ret == -ENOENT)\n\t\tret = __process_deleted_xattr(num, di_key, name, name_len, data,\n\t\t\t\tdata_len, type, ctx);\n\telse if (ret >= 0)\n\t\tret = 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__process_changed_new_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4270-4298",
    "snippet": "static int __process_changed_new_xattr(int num, struct btrfs_key *di_key,\n\t\t\t\t       const char *name, int name_len,\n\t\t\t\t       const char *data, int data_len,\n\t\t\t\t       u8 type, void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\tchar *found_data = NULL;\n\tint found_data_len  = 0;\n\n\tret = find_xattr(sctx->parent_root, sctx->right_path,\n\t\t\t sctx->cmp_key, name, name_len, &found_data,\n\t\t\t &found_data_len);\n\tif (ret == -ENOENT) {\n\t\tret = __process_new_xattr(num, di_key, name, name_len, data,\n\t\t\t\tdata_len, type, ctx);\n\t} else if (ret >= 0) {\n\t\tif (data_len != found_data_len ||\n\t\t    memcmp(data, found_data, data_len)) {\n\t\t\tret = __process_new_xattr(num, di_key, name, name_len,\n\t\t\t\t\tdata, data_len, type, ctx);\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tkfree(found_data);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "found_data"
          ],
          "line": 4296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__process_new_xattr",
          "args": [
            "num",
            "di_key",
            "name",
            "name_len",
            "data",
            "data_len",
            "type",
            "ctx"
          ],
          "line": 4289
        },
        "resolved": true,
        "details": {
          "function_name": "__process_new_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4127-4166",
          "snippet": "static int __process_new_xattr(int num, struct btrfs_key *di_key,\n\t\t\t       const char *name, int name_len,\n\t\t\t       const char *data, int data_len,\n\t\t\t       u8 type, void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\tstruct fs_path *p;\n\tposix_acl_xattr_header dummy_acl;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * This hack is needed because empty acl's are stored as zero byte\n\t * data in xattrs. Problem with that is, that receiving these zero byte\n\t * acl's will fail later. To fix this, we send a dummy acl list that\n\t * only contains the version number and no entries.\n\t */\n\tif (!strncmp(name, XATTR_NAME_POSIX_ACL_ACCESS, name_len) ||\n\t    !strncmp(name, XATTR_NAME_POSIX_ACL_DEFAULT, name_len)) {\n\t\tif (data_len == 0) {\n\t\t\tdummy_acl.a_version =\n\t\t\t\t\tcpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\t\t\tdata = (char *)&dummy_acl;\n\t\t\tdata_len = sizeof(dummy_acl);\n\t\t}\n\t}\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_set_xattr(sctx, p, name, name_len, data, data_len);\n\nout:\n\tfs_path_free(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int __process_new_xattr(int num, struct btrfs_key *di_key,\n\t\t\t       const char *name, int name_len,\n\t\t\t       const char *data, int data_len,\n\t\t\t       u8 type, void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\tstruct fs_path *p;\n\tposix_acl_xattr_header dummy_acl;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * This hack is needed because empty acl's are stored as zero byte\n\t * data in xattrs. Problem with that is, that receiving these zero byte\n\t * acl's will fail later. To fix this, we send a dummy acl list that\n\t * only contains the version number and no entries.\n\t */\n\tif (!strncmp(name, XATTR_NAME_POSIX_ACL_ACCESS, name_len) ||\n\t    !strncmp(name, XATTR_NAME_POSIX_ACL_DEFAULT, name_len)) {\n\t\tif (data_len == 0) {\n\t\t\tdummy_acl.a_version =\n\t\t\t\t\tcpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\t\t\tdata = (char *)&dummy_acl;\n\t\t\tdata_len = sizeof(dummy_acl);\n\t\t}\n\t}\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_set_xattr(sctx, p, name, name_len, data, data_len);\n\nout:\n\tfs_path_free(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "data",
            "found_data",
            "data_len"
          ],
          "line": 4288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_xattr",
          "args": [
            "sctx->parent_root",
            "sctx->right_path",
            "sctx->cmp_key",
            "name",
            "name_len",
            "&found_data",
            "&found_data_len"
          ],
          "line": 4280
        },
        "resolved": true,
        "details": {
          "function_name": "find_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4239-4267",
          "snippet": "static int find_xattr(struct btrfs_root *root,\n\t\t      struct btrfs_path *path,\n\t\t      struct btrfs_key *key,\n\t\t      const char *name, int name_len,\n\t\t      char **data, int *data_len)\n{\n\tint ret;\n\tstruct find_xattr_ctx ctx;\n\n\tctx.name = name;\n\tctx.name_len = name_len;\n\tctx.found_idx = -1;\n\tctx.found_data = NULL;\n\tctx.found_data_len = 0;\n\n\tret = iterate_dir_item(root, path, key, __find_xattr, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ctx.found_idx == -1)\n\t\treturn -ENOENT;\n\tif (data) {\n\t\t*data = ctx.found_data;\n\t\t*data_len = ctx.found_data_len;\n\t} else {\n\t\tkfree(ctx.found_data);\n\t}\n\treturn ctx.found_idx;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int find_xattr(struct btrfs_root *root,\n\t\t      struct btrfs_path *path,\n\t\t      struct btrfs_key *key,\n\t\t      const char *name, int name_len,\n\t\t      char **data, int *data_len)\n{\n\tint ret;\n\tstruct find_xattr_ctx ctx;\n\n\tctx.name = name;\n\tctx.name_len = name_len;\n\tctx.found_idx = -1;\n\tctx.found_data = NULL;\n\tctx.found_data_len = 0;\n\n\tret = iterate_dir_item(root, path, key, __find_xattr, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ctx.found_idx == -1)\n\t\treturn -ENOENT;\n\tif (data) {\n\t\t*data = ctx.found_data;\n\t\t*data_len = ctx.found_data_len;\n\t} else {\n\t\tkfree(ctx.found_data);\n\t}\n\treturn ctx.found_idx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int __process_changed_new_xattr(int num, struct btrfs_key *di_key,\n\t\t\t\t       const char *name, int name_len,\n\t\t\t\t       const char *data, int data_len,\n\t\t\t\t       u8 type, void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\tchar *found_data = NULL;\n\tint found_data_len  = 0;\n\n\tret = find_xattr(sctx->parent_root, sctx->right_path,\n\t\t\t sctx->cmp_key, name, name_len, &found_data,\n\t\t\t &found_data_len);\n\tif (ret == -ENOENT) {\n\t\tret = __process_new_xattr(num, di_key, name, name_len, data,\n\t\t\t\tdata_len, type, ctx);\n\t} else if (ret >= 0) {\n\t\tif (data_len != found_data_len ||\n\t\t    memcmp(data, found_data, data_len)) {\n\t\t\tret = __process_new_xattr(num, di_key, name, name_len,\n\t\t\t\t\tdata, data_len, type, ctx);\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tkfree(found_data);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4239-4267",
    "snippet": "static int find_xattr(struct btrfs_root *root,\n\t\t      struct btrfs_path *path,\n\t\t      struct btrfs_key *key,\n\t\t      const char *name, int name_len,\n\t\t      char **data, int *data_len)\n{\n\tint ret;\n\tstruct find_xattr_ctx ctx;\n\n\tctx.name = name;\n\tctx.name_len = name_len;\n\tctx.found_idx = -1;\n\tctx.found_data = NULL;\n\tctx.found_data_len = 0;\n\n\tret = iterate_dir_item(root, path, key, __find_xattr, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ctx.found_idx == -1)\n\t\treturn -ENOENT;\n\tif (data) {\n\t\t*data = ctx.found_data;\n\t\t*data_len = ctx.found_data_len;\n\t} else {\n\t\tkfree(ctx.found_data);\n\t}\n\treturn ctx.found_idx;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx.found_data"
          ],
          "line": 4264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate_dir_item",
          "args": [
            "root",
            "path",
            "key",
            "__find_xattr",
            "&ctx"
          ],
          "line": 4254
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "970-1081",
          "snippet": "static int iterate_dir_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *found_key,\n\t\t\t    iterate_dir_item_t iterate, void *ctx)\n{\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key di_key;\n\tchar *buf = NULL;\n\tint buf_len;\n\tu32 name_len;\n\tu32 data_len;\n\tu32 cur;\n\tu32 len;\n\tu32 total;\n\tint slot;\n\tint num;\n\tu8 type;\n\n\t/*\n\t * Start with a small buffer (1 page). If later we end up needing more\n\t * space, which can happen for xattrs on a fs with a leaf size greater\n\t * then the page size, attempt to increase the buffer. Typically xattr\n\t * values are small.\n\t */\n\tbuf_len = PATH_MAX;\n\tbuf = kmalloc(buf_len, GFP_NOFS);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem = btrfs_item_nr(slot);\n\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\tcur = 0;\n\tlen = 0;\n\ttotal = btrfs_item_size(eb, item);\n\n\tnum = 0;\n\twhile (cur < total) {\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tdata_len = btrfs_dir_data_len(eb, di);\n\t\ttype = btrfs_dir_type(eb, di);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (type == BTRFS_FT_XATTR) {\n\t\t\tif (name_len > XATTR_NAME_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (name_len + data_len > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Path too long\n\t\t\t */\n\t\t\tif (name_len + data_len > PATH_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (name_len + data_len > buf_len) {\n\t\t\tbuf_len = name_len + data_len;\n\t\t\tif (is_vmalloc_addr(buf)) {\n\t\t\t\tvfree(buf);\n\t\t\t\tbuf = NULL;\n\t\t\t} else {\n\t\t\t\tchar *tmp = krealloc(buf, buf_len,\n\t\t\t\t\t\t     GFP_NOFS | __GFP_NOWARN);\n\n\t\t\t\tif (!tmp)\n\t\t\t\t\tkfree(buf);\n\t\t\t\tbuf = tmp;\n\t\t\t}\n\t\t\tif (!buf) {\n\t\t\t\tbuf = vmalloc(buf_len);\n\t\t\t\tif (!buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tread_extent_buffer(eb, buf, (unsigned long)(di + 1),\n\t\t\t\tname_len + data_len);\n\n\t\tlen = sizeof(*di) + name_len + data_len;\n\t\tdi = (struct btrfs_dir_item *)((char *)di + len);\n\t\tcur += len;\n\n\t\tret = iterate(num, &di_key, buf, name_len, buf + name_len,\n\t\t\t\tdata_len, type, ctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum++;\n\t}\n\nout:\n\tkvfree(buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int iterate_dir_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *found_key,\n\t\t\t    iterate_dir_item_t iterate, void *ctx)\n{\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key di_key;\n\tchar *buf = NULL;\n\tint buf_len;\n\tu32 name_len;\n\tu32 data_len;\n\tu32 cur;\n\tu32 len;\n\tu32 total;\n\tint slot;\n\tint num;\n\tu8 type;\n\n\t/*\n\t * Start with a small buffer (1 page). If later we end up needing more\n\t * space, which can happen for xattrs on a fs with a leaf size greater\n\t * then the page size, attempt to increase the buffer. Typically xattr\n\t * values are small.\n\t */\n\tbuf_len = PATH_MAX;\n\tbuf = kmalloc(buf_len, GFP_NOFS);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem = btrfs_item_nr(slot);\n\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\tcur = 0;\n\tlen = 0;\n\ttotal = btrfs_item_size(eb, item);\n\n\tnum = 0;\n\twhile (cur < total) {\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tdata_len = btrfs_dir_data_len(eb, di);\n\t\ttype = btrfs_dir_type(eb, di);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (type == BTRFS_FT_XATTR) {\n\t\t\tif (name_len > XATTR_NAME_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (name_len + data_len > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Path too long\n\t\t\t */\n\t\t\tif (name_len + data_len > PATH_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (name_len + data_len > buf_len) {\n\t\t\tbuf_len = name_len + data_len;\n\t\t\tif (is_vmalloc_addr(buf)) {\n\t\t\t\tvfree(buf);\n\t\t\t\tbuf = NULL;\n\t\t\t} else {\n\t\t\t\tchar *tmp = krealloc(buf, buf_len,\n\t\t\t\t\t\t     GFP_NOFS | __GFP_NOWARN);\n\n\t\t\t\tif (!tmp)\n\t\t\t\t\tkfree(buf);\n\t\t\t\tbuf = tmp;\n\t\t\t}\n\t\t\tif (!buf) {\n\t\t\t\tbuf = vmalloc(buf_len);\n\t\t\t\tif (!buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tread_extent_buffer(eb, buf, (unsigned long)(di + 1),\n\t\t\t\tname_len + data_len);\n\n\t\tlen = sizeof(*di) + name_len + data_len;\n\t\tdi = (struct btrfs_dir_item *)((char *)di + len);\n\t\tcur += len;\n\n\t\tret = iterate(num, &di_key, buf, name_len, buf + name_len,\n\t\t\t\tdata_len, type, ctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum++;\n\t}\n\nout:\n\tkvfree(buf);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int find_xattr(struct btrfs_root *root,\n\t\t      struct btrfs_path *path,\n\t\t      struct btrfs_key *key,\n\t\t      const char *name, int name_len,\n\t\t      char **data, int *data_len)\n{\n\tint ret;\n\tstruct find_xattr_ctx ctx;\n\n\tctx.name = name;\n\tctx.name_len = name_len;\n\tctx.found_idx = -1;\n\tctx.found_data = NULL;\n\tctx.found_data_len = 0;\n\n\tret = iterate_dir_item(root, path, key, __find_xattr, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ctx.found_idx == -1)\n\t\treturn -ENOENT;\n\tif (data) {\n\t\t*data = ctx.found_data;\n\t\t*data_len = ctx.found_data_len;\n\t} else {\n\t\tkfree(ctx.found_data);\n\t}\n\treturn ctx.found_idx;\n}"
  },
  {
    "function_name": "__find_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4220-4237",
    "snippet": "static int __find_xattr(int num, struct btrfs_key *di_key,\n\t\t\tconst char *name, int name_len,\n\t\t\tconst char *data, int data_len,\n\t\t\tu8 type, void *vctx)\n{\n\tstruct find_xattr_ctx *ctx = vctx;\n\n\tif (name_len == ctx->name_len &&\n\t    strncmp(name, ctx->name, name_len) == 0) {\n\t\tctx->found_idx = num;\n\t\tctx->found_data_len = data_len;\n\t\tctx->found_data = kmemdup(data, data_len, GFP_NOFS);\n\t\tif (!ctx->found_data)\n\t\t\treturn -ENOMEM;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "data",
            "data_len",
            "GFP_NOFS"
          ],
          "line": 4231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "ctx->name",
            "name_len"
          ],
          "line": 4228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int __find_xattr(int num, struct btrfs_key *di_key,\n\t\t\tconst char *name, int name_len,\n\t\t\tconst char *data, int data_len,\n\t\t\tu8 type, void *vctx)\n{\n\tstruct find_xattr_ctx *ctx = vctx;\n\n\tif (name_len == ctx->name_len &&\n\t    strncmp(name, ctx->name, name_len) == 0) {\n\t\tctx->found_idx = num;\n\t\tctx->found_data_len = data_len;\n\t\tctx->found_data = kmemdup(data, data_len, GFP_NOFS);\n\t\tif (!ctx->found_data)\n\t\t\treturn -ENOMEM;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "process_deleted_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4202-4210",
    "snippet": "static int process_deleted_xattr(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tret = iterate_dir_item(sctx->parent_root, sctx->right_path,\n\t\t\t       sctx->cmp_key, __process_deleted_xattr, sctx);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterate_dir_item",
          "args": [
            "sctx->parent_root",
            "sctx->right_path",
            "sctx->cmp_key",
            "__process_deleted_xattr",
            "sctx"
          ],
          "line": 4206
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "970-1081",
          "snippet": "static int iterate_dir_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *found_key,\n\t\t\t    iterate_dir_item_t iterate, void *ctx)\n{\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key di_key;\n\tchar *buf = NULL;\n\tint buf_len;\n\tu32 name_len;\n\tu32 data_len;\n\tu32 cur;\n\tu32 len;\n\tu32 total;\n\tint slot;\n\tint num;\n\tu8 type;\n\n\t/*\n\t * Start with a small buffer (1 page). If later we end up needing more\n\t * space, which can happen for xattrs on a fs with a leaf size greater\n\t * then the page size, attempt to increase the buffer. Typically xattr\n\t * values are small.\n\t */\n\tbuf_len = PATH_MAX;\n\tbuf = kmalloc(buf_len, GFP_NOFS);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem = btrfs_item_nr(slot);\n\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\tcur = 0;\n\tlen = 0;\n\ttotal = btrfs_item_size(eb, item);\n\n\tnum = 0;\n\twhile (cur < total) {\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tdata_len = btrfs_dir_data_len(eb, di);\n\t\ttype = btrfs_dir_type(eb, di);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (type == BTRFS_FT_XATTR) {\n\t\t\tif (name_len > XATTR_NAME_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (name_len + data_len > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Path too long\n\t\t\t */\n\t\t\tif (name_len + data_len > PATH_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (name_len + data_len > buf_len) {\n\t\t\tbuf_len = name_len + data_len;\n\t\t\tif (is_vmalloc_addr(buf)) {\n\t\t\t\tvfree(buf);\n\t\t\t\tbuf = NULL;\n\t\t\t} else {\n\t\t\t\tchar *tmp = krealloc(buf, buf_len,\n\t\t\t\t\t\t     GFP_NOFS | __GFP_NOWARN);\n\n\t\t\t\tif (!tmp)\n\t\t\t\t\tkfree(buf);\n\t\t\t\tbuf = tmp;\n\t\t\t}\n\t\t\tif (!buf) {\n\t\t\t\tbuf = vmalloc(buf_len);\n\t\t\t\tif (!buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tread_extent_buffer(eb, buf, (unsigned long)(di + 1),\n\t\t\t\tname_len + data_len);\n\n\t\tlen = sizeof(*di) + name_len + data_len;\n\t\tdi = (struct btrfs_dir_item *)((char *)di + len);\n\t\tcur += len;\n\n\t\tret = iterate(num, &di_key, buf, name_len, buf + name_len,\n\t\t\t\tdata_len, type, ctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum++;\n\t}\n\nout:\n\tkvfree(buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int iterate_dir_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *found_key,\n\t\t\t    iterate_dir_item_t iterate, void *ctx)\n{\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key di_key;\n\tchar *buf = NULL;\n\tint buf_len;\n\tu32 name_len;\n\tu32 data_len;\n\tu32 cur;\n\tu32 len;\n\tu32 total;\n\tint slot;\n\tint num;\n\tu8 type;\n\n\t/*\n\t * Start with a small buffer (1 page). If later we end up needing more\n\t * space, which can happen for xattrs on a fs with a leaf size greater\n\t * then the page size, attempt to increase the buffer. Typically xattr\n\t * values are small.\n\t */\n\tbuf_len = PATH_MAX;\n\tbuf = kmalloc(buf_len, GFP_NOFS);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem = btrfs_item_nr(slot);\n\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\tcur = 0;\n\tlen = 0;\n\ttotal = btrfs_item_size(eb, item);\n\n\tnum = 0;\n\twhile (cur < total) {\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tdata_len = btrfs_dir_data_len(eb, di);\n\t\ttype = btrfs_dir_type(eb, di);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (type == BTRFS_FT_XATTR) {\n\t\t\tif (name_len > XATTR_NAME_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (name_len + data_len > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Path too long\n\t\t\t */\n\t\t\tif (name_len + data_len > PATH_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (name_len + data_len > buf_len) {\n\t\t\tbuf_len = name_len + data_len;\n\t\t\tif (is_vmalloc_addr(buf)) {\n\t\t\t\tvfree(buf);\n\t\t\t\tbuf = NULL;\n\t\t\t} else {\n\t\t\t\tchar *tmp = krealloc(buf, buf_len,\n\t\t\t\t\t\t     GFP_NOFS | __GFP_NOWARN);\n\n\t\t\t\tif (!tmp)\n\t\t\t\t\tkfree(buf);\n\t\t\t\tbuf = tmp;\n\t\t\t}\n\t\t\tif (!buf) {\n\t\t\t\tbuf = vmalloc(buf_len);\n\t\t\t\tif (!buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tread_extent_buffer(eb, buf, (unsigned long)(di + 1),\n\t\t\t\tname_len + data_len);\n\n\t\tlen = sizeof(*di) + name_len + data_len;\n\t\tdi = (struct btrfs_dir_item *)((char *)di + len);\n\t\tcur += len;\n\n\t\tret = iterate(num, &di_key, buf, name_len, buf + name_len,\n\t\t\t\tdata_len, type, ctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum++;\n\t}\n\nout:\n\tkvfree(buf);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_deleted_xattr(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tret = iterate_dir_item(sctx->parent_root, sctx->right_path,\n\t\t\t       sctx->cmp_key, __process_deleted_xattr, sctx);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "process_new_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4192-4200",
    "snippet": "static int process_new_xattr(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\tret = iterate_dir_item(sctx->send_root, sctx->left_path,\n\t\t\t       sctx->cmp_key, __process_new_xattr, sctx);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterate_dir_item",
          "args": [
            "sctx->send_root",
            "sctx->left_path",
            "sctx->cmp_key",
            "__process_new_xattr",
            "sctx"
          ],
          "line": 4196
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "970-1081",
          "snippet": "static int iterate_dir_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *found_key,\n\t\t\t    iterate_dir_item_t iterate, void *ctx)\n{\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key di_key;\n\tchar *buf = NULL;\n\tint buf_len;\n\tu32 name_len;\n\tu32 data_len;\n\tu32 cur;\n\tu32 len;\n\tu32 total;\n\tint slot;\n\tint num;\n\tu8 type;\n\n\t/*\n\t * Start with a small buffer (1 page). If later we end up needing more\n\t * space, which can happen for xattrs on a fs with a leaf size greater\n\t * then the page size, attempt to increase the buffer. Typically xattr\n\t * values are small.\n\t */\n\tbuf_len = PATH_MAX;\n\tbuf = kmalloc(buf_len, GFP_NOFS);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem = btrfs_item_nr(slot);\n\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\tcur = 0;\n\tlen = 0;\n\ttotal = btrfs_item_size(eb, item);\n\n\tnum = 0;\n\twhile (cur < total) {\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tdata_len = btrfs_dir_data_len(eb, di);\n\t\ttype = btrfs_dir_type(eb, di);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (type == BTRFS_FT_XATTR) {\n\t\t\tif (name_len > XATTR_NAME_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (name_len + data_len > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Path too long\n\t\t\t */\n\t\t\tif (name_len + data_len > PATH_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (name_len + data_len > buf_len) {\n\t\t\tbuf_len = name_len + data_len;\n\t\t\tif (is_vmalloc_addr(buf)) {\n\t\t\t\tvfree(buf);\n\t\t\t\tbuf = NULL;\n\t\t\t} else {\n\t\t\t\tchar *tmp = krealloc(buf, buf_len,\n\t\t\t\t\t\t     GFP_NOFS | __GFP_NOWARN);\n\n\t\t\t\tif (!tmp)\n\t\t\t\t\tkfree(buf);\n\t\t\t\tbuf = tmp;\n\t\t\t}\n\t\t\tif (!buf) {\n\t\t\t\tbuf = vmalloc(buf_len);\n\t\t\t\tif (!buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tread_extent_buffer(eb, buf, (unsigned long)(di + 1),\n\t\t\t\tname_len + data_len);\n\n\t\tlen = sizeof(*di) + name_len + data_len;\n\t\tdi = (struct btrfs_dir_item *)((char *)di + len);\n\t\tcur += len;\n\n\t\tret = iterate(num, &di_key, buf, name_len, buf + name_len,\n\t\t\t\tdata_len, type, ctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum++;\n\t}\n\nout:\n\tkvfree(buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int iterate_dir_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *found_key,\n\t\t\t    iterate_dir_item_t iterate, void *ctx)\n{\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key di_key;\n\tchar *buf = NULL;\n\tint buf_len;\n\tu32 name_len;\n\tu32 data_len;\n\tu32 cur;\n\tu32 len;\n\tu32 total;\n\tint slot;\n\tint num;\n\tu8 type;\n\n\t/*\n\t * Start with a small buffer (1 page). If later we end up needing more\n\t * space, which can happen for xattrs on a fs with a leaf size greater\n\t * then the page size, attempt to increase the buffer. Typically xattr\n\t * values are small.\n\t */\n\tbuf_len = PATH_MAX;\n\tbuf = kmalloc(buf_len, GFP_NOFS);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem = btrfs_item_nr(slot);\n\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\tcur = 0;\n\tlen = 0;\n\ttotal = btrfs_item_size(eb, item);\n\n\tnum = 0;\n\twhile (cur < total) {\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tdata_len = btrfs_dir_data_len(eb, di);\n\t\ttype = btrfs_dir_type(eb, di);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (type == BTRFS_FT_XATTR) {\n\t\t\tif (name_len > XATTR_NAME_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (name_len + data_len > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Path too long\n\t\t\t */\n\t\t\tif (name_len + data_len > PATH_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (name_len + data_len > buf_len) {\n\t\t\tbuf_len = name_len + data_len;\n\t\t\tif (is_vmalloc_addr(buf)) {\n\t\t\t\tvfree(buf);\n\t\t\t\tbuf = NULL;\n\t\t\t} else {\n\t\t\t\tchar *tmp = krealloc(buf, buf_len,\n\t\t\t\t\t\t     GFP_NOFS | __GFP_NOWARN);\n\n\t\t\t\tif (!tmp)\n\t\t\t\t\tkfree(buf);\n\t\t\t\tbuf = tmp;\n\t\t\t}\n\t\t\tif (!buf) {\n\t\t\t\tbuf = vmalloc(buf_len);\n\t\t\t\tif (!buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tread_extent_buffer(eb, buf, (unsigned long)(di + 1),\n\t\t\t\tname_len + data_len);\n\n\t\tlen = sizeof(*di) + name_len + data_len;\n\t\tdi = (struct btrfs_dir_item *)((char *)di + len);\n\t\tcur += len;\n\n\t\tret = iterate(num, &di_key, buf, name_len, buf + name_len,\n\t\t\t\tdata_len, type, ctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum++;\n\t}\n\nout:\n\tkvfree(buf);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_new_xattr(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\tret = iterate_dir_item(sctx->send_root, sctx->left_path,\n\t\t\t       sctx->cmp_key, __process_new_xattr, sctx);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__process_deleted_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4168-4190",
    "snippet": "static int __process_deleted_xattr(int num, struct btrfs_key *di_key,\n\t\t\t\t   const char *name, int name_len,\n\t\t\t\t   const char *data, int data_len,\n\t\t\t\t   u8 type, void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_remove_xattr(sctx, p, name, name_len);\n\nout:\n\tfs_path_free(p);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "p"
          ],
          "line": 4188
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_remove_xattr",
          "args": [
            "sctx",
            "p",
            "name",
            "name_len"
          ],
          "line": 4185
        },
        "resolved": true,
        "details": {
          "function_name": "send_remove_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4107-4125",
          "snippet": "static int send_remove_xattr(struct send_ctx *sctx,\n\t\t\t  struct fs_path *path,\n\t\t\t  const char *name, int name_len)\n{\n\tint ret = 0;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_REMOVE_XATTR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\tTLV_PUT_STRING(sctx, BTRFS_SEND_A_XATTR_NAME, name, name_len);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_remove_xattr(struct send_ctx *sctx,\n\t\t\t  struct fs_path *path,\n\t\t\t  const char *name, int name_len)\n{\n\tint ret = 0;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_REMOVE_XATTR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\tTLV_PUT_STRING(sctx, BTRFS_SEND_A_XATTR_NAME, name, name_len);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cur_path",
          "args": [
            "sctx",
            "sctx->cur_ino",
            "sctx->cur_inode_gen",
            "p"
          ],
          "line": 4181
        },
        "resolved": true,
        "details": {
          "function_name": "get_cur_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2207-2263",
          "snippet": "static int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 4177
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int __process_deleted_xattr(int num, struct btrfs_key *di_key,\n\t\t\t\t   const char *name, int name_len,\n\t\t\t\t   const char *data, int data_len,\n\t\t\t\t   u8 type, void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_remove_xattr(sctx, p, name, name_len);\n\nout:\n\tfs_path_free(p);\n\treturn ret;\n}"
  },
  {
    "function_name": "__process_new_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4127-4166",
    "snippet": "static int __process_new_xattr(int num, struct btrfs_key *di_key,\n\t\t\t       const char *name, int name_len,\n\t\t\t       const char *data, int data_len,\n\t\t\t       u8 type, void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\tstruct fs_path *p;\n\tposix_acl_xattr_header dummy_acl;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * This hack is needed because empty acl's are stored as zero byte\n\t * data in xattrs. Problem with that is, that receiving these zero byte\n\t * acl's will fail later. To fix this, we send a dummy acl list that\n\t * only contains the version number and no entries.\n\t */\n\tif (!strncmp(name, XATTR_NAME_POSIX_ACL_ACCESS, name_len) ||\n\t    !strncmp(name, XATTR_NAME_POSIX_ACL_DEFAULT, name_len)) {\n\t\tif (data_len == 0) {\n\t\t\tdummy_acl.a_version =\n\t\t\t\t\tcpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\t\t\tdata = (char *)&dummy_acl;\n\t\t\tdata_len = sizeof(dummy_acl);\n\t\t}\n\t}\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_set_xattr(sctx, p, name, name_len, data, data_len);\n\nout:\n\tfs_path_free(p);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "p"
          ],
          "line": 4164
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_set_xattr",
          "args": [
            "sctx",
            "p",
            "name",
            "name_len",
            "data",
            "data_len"
          ],
          "line": 4161
        },
        "resolved": true,
        "details": {
          "function_name": "send_set_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "4085-4105",
          "snippet": "static int send_set_xattr(struct send_ctx *sctx,\n\t\t\t  struct fs_path *path,\n\t\t\t  const char *name, int name_len,\n\t\t\t  const char *data, int data_len)\n{\n\tint ret = 0;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_SET_XATTR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\tTLV_PUT_STRING(sctx, BTRFS_SEND_A_XATTR_NAME, name, name_len);\n\tTLV_PUT(sctx, BTRFS_SEND_A_XATTR_DATA, data, data_len);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_set_xattr(struct send_ctx *sctx,\n\t\t\t  struct fs_path *path,\n\t\t\t  const char *name, int name_len,\n\t\t\t  const char *data, int data_len)\n{\n\tint ret = 0;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_SET_XATTR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\tTLV_PUT_STRING(sctx, BTRFS_SEND_A_XATTR_NAME, name, name_len);\n\tTLV_PUT(sctx, BTRFS_SEND_A_XATTR_DATA, data, data_len);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cur_path",
          "args": [
            "sctx",
            "sctx->cur_ino",
            "sctx->cur_inode_gen",
            "p"
          ],
          "line": 4157
        },
        "resolved": true,
        "details": {
          "function_name": "get_cur_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2207-2263",
          "snippet": "static int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "POSIX_ACL_XATTR_VERSION"
          ],
          "line": 4151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_NAME_POSIX_ACL_DEFAULT",
            "name_len"
          ],
          "line": 4148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_NAME_POSIX_ACL_ACCESS",
            "name_len"
          ],
          "line": 4147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 4137
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int __process_new_xattr(int num, struct btrfs_key *di_key,\n\t\t\t       const char *name, int name_len,\n\t\t\t       const char *data, int data_len,\n\t\t\t       u8 type, void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\tstruct fs_path *p;\n\tposix_acl_xattr_header dummy_acl;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * This hack is needed because empty acl's are stored as zero byte\n\t * data in xattrs. Problem with that is, that receiving these zero byte\n\t * acl's will fail later. To fix this, we send a dummy acl list that\n\t * only contains the version number and no entries.\n\t */\n\tif (!strncmp(name, XATTR_NAME_POSIX_ACL_ACCESS, name_len) ||\n\t    !strncmp(name, XATTR_NAME_POSIX_ACL_DEFAULT, name_len)) {\n\t\tif (data_len == 0) {\n\t\t\tdummy_acl.a_version =\n\t\t\t\t\tcpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\t\t\tdata = (char *)&dummy_acl;\n\t\t\tdata_len = sizeof(dummy_acl);\n\t\t}\n\t}\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_set_xattr(sctx, p, name, name_len, data, data_len);\n\nout:\n\tfs_path_free(p);\n\treturn ret;\n}"
  },
  {
    "function_name": "send_remove_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4107-4125",
    "snippet": "static int send_remove_xattr(struct send_ctx *sctx,\n\t\t\t  struct fs_path *path,\n\t\t\t  const char *name, int name_len)\n{\n\tint ret = 0;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_REMOVE_XATTR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\tTLV_PUT_STRING(sctx, BTRFS_SEND_A_XATTR_NAME, name, name_len);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_cmd",
          "args": [
            "sctx"
          ],
          "line": 4120
        },
        "resolved": true,
        "details": {
          "function_name": "send_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "667-688",
          "snippet": "static int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TLV_PUT_STRING",
          "args": [
            "sctx",
            "BTRFS_SEND_A_XATTR_NAME",
            "name",
            "name_len"
          ],
          "line": 4118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_PATH",
          "args": [
            "sctx",
            "BTRFS_SEND_A_PATH",
            "path"
          ],
          "line": 4117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_cmd",
          "args": [
            "sctx",
            "BTRFS_SEND_C_REMOVE_XATTR"
          ],
          "line": 4113
        },
        "resolved": true,
        "details": {
          "function_name": "begin_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "651-665",
          "snippet": "static int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_remove_xattr(struct send_ctx *sctx,\n\t\t\t  struct fs_path *path,\n\t\t\t  const char *name, int name_len)\n{\n\tint ret = 0;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_REMOVE_XATTR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\tTLV_PUT_STRING(sctx, BTRFS_SEND_A_XATTR_NAME, name, name_len);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "send_set_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4085-4105",
    "snippet": "static int send_set_xattr(struct send_ctx *sctx,\n\t\t\t  struct fs_path *path,\n\t\t\t  const char *name, int name_len,\n\t\t\t  const char *data, int data_len)\n{\n\tint ret = 0;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_SET_XATTR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\tTLV_PUT_STRING(sctx, BTRFS_SEND_A_XATTR_NAME, name, name_len);\n\tTLV_PUT(sctx, BTRFS_SEND_A_XATTR_DATA, data, data_len);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_cmd",
          "args": [
            "sctx"
          ],
          "line": 4100
        },
        "resolved": true,
        "details": {
          "function_name": "send_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "667-688",
          "snippet": "static int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TLV_PUT",
          "args": [
            "sctx",
            "BTRFS_SEND_A_XATTR_DATA",
            "data",
            "data_len"
          ],
          "line": 4098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_STRING",
          "args": [
            "sctx",
            "BTRFS_SEND_A_XATTR_NAME",
            "name",
            "name_len"
          ],
          "line": 4097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_PATH",
          "args": [
            "sctx",
            "BTRFS_SEND_A_PATH",
            "path"
          ],
          "line": 4096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_cmd",
          "args": [
            "sctx",
            "BTRFS_SEND_C_SET_XATTR"
          ],
          "line": 4092
        },
        "resolved": true,
        "details": {
          "function_name": "begin_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "651-665",
          "snippet": "static int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_set_xattr(struct send_ctx *sctx,\n\t\t\t  struct fs_path *path,\n\t\t\t  const char *name, int name_len,\n\t\t\t  const char *data, int data_len)\n{\n\tint ret = 0;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_SET_XATTR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\tTLV_PUT_STRING(sctx, BTRFS_SEND_A_XATTR_NAME, name, name_len);\n\tTLV_PUT(sctx, BTRFS_SEND_A_XATTR_DATA, data, data_len);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "process_all_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "4012-4083",
    "snippet": "static int process_all_refs(struct send_ctx *sctx,\n\t\t\t    enum btrfs_compare_tree_result cmd)\n{\n\tint ret;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\titerate_inode_ref_t cb;\n\tint pending_move = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (cmd == BTRFS_COMPARE_TREE_NEW) {\n\t\troot = sctx->send_root;\n\t\tcb = __record_new_ref;\n\t} else if (cmd == BTRFS_COMPARE_TREE_DELETED) {\n\t\troot = sctx->parent_root;\n\t\tcb = __record_deleted_ref;\n\t} else {\n\t\tbtrfs_err(sctx->send_root->fs_info,\n\t\t\t\t\"Wrong command %d in process_all_refs\", cmd);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t\t     found_key.type != BTRFS_INODE_EXTREF_KEY))\n\t\t\tbreak;\n\n\t\tret = iterate_inode_ref(root, path, &found_key, 0, cb, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tpath->slots[0]++;\n\t}\n\tbtrfs_release_path(path);\n\n\tret = process_recorded_refs(sctx, &pending_move);\n\t/* Only applicable to an incremental send. */\n\tASSERT(pending_move == 0);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 4081
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "pending_move == 0"
          ],
          "line": 4078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_recorded_refs",
          "args": [
            "sctx",
            "&pending_move"
          ],
          "line": 4076
        },
        "resolved": true,
        "details": {
          "function_name": "process_recorded_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3493-3805",
          "snippet": "static int process_recorded_refs(struct send_ctx *sctx, int *pending_move)\n{\n\tint ret = 0;\n\tstruct recorded_ref *cur;\n\tstruct recorded_ref *cur2;\n\tstruct list_head check_dirs;\n\tstruct fs_path *valid_path = NULL;\n\tu64 ow_inode = 0;\n\tu64 ow_gen;\n\tint did_overwrite = 0;\n\tint is_orphan = 0;\n\tu64 last_dir_ino_rm = 0;\n\tbool can_rename = true;\n\nverbose_printk(\"btrfs: process_recorded_refs %llu\\n\", sctx->cur_ino);\n\n\t/*\n\t * This should never happen as the root dir always has the same ref\n\t * which is always '..'\n\t */\n\tBUG_ON(sctx->cur_ino <= BTRFS_FIRST_FREE_OBJECTID);\n\tINIT_LIST_HEAD(&check_dirs);\n\n\tvalid_path = fs_path_alloc();\n\tif (!valid_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First, check if the first ref of the current inode was overwritten\n\t * before. If yes, we know that the current inode was already orphanized\n\t * and thus use the orphan name. If not, we can use get_cur_path to\n\t * get the path of the first ref as it would like while receiving at\n\t * this point in time.\n\t * New inodes are always orphan at the beginning, so force to use the\n\t * orphan name in this case.\n\t * The first ref is stored in valid_path and will be updated if it\n\t * gets moved around.\n\t */\n\tif (!sctx->cur_inode_new) {\n\t\tret = did_overwrite_first_ref(sctx, sctx->cur_ino,\n\t\t\t\tsctx->cur_inode_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret)\n\t\t\tdid_overwrite = 1;\n\t}\n\tif (sctx->cur_inode_new || did_overwrite) {\n\t\tret = gen_unique_name(sctx, sctx->cur_ino,\n\t\t\t\tsctx->cur_inode_gen, valid_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tis_orphan = 1;\n\t} else {\n\t\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tvalid_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(cur, &sctx->new_refs, list) {\n\t\t/*\n\t\t * We may have refs where the parent directory does not exist\n\t\t * yet. This happens if the parent directories inum is higher\n\t\t * the the current inum. To handle this case, we create the\n\t\t * parent directory out of order. But we need to check if this\n\t\t * did already happen before due to other refs in the same dir.\n\t\t */\n\t\tret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret == inode_state_will_create) {\n\t\t\tret = 0;\n\t\t\t/*\n\t\t\t * First check if any of the current inodes refs did\n\t\t\t * already create the dir.\n\t\t\t */\n\t\t\tlist_for_each_entry(cur2, &sctx->new_refs, list) {\n\t\t\t\tif (cur == cur2)\n\t\t\t\t\tbreak;\n\t\t\t\tif (cur2->dir == cur->dir) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If that did not happen, check if a previous inode\n\t\t\t * did already create the dir.\n\t\t\t */\n\t\t\tif (!ret)\n\t\t\t\tret = did_create_dir(sctx, cur->dir);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret) {\n\t\t\t\tret = send_create_inode(sctx, cur->dir);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Check if this new ref would overwrite the first ref of\n\t\t * another unprocessed inode. If yes, orphanize the\n\t\t * overwritten inode. If we find an overwritten ref that is\n\t\t * not the first ref, simply unlink it.\n\t\t */\n\t\tret = will_overwrite_ref(sctx, cur->dir, cur->dir_gen,\n\t\t\t\tcur->name, cur->name_len,\n\t\t\t\t&ow_inode, &ow_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = is_first_ref(sctx->parent_root,\n\t\t\t\t\t   ow_inode, cur->dir, cur->name,\n\t\t\t\t\t   cur->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret) {\n\t\t\t\tret = orphanize_inode(sctx, ow_inode, ow_gen,\n\t\t\t\t\t\tcur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tret = send_unlink(sctx, cur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (S_ISDIR(sctx->cur_inode_mode) && sctx->parent_root) {\n\t\t\tret = wait_for_dest_dir_move(sctx, cur, is_orphan);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 1) {\n\t\t\t\tcan_rename = false;\n\t\t\t\t*pending_move = 1;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * link/move the ref to the new place. If we have an orphan\n\t\t * inode, move it and update valid_path. If not, link or move\n\t\t * it depending on the inode mode.\n\t\t */\n\t\tif (is_orphan && can_rename) {\n\t\t\tret = send_rename(sctx, valid_path, cur->full_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tis_orphan = 0;\n\t\t\tret = fs_path_copy(valid_path, cur->full_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (can_rename) {\n\t\t\tif (S_ISDIR(sctx->cur_inode_mode)) {\n\t\t\t\t/*\n\t\t\t\t * Dirs can't be linked, so move it. For moved\n\t\t\t\t * dirs, we always have one new and one deleted\n\t\t\t\t * ref. The deleted ref is ignored later.\n\t\t\t\t */\n\t\t\t\tret = wait_for_parent_move(sctx, cur);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (ret) {\n\t\t\t\t\t*pending_move = 1;\n\t\t\t\t} else {\n\t\t\t\t\tret = send_rename(sctx, valid_path,\n\t\t\t\t\t\t\t  cur->full_path);\n\t\t\t\t\tif (!ret)\n\t\t\t\t\t\tret = fs_path_copy(valid_path,\n\t\t\t\t\t\t\t       cur->full_path);\n\t\t\t\t}\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tret = send_link(sctx, cur->full_path,\n\t\t\t\t\t\tvalid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = dup_ref(cur, &check_dirs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (S_ISDIR(sctx->cur_inode_mode) && sctx->cur_inode_deleted) {\n\t\t/*\n\t\t * Check if we can already rmdir the directory. If not,\n\t\t * orphanize it. For every dir item inside that gets deleted\n\t\t * later, we do this check again and rmdir it then if possible.\n\t\t * See the use of check_dirs for more details.\n\t\t */\n\t\tret = can_rmdir(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tsctx->cur_ino);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = send_rmdir(sctx, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (!is_orphan) {\n\t\t\tret = orphanize_inode(sctx, sctx->cur_ino,\n\t\t\t\t\tsctx->cur_inode_gen, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tis_orphan = 1;\n\t\t}\n\n\t\tlist_for_each_entry(cur, &sctx->deleted_refs, list) {\n\t\t\tret = dup_ref(cur, &check_dirs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t} else if (S_ISDIR(sctx->cur_inode_mode) &&\n\t\t   !list_empty(&sctx->deleted_refs)) {\n\t\t/*\n\t\t * We have a moved dir. Add the old parent to check_dirs\n\t\t */\n\t\tcur = list_entry(sctx->deleted_refs.next, struct recorded_ref,\n\t\t\t\tlist);\n\t\tret = dup_ref(cur, &check_dirs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else if (!S_ISDIR(sctx->cur_inode_mode)) {\n\t\t/*\n\t\t * We have a non dir inode. Go through all deleted refs and\n\t\t * unlink them if they were not already overwritten by other\n\t\t * inodes.\n\t\t */\n\t\tlist_for_each_entry(cur, &sctx->deleted_refs, list) {\n\t\t\tret = did_overwrite_ref(sctx, cur->dir, cur->dir_gen,\n\t\t\t\t\tsctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\t\tcur->name, cur->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret) {\n\t\t\t\tret = send_unlink(sctx, cur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = dup_ref(cur, &check_dirs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * If the inode is still orphan, unlink the orphan. This may\n\t\t * happen when a previous inode did overwrite the first ref\n\t\t * of this inode and no new refs were added for the current\n\t\t * inode. Unlinking does not mean that the inode is deleted in\n\t\t * all cases. There may still be links to this inode in other\n\t\t * places.\n\t\t */\n\t\tif (is_orphan) {\n\t\t\tret = send_unlink(sctx, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We did collect all parent dirs where cur_inode was once located. We\n\t * now go through all these dirs and check if they are pending for\n\t * deletion and if it's finally possible to perform the rmdir now.\n\t * We also update the inode stats of the parent dirs here.\n\t */\n\tlist_for_each_entry(cur, &check_dirs, list) {\n\t\t/*\n\t\t * In case we had refs into dirs that were not processed yet,\n\t\t * we don't need to do the utime and rmdir logic for these dirs.\n\t\t * The dir will be processed later.\n\t\t */\n\t\tif (cur->dir > sctx->cur_ino)\n\t\t\tcontinue;\n\n\t\tret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ret == inode_state_did_create ||\n\t\t    ret == inode_state_no_change) {\n\t\t\t/* TODO delayed utimes */\n\t\t\tret = send_utimes(sctx, cur->dir, cur->dir_gen);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (ret == inode_state_did_delete &&\n\t\t\t   cur->dir != last_dir_ino_rm) {\n\t\t\tret = can_rmdir(sctx, cur->dir, cur->dir_gen,\n\t\t\t\t\tsctx->cur_ino);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret) {\n\t\t\t\tret = get_cur_path(sctx, cur->dir,\n\t\t\t\t\t\t   cur->dir_gen, valid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tret = send_rmdir(sctx, valid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tlast_dir_ino_rm = cur->dir;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = 0;\n\nout:\n\t__free_recorded_refs(&check_dirs);\n\tfree_recorded_refs(sctx);\n\tfs_path_free(valid_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_recorded_refs(struct send_ctx *sctx, int *pending_move)\n{\n\tint ret = 0;\n\tstruct recorded_ref *cur;\n\tstruct recorded_ref *cur2;\n\tstruct list_head check_dirs;\n\tstruct fs_path *valid_path = NULL;\n\tu64 ow_inode = 0;\n\tu64 ow_gen;\n\tint did_overwrite = 0;\n\tint is_orphan = 0;\n\tu64 last_dir_ino_rm = 0;\n\tbool can_rename = true;\n\nverbose_printk(\"btrfs: process_recorded_refs %llu\\n\", sctx->cur_ino);\n\n\t/*\n\t * This should never happen as the root dir always has the same ref\n\t * which is always '..'\n\t */\n\tBUG_ON(sctx->cur_ino <= BTRFS_FIRST_FREE_OBJECTID);\n\tINIT_LIST_HEAD(&check_dirs);\n\n\tvalid_path = fs_path_alloc();\n\tif (!valid_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First, check if the first ref of the current inode was overwritten\n\t * before. If yes, we know that the current inode was already orphanized\n\t * and thus use the orphan name. If not, we can use get_cur_path to\n\t * get the path of the first ref as it would like while receiving at\n\t * this point in time.\n\t * New inodes are always orphan at the beginning, so force to use the\n\t * orphan name in this case.\n\t * The first ref is stored in valid_path and will be updated if it\n\t * gets moved around.\n\t */\n\tif (!sctx->cur_inode_new) {\n\t\tret = did_overwrite_first_ref(sctx, sctx->cur_ino,\n\t\t\t\tsctx->cur_inode_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret)\n\t\t\tdid_overwrite = 1;\n\t}\n\tif (sctx->cur_inode_new || did_overwrite) {\n\t\tret = gen_unique_name(sctx, sctx->cur_ino,\n\t\t\t\tsctx->cur_inode_gen, valid_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tis_orphan = 1;\n\t} else {\n\t\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tvalid_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(cur, &sctx->new_refs, list) {\n\t\t/*\n\t\t * We may have refs where the parent directory does not exist\n\t\t * yet. This happens if the parent directories inum is higher\n\t\t * the the current inum. To handle this case, we create the\n\t\t * parent directory out of order. But we need to check if this\n\t\t * did already happen before due to other refs in the same dir.\n\t\t */\n\t\tret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret == inode_state_will_create) {\n\t\t\tret = 0;\n\t\t\t/*\n\t\t\t * First check if any of the current inodes refs did\n\t\t\t * already create the dir.\n\t\t\t */\n\t\t\tlist_for_each_entry(cur2, &sctx->new_refs, list) {\n\t\t\t\tif (cur == cur2)\n\t\t\t\t\tbreak;\n\t\t\t\tif (cur2->dir == cur->dir) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If that did not happen, check if a previous inode\n\t\t\t * did already create the dir.\n\t\t\t */\n\t\t\tif (!ret)\n\t\t\t\tret = did_create_dir(sctx, cur->dir);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret) {\n\t\t\t\tret = send_create_inode(sctx, cur->dir);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Check if this new ref would overwrite the first ref of\n\t\t * another unprocessed inode. If yes, orphanize the\n\t\t * overwritten inode. If we find an overwritten ref that is\n\t\t * not the first ref, simply unlink it.\n\t\t */\n\t\tret = will_overwrite_ref(sctx, cur->dir, cur->dir_gen,\n\t\t\t\tcur->name, cur->name_len,\n\t\t\t\t&ow_inode, &ow_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = is_first_ref(sctx->parent_root,\n\t\t\t\t\t   ow_inode, cur->dir, cur->name,\n\t\t\t\t\t   cur->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret) {\n\t\t\t\tret = orphanize_inode(sctx, ow_inode, ow_gen,\n\t\t\t\t\t\tcur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tret = send_unlink(sctx, cur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (S_ISDIR(sctx->cur_inode_mode) && sctx->parent_root) {\n\t\t\tret = wait_for_dest_dir_move(sctx, cur, is_orphan);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 1) {\n\t\t\t\tcan_rename = false;\n\t\t\t\t*pending_move = 1;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * link/move the ref to the new place. If we have an orphan\n\t\t * inode, move it and update valid_path. If not, link or move\n\t\t * it depending on the inode mode.\n\t\t */\n\t\tif (is_orphan && can_rename) {\n\t\t\tret = send_rename(sctx, valid_path, cur->full_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tis_orphan = 0;\n\t\t\tret = fs_path_copy(valid_path, cur->full_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (can_rename) {\n\t\t\tif (S_ISDIR(sctx->cur_inode_mode)) {\n\t\t\t\t/*\n\t\t\t\t * Dirs can't be linked, so move it. For moved\n\t\t\t\t * dirs, we always have one new and one deleted\n\t\t\t\t * ref. The deleted ref is ignored later.\n\t\t\t\t */\n\t\t\t\tret = wait_for_parent_move(sctx, cur);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (ret) {\n\t\t\t\t\t*pending_move = 1;\n\t\t\t\t} else {\n\t\t\t\t\tret = send_rename(sctx, valid_path,\n\t\t\t\t\t\t\t  cur->full_path);\n\t\t\t\t\tif (!ret)\n\t\t\t\t\t\tret = fs_path_copy(valid_path,\n\t\t\t\t\t\t\t       cur->full_path);\n\t\t\t\t}\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tret = send_link(sctx, cur->full_path,\n\t\t\t\t\t\tvalid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = dup_ref(cur, &check_dirs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (S_ISDIR(sctx->cur_inode_mode) && sctx->cur_inode_deleted) {\n\t\t/*\n\t\t * Check if we can already rmdir the directory. If not,\n\t\t * orphanize it. For every dir item inside that gets deleted\n\t\t * later, we do this check again and rmdir it then if possible.\n\t\t * See the use of check_dirs for more details.\n\t\t */\n\t\tret = can_rmdir(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tsctx->cur_ino);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = send_rmdir(sctx, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (!is_orphan) {\n\t\t\tret = orphanize_inode(sctx, sctx->cur_ino,\n\t\t\t\t\tsctx->cur_inode_gen, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tis_orphan = 1;\n\t\t}\n\n\t\tlist_for_each_entry(cur, &sctx->deleted_refs, list) {\n\t\t\tret = dup_ref(cur, &check_dirs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t} else if (S_ISDIR(sctx->cur_inode_mode) &&\n\t\t   !list_empty(&sctx->deleted_refs)) {\n\t\t/*\n\t\t * We have a moved dir. Add the old parent to check_dirs\n\t\t */\n\t\tcur = list_entry(sctx->deleted_refs.next, struct recorded_ref,\n\t\t\t\tlist);\n\t\tret = dup_ref(cur, &check_dirs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else if (!S_ISDIR(sctx->cur_inode_mode)) {\n\t\t/*\n\t\t * We have a non dir inode. Go through all deleted refs and\n\t\t * unlink them if they were not already overwritten by other\n\t\t * inodes.\n\t\t */\n\t\tlist_for_each_entry(cur, &sctx->deleted_refs, list) {\n\t\t\tret = did_overwrite_ref(sctx, cur->dir, cur->dir_gen,\n\t\t\t\t\tsctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\t\tcur->name, cur->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret) {\n\t\t\t\tret = send_unlink(sctx, cur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = dup_ref(cur, &check_dirs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * If the inode is still orphan, unlink the orphan. This may\n\t\t * happen when a previous inode did overwrite the first ref\n\t\t * of this inode and no new refs were added for the current\n\t\t * inode. Unlinking does not mean that the inode is deleted in\n\t\t * all cases. There may still be links to this inode in other\n\t\t * places.\n\t\t */\n\t\tif (is_orphan) {\n\t\t\tret = send_unlink(sctx, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We did collect all parent dirs where cur_inode was once located. We\n\t * now go through all these dirs and check if they are pending for\n\t * deletion and if it's finally possible to perform the rmdir now.\n\t * We also update the inode stats of the parent dirs here.\n\t */\n\tlist_for_each_entry(cur, &check_dirs, list) {\n\t\t/*\n\t\t * In case we had refs into dirs that were not processed yet,\n\t\t * we don't need to do the utime and rmdir logic for these dirs.\n\t\t * The dir will be processed later.\n\t\t */\n\t\tif (cur->dir > sctx->cur_ino)\n\t\t\tcontinue;\n\n\t\tret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ret == inode_state_did_create ||\n\t\t    ret == inode_state_no_change) {\n\t\t\t/* TODO delayed utimes */\n\t\t\tret = send_utimes(sctx, cur->dir, cur->dir_gen);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (ret == inode_state_did_delete &&\n\t\t\t   cur->dir != last_dir_ino_rm) {\n\t\t\tret = can_rmdir(sctx, cur->dir, cur->dir_gen,\n\t\t\t\t\tsctx->cur_ino);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret) {\n\t\t\t\tret = get_cur_path(sctx, cur->dir,\n\t\t\t\t\t\t   cur->dir_gen, valid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tret = send_rmdir(sctx, valid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tlast_dir_ino_rm = cur->dir;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = 0;\n\nout:\n\t__free_recorded_refs(&check_dirs);\n\tfree_recorded_refs(sctx);\n\tfs_path_free(valid_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 4074
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_inode_ref",
          "args": [
            "root",
            "path",
            "&found_key",
            "0",
            "cb",
            "sctx"
          ],
          "line": 4068
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_inode_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "850-956",
          "snippet": "static int iterate_inode_ref(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *found_key, int resolve,\n\t\t\t     iterate_inode_ref_t iterate, void *ctx)\n{\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct btrfs_item *item;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_inode_extref *extref;\n\tstruct btrfs_path *tmp_path;\n\tstruct fs_path *p;\n\tu32 cur = 0;\n\tu32 total;\n\tint slot = path->slots[0];\n\tu32 name_len;\n\tchar *start;\n\tint ret = 0;\n\tint num = 0;\n\tint index;\n\tu64 dir;\n\tunsigned long name_off;\n\tunsigned long elem_size;\n\tunsigned long ptr;\n\n\tp = fs_path_alloc_reversed();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path) {\n\t\tfs_path_free(p);\n\t\treturn -ENOMEM;\n\t}\n\n\n\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\tptr = (unsigned long)btrfs_item_ptr(eb, slot,\n\t\t\t\t\t\t    struct btrfs_inode_ref);\n\t\titem = btrfs_item_nr(slot);\n\t\ttotal = btrfs_item_size(eb, item);\n\t\telem_size = sizeof(*iref);\n\t} else {\n\t\tptr = btrfs_item_ptr_offset(eb, slot);\n\t\ttotal = btrfs_item_size_nr(eb, slot);\n\t\telem_size = sizeof(*extref);\n\t}\n\n\twhile (cur < total) {\n\t\tfs_path_reset(p);\n\n\t\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\t\tiref = (struct btrfs_inode_ref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\tname_off = (unsigned long)(iref + 1);\n\t\t\tindex = btrfs_inode_ref_index(eb, iref);\n\t\t\tdir = found_key->offset;\n\t\t} else {\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tname_off = (unsigned long)&extref->name;\n\t\t\tindex = btrfs_inode_extref_index(eb, extref);\n\t\t\tdir = btrfs_inode_extref_parent(eb, extref);\n\t\t}\n\n\t\tif (resolve) {\n\t\t\tstart = btrfs_ref_to_path(root, tmp_path, name_len,\n\t\t\t\t\t\t  name_off, eb, dir,\n\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\tif (IS_ERR(start)) {\n\t\t\t\tret = PTR_ERR(start);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (start < p->buf) {\n\t\t\t\t/* overflow , try again with larger buffer */\n\t\t\t\tret = fs_path_ensure_buf(p,\n\t\t\t\t\t\tp->buf_len + p->buf - start);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tstart = btrfs_ref_to_path(root, tmp_path,\n\t\t\t\t\t\t\t  name_len, name_off,\n\t\t\t\t\t\t\t  eb, dir,\n\t\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\t\tif (IS_ERR(start)) {\n\t\t\t\t\tret = PTR_ERR(start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tBUG_ON(start < p->buf);\n\t\t\t}\n\t\t\tp->start = start;\n\t\t} else {\n\t\t\tret = fs_path_add_from_extent_buffer(p, eb, name_off,\n\t\t\t\t\t\t\t     name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcur += elem_size + name_len;\n\t\tret = iterate(num, dir, index, p, ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnum++;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tfs_path_free(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int iterate_inode_ref(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *found_key, int resolve,\n\t\t\t     iterate_inode_ref_t iterate, void *ctx)\n{\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct btrfs_item *item;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_inode_extref *extref;\n\tstruct btrfs_path *tmp_path;\n\tstruct fs_path *p;\n\tu32 cur = 0;\n\tu32 total;\n\tint slot = path->slots[0];\n\tu32 name_len;\n\tchar *start;\n\tint ret = 0;\n\tint num = 0;\n\tint index;\n\tu64 dir;\n\tunsigned long name_off;\n\tunsigned long elem_size;\n\tunsigned long ptr;\n\n\tp = fs_path_alloc_reversed();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path) {\n\t\tfs_path_free(p);\n\t\treturn -ENOMEM;\n\t}\n\n\n\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\tptr = (unsigned long)btrfs_item_ptr(eb, slot,\n\t\t\t\t\t\t    struct btrfs_inode_ref);\n\t\titem = btrfs_item_nr(slot);\n\t\ttotal = btrfs_item_size(eb, item);\n\t\telem_size = sizeof(*iref);\n\t} else {\n\t\tptr = btrfs_item_ptr_offset(eb, slot);\n\t\ttotal = btrfs_item_size_nr(eb, slot);\n\t\telem_size = sizeof(*extref);\n\t}\n\n\twhile (cur < total) {\n\t\tfs_path_reset(p);\n\n\t\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\t\tiref = (struct btrfs_inode_ref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\tname_off = (unsigned long)(iref + 1);\n\t\t\tindex = btrfs_inode_ref_index(eb, iref);\n\t\t\tdir = found_key->offset;\n\t\t} else {\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tname_off = (unsigned long)&extref->name;\n\t\t\tindex = btrfs_inode_extref_index(eb, extref);\n\t\t\tdir = btrfs_inode_extref_parent(eb, extref);\n\t\t}\n\n\t\tif (resolve) {\n\t\t\tstart = btrfs_ref_to_path(root, tmp_path, name_len,\n\t\t\t\t\t\t  name_off, eb, dir,\n\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\tif (IS_ERR(start)) {\n\t\t\t\tret = PTR_ERR(start);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (start < p->buf) {\n\t\t\t\t/* overflow , try again with larger buffer */\n\t\t\t\tret = fs_path_ensure_buf(p,\n\t\t\t\t\t\tp->buf_len + p->buf - start);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tstart = btrfs_ref_to_path(root, tmp_path,\n\t\t\t\t\t\t\t  name_len, name_off,\n\t\t\t\t\t\t\t  eb, dir,\n\t\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\t\tif (IS_ERR(start)) {\n\t\t\t\t\tret = PTR_ERR(start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tBUG_ON(start < p->buf);\n\t\t\t}\n\t\t\tp->start = start;\n\t\t} else {\n\t\t\tret = fs_path_add_from_extent_buffer(p, eb, name_off,\n\t\t\t\t\t\t\t     name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcur += elem_size + name_len;\n\t\tret = iterate(num, dir, index, p, ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnum++;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tfs_path_free(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "eb",
            "&found_key",
            "slot"
          ],
          "line": 4061
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 4053
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "eb"
          ],
          "line": 4052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 4045
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "sctx->send_root->fs_info",
            "\"Wrong command %d in process_all_refs\"",
            "cmd"
          ],
          "line": 4036
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_path_for_send",
          "args": [],
          "line": 4025
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_path_for_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "496-507",
          "snippet": "static struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_all_refs(struct send_ctx *sctx,\n\t\t\t    enum btrfs_compare_tree_result cmd)\n{\n\tint ret;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\titerate_inode_ref_t cb;\n\tint pending_move = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (cmd == BTRFS_COMPARE_TREE_NEW) {\n\t\troot = sctx->send_root;\n\t\tcb = __record_new_ref;\n\t} else if (cmd == BTRFS_COMPARE_TREE_DELETED) {\n\t\troot = sctx->parent_root;\n\t\tcb = __record_deleted_ref;\n\t} else {\n\t\tbtrfs_err(sctx->send_root->fs_info,\n\t\t\t\t\"Wrong command %d in process_all_refs\", cmd);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t\t     found_key.type != BTRFS_INODE_EXTREF_KEY))\n\t\t\tbreak;\n\n\t\tret = iterate_inode_ref(root, path, &found_key, 0, cb, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tpath->slots[0]++;\n\t}\n\tbtrfs_release_path(path);\n\n\tret = process_recorded_refs(sctx, &pending_move);\n\t/* Only applicable to an incremental send. */\n\tASSERT(pending_move == 0);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "record_changed_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "3990-4006",
    "snippet": "static int record_changed_ref(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\tret = iterate_inode_ref(sctx->send_root, sctx->left_path,\n\t\t\tsctx->cmp_key, 0, __record_changed_new_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = iterate_inode_ref(sctx->parent_root, sctx->right_path,\n\t\t\tsctx->cmp_key, 0, __record_changed_deleted_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterate_inode_ref",
          "args": [
            "sctx->parent_root",
            "sctx->right_path",
            "sctx->cmp_key",
            "0",
            "__record_changed_deleted_ref",
            "sctx"
          ],
          "line": 3998
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_inode_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "850-956",
          "snippet": "static int iterate_inode_ref(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *found_key, int resolve,\n\t\t\t     iterate_inode_ref_t iterate, void *ctx)\n{\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct btrfs_item *item;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_inode_extref *extref;\n\tstruct btrfs_path *tmp_path;\n\tstruct fs_path *p;\n\tu32 cur = 0;\n\tu32 total;\n\tint slot = path->slots[0];\n\tu32 name_len;\n\tchar *start;\n\tint ret = 0;\n\tint num = 0;\n\tint index;\n\tu64 dir;\n\tunsigned long name_off;\n\tunsigned long elem_size;\n\tunsigned long ptr;\n\n\tp = fs_path_alloc_reversed();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path) {\n\t\tfs_path_free(p);\n\t\treturn -ENOMEM;\n\t}\n\n\n\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\tptr = (unsigned long)btrfs_item_ptr(eb, slot,\n\t\t\t\t\t\t    struct btrfs_inode_ref);\n\t\titem = btrfs_item_nr(slot);\n\t\ttotal = btrfs_item_size(eb, item);\n\t\telem_size = sizeof(*iref);\n\t} else {\n\t\tptr = btrfs_item_ptr_offset(eb, slot);\n\t\ttotal = btrfs_item_size_nr(eb, slot);\n\t\telem_size = sizeof(*extref);\n\t}\n\n\twhile (cur < total) {\n\t\tfs_path_reset(p);\n\n\t\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\t\tiref = (struct btrfs_inode_ref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\tname_off = (unsigned long)(iref + 1);\n\t\t\tindex = btrfs_inode_ref_index(eb, iref);\n\t\t\tdir = found_key->offset;\n\t\t} else {\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tname_off = (unsigned long)&extref->name;\n\t\t\tindex = btrfs_inode_extref_index(eb, extref);\n\t\t\tdir = btrfs_inode_extref_parent(eb, extref);\n\t\t}\n\n\t\tif (resolve) {\n\t\t\tstart = btrfs_ref_to_path(root, tmp_path, name_len,\n\t\t\t\t\t\t  name_off, eb, dir,\n\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\tif (IS_ERR(start)) {\n\t\t\t\tret = PTR_ERR(start);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (start < p->buf) {\n\t\t\t\t/* overflow , try again with larger buffer */\n\t\t\t\tret = fs_path_ensure_buf(p,\n\t\t\t\t\t\tp->buf_len + p->buf - start);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tstart = btrfs_ref_to_path(root, tmp_path,\n\t\t\t\t\t\t\t  name_len, name_off,\n\t\t\t\t\t\t\t  eb, dir,\n\t\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\t\tif (IS_ERR(start)) {\n\t\t\t\t\tret = PTR_ERR(start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tBUG_ON(start < p->buf);\n\t\t\t}\n\t\t\tp->start = start;\n\t\t} else {\n\t\t\tret = fs_path_add_from_extent_buffer(p, eb, name_off,\n\t\t\t\t\t\t\t     name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcur += elem_size + name_len;\n\t\tret = iterate(num, dir, index, p, ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnum++;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tfs_path_free(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int iterate_inode_ref(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *found_key, int resolve,\n\t\t\t     iterate_inode_ref_t iterate, void *ctx)\n{\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct btrfs_item *item;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_inode_extref *extref;\n\tstruct btrfs_path *tmp_path;\n\tstruct fs_path *p;\n\tu32 cur = 0;\n\tu32 total;\n\tint slot = path->slots[0];\n\tu32 name_len;\n\tchar *start;\n\tint ret = 0;\n\tint num = 0;\n\tint index;\n\tu64 dir;\n\tunsigned long name_off;\n\tunsigned long elem_size;\n\tunsigned long ptr;\n\n\tp = fs_path_alloc_reversed();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path) {\n\t\tfs_path_free(p);\n\t\treturn -ENOMEM;\n\t}\n\n\n\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\tptr = (unsigned long)btrfs_item_ptr(eb, slot,\n\t\t\t\t\t\t    struct btrfs_inode_ref);\n\t\titem = btrfs_item_nr(slot);\n\t\ttotal = btrfs_item_size(eb, item);\n\t\telem_size = sizeof(*iref);\n\t} else {\n\t\tptr = btrfs_item_ptr_offset(eb, slot);\n\t\ttotal = btrfs_item_size_nr(eb, slot);\n\t\telem_size = sizeof(*extref);\n\t}\n\n\twhile (cur < total) {\n\t\tfs_path_reset(p);\n\n\t\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\t\tiref = (struct btrfs_inode_ref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\tname_off = (unsigned long)(iref + 1);\n\t\t\tindex = btrfs_inode_ref_index(eb, iref);\n\t\t\tdir = found_key->offset;\n\t\t} else {\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tname_off = (unsigned long)&extref->name;\n\t\t\tindex = btrfs_inode_extref_index(eb, extref);\n\t\t\tdir = btrfs_inode_extref_parent(eb, extref);\n\t\t}\n\n\t\tif (resolve) {\n\t\t\tstart = btrfs_ref_to_path(root, tmp_path, name_len,\n\t\t\t\t\t\t  name_off, eb, dir,\n\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\tif (IS_ERR(start)) {\n\t\t\t\tret = PTR_ERR(start);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (start < p->buf) {\n\t\t\t\t/* overflow , try again with larger buffer */\n\t\t\t\tret = fs_path_ensure_buf(p,\n\t\t\t\t\t\tp->buf_len + p->buf - start);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tstart = btrfs_ref_to_path(root, tmp_path,\n\t\t\t\t\t\t\t  name_len, name_off,\n\t\t\t\t\t\t\t  eb, dir,\n\t\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\t\tif (IS_ERR(start)) {\n\t\t\t\t\tret = PTR_ERR(start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tBUG_ON(start < p->buf);\n\t\t\t}\n\t\t\tp->start = start;\n\t\t} else {\n\t\t\tret = fs_path_add_from_extent_buffer(p, eb, name_off,\n\t\t\t\t\t\t\t     name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcur += elem_size + name_len;\n\t\tret = iterate(num, dir, index, p, ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnum++;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tfs_path_free(p);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int record_changed_ref(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\tret = iterate_inode_ref(sctx->send_root, sctx->left_path,\n\t\t\tsctx->cmp_key, 0, __record_changed_new_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = iterate_inode_ref(sctx->parent_root, sctx->right_path,\n\t\t\tsctx->cmp_key, 0, __record_changed_deleted_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "__record_changed_deleted_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "3967-3988",
    "snippet": "static int __record_changed_deleted_ref(int num, u64 dir, int index,\n\t\t\t\t\tstruct fs_path *name,\n\t\t\t\t\tvoid *ctx)\n{\n\tu64 dir_gen;\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\n\tret = get_inode_info(sctx->parent_root, dir, NULL, &dir_gen, NULL,\n\t\t\t     NULL, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = find_iref(sctx->send_root, sctx->left_path, sctx->cmp_key,\n\t\t\tdir, dir_gen, name);\n\tif (ret == -ENOENT)\n\t\tret = __record_deleted_ref(num, dir, index, name, sctx);\n\telse if (ret > 0)\n\t\tret = 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__record_deleted_ref",
          "args": [
            "num",
            "dir",
            "index",
            "name",
            "sctx"
          ],
          "line": 3983
        },
        "resolved": true,
        "details": {
          "function_name": "__record_deleted_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3849-3856",
          "snippet": "static int __record_deleted_ref(int num, u64 dir, int index,\n\t\t\t\tstruct fs_path *name,\n\t\t\t\tvoid *ctx)\n{\n\tstruct send_ctx *sctx = ctx;\n\treturn record_ref(sctx->parent_root, num, dir, index, name,\n\t\t\t  ctx, &sctx->deleted_refs);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int __record_deleted_ref(int num, u64 dir, int index,\n\t\t\t\tstruct fs_path *name,\n\t\t\t\tvoid *ctx)\n{\n\tstruct send_ctx *sctx = ctx;\n\treturn record_ref(sctx->parent_root, num, dir, index, name,\n\t\t\t  ctx, &sctx->deleted_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_iref",
          "args": [
            "sctx->send_root",
            "sctx->left_path",
            "sctx->cmp_key",
            "dir",
            "dir_gen",
            "name"
          ],
          "line": 3980
        },
        "resolved": true,
        "details": {
          "function_name": "find_iref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3920-3942",
          "snippet": "static int find_iref(struct btrfs_root *root,\n\t\t     struct btrfs_path *path,\n\t\t     struct btrfs_key *key,\n\t\t     u64 dir, u64 dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct find_ref_ctx ctx;\n\n\tctx.dir = dir;\n\tctx.name = name;\n\tctx.dir_gen = dir_gen;\n\tctx.found_idx = -1;\n\tctx.root = root;\n\n\tret = iterate_inode_ref(root, path, key, 0, __find_iref, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ctx.found_idx == -1)\n\t\treturn -ENOENT;\n\n\treturn ctx.found_idx;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int find_iref(struct btrfs_root *root,\n\t\t     struct btrfs_path *path,\n\t\t     struct btrfs_key *key,\n\t\t     u64 dir, u64 dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct find_ref_ctx ctx;\n\n\tctx.dir = dir;\n\tctx.name = name;\n\tctx.dir_gen = dir_gen;\n\tctx.found_idx = -1;\n\tctx.root = root;\n\n\tret = iterate_inode_ref(root, path, key, 0, __find_iref, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ctx.found_idx == -1)\n\t\treturn -ENOENT;\n\n\treturn ctx.found_idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode_info",
          "args": [
            "sctx->parent_root",
            "dir",
            "NULL",
            "&dir_gen",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 3975
        },
        "resolved": true,
        "details": {
          "function_name": "get_inode_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "821-836",
          "snippet": "static int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int __record_changed_deleted_ref(int num, u64 dir, int index,\n\t\t\t\t\tstruct fs_path *name,\n\t\t\t\t\tvoid *ctx)\n{\n\tu64 dir_gen;\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\n\tret = get_inode_info(sctx->parent_root, dir, NULL, &dir_gen, NULL,\n\t\t\t     NULL, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = find_iref(sctx->send_root, sctx->left_path, sctx->cmp_key,\n\t\t\tdir, dir_gen, name);\n\tif (ret == -ENOENT)\n\t\tret = __record_deleted_ref(num, dir, index, name, sctx);\n\telse if (ret > 0)\n\t\tret = 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__record_changed_new_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "3944-3965",
    "snippet": "static int __record_changed_new_ref(int num, u64 dir, int index,\n\t\t\t\t    struct fs_path *name,\n\t\t\t\t    void *ctx)\n{\n\tu64 dir_gen;\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\n\tret = get_inode_info(sctx->send_root, dir, NULL, &dir_gen, NULL,\n\t\t\t     NULL, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = find_iref(sctx->parent_root, sctx->right_path,\n\t\t\tsctx->cmp_key, dir, dir_gen, name);\n\tif (ret == -ENOENT)\n\t\tret = __record_new_ref(num, dir, index, name, sctx);\n\telse if (ret > 0)\n\t\tret = 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__record_new_ref",
          "args": [
            "num",
            "dir",
            "index",
            "name",
            "sctx"
          ],
          "line": 3960
        },
        "resolved": true,
        "details": {
          "function_name": "__record_new_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3839-3846",
          "snippet": "static int __record_new_ref(int num, u64 dir, int index,\n\t\t\t    struct fs_path *name,\n\t\t\t    void *ctx)\n{\n\tstruct send_ctx *sctx = ctx;\n\treturn record_ref(sctx->send_root, num, dir, index, name,\n\t\t\t  ctx, &sctx->new_refs);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int __record_new_ref(int num, u64 dir, int index,\n\t\t\t    struct fs_path *name,\n\t\t\t    void *ctx)\n{\n\tstruct send_ctx *sctx = ctx;\n\treturn record_ref(sctx->send_root, num, dir, index, name,\n\t\t\t  ctx, &sctx->new_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_iref",
          "args": [
            "sctx->parent_root",
            "sctx->right_path",
            "sctx->cmp_key",
            "dir",
            "dir_gen",
            "name"
          ],
          "line": 3957
        },
        "resolved": true,
        "details": {
          "function_name": "find_iref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3920-3942",
          "snippet": "static int find_iref(struct btrfs_root *root,\n\t\t     struct btrfs_path *path,\n\t\t     struct btrfs_key *key,\n\t\t     u64 dir, u64 dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct find_ref_ctx ctx;\n\n\tctx.dir = dir;\n\tctx.name = name;\n\tctx.dir_gen = dir_gen;\n\tctx.found_idx = -1;\n\tctx.root = root;\n\n\tret = iterate_inode_ref(root, path, key, 0, __find_iref, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ctx.found_idx == -1)\n\t\treturn -ENOENT;\n\n\treturn ctx.found_idx;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int find_iref(struct btrfs_root *root,\n\t\t     struct btrfs_path *path,\n\t\t     struct btrfs_key *key,\n\t\t     u64 dir, u64 dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct find_ref_ctx ctx;\n\n\tctx.dir = dir;\n\tctx.name = name;\n\tctx.dir_gen = dir_gen;\n\tctx.found_idx = -1;\n\tctx.root = root;\n\n\tret = iterate_inode_ref(root, path, key, 0, __find_iref, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ctx.found_idx == -1)\n\t\treturn -ENOENT;\n\n\treturn ctx.found_idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode_info",
          "args": [
            "sctx->send_root",
            "dir",
            "NULL",
            "&dir_gen",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 3952
        },
        "resolved": true,
        "details": {
          "function_name": "get_inode_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "821-836",
          "snippet": "static int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int __record_changed_new_ref(int num, u64 dir, int index,\n\t\t\t\t    struct fs_path *name,\n\t\t\t\t    void *ctx)\n{\n\tu64 dir_gen;\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\n\tret = get_inode_info(sctx->send_root, dir, NULL, &dir_gen, NULL,\n\t\t\t     NULL, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = find_iref(sctx->parent_root, sctx->right_path,\n\t\t\tsctx->cmp_key, dir, dir_gen, name);\n\tif (ret == -ENOENT)\n\t\tret = __record_new_ref(num, dir, index, name, sctx);\n\telse if (ret > 0)\n\t\tret = 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "find_iref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "3920-3942",
    "snippet": "static int find_iref(struct btrfs_root *root,\n\t\t     struct btrfs_path *path,\n\t\t     struct btrfs_key *key,\n\t\t     u64 dir, u64 dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct find_ref_ctx ctx;\n\n\tctx.dir = dir;\n\tctx.name = name;\n\tctx.dir_gen = dir_gen;\n\tctx.found_idx = -1;\n\tctx.root = root;\n\n\tret = iterate_inode_ref(root, path, key, 0, __find_iref, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ctx.found_idx == -1)\n\t\treturn -ENOENT;\n\n\treturn ctx.found_idx;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterate_inode_ref",
          "args": [
            "root",
            "path",
            "key",
            "0",
            "__find_iref",
            "&ctx"
          ],
          "line": 3934
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_inode_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "850-956",
          "snippet": "static int iterate_inode_ref(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *found_key, int resolve,\n\t\t\t     iterate_inode_ref_t iterate, void *ctx)\n{\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct btrfs_item *item;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_inode_extref *extref;\n\tstruct btrfs_path *tmp_path;\n\tstruct fs_path *p;\n\tu32 cur = 0;\n\tu32 total;\n\tint slot = path->slots[0];\n\tu32 name_len;\n\tchar *start;\n\tint ret = 0;\n\tint num = 0;\n\tint index;\n\tu64 dir;\n\tunsigned long name_off;\n\tunsigned long elem_size;\n\tunsigned long ptr;\n\n\tp = fs_path_alloc_reversed();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path) {\n\t\tfs_path_free(p);\n\t\treturn -ENOMEM;\n\t}\n\n\n\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\tptr = (unsigned long)btrfs_item_ptr(eb, slot,\n\t\t\t\t\t\t    struct btrfs_inode_ref);\n\t\titem = btrfs_item_nr(slot);\n\t\ttotal = btrfs_item_size(eb, item);\n\t\telem_size = sizeof(*iref);\n\t} else {\n\t\tptr = btrfs_item_ptr_offset(eb, slot);\n\t\ttotal = btrfs_item_size_nr(eb, slot);\n\t\telem_size = sizeof(*extref);\n\t}\n\n\twhile (cur < total) {\n\t\tfs_path_reset(p);\n\n\t\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\t\tiref = (struct btrfs_inode_ref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\tname_off = (unsigned long)(iref + 1);\n\t\t\tindex = btrfs_inode_ref_index(eb, iref);\n\t\t\tdir = found_key->offset;\n\t\t} else {\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tname_off = (unsigned long)&extref->name;\n\t\t\tindex = btrfs_inode_extref_index(eb, extref);\n\t\t\tdir = btrfs_inode_extref_parent(eb, extref);\n\t\t}\n\n\t\tif (resolve) {\n\t\t\tstart = btrfs_ref_to_path(root, tmp_path, name_len,\n\t\t\t\t\t\t  name_off, eb, dir,\n\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\tif (IS_ERR(start)) {\n\t\t\t\tret = PTR_ERR(start);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (start < p->buf) {\n\t\t\t\t/* overflow , try again with larger buffer */\n\t\t\t\tret = fs_path_ensure_buf(p,\n\t\t\t\t\t\tp->buf_len + p->buf - start);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tstart = btrfs_ref_to_path(root, tmp_path,\n\t\t\t\t\t\t\t  name_len, name_off,\n\t\t\t\t\t\t\t  eb, dir,\n\t\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\t\tif (IS_ERR(start)) {\n\t\t\t\t\tret = PTR_ERR(start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tBUG_ON(start < p->buf);\n\t\t\t}\n\t\t\tp->start = start;\n\t\t} else {\n\t\t\tret = fs_path_add_from_extent_buffer(p, eb, name_off,\n\t\t\t\t\t\t\t     name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcur += elem_size + name_len;\n\t\tret = iterate(num, dir, index, p, ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnum++;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tfs_path_free(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int iterate_inode_ref(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *found_key, int resolve,\n\t\t\t     iterate_inode_ref_t iterate, void *ctx)\n{\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct btrfs_item *item;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_inode_extref *extref;\n\tstruct btrfs_path *tmp_path;\n\tstruct fs_path *p;\n\tu32 cur = 0;\n\tu32 total;\n\tint slot = path->slots[0];\n\tu32 name_len;\n\tchar *start;\n\tint ret = 0;\n\tint num = 0;\n\tint index;\n\tu64 dir;\n\tunsigned long name_off;\n\tunsigned long elem_size;\n\tunsigned long ptr;\n\n\tp = fs_path_alloc_reversed();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path) {\n\t\tfs_path_free(p);\n\t\treturn -ENOMEM;\n\t}\n\n\n\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\tptr = (unsigned long)btrfs_item_ptr(eb, slot,\n\t\t\t\t\t\t    struct btrfs_inode_ref);\n\t\titem = btrfs_item_nr(slot);\n\t\ttotal = btrfs_item_size(eb, item);\n\t\telem_size = sizeof(*iref);\n\t} else {\n\t\tptr = btrfs_item_ptr_offset(eb, slot);\n\t\ttotal = btrfs_item_size_nr(eb, slot);\n\t\telem_size = sizeof(*extref);\n\t}\n\n\twhile (cur < total) {\n\t\tfs_path_reset(p);\n\n\t\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\t\tiref = (struct btrfs_inode_ref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\tname_off = (unsigned long)(iref + 1);\n\t\t\tindex = btrfs_inode_ref_index(eb, iref);\n\t\t\tdir = found_key->offset;\n\t\t} else {\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tname_off = (unsigned long)&extref->name;\n\t\t\tindex = btrfs_inode_extref_index(eb, extref);\n\t\t\tdir = btrfs_inode_extref_parent(eb, extref);\n\t\t}\n\n\t\tif (resolve) {\n\t\t\tstart = btrfs_ref_to_path(root, tmp_path, name_len,\n\t\t\t\t\t\t  name_off, eb, dir,\n\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\tif (IS_ERR(start)) {\n\t\t\t\tret = PTR_ERR(start);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (start < p->buf) {\n\t\t\t\t/* overflow , try again with larger buffer */\n\t\t\t\tret = fs_path_ensure_buf(p,\n\t\t\t\t\t\tp->buf_len + p->buf - start);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tstart = btrfs_ref_to_path(root, tmp_path,\n\t\t\t\t\t\t\t  name_len, name_off,\n\t\t\t\t\t\t\t  eb, dir,\n\t\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\t\tif (IS_ERR(start)) {\n\t\t\t\t\tret = PTR_ERR(start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tBUG_ON(start < p->buf);\n\t\t\t}\n\t\t\tp->start = start;\n\t\t} else {\n\t\t\tret = fs_path_add_from_extent_buffer(p, eb, name_off,\n\t\t\t\t\t\t\t     name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcur += elem_size + name_len;\n\t\tret = iterate(num, dir, index, p, ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnum++;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tfs_path_free(p);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int find_iref(struct btrfs_root *root,\n\t\t     struct btrfs_path *path,\n\t\t     struct btrfs_key *key,\n\t\t     u64 dir, u64 dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct find_ref_ctx ctx;\n\n\tctx.dir = dir;\n\tctx.name = name;\n\tctx.dir_gen = dir_gen;\n\tctx.found_idx = -1;\n\tctx.root = root;\n\n\tret = iterate_inode_ref(root, path, key, 0, __find_iref, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ctx.found_idx == -1)\n\t\treturn -ENOENT;\n\n\treturn ctx.found_idx;\n}"
  },
  {
    "function_name": "__find_iref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "3894-3918",
    "snippet": "static int __find_iref(int num, u64 dir, int index,\n\t\t       struct fs_path *name,\n\t\t       void *ctx_)\n{\n\tstruct find_ref_ctx *ctx = ctx_;\n\tu64 dir_gen;\n\tint ret;\n\n\tif (dir == ctx->dir && fs_path_len(name) == fs_path_len(ctx->name) &&\n\t    strncmp(name->start, ctx->name->start, fs_path_len(name)) == 0) {\n\t\t/*\n\t\t * To avoid doing extra lookups we'll only do this if everything\n\t\t * else matches.\n\t\t */\n\t\tret = get_inode_info(ctx->root, dir, NULL, &dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (dir_gen != ctx->dir_gen)\n\t\t\treturn 0;\n\t\tctx->found_idx = num;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_inode_info",
          "args": [
            "ctx->root",
            "dir",
            "NULL",
            "&dir_gen",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 3908
        },
        "resolved": true,
        "details": {
          "function_name": "get_inode_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "821-836",
          "snippet": "static int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name->start",
            "ctx->name->start",
            "fs_path_len(name)"
          ],
          "line": 3903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_path_len",
          "args": [
            "name"
          ],
          "line": 3903
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "337-340",
          "snippet": "static int fs_path_len(struct fs_path *p)\n{\n\treturn p->end - p->start;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_len(struct fs_path *p)\n{\n\treturn p->end - p->start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int __find_iref(int num, u64 dir, int index,\n\t\t       struct fs_path *name,\n\t\t       void *ctx_)\n{\n\tstruct find_ref_ctx *ctx = ctx_;\n\tu64 dir_gen;\n\tint ret;\n\n\tif (dir == ctx->dir && fs_path_len(name) == fs_path_len(ctx->name) &&\n\t    strncmp(name->start, ctx->name->start, fs_path_len(name)) == 0) {\n\t\t/*\n\t\t * To avoid doing extra lookups we'll only do this if everything\n\t\t * else matches.\n\t\t */\n\t\tret = get_inode_info(ctx->root, dir, NULL, &dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (dir_gen != ctx->dir_gen)\n\t\t\treturn 0;\n\t\tctx->found_idx = num;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "record_deleted_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "3872-3884",
    "snippet": "static int record_deleted_ref(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tret = iterate_inode_ref(sctx->parent_root, sctx->right_path,\n\t\t\t\tsctx->cmp_key, 0, __record_deleted_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterate_inode_ref",
          "args": [
            "sctx->parent_root",
            "sctx->right_path",
            "sctx->cmp_key",
            "0",
            "__record_deleted_ref",
            "sctx"
          ],
          "line": 3876
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_inode_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "850-956",
          "snippet": "static int iterate_inode_ref(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *found_key, int resolve,\n\t\t\t     iterate_inode_ref_t iterate, void *ctx)\n{\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct btrfs_item *item;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_inode_extref *extref;\n\tstruct btrfs_path *tmp_path;\n\tstruct fs_path *p;\n\tu32 cur = 0;\n\tu32 total;\n\tint slot = path->slots[0];\n\tu32 name_len;\n\tchar *start;\n\tint ret = 0;\n\tint num = 0;\n\tint index;\n\tu64 dir;\n\tunsigned long name_off;\n\tunsigned long elem_size;\n\tunsigned long ptr;\n\n\tp = fs_path_alloc_reversed();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path) {\n\t\tfs_path_free(p);\n\t\treturn -ENOMEM;\n\t}\n\n\n\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\tptr = (unsigned long)btrfs_item_ptr(eb, slot,\n\t\t\t\t\t\t    struct btrfs_inode_ref);\n\t\titem = btrfs_item_nr(slot);\n\t\ttotal = btrfs_item_size(eb, item);\n\t\telem_size = sizeof(*iref);\n\t} else {\n\t\tptr = btrfs_item_ptr_offset(eb, slot);\n\t\ttotal = btrfs_item_size_nr(eb, slot);\n\t\telem_size = sizeof(*extref);\n\t}\n\n\twhile (cur < total) {\n\t\tfs_path_reset(p);\n\n\t\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\t\tiref = (struct btrfs_inode_ref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\tname_off = (unsigned long)(iref + 1);\n\t\t\tindex = btrfs_inode_ref_index(eb, iref);\n\t\t\tdir = found_key->offset;\n\t\t} else {\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tname_off = (unsigned long)&extref->name;\n\t\t\tindex = btrfs_inode_extref_index(eb, extref);\n\t\t\tdir = btrfs_inode_extref_parent(eb, extref);\n\t\t}\n\n\t\tif (resolve) {\n\t\t\tstart = btrfs_ref_to_path(root, tmp_path, name_len,\n\t\t\t\t\t\t  name_off, eb, dir,\n\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\tif (IS_ERR(start)) {\n\t\t\t\tret = PTR_ERR(start);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (start < p->buf) {\n\t\t\t\t/* overflow , try again with larger buffer */\n\t\t\t\tret = fs_path_ensure_buf(p,\n\t\t\t\t\t\tp->buf_len + p->buf - start);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tstart = btrfs_ref_to_path(root, tmp_path,\n\t\t\t\t\t\t\t  name_len, name_off,\n\t\t\t\t\t\t\t  eb, dir,\n\t\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\t\tif (IS_ERR(start)) {\n\t\t\t\t\tret = PTR_ERR(start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tBUG_ON(start < p->buf);\n\t\t\t}\n\t\t\tp->start = start;\n\t\t} else {\n\t\t\tret = fs_path_add_from_extent_buffer(p, eb, name_off,\n\t\t\t\t\t\t\t     name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcur += elem_size + name_len;\n\t\tret = iterate(num, dir, index, p, ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnum++;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tfs_path_free(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int iterate_inode_ref(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *found_key, int resolve,\n\t\t\t     iterate_inode_ref_t iterate, void *ctx)\n{\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct btrfs_item *item;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_inode_extref *extref;\n\tstruct btrfs_path *tmp_path;\n\tstruct fs_path *p;\n\tu32 cur = 0;\n\tu32 total;\n\tint slot = path->slots[0];\n\tu32 name_len;\n\tchar *start;\n\tint ret = 0;\n\tint num = 0;\n\tint index;\n\tu64 dir;\n\tunsigned long name_off;\n\tunsigned long elem_size;\n\tunsigned long ptr;\n\n\tp = fs_path_alloc_reversed();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path) {\n\t\tfs_path_free(p);\n\t\treturn -ENOMEM;\n\t}\n\n\n\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\tptr = (unsigned long)btrfs_item_ptr(eb, slot,\n\t\t\t\t\t\t    struct btrfs_inode_ref);\n\t\titem = btrfs_item_nr(slot);\n\t\ttotal = btrfs_item_size(eb, item);\n\t\telem_size = sizeof(*iref);\n\t} else {\n\t\tptr = btrfs_item_ptr_offset(eb, slot);\n\t\ttotal = btrfs_item_size_nr(eb, slot);\n\t\telem_size = sizeof(*extref);\n\t}\n\n\twhile (cur < total) {\n\t\tfs_path_reset(p);\n\n\t\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\t\tiref = (struct btrfs_inode_ref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\tname_off = (unsigned long)(iref + 1);\n\t\t\tindex = btrfs_inode_ref_index(eb, iref);\n\t\t\tdir = found_key->offset;\n\t\t} else {\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tname_off = (unsigned long)&extref->name;\n\t\t\tindex = btrfs_inode_extref_index(eb, extref);\n\t\t\tdir = btrfs_inode_extref_parent(eb, extref);\n\t\t}\n\n\t\tif (resolve) {\n\t\t\tstart = btrfs_ref_to_path(root, tmp_path, name_len,\n\t\t\t\t\t\t  name_off, eb, dir,\n\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\tif (IS_ERR(start)) {\n\t\t\t\tret = PTR_ERR(start);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (start < p->buf) {\n\t\t\t\t/* overflow , try again with larger buffer */\n\t\t\t\tret = fs_path_ensure_buf(p,\n\t\t\t\t\t\tp->buf_len + p->buf - start);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tstart = btrfs_ref_to_path(root, tmp_path,\n\t\t\t\t\t\t\t  name_len, name_off,\n\t\t\t\t\t\t\t  eb, dir,\n\t\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\t\tif (IS_ERR(start)) {\n\t\t\t\t\tret = PTR_ERR(start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tBUG_ON(start < p->buf);\n\t\t\t}\n\t\t\tp->start = start;\n\t\t} else {\n\t\t\tret = fs_path_add_from_extent_buffer(p, eb, name_off,\n\t\t\t\t\t\t\t     name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcur += elem_size + name_len;\n\t\tret = iterate(num, dir, index, p, ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnum++;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tfs_path_free(p);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int record_deleted_ref(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tret = iterate_inode_ref(sctx->parent_root, sctx->right_path,\n\t\t\t\tsctx->cmp_key, 0, __record_deleted_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "record_new_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "3858-3870",
    "snippet": "static int record_new_ref(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tret = iterate_inode_ref(sctx->send_root, sctx->left_path,\n\t\t\t\tsctx->cmp_key, 0, __record_new_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterate_inode_ref",
          "args": [
            "sctx->send_root",
            "sctx->left_path",
            "sctx->cmp_key",
            "0",
            "__record_new_ref",
            "sctx"
          ],
          "line": 3862
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_inode_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "850-956",
          "snippet": "static int iterate_inode_ref(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *found_key, int resolve,\n\t\t\t     iterate_inode_ref_t iterate, void *ctx)\n{\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct btrfs_item *item;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_inode_extref *extref;\n\tstruct btrfs_path *tmp_path;\n\tstruct fs_path *p;\n\tu32 cur = 0;\n\tu32 total;\n\tint slot = path->slots[0];\n\tu32 name_len;\n\tchar *start;\n\tint ret = 0;\n\tint num = 0;\n\tint index;\n\tu64 dir;\n\tunsigned long name_off;\n\tunsigned long elem_size;\n\tunsigned long ptr;\n\n\tp = fs_path_alloc_reversed();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path) {\n\t\tfs_path_free(p);\n\t\treturn -ENOMEM;\n\t}\n\n\n\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\tptr = (unsigned long)btrfs_item_ptr(eb, slot,\n\t\t\t\t\t\t    struct btrfs_inode_ref);\n\t\titem = btrfs_item_nr(slot);\n\t\ttotal = btrfs_item_size(eb, item);\n\t\telem_size = sizeof(*iref);\n\t} else {\n\t\tptr = btrfs_item_ptr_offset(eb, slot);\n\t\ttotal = btrfs_item_size_nr(eb, slot);\n\t\telem_size = sizeof(*extref);\n\t}\n\n\twhile (cur < total) {\n\t\tfs_path_reset(p);\n\n\t\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\t\tiref = (struct btrfs_inode_ref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\tname_off = (unsigned long)(iref + 1);\n\t\t\tindex = btrfs_inode_ref_index(eb, iref);\n\t\t\tdir = found_key->offset;\n\t\t} else {\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tname_off = (unsigned long)&extref->name;\n\t\t\tindex = btrfs_inode_extref_index(eb, extref);\n\t\t\tdir = btrfs_inode_extref_parent(eb, extref);\n\t\t}\n\n\t\tif (resolve) {\n\t\t\tstart = btrfs_ref_to_path(root, tmp_path, name_len,\n\t\t\t\t\t\t  name_off, eb, dir,\n\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\tif (IS_ERR(start)) {\n\t\t\t\tret = PTR_ERR(start);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (start < p->buf) {\n\t\t\t\t/* overflow , try again with larger buffer */\n\t\t\t\tret = fs_path_ensure_buf(p,\n\t\t\t\t\t\tp->buf_len + p->buf - start);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tstart = btrfs_ref_to_path(root, tmp_path,\n\t\t\t\t\t\t\t  name_len, name_off,\n\t\t\t\t\t\t\t  eb, dir,\n\t\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\t\tif (IS_ERR(start)) {\n\t\t\t\t\tret = PTR_ERR(start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tBUG_ON(start < p->buf);\n\t\t\t}\n\t\t\tp->start = start;\n\t\t} else {\n\t\t\tret = fs_path_add_from_extent_buffer(p, eb, name_off,\n\t\t\t\t\t\t\t     name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcur += elem_size + name_len;\n\t\tret = iterate(num, dir, index, p, ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnum++;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tfs_path_free(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int iterate_inode_ref(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *found_key, int resolve,\n\t\t\t     iterate_inode_ref_t iterate, void *ctx)\n{\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct btrfs_item *item;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_inode_extref *extref;\n\tstruct btrfs_path *tmp_path;\n\tstruct fs_path *p;\n\tu32 cur = 0;\n\tu32 total;\n\tint slot = path->slots[0];\n\tu32 name_len;\n\tchar *start;\n\tint ret = 0;\n\tint num = 0;\n\tint index;\n\tu64 dir;\n\tunsigned long name_off;\n\tunsigned long elem_size;\n\tunsigned long ptr;\n\n\tp = fs_path_alloc_reversed();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path) {\n\t\tfs_path_free(p);\n\t\treturn -ENOMEM;\n\t}\n\n\n\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\tptr = (unsigned long)btrfs_item_ptr(eb, slot,\n\t\t\t\t\t\t    struct btrfs_inode_ref);\n\t\titem = btrfs_item_nr(slot);\n\t\ttotal = btrfs_item_size(eb, item);\n\t\telem_size = sizeof(*iref);\n\t} else {\n\t\tptr = btrfs_item_ptr_offset(eb, slot);\n\t\ttotal = btrfs_item_size_nr(eb, slot);\n\t\telem_size = sizeof(*extref);\n\t}\n\n\twhile (cur < total) {\n\t\tfs_path_reset(p);\n\n\t\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\t\tiref = (struct btrfs_inode_ref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\tname_off = (unsigned long)(iref + 1);\n\t\t\tindex = btrfs_inode_ref_index(eb, iref);\n\t\t\tdir = found_key->offset;\n\t\t} else {\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tname_off = (unsigned long)&extref->name;\n\t\t\tindex = btrfs_inode_extref_index(eb, extref);\n\t\t\tdir = btrfs_inode_extref_parent(eb, extref);\n\t\t}\n\n\t\tif (resolve) {\n\t\t\tstart = btrfs_ref_to_path(root, tmp_path, name_len,\n\t\t\t\t\t\t  name_off, eb, dir,\n\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\tif (IS_ERR(start)) {\n\t\t\t\tret = PTR_ERR(start);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (start < p->buf) {\n\t\t\t\t/* overflow , try again with larger buffer */\n\t\t\t\tret = fs_path_ensure_buf(p,\n\t\t\t\t\t\tp->buf_len + p->buf - start);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tstart = btrfs_ref_to_path(root, tmp_path,\n\t\t\t\t\t\t\t  name_len, name_off,\n\t\t\t\t\t\t\t  eb, dir,\n\t\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\t\tif (IS_ERR(start)) {\n\t\t\t\t\tret = PTR_ERR(start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tBUG_ON(start < p->buf);\n\t\t\t}\n\t\t\tp->start = start;\n\t\t} else {\n\t\t\tret = fs_path_add_from_extent_buffer(p, eb, name_off,\n\t\t\t\t\t\t\t     name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcur += elem_size + name_len;\n\t\tret = iterate(num, dir, index, p, ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnum++;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tfs_path_free(p);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int record_new_ref(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tret = iterate_inode_ref(sctx->send_root, sctx->left_path,\n\t\t\t\tsctx->cmp_key, 0, __record_new_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "__record_deleted_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "3849-3856",
    "snippet": "static int __record_deleted_ref(int num, u64 dir, int index,\n\t\t\t\tstruct fs_path *name,\n\t\t\t\tvoid *ctx)\n{\n\tstruct send_ctx *sctx = ctx;\n\treturn record_ref(sctx->parent_root, num, dir, index, name,\n\t\t\t  ctx, &sctx->deleted_refs);\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "record_ref",
          "args": [
            "sctx->parent_root",
            "num",
            "dir",
            "index",
            "name",
            "ctx",
            "&sctx->deleted_refs"
          ],
          "line": 3854
        },
        "resolved": true,
        "details": {
          "function_name": "record_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3807-3837",
          "snippet": "static int record_ref(struct btrfs_root *root, int num, u64 dir, int index,\n\t\t      struct fs_path *name, void *ctx, struct list_head *refs)\n{\n\tint ret = 0;\n\tstruct send_ctx *sctx = ctx;\n\tstruct fs_path *p;\n\tu64 gen;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = get_inode_info(root, dir, NULL, &gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, dir, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = fs_path_add_path(p, name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = __record_ref(refs, dir, gen, p);\n\nout:\n\tif (ret)\n\t\tfs_path_free(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int record_ref(struct btrfs_root *root, int num, u64 dir, int index,\n\t\t      struct fs_path *name, void *ctx, struct list_head *refs)\n{\n\tint ret = 0;\n\tstruct send_ctx *sctx = ctx;\n\tstruct fs_path *p;\n\tu64 gen;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = get_inode_info(root, dir, NULL, &gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, dir, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = fs_path_add_path(p, name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = __record_ref(refs, dir, gen, p);\n\nout:\n\tif (ret)\n\t\tfs_path_free(p);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int __record_deleted_ref(int num, u64 dir, int index,\n\t\t\t\tstruct fs_path *name,\n\t\t\t\tvoid *ctx)\n{\n\tstruct send_ctx *sctx = ctx;\n\treturn record_ref(sctx->parent_root, num, dir, index, name,\n\t\t\t  ctx, &sctx->deleted_refs);\n}"
  },
  {
    "function_name": "__record_new_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "3839-3846",
    "snippet": "static int __record_new_ref(int num, u64 dir, int index,\n\t\t\t    struct fs_path *name,\n\t\t\t    void *ctx)\n{\n\tstruct send_ctx *sctx = ctx;\n\treturn record_ref(sctx->send_root, num, dir, index, name,\n\t\t\t  ctx, &sctx->new_refs);\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "record_ref",
          "args": [
            "sctx->send_root",
            "num",
            "dir",
            "index",
            "name",
            "ctx",
            "&sctx->new_refs"
          ],
          "line": 3844
        },
        "resolved": true,
        "details": {
          "function_name": "record_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3807-3837",
          "snippet": "static int record_ref(struct btrfs_root *root, int num, u64 dir, int index,\n\t\t      struct fs_path *name, void *ctx, struct list_head *refs)\n{\n\tint ret = 0;\n\tstruct send_ctx *sctx = ctx;\n\tstruct fs_path *p;\n\tu64 gen;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = get_inode_info(root, dir, NULL, &gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, dir, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = fs_path_add_path(p, name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = __record_ref(refs, dir, gen, p);\n\nout:\n\tif (ret)\n\t\tfs_path_free(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int record_ref(struct btrfs_root *root, int num, u64 dir, int index,\n\t\t      struct fs_path *name, void *ctx, struct list_head *refs)\n{\n\tint ret = 0;\n\tstruct send_ctx *sctx = ctx;\n\tstruct fs_path *p;\n\tu64 gen;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = get_inode_info(root, dir, NULL, &gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, dir, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = fs_path_add_path(p, name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = __record_ref(refs, dir, gen, p);\n\nout:\n\tif (ret)\n\t\tfs_path_free(p);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int __record_new_ref(int num, u64 dir, int index,\n\t\t\t    struct fs_path *name,\n\t\t\t    void *ctx)\n{\n\tstruct send_ctx *sctx = ctx;\n\treturn record_ref(sctx->send_root, num, dir, index, name,\n\t\t\t  ctx, &sctx->new_refs);\n}"
  },
  {
    "function_name": "record_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "3807-3837",
    "snippet": "static int record_ref(struct btrfs_root *root, int num, u64 dir, int index,\n\t\t      struct fs_path *name, void *ctx, struct list_head *refs)\n{\n\tint ret = 0;\n\tstruct send_ctx *sctx = ctx;\n\tstruct fs_path *p;\n\tu64 gen;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = get_inode_info(root, dir, NULL, &gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, dir, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = fs_path_add_path(p, name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = __record_ref(refs, dir, gen, p);\n\nout:\n\tif (ret)\n\t\tfs_path_free(p);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "p"
          ],
          "line": 3835
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__record_ref",
          "args": [
            "refs",
            "dir",
            "gen",
            "p"
          ],
          "line": 3831
        },
        "resolved": true,
        "details": {
          "function_name": "__record_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2684-2708",
          "snippet": "static int __record_ref(struct list_head *head, u64 dir,\n\t\t      u64 dir_gen, struct fs_path *path)\n{\n\tstruct recorded_ref *ref;\n\n\tref = kmalloc(sizeof(*ref), GFP_NOFS);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\tref->dir = dir;\n\tref->dir_gen = dir_gen;\n\tref->full_path = path;\n\n\tref->name = (char *)kbasename(ref->full_path->start);\n\tref->name_len = ref->full_path->end - ref->name;\n\tref->dir_path = ref->full_path->start;\n\tif (ref->name == ref->full_path->start)\n\t\tref->dir_path_len = 0;\n\telse\n\t\tref->dir_path_len = ref->full_path->end -\n\t\t\t\tref->full_path->start - 1 - ref->name_len;\n\n\tlist_add_tail(&ref->list, head);\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int __record_ref(struct list_head *head, u64 dir,\n\t\t      u64 dir_gen, struct fs_path *path)\n{\n\tstruct recorded_ref *ref;\n\n\tref = kmalloc(sizeof(*ref), GFP_NOFS);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\tref->dir = dir;\n\tref->dir_gen = dir_gen;\n\tref->full_path = path;\n\n\tref->name = (char *)kbasename(ref->full_path->start);\n\tref->name_len = ref->full_path->end - ref->name;\n\tref->dir_path = ref->full_path->start;\n\tif (ref->name == ref->full_path->start)\n\t\tref->dir_path_len = 0;\n\telse\n\t\tref->dir_path_len = ref->full_path->end -\n\t\t\t\tref->full_path->start - 1 - ref->name_len;\n\n\tlist_add_tail(&ref->list, head);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_add_path",
          "args": [
            "p",
            "name"
          ],
          "line": 3827
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_add_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "436-448",
          "snippet": "static int fs_path_add_path(struct fs_path *p, struct fs_path *p2)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, p2->end - p2->start, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, p2->start, p2->end - p2->start);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_add_path(struct fs_path *p, struct fs_path *p2)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, p2->end - p2->start, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, p2->start, p2->end - p2->start);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cur_path",
          "args": [
            "sctx",
            "dir",
            "gen",
            "p"
          ],
          "line": 3824
        },
        "resolved": true,
        "details": {
          "function_name": "get_cur_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2207-2263",
          "snippet": "static int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode_info",
          "args": [
            "root",
            "dir",
            "NULL",
            "&gen",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 3819
        },
        "resolved": true,
        "details": {
          "function_name": "get_inode_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "821-836",
          "snippet": "static int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 3815
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int record_ref(struct btrfs_root *root, int num, u64 dir, int index,\n\t\t      struct fs_path *name, void *ctx, struct list_head *refs)\n{\n\tint ret = 0;\n\tstruct send_ctx *sctx = ctx;\n\tstruct fs_path *p;\n\tu64 gen;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = get_inode_info(root, dir, NULL, &gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, dir, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = fs_path_add_path(p, name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = __record_ref(refs, dir, gen, p);\n\nout:\n\tif (ret)\n\t\tfs_path_free(p);\n\treturn ret;\n}"
  },
  {
    "function_name": "process_recorded_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "3493-3805",
    "snippet": "static int process_recorded_refs(struct send_ctx *sctx, int *pending_move)\n{\n\tint ret = 0;\n\tstruct recorded_ref *cur;\n\tstruct recorded_ref *cur2;\n\tstruct list_head check_dirs;\n\tstruct fs_path *valid_path = NULL;\n\tu64 ow_inode = 0;\n\tu64 ow_gen;\n\tint did_overwrite = 0;\n\tint is_orphan = 0;\n\tu64 last_dir_ino_rm = 0;\n\tbool can_rename = true;\n\nverbose_printk(\"btrfs: process_recorded_refs %llu\\n\", sctx->cur_ino);\n\n\t/*\n\t * This should never happen as the root dir always has the same ref\n\t * which is always '..'\n\t */\n\tBUG_ON(sctx->cur_ino <= BTRFS_FIRST_FREE_OBJECTID);\n\tINIT_LIST_HEAD(&check_dirs);\n\n\tvalid_path = fs_path_alloc();\n\tif (!valid_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First, check if the first ref of the current inode was overwritten\n\t * before. If yes, we know that the current inode was already orphanized\n\t * and thus use the orphan name. If not, we can use get_cur_path to\n\t * get the path of the first ref as it would like while receiving at\n\t * this point in time.\n\t * New inodes are always orphan at the beginning, so force to use the\n\t * orphan name in this case.\n\t * The first ref is stored in valid_path and will be updated if it\n\t * gets moved around.\n\t */\n\tif (!sctx->cur_inode_new) {\n\t\tret = did_overwrite_first_ref(sctx, sctx->cur_ino,\n\t\t\t\tsctx->cur_inode_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret)\n\t\t\tdid_overwrite = 1;\n\t}\n\tif (sctx->cur_inode_new || did_overwrite) {\n\t\tret = gen_unique_name(sctx, sctx->cur_ino,\n\t\t\t\tsctx->cur_inode_gen, valid_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tis_orphan = 1;\n\t} else {\n\t\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tvalid_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(cur, &sctx->new_refs, list) {\n\t\t/*\n\t\t * We may have refs where the parent directory does not exist\n\t\t * yet. This happens if the parent directories inum is higher\n\t\t * the the current inum. To handle this case, we create the\n\t\t * parent directory out of order. But we need to check if this\n\t\t * did already happen before due to other refs in the same dir.\n\t\t */\n\t\tret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret == inode_state_will_create) {\n\t\t\tret = 0;\n\t\t\t/*\n\t\t\t * First check if any of the current inodes refs did\n\t\t\t * already create the dir.\n\t\t\t */\n\t\t\tlist_for_each_entry(cur2, &sctx->new_refs, list) {\n\t\t\t\tif (cur == cur2)\n\t\t\t\t\tbreak;\n\t\t\t\tif (cur2->dir == cur->dir) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If that did not happen, check if a previous inode\n\t\t\t * did already create the dir.\n\t\t\t */\n\t\t\tif (!ret)\n\t\t\t\tret = did_create_dir(sctx, cur->dir);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret) {\n\t\t\t\tret = send_create_inode(sctx, cur->dir);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Check if this new ref would overwrite the first ref of\n\t\t * another unprocessed inode. If yes, orphanize the\n\t\t * overwritten inode. If we find an overwritten ref that is\n\t\t * not the first ref, simply unlink it.\n\t\t */\n\t\tret = will_overwrite_ref(sctx, cur->dir, cur->dir_gen,\n\t\t\t\tcur->name, cur->name_len,\n\t\t\t\t&ow_inode, &ow_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = is_first_ref(sctx->parent_root,\n\t\t\t\t\t   ow_inode, cur->dir, cur->name,\n\t\t\t\t\t   cur->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret) {\n\t\t\t\tret = orphanize_inode(sctx, ow_inode, ow_gen,\n\t\t\t\t\t\tcur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tret = send_unlink(sctx, cur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (S_ISDIR(sctx->cur_inode_mode) && sctx->parent_root) {\n\t\t\tret = wait_for_dest_dir_move(sctx, cur, is_orphan);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 1) {\n\t\t\t\tcan_rename = false;\n\t\t\t\t*pending_move = 1;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * link/move the ref to the new place. If we have an orphan\n\t\t * inode, move it and update valid_path. If not, link or move\n\t\t * it depending on the inode mode.\n\t\t */\n\t\tif (is_orphan && can_rename) {\n\t\t\tret = send_rename(sctx, valid_path, cur->full_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tis_orphan = 0;\n\t\t\tret = fs_path_copy(valid_path, cur->full_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (can_rename) {\n\t\t\tif (S_ISDIR(sctx->cur_inode_mode)) {\n\t\t\t\t/*\n\t\t\t\t * Dirs can't be linked, so move it. For moved\n\t\t\t\t * dirs, we always have one new and one deleted\n\t\t\t\t * ref. The deleted ref is ignored later.\n\t\t\t\t */\n\t\t\t\tret = wait_for_parent_move(sctx, cur);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (ret) {\n\t\t\t\t\t*pending_move = 1;\n\t\t\t\t} else {\n\t\t\t\t\tret = send_rename(sctx, valid_path,\n\t\t\t\t\t\t\t  cur->full_path);\n\t\t\t\t\tif (!ret)\n\t\t\t\t\t\tret = fs_path_copy(valid_path,\n\t\t\t\t\t\t\t       cur->full_path);\n\t\t\t\t}\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tret = send_link(sctx, cur->full_path,\n\t\t\t\t\t\tvalid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = dup_ref(cur, &check_dirs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (S_ISDIR(sctx->cur_inode_mode) && sctx->cur_inode_deleted) {\n\t\t/*\n\t\t * Check if we can already rmdir the directory. If not,\n\t\t * orphanize it. For every dir item inside that gets deleted\n\t\t * later, we do this check again and rmdir it then if possible.\n\t\t * See the use of check_dirs for more details.\n\t\t */\n\t\tret = can_rmdir(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tsctx->cur_ino);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = send_rmdir(sctx, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (!is_orphan) {\n\t\t\tret = orphanize_inode(sctx, sctx->cur_ino,\n\t\t\t\t\tsctx->cur_inode_gen, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tis_orphan = 1;\n\t\t}\n\n\t\tlist_for_each_entry(cur, &sctx->deleted_refs, list) {\n\t\t\tret = dup_ref(cur, &check_dirs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t} else if (S_ISDIR(sctx->cur_inode_mode) &&\n\t\t   !list_empty(&sctx->deleted_refs)) {\n\t\t/*\n\t\t * We have a moved dir. Add the old parent to check_dirs\n\t\t */\n\t\tcur = list_entry(sctx->deleted_refs.next, struct recorded_ref,\n\t\t\t\tlist);\n\t\tret = dup_ref(cur, &check_dirs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else if (!S_ISDIR(sctx->cur_inode_mode)) {\n\t\t/*\n\t\t * We have a non dir inode. Go through all deleted refs and\n\t\t * unlink them if they were not already overwritten by other\n\t\t * inodes.\n\t\t */\n\t\tlist_for_each_entry(cur, &sctx->deleted_refs, list) {\n\t\t\tret = did_overwrite_ref(sctx, cur->dir, cur->dir_gen,\n\t\t\t\t\tsctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\t\tcur->name, cur->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret) {\n\t\t\t\tret = send_unlink(sctx, cur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = dup_ref(cur, &check_dirs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * If the inode is still orphan, unlink the orphan. This may\n\t\t * happen when a previous inode did overwrite the first ref\n\t\t * of this inode and no new refs were added for the current\n\t\t * inode. Unlinking does not mean that the inode is deleted in\n\t\t * all cases. There may still be links to this inode in other\n\t\t * places.\n\t\t */\n\t\tif (is_orphan) {\n\t\t\tret = send_unlink(sctx, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We did collect all parent dirs where cur_inode was once located. We\n\t * now go through all these dirs and check if they are pending for\n\t * deletion and if it's finally possible to perform the rmdir now.\n\t * We also update the inode stats of the parent dirs here.\n\t */\n\tlist_for_each_entry(cur, &check_dirs, list) {\n\t\t/*\n\t\t * In case we had refs into dirs that were not processed yet,\n\t\t * we don't need to do the utime and rmdir logic for these dirs.\n\t\t * The dir will be processed later.\n\t\t */\n\t\tif (cur->dir > sctx->cur_ino)\n\t\t\tcontinue;\n\n\t\tret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ret == inode_state_did_create ||\n\t\t    ret == inode_state_no_change) {\n\t\t\t/* TODO delayed utimes */\n\t\t\tret = send_utimes(sctx, cur->dir, cur->dir_gen);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (ret == inode_state_did_delete &&\n\t\t\t   cur->dir != last_dir_ino_rm) {\n\t\t\tret = can_rmdir(sctx, cur->dir, cur->dir_gen,\n\t\t\t\t\tsctx->cur_ino);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret) {\n\t\t\t\tret = get_cur_path(sctx, cur->dir,\n\t\t\t\t\t\t   cur->dir_gen, valid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tret = send_rmdir(sctx, valid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tlast_dir_ino_rm = cur->dir;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = 0;\n\nout:\n\t__free_recorded_refs(&check_dirs);\n\tfree_recorded_refs(sctx);\n\tfs_path_free(valid_path);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "valid_path"
          ],
          "line": 3803
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_recorded_refs",
          "args": [
            "sctx"
          ],
          "line": 3802
        },
        "resolved": true,
        "details": {
          "function_name": "free_recorded_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2738-2742",
          "snippet": "static void free_recorded_refs(struct send_ctx *sctx)\n{\n\t__free_recorded_refs(&sctx->new_refs);\n\t__free_recorded_refs(&sctx->deleted_refs);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void free_recorded_refs(struct send_ctx *sctx)\n{\n\t__free_recorded_refs(&sctx->new_refs);\n\t__free_recorded_refs(&sctx->deleted_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_recorded_refs",
          "args": [
            "&check_dirs"
          ],
          "line": 3801
        },
        "resolved": true,
        "details": {
          "function_name": "__free_recorded_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2726-2736",
          "snippet": "static void __free_recorded_refs(struct list_head *head)\n{\n\tstruct recorded_ref *cur;\n\n\twhile (!list_empty(head)) {\n\t\tcur = list_entry(head->next, struct recorded_ref, list);\n\t\tfs_path_free(cur->full_path);\n\t\tlist_del(&cur->list);\n\t\tkfree(cur);\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void __free_recorded_refs(struct list_head *head)\n{\n\tstruct recorded_ref *cur;\n\n\twhile (!list_empty(head)) {\n\t\tcur = list_entry(head->next, struct recorded_ref, list);\n\t\tfs_path_free(cur->full_path);\n\t\tlist_del(&cur->list);\n\t\tkfree(cur);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_rmdir",
          "args": [
            "sctx",
            "valid_path"
          ],
          "line": 3790
        },
        "resolved": true,
        "details": {
          "function_name": "send_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "763-780",
          "snippet": "static int send_rmdir(struct send_ctx *sctx, struct fs_path *path)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_rmdir %s\\n\", path->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_RMDIR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_rmdir(struct send_ctx *sctx, struct fs_path *path)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_rmdir %s\\n\", path->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_RMDIR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cur_path",
          "args": [
            "sctx",
            "cur->dir",
            "cur->dir_gen",
            "valid_path"
          ],
          "line": 3786
        },
        "resolved": true,
        "details": {
          "function_name": "get_cur_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2207-2263",
          "snippet": "static int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_rmdir",
          "args": [
            "sctx",
            "cur->dir",
            "cur->dir_gen",
            "sctx->cur_ino"
          ],
          "line": 3781
        },
        "resolved": true,
        "details": {
          "function_name": "can_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2840-2917",
          "snippet": "static int can_rmdir(struct send_ctx *sctx, u64 dir, u64 dir_gen,\n\t\t     u64 send_progress)\n{\n\tint ret = 0;\n\tstruct btrfs_root *root = sctx->parent_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key loc;\n\tstruct btrfs_dir_item *di;\n\n\t/*\n\t * Don't try to rmdir the top/root subvolume dir.\n\t */\n\tif (dir == BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstruct waiting_dir_move *dm;\n\n\t\tif (path->slots[0] >= btrfs_header_nritems(path->nodes[0])) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type)\n\t\t\tbreak;\n\n\t\tdi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\tstruct btrfs_dir_item);\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &loc);\n\n\t\tdm = get_waiting_dir_move(sctx, loc.objectid);\n\t\tif (dm) {\n\t\t\tstruct orphan_dir_info *odi;\n\n\t\t\todi = add_orphan_dir_info(sctx, dir);\n\t\t\tif (IS_ERR(odi)) {\n\t\t\t\tret = PTR_ERR(odi);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\todi->gen = dir_gen;\n\t\t\tdm->rmdir_ino = dir;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (loc.objectid > send_progress) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t}\n\n\tret = 1;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int can_rmdir(struct send_ctx *sctx, u64 dir, u64 dir_gen,\n\t\t     u64 send_progress)\n{\n\tint ret = 0;\n\tstruct btrfs_root *root = sctx->parent_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key loc;\n\tstruct btrfs_dir_item *di;\n\n\t/*\n\t * Don't try to rmdir the top/root subvolume dir.\n\t */\n\tif (dir == BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstruct waiting_dir_move *dm;\n\n\t\tif (path->slots[0] >= btrfs_header_nritems(path->nodes[0])) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type)\n\t\t\tbreak;\n\n\t\tdi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\tstruct btrfs_dir_item);\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &loc);\n\n\t\tdm = get_waiting_dir_move(sctx, loc.objectid);\n\t\tif (dm) {\n\t\t\tstruct orphan_dir_info *odi;\n\n\t\t\todi = add_orphan_dir_info(sctx, dir);\n\t\t\tif (IS_ERR(odi)) {\n\t\t\t\tret = PTR_ERR(odi);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\todi->gen = dir_gen;\n\t\t\tdm->rmdir_ino = dir;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (loc.objectid > send_progress) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t}\n\n\tret = 1;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_utimes",
          "args": [
            "sctx",
            "cur->dir",
            "cur->dir_gen"
          ],
          "line": 3776
        },
        "resolved": true,
        "details": {
          "function_name": "send_utimes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2434-2487",
          "snippet": "static int send_utimes(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret = 0;\n\tstruct fs_path *p = NULL;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_key key;\n\tint slot;\n\nverbose_printk(\"btrfs: send_utimes %llu\\n\", ino);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpath = alloc_path_for_send();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, sctx->send_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tii = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UTIMES);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_ATIME, eb, &ii->atime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_MTIME, eb, &ii->mtime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_CTIME, eb, &ii->ctime);\n\t/* TODO Add otime support when the otime patches get into upstream */\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int send_utimes(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret = 0;\n\tstruct fs_path *p = NULL;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_key key;\n\tint slot;\n\nverbose_printk(\"btrfs: send_utimes %llu\\n\", ino);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpath = alloc_path_for_send();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, sctx->send_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tii = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UTIMES);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_ATIME, eb, &ii->atime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_MTIME, eb, &ii->mtime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_CTIME, eb, &ii->ctime);\n\t/* TODO Add otime support when the otime patches get into upstream */\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cur_inode_state",
          "args": [
            "sctx",
            "cur->dir",
            "cur->dir_gen"
          ],
          "line": 3769
        },
        "resolved": true,
        "details": {
          "function_name": "get_cur_inode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1560-1624",
          "snippet": "static int get_cur_inode_state(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret;\n\tint left_ret;\n\tint right_ret;\n\tu64 left_gen;\n\tu64 right_gen;\n\n\tret = get_inode_info(sctx->send_root, ino, NULL, &left_gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tleft_ret = ret;\n\n\tif (!sctx->parent_root) {\n\t\tright_ret = -ENOENT;\n\t} else {\n\t\tret = get_inode_info(sctx->parent_root, ino, NULL, &right_gen,\n\t\t\t\tNULL, NULL, NULL, NULL);\n\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\tgoto out;\n\t\tright_ret = ret;\n\t}\n\n\tif (!left_ret && !right_ret) {\n\t\tif (left_gen == gen && right_gen == gen) {\n\t\t\tret = inode_state_no_change;\n\t\t} else if (left_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_create;\n\t\t\telse\n\t\t\t\tret = inode_state_will_create;\n\t\t} else if (right_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_delete;\n\t\t\telse\n\t\t\t\tret = inode_state_will_delete;\n\t\t} else  {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else if (!left_ret) {\n\t\tif (left_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_create;\n\t\t\telse\n\t\t\t\tret = inode_state_will_create;\n\t\t} else {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else if (!right_ret) {\n\t\tif (right_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_delete;\n\t\t\telse\n\t\t\t\tret = inode_state_will_delete;\n\t\t} else {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_cur_inode_state(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret;\n\tint left_ret;\n\tint right_ret;\n\tu64 left_gen;\n\tu64 right_gen;\n\n\tret = get_inode_info(sctx->send_root, ino, NULL, &left_gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tleft_ret = ret;\n\n\tif (!sctx->parent_root) {\n\t\tright_ret = -ENOENT;\n\t} else {\n\t\tret = get_inode_info(sctx->parent_root, ino, NULL, &right_gen,\n\t\t\t\tNULL, NULL, NULL, NULL);\n\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\tgoto out;\n\t\tright_ret = ret;\n\t}\n\n\tif (!left_ret && !right_ret) {\n\t\tif (left_gen == gen && right_gen == gen) {\n\t\t\tret = inode_state_no_change;\n\t\t} else if (left_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_create;\n\t\t\telse\n\t\t\t\tret = inode_state_will_create;\n\t\t} else if (right_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_delete;\n\t\t\telse\n\t\t\t\tret = inode_state_will_delete;\n\t\t} else  {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else if (!left_ret) {\n\t\tif (left_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_create;\n\t\t\telse\n\t\t\t\tret = inode_state_will_create;\n\t\t} else {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else if (!right_ret) {\n\t\tif (right_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_delete;\n\t\t\telse\n\t\t\t\tret = inode_state_will_delete;\n\t\t} else {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cur",
            "&check_dirs",
            "list"
          ],
          "line": 3760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_unlink",
          "args": [
            "sctx",
            "valid_path"
          ],
          "line": 3748
        },
        "resolved": true,
        "details": {
          "function_name": "send_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "741-758",
          "snippet": "static int send_unlink(struct send_ctx *sctx, struct fs_path *path)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_unlink %s\\n\", path->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UNLINK);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_unlink(struct send_ctx *sctx, struct fs_path *path)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_unlink %s\\n\", path->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UNLINK);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup_ref",
          "args": [
            "cur",
            "&check_dirs"
          ],
          "line": 3735
        },
        "resolved": true,
        "details": {
          "function_name": "dup_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2710-2724",
          "snippet": "static int dup_ref(struct recorded_ref *ref, struct list_head *list)\n{\n\tstruct recorded_ref *new;\n\n\tnew = kmalloc(sizeof(*ref), GFP_NOFS);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->dir = ref->dir;\n\tnew->dir_gen = ref->dir_gen;\n\tnew->full_path = NULL;\n\tINIT_LIST_HEAD(&new->list);\n\tlist_add_tail(&new->list, list);\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int dup_ref(struct recorded_ref *ref, struct list_head *list)\n{\n\tstruct recorded_ref *new;\n\n\tnew = kmalloc(sizeof(*ref), GFP_NOFS);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->dir = ref->dir;\n\tnew->dir_gen = ref->dir_gen;\n\tnew->full_path = NULL;\n\tINIT_LIST_HEAD(&new->list);\n\tlist_add_tail(&new->list, list);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "did_overwrite_ref",
          "args": [
            "sctx",
            "cur->dir",
            "cur->dir_gen",
            "sctx->cur_ino",
            "sctx->cur_inode_gen",
            "cur->name",
            "cur->name_len"
          ],
          "line": 3725
        },
        "resolved": true,
        "details": {
          "function_name": "did_overwrite_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1865-1911",
          "snippet": "static int did_overwrite_ref(struct send_ctx *sctx,\n\t\t\t    u64 dir, u64 dir_gen,\n\t\t\t    u64 ino, u64 ino_gen,\n\t\t\t    const char *name, int name_len)\n{\n\tint ret = 0;\n\tu64 gen;\n\tu64 ow_inode;\n\tu8 other_type;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tret = is_inode_existent(sctx, dir, dir_gen);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\t/* check if the ref was overwritten by another ref */\n\tret = lookup_dir_item_inode(sctx->send_root, dir, name, name_len,\n\t\t\t&ow_inode, &other_type);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tif (ret) {\n\t\t/* was never and will never be overwritten */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = get_inode_info(sctx->send_root, ow_inode, NULL, &gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ow_inode == ino && gen == ino_gen) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* we know that it is or will be overwritten. check this now */\n\tif (ow_inode < sctx->send_progress)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int did_overwrite_ref(struct send_ctx *sctx,\n\t\t\t    u64 dir, u64 dir_gen,\n\t\t\t    u64 ino, u64 ino_gen,\n\t\t\t    const char *name, int name_len)\n{\n\tint ret = 0;\n\tu64 gen;\n\tu64 ow_inode;\n\tu8 other_type;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tret = is_inode_existent(sctx, dir, dir_gen);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\t/* check if the ref was overwritten by another ref */\n\tret = lookup_dir_item_inode(sctx->send_root, dir, name, name_len,\n\t\t\t&ow_inode, &other_type);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tif (ret) {\n\t\t/* was never and will never be overwritten */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = get_inode_info(sctx->send_root, ow_inode, NULL, &gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ow_inode == ino && gen == ino_gen) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* we know that it is or will be overwritten. check this now */\n\tif (ow_inode < sctx->send_progress)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cur",
            "&sctx->deleted_refs",
            "list"
          ],
          "line": 3724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sctx->cur_inode_mode"
          ],
          "line": 3718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "sctx->deleted_refs.next",
            "structrecorded_ref",
            "list"
          ],
          "line": 3713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sctx->deleted_refs"
          ],
          "line": 3709
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sctx->cur_inode_mode"
          ],
          "line": 3708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cur",
            "&sctx->deleted_refs",
            "list"
          ],
          "line": 3703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanize_inode",
          "args": [
            "sctx",
            "sctx->cur_ino",
            "sctx->cur_inode_gen",
            "valid_path"
          ],
          "line": 3696
        },
        "resolved": true,
        "details": {
          "function_name": "orphanize_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2749-2768",
          "snippet": "static int orphanize_inode(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\t  struct fs_path *path)\n{\n\tint ret;\n\tstruct fs_path *orphan;\n\n\torphan = fs_path_alloc();\n\tif (!orphan)\n\t\treturn -ENOMEM;\n\n\tret = gen_unique_name(sctx, ino, gen, orphan);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_rename(sctx, path, orphan);\n\nout:\n\tfs_path_free(orphan);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int orphanize_inode(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\t  struct fs_path *path)\n{\n\tint ret;\n\tstruct fs_path *orphan;\n\n\torphan = fs_path_alloc();\n\tif (!orphan)\n\t\treturn -ENOMEM;\n\n\tret = gen_unique_name(sctx, ino, gen, orphan);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_rename(sctx, path, orphan);\n\nout:\n\tfs_path_free(orphan);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sctx->cur_inode_mode"
          ],
          "line": 3680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_link",
          "args": [
            "sctx",
            "cur->full_path",
            "valid_path"
          ],
          "line": 3669
        },
        "resolved": true,
        "details": {
          "function_name": "send_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "717-736",
          "snippet": "static int send_link(struct send_ctx *sctx,\n\t\t     struct fs_path *path, struct fs_path *lnk)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_link %s -> %s\\n\", path->start, lnk->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_LINK);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_LINK, lnk);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_link(struct send_ctx *sctx,\n\t\t     struct fs_path *path, struct fs_path *lnk)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_link %s -> %s\\n\", path->start, lnk->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_LINK);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_LINK, lnk);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_copy",
          "args": [
            "valid_path",
            "cur->full_path"
          ],
          "line": 3663
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "467-477",
          "snippet": "static int fs_path_copy(struct fs_path *p, struct fs_path *from)\n{\n\tint ret;\n\n\tp->reversed = from->reversed;\n\tfs_path_reset(p);\n\n\tret = fs_path_add_path(p, from);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_copy(struct fs_path *p, struct fs_path *from)\n{\n\tint ret;\n\n\tp->reversed = from->reversed;\n\tfs_path_reset(p);\n\n\tret = fs_path_add_path(p, from);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_rename",
          "args": [
            "sctx",
            "valid_path",
            "cur->full_path"
          ],
          "line": 3660
        },
        "resolved": true,
        "details": {
          "function_name": "send_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "693-712",
          "snippet": "static int send_rename(struct send_ctx *sctx,\n\t\t     struct fs_path *from, struct fs_path *to)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_rename %s -> %s\\n\", from->start, to->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_RENAME);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, from);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_TO, to);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_rename(struct send_ctx *sctx,\n\t\t     struct fs_path *from, struct fs_path *to)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_rename %s -> %s\\n\", from->start, to->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_RENAME);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, from);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_TO, to);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_parent_move",
          "args": [
            "sctx",
            "cur"
          ],
          "line": 3654
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_parent_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3415-3488",
          "snippet": "static int wait_for_parent_move(struct send_ctx *sctx,\n\t\t\t\tstruct recorded_ref *parent_ref)\n{\n\tint ret = 0;\n\tu64 ino = parent_ref->dir;\n\tu64 parent_ino_before, parent_ino_after;\n\tstruct fs_path *path_before = NULL;\n\tstruct fs_path *path_after = NULL;\n\tint len1, len2;\n\n\tpath_after = fs_path_alloc();\n\tpath_before = fs_path_alloc();\n\tif (!path_after || !path_before) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Our current directory inode may not yet be renamed/moved because some\n\t * ancestor (immediate or not) has to be renamed/moved first. So find if\n\t * such ancestor exists and make sure our own rename/move happens after\n\t * that ancestor is processed.\n\t */\n\twhile (ino > BTRFS_FIRST_FREE_OBJECTID) {\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tfs_path_reset(path_before);\n\t\tfs_path_reset(path_after);\n\n\t\tret = get_first_ref(sctx->send_root, ino, &parent_ino_after,\n\t\t\t\t    NULL, path_after);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = get_first_ref(sctx->parent_root, ino, &parent_ino_before,\n\t\t\t\t    NULL, path_before);\n\t\tif (ret < 0 && ret != -ENOENT) {\n\t\t\tgoto out;\n\t\t} else if (ret == -ENOENT) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tlen1 = fs_path_len(path_before);\n\t\tlen2 = fs_path_len(path_after);\n\t\tif (ino > sctx->cur_ino &&\n\t\t    (parent_ino_before != parent_ino_after || len1 != len2 ||\n\t\t     memcmp(path_before->start, path_after->start, len1))) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tino = parent_ino_after;\n\t}\n\nout:\n\tfs_path_free(path_before);\n\tfs_path_free(path_after);\n\n\tif (ret == 1) {\n\t\tret = add_pending_dir_move(sctx,\n\t\t\t\t\t   sctx->cur_ino,\n\t\t\t\t\t   sctx->cur_inode_gen,\n\t\t\t\t\t   ino,\n\t\t\t\t\t   &sctx->new_refs,\n\t\t\t\t\t   &sctx->deleted_refs,\n\t\t\t\t\t   false);\n\t\tif (!ret)\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int wait_for_parent_move(struct send_ctx *sctx,\n\t\t\t\tstruct recorded_ref *parent_ref)\n{\n\tint ret = 0;\n\tu64 ino = parent_ref->dir;\n\tu64 parent_ino_before, parent_ino_after;\n\tstruct fs_path *path_before = NULL;\n\tstruct fs_path *path_after = NULL;\n\tint len1, len2;\n\n\tpath_after = fs_path_alloc();\n\tpath_before = fs_path_alloc();\n\tif (!path_after || !path_before) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Our current directory inode may not yet be renamed/moved because some\n\t * ancestor (immediate or not) has to be renamed/moved first. So find if\n\t * such ancestor exists and make sure our own rename/move happens after\n\t * that ancestor is processed.\n\t */\n\twhile (ino > BTRFS_FIRST_FREE_OBJECTID) {\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tfs_path_reset(path_before);\n\t\tfs_path_reset(path_after);\n\n\t\tret = get_first_ref(sctx->send_root, ino, &parent_ino_after,\n\t\t\t\t    NULL, path_after);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = get_first_ref(sctx->parent_root, ino, &parent_ino_before,\n\t\t\t\t    NULL, path_before);\n\t\tif (ret < 0 && ret != -ENOENT) {\n\t\t\tgoto out;\n\t\t} else if (ret == -ENOENT) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tlen1 = fs_path_len(path_before);\n\t\tlen2 = fs_path_len(path_after);\n\t\tif (ino > sctx->cur_ino &&\n\t\t    (parent_ino_before != parent_ino_after || len1 != len2 ||\n\t\t     memcmp(path_before->start, path_after->start, len1))) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tino = parent_ino_after;\n\t}\n\nout:\n\tfs_path_free(path_before);\n\tfs_path_free(path_after);\n\n\tif (ret == 1) {\n\t\tret = add_pending_dir_move(sctx,\n\t\t\t\t\t   sctx->cur_ino,\n\t\t\t\t\t   sctx->cur_inode_gen,\n\t\t\t\t\t   ino,\n\t\t\t\t\t   &sctx->new_refs,\n\t\t\t\t\t   &sctx->deleted_refs,\n\t\t\t\t\t   false);\n\t\tif (!ret)\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sctx->cur_inode_mode"
          ],
          "line": 3648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_dest_dir_move",
          "args": [
            "sctx",
            "cur",
            "is_orphan"
          ],
          "line": 3625
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_dest_dir_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3330-3413",
          "snippet": "static int wait_for_dest_dir_move(struct send_ctx *sctx,\n\t\t\t\t  struct recorded_ref *parent_ref,\n\t\t\t\t  const bool is_orphan)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key di_key;\n\tstruct btrfs_dir_item *di;\n\tu64 left_gen;\n\tu64 right_gen;\n\tint ret = 0;\n\n\tif (RB_EMPTY_ROOT(&sctx->waiting_dir_moves))\n\t\treturn 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = parent_ref->dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(parent_ref->name, parent_ref->name_len);\n\n\tret = btrfs_search_slot(NULL, sctx->parent_root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret > 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tdi = btrfs_match_dir_item_name(sctx->parent_root, path,\n\t\t\t\t       parent_ref->name, parent_ref->name_len);\n\tif (!di) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\t/*\n\t * di_key.objectid has the number of the inode that has a dentry in the\n\t * parent directory with the same name that sctx->cur_ino is being\n\t * renamed to. We need to check if that inode is in the send root as\n\t * well and if it is currently marked as an inode with a pending rename,\n\t * if it is, we need to delay the rename of sctx->cur_ino as well, so\n\t * that it happens after that other inode is renamed.\n\t */\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &di_key);\n\tif (di_key.type != BTRFS_INODE_ITEM_KEY) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = get_inode_info(sctx->parent_root, di_key.objectid, NULL,\n\t\t\t     &left_gen, NULL, NULL, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = get_inode_info(sctx->send_root, di_key.objectid, NULL,\n\t\t\t     &right_gen, NULL, NULL, NULL, NULL);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Different inode, no need to delay the rename of sctx->cur_ino */\n\tif (right_gen != left_gen) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (is_waiting_for_move(sctx, di_key.objectid)) {\n\t\tret = add_pending_dir_move(sctx,\n\t\t\t\t\t   sctx->cur_ino,\n\t\t\t\t\t   sctx->cur_inode_gen,\n\t\t\t\t\t   di_key.objectid,\n\t\t\t\t\t   &sctx->new_refs,\n\t\t\t\t\t   &sctx->deleted_refs,\n\t\t\t\t\t   is_orphan);\n\t\tif (!ret)\n\t\t\tret = 1;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int wait_for_dest_dir_move(struct send_ctx *sctx,\n\t\t\t\t  struct recorded_ref *parent_ref,\n\t\t\t\t  const bool is_orphan)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key di_key;\n\tstruct btrfs_dir_item *di;\n\tu64 left_gen;\n\tu64 right_gen;\n\tint ret = 0;\n\n\tif (RB_EMPTY_ROOT(&sctx->waiting_dir_moves))\n\t\treturn 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = parent_ref->dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(parent_ref->name, parent_ref->name_len);\n\n\tret = btrfs_search_slot(NULL, sctx->parent_root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret > 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tdi = btrfs_match_dir_item_name(sctx->parent_root, path,\n\t\t\t\t       parent_ref->name, parent_ref->name_len);\n\tif (!di) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\t/*\n\t * di_key.objectid has the number of the inode that has a dentry in the\n\t * parent directory with the same name that sctx->cur_ino is being\n\t * renamed to. We need to check if that inode is in the send root as\n\t * well and if it is currently marked as an inode with a pending rename,\n\t * if it is, we need to delay the rename of sctx->cur_ino as well, so\n\t * that it happens after that other inode is renamed.\n\t */\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &di_key);\n\tif (di_key.type != BTRFS_INODE_ITEM_KEY) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = get_inode_info(sctx->parent_root, di_key.objectid, NULL,\n\t\t\t     &left_gen, NULL, NULL, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = get_inode_info(sctx->send_root, di_key.objectid, NULL,\n\t\t\t     &right_gen, NULL, NULL, NULL, NULL);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Different inode, no need to delay the rename of sctx->cur_ino */\n\tif (right_gen != left_gen) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (is_waiting_for_move(sctx, di_key.objectid)) {\n\t\tret = add_pending_dir_move(sctx,\n\t\t\t\t\t   sctx->cur_ino,\n\t\t\t\t\t   sctx->cur_inode_gen,\n\t\t\t\t\t   di_key.objectid,\n\t\t\t\t\t   &sctx->new_refs,\n\t\t\t\t\t   &sctx->deleted_refs,\n\t\t\t\t\t   is_orphan);\n\t\tif (!ret)\n\t\t\tret = 1;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sctx->cur_inode_mode"
          ],
          "line": 3624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_first_ref",
          "args": [
            "sctx->parent_root",
            "ow_inode",
            "cur->dir",
            "cur->name",
            "cur->name_len"
          ],
          "line": 3607
        },
        "resolved": true,
        "details": {
          "function_name": "is_first_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1756-1782",
          "snippet": "static int is_first_ref(struct btrfs_root *root,\n\t\t\tu64 ino, u64 dir,\n\t\t\tconst char *name, int name_len)\n{\n\tint ret;\n\tstruct fs_path *tmp_name;\n\tu64 tmp_dir;\n\n\ttmp_name = fs_path_alloc();\n\tif (!tmp_name)\n\t\treturn -ENOMEM;\n\n\tret = get_first_ref(root, ino, &tmp_dir, NULL, tmp_name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (dir != tmp_dir || name_len != fs_path_len(tmp_name)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = !memcmp(tmp_name->start, name, name_len);\n\nout:\n\tfs_path_free(tmp_name);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int is_first_ref(struct btrfs_root *root,\n\t\t\tu64 ino, u64 dir,\n\t\t\tconst char *name, int name_len)\n{\n\tint ret;\n\tstruct fs_path *tmp_name;\n\tu64 tmp_dir;\n\n\ttmp_name = fs_path_alloc();\n\tif (!tmp_name)\n\t\treturn -ENOMEM;\n\n\tret = get_first_ref(root, ino, &tmp_dir, NULL, tmp_name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (dir != tmp_dir || name_len != fs_path_len(tmp_name)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = !memcmp(tmp_name->start, name, name_len);\n\nout:\n\tfs_path_free(tmp_name);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "will_overwrite_ref",
          "args": [
            "sctx",
            "cur->dir",
            "cur->dir_gen",
            "cur->name",
            "cur->name_len",
            "&ow_inode",
            "&ow_gen"
          ],
          "line": 3601
        },
        "resolved": true,
        "details": {
          "function_name": "will_overwrite_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1794-1856",
          "snippet": "static int will_overwrite_ref(struct send_ctx *sctx, u64 dir, u64 dir_gen,\n\t\t\t      const char *name, int name_len,\n\t\t\t      u64 *who_ino, u64 *who_gen)\n{\n\tint ret = 0;\n\tu64 gen;\n\tu64 other_inode = 0;\n\tu8 other_type = 0;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tret = is_inode_existent(sctx, dir, dir_gen);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\t/*\n\t * If we have a parent root we need to verify that the parent dir was\n\t * not delted and then re-created, if it was then we have no overwrite\n\t * and we can just unlink this entry.\n\t */\n\tif (sctx->parent_root) {\n\t\tret = get_inode_info(sctx->parent_root, dir, NULL, &gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (gen != dir_gen)\n\t\t\tgoto out;\n\t}\n\n\tret = lookup_dir_item_inode(sctx->parent_root, dir, name, name_len,\n\t\t\t&other_inode, &other_type);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Check if the overwritten ref was already processed. If yes, the ref\n\t * was already unlinked/moved, so we can safely assume that we will not\n\t * overwrite anything at this point in time.\n\t */\n\tif (other_inode > sctx->send_progress) {\n\t\tret = get_inode_info(sctx->parent_root, other_inode, NULL,\n\t\t\t\twho_gen, NULL, NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = 1;\n\t\t*who_ino = other_inode;\n\t} else {\n\t\tret = 0;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int will_overwrite_ref(struct send_ctx *sctx, u64 dir, u64 dir_gen,\n\t\t\t      const char *name, int name_len,\n\t\t\t      u64 *who_ino, u64 *who_gen)\n{\n\tint ret = 0;\n\tu64 gen;\n\tu64 other_inode = 0;\n\tu8 other_type = 0;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tret = is_inode_existent(sctx, dir, dir_gen);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\t/*\n\t * If we have a parent root we need to verify that the parent dir was\n\t * not delted and then re-created, if it was then we have no overwrite\n\t * and we can just unlink this entry.\n\t */\n\tif (sctx->parent_root) {\n\t\tret = get_inode_info(sctx->parent_root, dir, NULL, &gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (gen != dir_gen)\n\t\t\tgoto out;\n\t}\n\n\tret = lookup_dir_item_inode(sctx->parent_root, dir, name, name_len,\n\t\t\t&other_inode, &other_type);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Check if the overwritten ref was already processed. If yes, the ref\n\t * was already unlinked/moved, so we can safely assume that we will not\n\t * overwrite anything at this point in time.\n\t */\n\tif (other_inode > sctx->send_progress) {\n\t\tret = get_inode_info(sctx->parent_root, other_inode, NULL,\n\t\t\t\twho_gen, NULL, NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = 1;\n\t\t*who_ino = other_inode;\n\t} else {\n\t\tret = 0;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_create_inode",
          "args": [
            "sctx",
            "cur->dir"
          ],
          "line": 3589
        },
        "resolved": true,
        "details": {
          "function_name": "send_create_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2494-2571",
          "snippet": "static int send_create_inode(struct send_ctx *sctx, u64 ino)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\tint cmd;\n\tu64 gen;\n\tu64 mode;\n\tu64 rdev;\n\nverbose_printk(\"btrfs: send_create_inode %llu\\n\", ino);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tif (ino != sctx->cur_ino) {\n\t\tret = get_inode_info(sctx->send_root, ino, NULL, &gen, &mode,\n\t\t\t\t     NULL, NULL, &rdev);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tgen = sctx->cur_inode_gen;\n\t\tmode = sctx->cur_inode_mode;\n\t\trdev = sctx->cur_inode_rdev;\n\t}\n\n\tif (S_ISREG(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKFILE;\n\t} else if (S_ISDIR(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKDIR;\n\t} else if (S_ISLNK(mode)) {\n\t\tcmd = BTRFS_SEND_C_SYMLINK;\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKNOD;\n\t} else if (S_ISFIFO(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKFIFO;\n\t} else if (S_ISSOCK(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKSOCK;\n\t} else {\n\t\tprintk(KERN_WARNING \"btrfs: unexpected inode type %o\",\n\t\t\t\t(int)(mode & S_IFMT));\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = begin_cmd(sctx, cmd);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = gen_unique_name(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_INO, ino);\n\n\tif (S_ISLNK(mode)) {\n\t\tfs_path_reset(p);\n\t\tret = read_symlink(sctx->send_root, ino, p);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_LINK, p);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) ||\n\t\t   S_ISFIFO(mode) || S_ISSOCK(mode)) {\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_RDEV, new_encode_dev(rdev));\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_MODE, mode);\n\t}\n\n\tret = send_cmd(sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int send_create_inode(struct send_ctx *sctx, u64 ino)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\tint cmd;\n\tu64 gen;\n\tu64 mode;\n\tu64 rdev;\n\nverbose_printk(\"btrfs: send_create_inode %llu\\n\", ino);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tif (ino != sctx->cur_ino) {\n\t\tret = get_inode_info(sctx->send_root, ino, NULL, &gen, &mode,\n\t\t\t\t     NULL, NULL, &rdev);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tgen = sctx->cur_inode_gen;\n\t\tmode = sctx->cur_inode_mode;\n\t\trdev = sctx->cur_inode_rdev;\n\t}\n\n\tif (S_ISREG(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKFILE;\n\t} else if (S_ISDIR(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKDIR;\n\t} else if (S_ISLNK(mode)) {\n\t\tcmd = BTRFS_SEND_C_SYMLINK;\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKNOD;\n\t} else if (S_ISFIFO(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKFIFO;\n\t} else if (S_ISSOCK(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKSOCK;\n\t} else {\n\t\tprintk(KERN_WARNING \"btrfs: unexpected inode type %o\",\n\t\t\t\t(int)(mode & S_IFMT));\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = begin_cmd(sctx, cmd);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = gen_unique_name(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_INO, ino);\n\n\tif (S_ISLNK(mode)) {\n\t\tfs_path_reset(p);\n\t\tret = read_symlink(sctx->send_root, ino, p);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_LINK, p);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) ||\n\t\t   S_ISFIFO(mode) || S_ISSOCK(mode)) {\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_RDEV, new_encode_dev(rdev));\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_MODE, mode);\n\t}\n\n\tret = send_cmd(sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "did_create_dir",
          "args": [
            "sctx",
            "cur->dir"
          ],
          "line": 3585
        },
        "resolved": true,
        "details": {
          "function_name": "did_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2578-2638",
          "snippet": "static int did_create_dir(struct send_ctx *sctx, u64 dir)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key di_key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_dir_item *di;\n\tint slot;\n\n\tpath = alloc_path_for_send();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, sctx->send_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(sctx->send_root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (di_key.type != BTRFS_ROOT_ITEM_KEY &&\n\t\t    di_key.objectid < sctx->send_progress) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int did_create_dir(struct send_ctx *sctx, u64 dir)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key di_key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_dir_item *di;\n\tint slot;\n\n\tpath = alloc_path_for_send();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, sctx->send_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(sctx->send_root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (di_key.type != BTRFS_ROOT_ITEM_KEY &&\n\t\t    di_key.objectid < sctx->send_progress) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cur2",
            "&sctx->new_refs",
            "list"
          ],
          "line": 3571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cur",
            "&sctx->new_refs",
            "list"
          ],
          "line": 3554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_unique_name",
          "args": [
            "sctx",
            "sctx->cur_ino",
            "sctx->cur_inode_gen",
            "valid_path"
          ],
          "line": 3542
        },
        "resolved": true,
        "details": {
          "function_name": "gen_unique_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1488-1550",
          "snippet": "static int gen_unique_name(struct send_ctx *sctx,\n\t\t\t   u64 ino, u64 gen,\n\t\t\t   struct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tchar tmp[64];\n\tint len;\n\tu64 idx = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tlen = snprintf(tmp, sizeof(tmp), \"o%llu-%llu-%llu\",\n\t\t\t\tino, gen, idx);\n\t\tASSERT(len < sizeof(tmp));\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->send_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sctx->parent_root) {\n\t\t\t/* unique */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->parent_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* unique */\n\t\tbreak;\n\t}\n\n\tret = fs_path_add(dest, tmp, strlen(tmp));\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int gen_unique_name(struct send_ctx *sctx,\n\t\t\t   u64 ino, u64 gen,\n\t\t\t   struct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tchar tmp[64];\n\tint len;\n\tu64 idx = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tlen = snprintf(tmp, sizeof(tmp), \"o%llu-%llu-%llu\",\n\t\t\t\tino, gen, idx);\n\t\tASSERT(len < sizeof(tmp));\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->send_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sctx->parent_root) {\n\t\t\t/* unique */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->parent_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* unique */\n\t\tbreak;\n\t}\n\n\tret = fs_path_add(dest, tmp, strlen(tmp));\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "did_overwrite_first_ref",
          "args": [
            "sctx",
            "sctx->cur_ino",
            "sctx->cur_inode_gen"
          ],
          "line": 3534
        },
        "resolved": true,
        "details": {
          "function_name": "did_overwrite_first_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1918-1942",
          "snippet": "static int did_overwrite_first_ref(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 dir;\n\tu64 dir_gen;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tname = fs_path_alloc();\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tret = get_first_ref(sctx->parent_root, ino, &dir, &dir_gen, name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = did_overwrite_ref(sctx, dir, dir_gen, ino, gen,\n\t\t\tname->start, fs_path_len(name));\n\nout:\n\tfs_path_free(name);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int did_overwrite_first_ref(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 dir;\n\tu64 dir_gen;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tname = fs_path_alloc();\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tret = get_first_ref(sctx->parent_root, ino, &dir, &dir_gen, name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = did_overwrite_ref(sctx, dir, dir_gen, ino, gen,\n\t\t\tname->start, fs_path_len(name));\n\nout:\n\tfs_path_free(name);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 3516
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&check_dirs"
          ],
          "line": 3514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sctx->cur_ino <= BTRFS_FIRST_FREE_OBJECTID"
          ],
          "line": 3513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose_printk",
          "args": [
            "\"btrfs: process_recorded_refs %llu\\n\"",
            "sctx->cur_ino"
          ],
          "line": 3507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int process_recorded_refs(struct send_ctx *sctx, int *pending_move)\n{\n\tint ret = 0;\n\tstruct recorded_ref *cur;\n\tstruct recorded_ref *cur2;\n\tstruct list_head check_dirs;\n\tstruct fs_path *valid_path = NULL;\n\tu64 ow_inode = 0;\n\tu64 ow_gen;\n\tint did_overwrite = 0;\n\tint is_orphan = 0;\n\tu64 last_dir_ino_rm = 0;\n\tbool can_rename = true;\n\nverbose_printk(\"btrfs: process_recorded_refs %llu\\n\", sctx->cur_ino);\n\n\t/*\n\t * This should never happen as the root dir always has the same ref\n\t * which is always '..'\n\t */\n\tBUG_ON(sctx->cur_ino <= BTRFS_FIRST_FREE_OBJECTID);\n\tINIT_LIST_HEAD(&check_dirs);\n\n\tvalid_path = fs_path_alloc();\n\tif (!valid_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First, check if the first ref of the current inode was overwritten\n\t * before. If yes, we know that the current inode was already orphanized\n\t * and thus use the orphan name. If not, we can use get_cur_path to\n\t * get the path of the first ref as it would like while receiving at\n\t * this point in time.\n\t * New inodes are always orphan at the beginning, so force to use the\n\t * orphan name in this case.\n\t * The first ref is stored in valid_path and will be updated if it\n\t * gets moved around.\n\t */\n\tif (!sctx->cur_inode_new) {\n\t\tret = did_overwrite_first_ref(sctx, sctx->cur_ino,\n\t\t\t\tsctx->cur_inode_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret)\n\t\t\tdid_overwrite = 1;\n\t}\n\tif (sctx->cur_inode_new || did_overwrite) {\n\t\tret = gen_unique_name(sctx, sctx->cur_ino,\n\t\t\t\tsctx->cur_inode_gen, valid_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tis_orphan = 1;\n\t} else {\n\t\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tvalid_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(cur, &sctx->new_refs, list) {\n\t\t/*\n\t\t * We may have refs where the parent directory does not exist\n\t\t * yet. This happens if the parent directories inum is higher\n\t\t * the the current inum. To handle this case, we create the\n\t\t * parent directory out of order. But we need to check if this\n\t\t * did already happen before due to other refs in the same dir.\n\t\t */\n\t\tret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret == inode_state_will_create) {\n\t\t\tret = 0;\n\t\t\t/*\n\t\t\t * First check if any of the current inodes refs did\n\t\t\t * already create the dir.\n\t\t\t */\n\t\t\tlist_for_each_entry(cur2, &sctx->new_refs, list) {\n\t\t\t\tif (cur == cur2)\n\t\t\t\t\tbreak;\n\t\t\t\tif (cur2->dir == cur->dir) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If that did not happen, check if a previous inode\n\t\t\t * did already create the dir.\n\t\t\t */\n\t\t\tif (!ret)\n\t\t\t\tret = did_create_dir(sctx, cur->dir);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret) {\n\t\t\t\tret = send_create_inode(sctx, cur->dir);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Check if this new ref would overwrite the first ref of\n\t\t * another unprocessed inode. If yes, orphanize the\n\t\t * overwritten inode. If we find an overwritten ref that is\n\t\t * not the first ref, simply unlink it.\n\t\t */\n\t\tret = will_overwrite_ref(sctx, cur->dir, cur->dir_gen,\n\t\t\t\tcur->name, cur->name_len,\n\t\t\t\t&ow_inode, &ow_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = is_first_ref(sctx->parent_root,\n\t\t\t\t\t   ow_inode, cur->dir, cur->name,\n\t\t\t\t\t   cur->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret) {\n\t\t\t\tret = orphanize_inode(sctx, ow_inode, ow_gen,\n\t\t\t\t\t\tcur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tret = send_unlink(sctx, cur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (S_ISDIR(sctx->cur_inode_mode) && sctx->parent_root) {\n\t\t\tret = wait_for_dest_dir_move(sctx, cur, is_orphan);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 1) {\n\t\t\t\tcan_rename = false;\n\t\t\t\t*pending_move = 1;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * link/move the ref to the new place. If we have an orphan\n\t\t * inode, move it and update valid_path. If not, link or move\n\t\t * it depending on the inode mode.\n\t\t */\n\t\tif (is_orphan && can_rename) {\n\t\t\tret = send_rename(sctx, valid_path, cur->full_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tis_orphan = 0;\n\t\t\tret = fs_path_copy(valid_path, cur->full_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (can_rename) {\n\t\t\tif (S_ISDIR(sctx->cur_inode_mode)) {\n\t\t\t\t/*\n\t\t\t\t * Dirs can't be linked, so move it. For moved\n\t\t\t\t * dirs, we always have one new and one deleted\n\t\t\t\t * ref. The deleted ref is ignored later.\n\t\t\t\t */\n\t\t\t\tret = wait_for_parent_move(sctx, cur);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (ret) {\n\t\t\t\t\t*pending_move = 1;\n\t\t\t\t} else {\n\t\t\t\t\tret = send_rename(sctx, valid_path,\n\t\t\t\t\t\t\t  cur->full_path);\n\t\t\t\t\tif (!ret)\n\t\t\t\t\t\tret = fs_path_copy(valid_path,\n\t\t\t\t\t\t\t       cur->full_path);\n\t\t\t\t}\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tret = send_link(sctx, cur->full_path,\n\t\t\t\t\t\tvalid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = dup_ref(cur, &check_dirs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (S_ISDIR(sctx->cur_inode_mode) && sctx->cur_inode_deleted) {\n\t\t/*\n\t\t * Check if we can already rmdir the directory. If not,\n\t\t * orphanize it. For every dir item inside that gets deleted\n\t\t * later, we do this check again and rmdir it then if possible.\n\t\t * See the use of check_dirs for more details.\n\t\t */\n\t\tret = can_rmdir(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tsctx->cur_ino);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = send_rmdir(sctx, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (!is_orphan) {\n\t\t\tret = orphanize_inode(sctx, sctx->cur_ino,\n\t\t\t\t\tsctx->cur_inode_gen, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tis_orphan = 1;\n\t\t}\n\n\t\tlist_for_each_entry(cur, &sctx->deleted_refs, list) {\n\t\t\tret = dup_ref(cur, &check_dirs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t} else if (S_ISDIR(sctx->cur_inode_mode) &&\n\t\t   !list_empty(&sctx->deleted_refs)) {\n\t\t/*\n\t\t * We have a moved dir. Add the old parent to check_dirs\n\t\t */\n\t\tcur = list_entry(sctx->deleted_refs.next, struct recorded_ref,\n\t\t\t\tlist);\n\t\tret = dup_ref(cur, &check_dirs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else if (!S_ISDIR(sctx->cur_inode_mode)) {\n\t\t/*\n\t\t * We have a non dir inode. Go through all deleted refs and\n\t\t * unlink them if they were not already overwritten by other\n\t\t * inodes.\n\t\t */\n\t\tlist_for_each_entry(cur, &sctx->deleted_refs, list) {\n\t\t\tret = did_overwrite_ref(sctx, cur->dir, cur->dir_gen,\n\t\t\t\t\tsctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\t\tcur->name, cur->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret) {\n\t\t\t\tret = send_unlink(sctx, cur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = dup_ref(cur, &check_dirs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * If the inode is still orphan, unlink the orphan. This may\n\t\t * happen when a previous inode did overwrite the first ref\n\t\t * of this inode and no new refs were added for the current\n\t\t * inode. Unlinking does not mean that the inode is deleted in\n\t\t * all cases. There may still be links to this inode in other\n\t\t * places.\n\t\t */\n\t\tif (is_orphan) {\n\t\t\tret = send_unlink(sctx, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We did collect all parent dirs where cur_inode was once located. We\n\t * now go through all these dirs and check if they are pending for\n\t * deletion and if it's finally possible to perform the rmdir now.\n\t * We also update the inode stats of the parent dirs here.\n\t */\n\tlist_for_each_entry(cur, &check_dirs, list) {\n\t\t/*\n\t\t * In case we had refs into dirs that were not processed yet,\n\t\t * we don't need to do the utime and rmdir logic for these dirs.\n\t\t * The dir will be processed later.\n\t\t */\n\t\tif (cur->dir > sctx->cur_ino)\n\t\t\tcontinue;\n\n\t\tret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ret == inode_state_did_create ||\n\t\t    ret == inode_state_no_change) {\n\t\t\t/* TODO delayed utimes */\n\t\t\tret = send_utimes(sctx, cur->dir, cur->dir_gen);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (ret == inode_state_did_delete &&\n\t\t\t   cur->dir != last_dir_ino_rm) {\n\t\t\tret = can_rmdir(sctx, cur->dir, cur->dir_gen,\n\t\t\t\t\tsctx->cur_ino);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret) {\n\t\t\t\tret = get_cur_path(sctx, cur->dir,\n\t\t\t\t\t\t   cur->dir_gen, valid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tret = send_rmdir(sctx, valid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tlast_dir_ino_rm = cur->dir;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = 0;\n\nout:\n\t__free_recorded_refs(&check_dirs);\n\tfree_recorded_refs(sctx);\n\tfs_path_free(valid_path);\n\treturn ret;\n}"
  },
  {
    "function_name": "wait_for_parent_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "3415-3488",
    "snippet": "static int wait_for_parent_move(struct send_ctx *sctx,\n\t\t\t\tstruct recorded_ref *parent_ref)\n{\n\tint ret = 0;\n\tu64 ino = parent_ref->dir;\n\tu64 parent_ino_before, parent_ino_after;\n\tstruct fs_path *path_before = NULL;\n\tstruct fs_path *path_after = NULL;\n\tint len1, len2;\n\n\tpath_after = fs_path_alloc();\n\tpath_before = fs_path_alloc();\n\tif (!path_after || !path_before) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Our current directory inode may not yet be renamed/moved because some\n\t * ancestor (immediate or not) has to be renamed/moved first. So find if\n\t * such ancestor exists and make sure our own rename/move happens after\n\t * that ancestor is processed.\n\t */\n\twhile (ino > BTRFS_FIRST_FREE_OBJECTID) {\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tfs_path_reset(path_before);\n\t\tfs_path_reset(path_after);\n\n\t\tret = get_first_ref(sctx->send_root, ino, &parent_ino_after,\n\t\t\t\t    NULL, path_after);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = get_first_ref(sctx->parent_root, ino, &parent_ino_before,\n\t\t\t\t    NULL, path_before);\n\t\tif (ret < 0 && ret != -ENOENT) {\n\t\t\tgoto out;\n\t\t} else if (ret == -ENOENT) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tlen1 = fs_path_len(path_before);\n\t\tlen2 = fs_path_len(path_after);\n\t\tif (ino > sctx->cur_ino &&\n\t\t    (parent_ino_before != parent_ino_after || len1 != len2 ||\n\t\t     memcmp(path_before->start, path_after->start, len1))) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tino = parent_ino_after;\n\t}\n\nout:\n\tfs_path_free(path_before);\n\tfs_path_free(path_after);\n\n\tif (ret == 1) {\n\t\tret = add_pending_dir_move(sctx,\n\t\t\t\t\t   sctx->cur_ino,\n\t\t\t\t\t   sctx->cur_inode_gen,\n\t\t\t\t\t   ino,\n\t\t\t\t\t   &sctx->new_refs,\n\t\t\t\t\t   &sctx->deleted_refs,\n\t\t\t\t\t   false);\n\t\tif (!ret)\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_pending_dir_move",
          "args": [
            "sctx",
            "sctx->cur_ino",
            "sctx->cur_inode_gen",
            "ino",
            "&sctx->new_refs",
            "&sctx->deleted_refs",
            "false"
          ],
          "line": 3476
        },
        "resolved": true,
        "details": {
          "function_name": "add_pending_dir_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2983-3050",
          "snippet": "static int add_pending_dir_move(struct send_ctx *sctx,\n\t\t\t\tu64 ino,\n\t\t\t\tu64 ino_gen,\n\t\t\t\tu64 parent_ino,\n\t\t\t\tstruct list_head *new_refs,\n\t\t\t\tstruct list_head *deleted_refs,\n\t\t\t\tconst bool is_orphan)\n{\n\tstruct rb_node **p = &sctx->pending_dir_moves.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct pending_dir_move *entry = NULL, *pm;\n\tstruct recorded_ref *cur;\n\tint exists = 0;\n\tint ret;\n\n\tpm = kmalloc(sizeof(*pm), GFP_NOFS);\n\tif (!pm)\n\t\treturn -ENOMEM;\n\tpm->parent_ino = parent_ino;\n\tpm->ino = ino;\n\tpm->gen = ino_gen;\n\tpm->is_orphan = is_orphan;\n\tINIT_LIST_HEAD(&pm->list);\n\tINIT_LIST_HEAD(&pm->update_refs);\n\tRB_CLEAR_NODE(&pm->node);\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct pending_dir_move, node);\n\t\tif (parent_ino < entry->parent_ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (parent_ino > entry->parent_ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\texists = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(cur, deleted_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tlist_for_each_entry(cur, new_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = add_waiting_dir_move(sctx, pm->ino);\n\tif (ret)\n\t\tgoto out;\n\n\tif (exists) {\n\t\tlist_add_tail(&pm->list, &entry->list);\n\t} else {\n\t\trb_link_node(&pm->node, parent, p);\n\t\trb_insert_color(&pm->node, &sctx->pending_dir_moves);\n\t}\n\tret = 0;\nout:\n\tif (ret) {\n\t\t__free_recorded_refs(&pm->update_refs);\n\t\tkfree(pm);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int add_pending_dir_move(struct send_ctx *sctx,\n\t\t\t\tu64 ino,\n\t\t\t\tu64 ino_gen,\n\t\t\t\tu64 parent_ino,\n\t\t\t\tstruct list_head *new_refs,\n\t\t\t\tstruct list_head *deleted_refs,\n\t\t\t\tconst bool is_orphan)\n{\n\tstruct rb_node **p = &sctx->pending_dir_moves.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct pending_dir_move *entry = NULL, *pm;\n\tstruct recorded_ref *cur;\n\tint exists = 0;\n\tint ret;\n\n\tpm = kmalloc(sizeof(*pm), GFP_NOFS);\n\tif (!pm)\n\t\treturn -ENOMEM;\n\tpm->parent_ino = parent_ino;\n\tpm->ino = ino;\n\tpm->gen = ino_gen;\n\tpm->is_orphan = is_orphan;\n\tINIT_LIST_HEAD(&pm->list);\n\tINIT_LIST_HEAD(&pm->update_refs);\n\tRB_CLEAR_NODE(&pm->node);\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct pending_dir_move, node);\n\t\tif (parent_ino < entry->parent_ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (parent_ino > entry->parent_ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\texists = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(cur, deleted_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tlist_for_each_entry(cur, new_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = add_waiting_dir_move(sctx, pm->ino);\n\tif (ret)\n\t\tgoto out;\n\n\tif (exists) {\n\t\tlist_add_tail(&pm->list, &entry->list);\n\t} else {\n\t\trb_link_node(&pm->node, parent, p);\n\t\trb_insert_color(&pm->node, &sctx->pending_dir_moves);\n\t}\n\tret = 0;\nout:\n\tif (ret) {\n\t\t__free_recorded_refs(&pm->update_refs);\n\t\tkfree(pm);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "path_after"
          ],
          "line": 3473
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "path_before->start",
            "path_after->start",
            "len1"
          ],
          "line": 3464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_path_len",
          "args": [
            "path_after"
          ],
          "line": 3461
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "337-340",
          "snippet": "static int fs_path_len(struct fs_path *p)\n{\n\treturn p->end - p->start;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_len(struct fs_path *p)\n{\n\treturn p->end - p->start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_first_ref",
          "args": [
            "sctx->parent_root",
            "ino",
            "&parent_ino_before",
            "NULL",
            "path_before"
          ],
          "line": 3451
        },
        "resolved": true,
        "details": {
          "function_name": "get_first_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1689-1754",
          "snippet": "static int get_first_ref(struct btrfs_root *root, u64 ino,\n\t\t\t u64 *dir, u64 *dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tint len;\n\tu64 parent_dir;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\tpath->slots[0]);\n\tif (ret || found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (found_key.type == BTRFS_INODE_REF_KEY) {\n\t\tstruct btrfs_inode_ref *iref;\n\t\tiref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(path->nodes[0], iref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t\t     (unsigned long)(iref + 1),\n\t\t\t\t\t\t     len);\n\t\tparent_dir = found_key.offset;\n\t} else {\n\t\tstruct btrfs_inode_extref *extref;\n\t\textref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_extref);\n\t\tlen = btrfs_inode_extref_name_len(path->nodes[0], extref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t(unsigned long)&extref->name, len);\n\t\tparent_dir = btrfs_inode_extref_parent(path->nodes[0], extref);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tif (dir_gen) {\n\t\tret = get_inode_info(root, parent_dir, NULL, dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t*dir = parent_dir;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_first_ref(struct btrfs_root *root, u64 ino,\n\t\t\t u64 *dir, u64 *dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tint len;\n\tu64 parent_dir;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\tpath->slots[0]);\n\tif (ret || found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (found_key.type == BTRFS_INODE_REF_KEY) {\n\t\tstruct btrfs_inode_ref *iref;\n\t\tiref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(path->nodes[0], iref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t\t     (unsigned long)(iref + 1),\n\t\t\t\t\t\t     len);\n\t\tparent_dir = found_key.offset;\n\t} else {\n\t\tstruct btrfs_inode_extref *extref;\n\t\textref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_extref);\n\t\tlen = btrfs_inode_extref_name_len(path->nodes[0], extref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t(unsigned long)&extref->name, len);\n\t\tparent_dir = btrfs_inode_extref_parent(path->nodes[0], extref);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tif (dir_gen) {\n\t\tret = get_inode_info(root, parent_dir, NULL, dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t*dir = parent_dir;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_reset",
          "args": [
            "path_after"
          ],
          "line": 3445
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "289-300",
          "snippet": "static void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_waiting_for_move",
          "args": [
            "sctx",
            "ino"
          ],
          "line": 3439
        },
        "resolved": true,
        "details": {
          "function_name": "is_waiting_for_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2919-2924",
          "snippet": "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct waiting_dir_move *entry = get_waiting_dir_move(sctx, ino);\n\n\treturn entry != NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct waiting_dir_move *entry = get_waiting_dir_move(sctx, ino);\n\n\treturn entry != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 3426
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int wait_for_parent_move(struct send_ctx *sctx,\n\t\t\t\tstruct recorded_ref *parent_ref)\n{\n\tint ret = 0;\n\tu64 ino = parent_ref->dir;\n\tu64 parent_ino_before, parent_ino_after;\n\tstruct fs_path *path_before = NULL;\n\tstruct fs_path *path_after = NULL;\n\tint len1, len2;\n\n\tpath_after = fs_path_alloc();\n\tpath_before = fs_path_alloc();\n\tif (!path_after || !path_before) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Our current directory inode may not yet be renamed/moved because some\n\t * ancestor (immediate or not) has to be renamed/moved first. So find if\n\t * such ancestor exists and make sure our own rename/move happens after\n\t * that ancestor is processed.\n\t */\n\twhile (ino > BTRFS_FIRST_FREE_OBJECTID) {\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tfs_path_reset(path_before);\n\t\tfs_path_reset(path_after);\n\n\t\tret = get_first_ref(sctx->send_root, ino, &parent_ino_after,\n\t\t\t\t    NULL, path_after);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = get_first_ref(sctx->parent_root, ino, &parent_ino_before,\n\t\t\t\t    NULL, path_before);\n\t\tif (ret < 0 && ret != -ENOENT) {\n\t\t\tgoto out;\n\t\t} else if (ret == -ENOENT) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tlen1 = fs_path_len(path_before);\n\t\tlen2 = fs_path_len(path_after);\n\t\tif (ino > sctx->cur_ino &&\n\t\t    (parent_ino_before != parent_ino_after || len1 != len2 ||\n\t\t     memcmp(path_before->start, path_after->start, len1))) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tino = parent_ino_after;\n\t}\n\nout:\n\tfs_path_free(path_before);\n\tfs_path_free(path_after);\n\n\tif (ret == 1) {\n\t\tret = add_pending_dir_move(sctx,\n\t\t\t\t\t   sctx->cur_ino,\n\t\t\t\t\t   sctx->cur_inode_gen,\n\t\t\t\t\t   ino,\n\t\t\t\t\t   &sctx->new_refs,\n\t\t\t\t\t   &sctx->deleted_refs,\n\t\t\t\t\t   false);\n\t\tif (!ret)\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "wait_for_dest_dir_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "3330-3413",
    "snippet": "static int wait_for_dest_dir_move(struct send_ctx *sctx,\n\t\t\t\t  struct recorded_ref *parent_ref,\n\t\t\t\t  const bool is_orphan)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key di_key;\n\tstruct btrfs_dir_item *di;\n\tu64 left_gen;\n\tu64 right_gen;\n\tint ret = 0;\n\n\tif (RB_EMPTY_ROOT(&sctx->waiting_dir_moves))\n\t\treturn 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = parent_ref->dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(parent_ref->name, parent_ref->name_len);\n\n\tret = btrfs_search_slot(NULL, sctx->parent_root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret > 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tdi = btrfs_match_dir_item_name(sctx->parent_root, path,\n\t\t\t\t       parent_ref->name, parent_ref->name_len);\n\tif (!di) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\t/*\n\t * di_key.objectid has the number of the inode that has a dentry in the\n\t * parent directory with the same name that sctx->cur_ino is being\n\t * renamed to. We need to check if that inode is in the send root as\n\t * well and if it is currently marked as an inode with a pending rename,\n\t * if it is, we need to delay the rename of sctx->cur_ino as well, so\n\t * that it happens after that other inode is renamed.\n\t */\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &di_key);\n\tif (di_key.type != BTRFS_INODE_ITEM_KEY) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = get_inode_info(sctx->parent_root, di_key.objectid, NULL,\n\t\t\t     &left_gen, NULL, NULL, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = get_inode_info(sctx->send_root, di_key.objectid, NULL,\n\t\t\t     &right_gen, NULL, NULL, NULL, NULL);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Different inode, no need to delay the rename of sctx->cur_ino */\n\tif (right_gen != left_gen) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (is_waiting_for_move(sctx, di_key.objectid)) {\n\t\tret = add_pending_dir_move(sctx,\n\t\t\t\t\t   sctx->cur_ino,\n\t\t\t\t\t   sctx->cur_inode_gen,\n\t\t\t\t\t   di_key.objectid,\n\t\t\t\t\t   &sctx->new_refs,\n\t\t\t\t\t   &sctx->deleted_refs,\n\t\t\t\t\t   is_orphan);\n\t\tif (!ret)\n\t\t\tret = 1;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 3411
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_pending_dir_move",
          "args": [
            "sctx",
            "sctx->cur_ino",
            "sctx->cur_inode_gen",
            "di_key.objectid",
            "&sctx->new_refs",
            "&sctx->deleted_refs",
            "is_orphan"
          ],
          "line": 3400
        },
        "resolved": true,
        "details": {
          "function_name": "add_pending_dir_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2983-3050",
          "snippet": "static int add_pending_dir_move(struct send_ctx *sctx,\n\t\t\t\tu64 ino,\n\t\t\t\tu64 ino_gen,\n\t\t\t\tu64 parent_ino,\n\t\t\t\tstruct list_head *new_refs,\n\t\t\t\tstruct list_head *deleted_refs,\n\t\t\t\tconst bool is_orphan)\n{\n\tstruct rb_node **p = &sctx->pending_dir_moves.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct pending_dir_move *entry = NULL, *pm;\n\tstruct recorded_ref *cur;\n\tint exists = 0;\n\tint ret;\n\n\tpm = kmalloc(sizeof(*pm), GFP_NOFS);\n\tif (!pm)\n\t\treturn -ENOMEM;\n\tpm->parent_ino = parent_ino;\n\tpm->ino = ino;\n\tpm->gen = ino_gen;\n\tpm->is_orphan = is_orphan;\n\tINIT_LIST_HEAD(&pm->list);\n\tINIT_LIST_HEAD(&pm->update_refs);\n\tRB_CLEAR_NODE(&pm->node);\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct pending_dir_move, node);\n\t\tif (parent_ino < entry->parent_ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (parent_ino > entry->parent_ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\texists = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(cur, deleted_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tlist_for_each_entry(cur, new_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = add_waiting_dir_move(sctx, pm->ino);\n\tif (ret)\n\t\tgoto out;\n\n\tif (exists) {\n\t\tlist_add_tail(&pm->list, &entry->list);\n\t} else {\n\t\trb_link_node(&pm->node, parent, p);\n\t\trb_insert_color(&pm->node, &sctx->pending_dir_moves);\n\t}\n\tret = 0;\nout:\n\tif (ret) {\n\t\t__free_recorded_refs(&pm->update_refs);\n\t\tkfree(pm);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int add_pending_dir_move(struct send_ctx *sctx,\n\t\t\t\tu64 ino,\n\t\t\t\tu64 ino_gen,\n\t\t\t\tu64 parent_ino,\n\t\t\t\tstruct list_head *new_refs,\n\t\t\t\tstruct list_head *deleted_refs,\n\t\t\t\tconst bool is_orphan)\n{\n\tstruct rb_node **p = &sctx->pending_dir_moves.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct pending_dir_move *entry = NULL, *pm;\n\tstruct recorded_ref *cur;\n\tint exists = 0;\n\tint ret;\n\n\tpm = kmalloc(sizeof(*pm), GFP_NOFS);\n\tif (!pm)\n\t\treturn -ENOMEM;\n\tpm->parent_ino = parent_ino;\n\tpm->ino = ino;\n\tpm->gen = ino_gen;\n\tpm->is_orphan = is_orphan;\n\tINIT_LIST_HEAD(&pm->list);\n\tINIT_LIST_HEAD(&pm->update_refs);\n\tRB_CLEAR_NODE(&pm->node);\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct pending_dir_move, node);\n\t\tif (parent_ino < entry->parent_ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (parent_ino > entry->parent_ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\texists = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(cur, deleted_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tlist_for_each_entry(cur, new_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = add_waiting_dir_move(sctx, pm->ino);\n\tif (ret)\n\t\tgoto out;\n\n\tif (exists) {\n\t\tlist_add_tail(&pm->list, &entry->list);\n\t} else {\n\t\trb_link_node(&pm->node, parent, p);\n\t\trb_insert_color(&pm->node, &sctx->pending_dir_moves);\n\t}\n\tret = 0;\nout:\n\tif (ret) {\n\t\t__free_recorded_refs(&pm->update_refs);\n\t\tkfree(pm);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_waiting_for_move",
          "args": [
            "sctx",
            "di_key.objectid"
          ],
          "line": 3399
        },
        "resolved": true,
        "details": {
          "function_name": "is_waiting_for_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2919-2924",
          "snippet": "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct waiting_dir_move *entry = get_waiting_dir_move(sctx, ino);\n\n\treturn entry != NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct waiting_dir_move *entry = get_waiting_dir_move(sctx, ino);\n\n\treturn entry != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode_info",
          "args": [
            "sctx->send_root",
            "di_key.objectid",
            "NULL",
            "&right_gen",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 3385
        },
        "resolved": true,
        "details": {
          "function_name": "get_inode_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "821-836",
          "snippet": "static int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "di",
            "&di_key"
          ],
          "line": 3375
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dir_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2763-2770",
          "snippet": "static inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_match_dir_item_name",
          "args": [
            "sctx->parent_root",
            "path",
            "parent_ref->name",
            "parent_ref->name_len"
          ],
          "line": 3361
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_match_dir_item_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "382-414",
          "snippet": "struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n\t\t\t\t\t\t struct btrfs_path *path,\n\t\t\t\t\t\t const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr;\n\tu32 total_len;\n\tu32 cur = 0;\n\tu32 this_len;\n\tstruct extent_buffer *leaf;\n\n\tleaf = path->nodes[0];\n\tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\tif (verify_dir_item(root, leaf, dir_item))\n\t\treturn NULL;\n\n\ttotal_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\twhile (cur < total_len) {\n\t\tthis_len = sizeof(*dir_item) +\n\t\t\tbtrfs_dir_name_len(leaf, dir_item) +\n\t\t\tbtrfs_dir_data_len(leaf, dir_item);\n\t\tname_ptr = (unsigned long)(dir_item + 1);\n\n\t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\n\t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\n\t\t\treturn dir_item;\n\n\t\tcur += this_len;\n\t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +\n\t\t\t\t\t\t     this_len);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n\t\t\t\t\t\t struct btrfs_path *path,\n\t\t\t\t\t\t const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr;\n\tu32 total_len;\n\tu32 cur = 0;\n\tu32 this_len;\n\tstruct extent_buffer *leaf;\n\n\tleaf = path->nodes[0];\n\tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\tif (verify_dir_item(root, leaf, dir_item))\n\t\treturn NULL;\n\n\ttotal_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\twhile (cur < total_len) {\n\t\tthis_len = sizeof(*dir_item) +\n\t\t\tbtrfs_dir_name_len(leaf, dir_item) +\n\t\t\tbtrfs_dir_data_len(leaf, dir_item);\n\t\tname_ptr = (unsigned long)(dir_item + 1);\n\n\t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\n\t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\n\t\t\treturn dir_item;\n\n\t\tcur += this_len;\n\t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +\n\t\t\t\t\t\t     this_len);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "sctx->parent_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 3353
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_name_hash",
          "args": [
            "parent_ref->name",
            "parent_ref->name_len"
          ],
          "line": 3351
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/hash.h",
          "lines": "28-31",
          "snippet": "static inline u64 btrfs_name_hash(const char *name, int len)\n{\n\treturn btrfs_crc32c((u32)~1, name, len);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 btrfs_name_hash(const char *name, int len)\n{\n\treturn btrfs_crc32c((u32)~1, name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_path_for_send",
          "args": [],
          "line": 3345
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_path_for_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "496-507",
          "snippet": "static struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&sctx->waiting_dir_moves"
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int wait_for_dest_dir_move(struct send_ctx *sctx,\n\t\t\t\t  struct recorded_ref *parent_ref,\n\t\t\t\t  const bool is_orphan)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key di_key;\n\tstruct btrfs_dir_item *di;\n\tu64 left_gen;\n\tu64 right_gen;\n\tint ret = 0;\n\n\tif (RB_EMPTY_ROOT(&sctx->waiting_dir_moves))\n\t\treturn 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = parent_ref->dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(parent_ref->name, parent_ref->name_len);\n\n\tret = btrfs_search_slot(NULL, sctx->parent_root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret > 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tdi = btrfs_match_dir_item_name(sctx->parent_root, path,\n\t\t\t\t       parent_ref->name, parent_ref->name_len);\n\tif (!di) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\t/*\n\t * di_key.objectid has the number of the inode that has a dentry in the\n\t * parent directory with the same name that sctx->cur_ino is being\n\t * renamed to. We need to check if that inode is in the send root as\n\t * well and if it is currently marked as an inode with a pending rename,\n\t * if it is, we need to delay the rename of sctx->cur_ino as well, so\n\t * that it happens after that other inode is renamed.\n\t */\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &di_key);\n\tif (di_key.type != BTRFS_INODE_ITEM_KEY) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = get_inode_info(sctx->parent_root, di_key.objectid, NULL,\n\t\t\t     &left_gen, NULL, NULL, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = get_inode_info(sctx->send_root, di_key.objectid, NULL,\n\t\t\t     &right_gen, NULL, NULL, NULL, NULL);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Different inode, no need to delay the rename of sctx->cur_ino */\n\tif (right_gen != left_gen) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (is_waiting_for_move(sctx, di_key.objectid)) {\n\t\tret = add_pending_dir_move(sctx,\n\t\t\t\t\t   sctx->cur_ino,\n\t\t\t\t\t   sctx->cur_inode_gen,\n\t\t\t\t\t   di_key.objectid,\n\t\t\t\t\t   &sctx->new_refs,\n\t\t\t\t\t   &sctx->deleted_refs,\n\t\t\t\t\t   is_orphan);\n\t\tif (!ret)\n\t\t\tret = 1;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "apply_children_dir_moves",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "3259-3292",
    "snippet": "static int apply_children_dir_moves(struct send_ctx *sctx)\n{\n\tstruct pending_dir_move *pm;\n\tstruct list_head stack;\n\tu64 parent_ino = sctx->cur_ino;\n\tint ret = 0;\n\n\tpm = get_pending_dir_moves(sctx, parent_ino);\n\tif (!pm)\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&stack);\n\ttail_append_pending_moves(pm, &stack);\n\n\twhile (!list_empty(&stack)) {\n\t\tpm = list_first_entry(&stack, struct pending_dir_move, list);\n\t\tparent_ino = pm->ino;\n\t\tret = apply_dir_move(sctx, pm);\n\t\tfree_pending_move(sctx, pm);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tpm = get_pending_dir_moves(sctx, parent_ino);\n\t\tif (pm)\n\t\t\ttail_append_pending_moves(pm, &stack);\n\t}\n\treturn 0;\n\nout:\n\twhile (!list_empty(&stack)) {\n\t\tpm = list_first_entry(&stack, struct pending_dir_move, list);\n\t\tfree_pending_move(sctx, pm);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pending_move",
          "args": [
            "sctx",
            "pm"
          ],
          "line": 3289
        },
        "resolved": true,
        "details": {
          "function_name": "free_pending_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3236-3244",
          "snippet": "static void free_pending_move(struct send_ctx *sctx, struct pending_dir_move *m)\n{\n\tif (!list_empty(&m->list))\n\t\tlist_del(&m->list);\n\tif (!RB_EMPTY_NODE(&m->node))\n\t\trb_erase(&m->node, &sctx->pending_dir_moves);\n\t__free_recorded_refs(&m->update_refs);\n\tkfree(m);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void free_pending_move(struct send_ctx *sctx, struct pending_dir_move *m)\n{\n\tif (!list_empty(&m->list))\n\t\tlist_del(&m->list);\n\tif (!RB_EMPTY_NODE(&m->node))\n\t\trb_erase(&m->node, &sctx->pending_dir_moves);\n\t__free_recorded_refs(&m->update_refs);\n\tkfree(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&stack",
            "structpending_dir_move",
            "list"
          ],
          "line": 3288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&stack"
          ],
          "line": 3287
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tail_append_pending_moves",
          "args": [
            "pm",
            "&stack"
          ],
          "line": 3282
        },
        "resolved": true,
        "details": {
          "function_name": "tail_append_pending_moves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3246-3257",
          "snippet": "static void tail_append_pending_moves(struct pending_dir_move *moves,\n\t\t\t\t      struct list_head *stack)\n{\n\tif (list_empty(&moves->list)) {\n\t\tlist_add_tail(&moves->list, stack);\n\t} else {\n\t\tLIST_HEAD(list);\n\t\tlist_splice_init(&moves->list, &list);\n\t\tlist_add_tail(&moves->list, stack);\n\t\tlist_splice_tail(&list, stack);\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void tail_append_pending_moves(struct pending_dir_move *moves,\n\t\t\t\t      struct list_head *stack)\n{\n\tif (list_empty(&moves->list)) {\n\t\tlist_add_tail(&moves->list, stack);\n\t} else {\n\t\tLIST_HEAD(list);\n\t\tlist_splice_init(&moves->list, &list);\n\t\tlist_add_tail(&moves->list, stack);\n\t\tlist_splice_tail(&list, stack);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pending_dir_moves",
          "args": [
            "sctx",
            "parent_ino"
          ],
          "line": 3280
        },
        "resolved": true,
        "details": {
          "function_name": "get_pending_dir_moves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3052-3068",
          "snippet": "static struct pending_dir_move *get_pending_dir_moves(struct send_ctx *sctx,\n\t\t\t\t\t\t      u64 parent_ino)\n{\n\tstruct rb_node *n = sctx->pending_dir_moves.rb_node;\n\tstruct pending_dir_move *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct pending_dir_move, node);\n\t\tif (parent_ino < entry->parent_ino)\n\t\t\tn = n->rb_left;\n\t\telse if (parent_ino > entry->parent_ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct pending_dir_move *get_pending_dir_moves(struct send_ctx *sctx,\n\t\t\t\t\t\t      u64 parent_ino)\n{\n\tstruct rb_node *n = sctx->pending_dir_moves.rb_node;\n\tstruct pending_dir_move *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct pending_dir_move, node);\n\t\tif (parent_ino < entry->parent_ino)\n\t\t\tn = n->rb_left;\n\t\telse if (parent_ino > entry->parent_ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_dir_move",
          "args": [
            "sctx",
            "pm"
          ],
          "line": 3276
        },
        "resolved": true,
        "details": {
          "function_name": "apply_dir_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3112-3234",
          "snippet": "static int apply_dir_move(struct send_ctx *sctx, struct pending_dir_move *pm)\n{\n\tstruct fs_path *from_path = NULL;\n\tstruct fs_path *to_path = NULL;\n\tstruct fs_path *name = NULL;\n\tu64 orig_progress = sctx->send_progress;\n\tstruct recorded_ref *cur;\n\tu64 parent_ino, parent_gen;\n\tstruct waiting_dir_move *dm = NULL;\n\tu64 rmdir_ino = 0;\n\tint ret;\n\tu64 ancestor = 0;\n\n\tname = fs_path_alloc();\n\tfrom_path = fs_path_alloc();\n\tif (!name || !from_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdm = get_waiting_dir_move(sctx, pm->ino);\n\tASSERT(dm);\n\trmdir_ino = dm->rmdir_ino;\n\tfree_waiting_dir_move(sctx, dm);\n\n\tif (pm->is_orphan) {\n\t\tret = gen_unique_name(sctx, pm->ino,\n\t\t\t\t      pm->gen, from_path);\n\t} else {\n\t\tret = get_first_ref(sctx->parent_root, pm->ino,\n\t\t\t\t    &parent_ino, &parent_gen, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = get_cur_path(sctx, parent_ino, parent_gen,\n\t\t\t\t   from_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = fs_path_add_path(from_path, name);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsctx->send_progress = sctx->cur_ino + 1;\n\tret = path_loop(sctx, name, pm->ino, pm->gen, &ancestor);\n\tif (ret) {\n\t\tLIST_HEAD(deleted_refs);\n\t\tASSERT(ancestor > BTRFS_FIRST_FREE_OBJECTID);\n\t\tret = add_pending_dir_move(sctx, pm->ino, pm->gen, ancestor,\n\t\t\t\t\t   &pm->update_refs, &deleted_refs,\n\t\t\t\t\t   pm->is_orphan);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (rmdir_ino) {\n\t\t\tdm = get_waiting_dir_move(sctx, pm->ino);\n\t\t\tASSERT(dm);\n\t\t\tdm->rmdir_ino = rmdir_ino;\n\t\t}\n\t\tgoto out;\n\t}\n\tfs_path_reset(name);\n\tto_path = name;\n\tname = NULL;\n\tret = get_cur_path(sctx, pm->ino, pm->gen, to_path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_rename(sctx, from_path, to_path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (rmdir_ino) {\n\t\tstruct orphan_dir_info *odi;\n\n\t\todi = get_orphan_dir_info(sctx, rmdir_ino);\n\t\tif (!odi) {\n\t\t\t/* already deleted */\n\t\t\tgoto finish;\n\t\t}\n\t\tret = can_rmdir(sctx, rmdir_ino, odi->gen, sctx->cur_ino + 1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (!ret)\n\t\t\tgoto finish;\n\n\t\tname = fs_path_alloc();\n\t\tif (!name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_cur_path(sctx, rmdir_ino, odi->gen, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = send_rmdir(sctx, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tfree_orphan_dir_info(sctx, odi);\n\t}\n\nfinish:\n\tret = send_utimes(sctx, pm->ino, pm->gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * After rename/move, need to update the utimes of both new parent(s)\n\t * and old parent(s).\n\t */\n\tlist_for_each_entry(cur, &pm->update_refs, list) {\n\t\tif (cur->dir == rmdir_ino)\n\t\t\tcontinue;\n\t\tret = send_utimes(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tfs_path_free(name);\n\tfs_path_free(from_path);\n\tfs_path_free(to_path);\n\tsctx->send_progress = orig_progress;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int apply_dir_move(struct send_ctx *sctx, struct pending_dir_move *pm)\n{\n\tstruct fs_path *from_path = NULL;\n\tstruct fs_path *to_path = NULL;\n\tstruct fs_path *name = NULL;\n\tu64 orig_progress = sctx->send_progress;\n\tstruct recorded_ref *cur;\n\tu64 parent_ino, parent_gen;\n\tstruct waiting_dir_move *dm = NULL;\n\tu64 rmdir_ino = 0;\n\tint ret;\n\tu64 ancestor = 0;\n\n\tname = fs_path_alloc();\n\tfrom_path = fs_path_alloc();\n\tif (!name || !from_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdm = get_waiting_dir_move(sctx, pm->ino);\n\tASSERT(dm);\n\trmdir_ino = dm->rmdir_ino;\n\tfree_waiting_dir_move(sctx, dm);\n\n\tif (pm->is_orphan) {\n\t\tret = gen_unique_name(sctx, pm->ino,\n\t\t\t\t      pm->gen, from_path);\n\t} else {\n\t\tret = get_first_ref(sctx->parent_root, pm->ino,\n\t\t\t\t    &parent_ino, &parent_gen, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = get_cur_path(sctx, parent_ino, parent_gen,\n\t\t\t\t   from_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = fs_path_add_path(from_path, name);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsctx->send_progress = sctx->cur_ino + 1;\n\tret = path_loop(sctx, name, pm->ino, pm->gen, &ancestor);\n\tif (ret) {\n\t\tLIST_HEAD(deleted_refs);\n\t\tASSERT(ancestor > BTRFS_FIRST_FREE_OBJECTID);\n\t\tret = add_pending_dir_move(sctx, pm->ino, pm->gen, ancestor,\n\t\t\t\t\t   &pm->update_refs, &deleted_refs,\n\t\t\t\t\t   pm->is_orphan);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (rmdir_ino) {\n\t\t\tdm = get_waiting_dir_move(sctx, pm->ino);\n\t\t\tASSERT(dm);\n\t\t\tdm->rmdir_ino = rmdir_ino;\n\t\t}\n\t\tgoto out;\n\t}\n\tfs_path_reset(name);\n\tto_path = name;\n\tname = NULL;\n\tret = get_cur_path(sctx, pm->ino, pm->gen, to_path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_rename(sctx, from_path, to_path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (rmdir_ino) {\n\t\tstruct orphan_dir_info *odi;\n\n\t\todi = get_orphan_dir_info(sctx, rmdir_ino);\n\t\tif (!odi) {\n\t\t\t/* already deleted */\n\t\t\tgoto finish;\n\t\t}\n\t\tret = can_rmdir(sctx, rmdir_ino, odi->gen, sctx->cur_ino + 1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (!ret)\n\t\t\tgoto finish;\n\n\t\tname = fs_path_alloc();\n\t\tif (!name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_cur_path(sctx, rmdir_ino, odi->gen, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = send_rmdir(sctx, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tfree_orphan_dir_info(sctx, odi);\n\t}\n\nfinish:\n\tret = send_utimes(sctx, pm->ino, pm->gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * After rename/move, need to update the utimes of both new parent(s)\n\t * and old parent(s).\n\t */\n\tlist_for_each_entry(cur, &pm->update_refs, list) {\n\t\tif (cur->dir == rmdir_ino)\n\t\t\tcontinue;\n\t\tret = send_utimes(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tfs_path_free(name);\n\tfs_path_free(from_path);\n\tfs_path_free(to_path);\n\tsctx->send_progress = orig_progress;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&stack",
            "structpending_dir_move",
            "list"
          ],
          "line": 3274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&stack"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int apply_children_dir_moves(struct send_ctx *sctx)\n{\n\tstruct pending_dir_move *pm;\n\tstruct list_head stack;\n\tu64 parent_ino = sctx->cur_ino;\n\tint ret = 0;\n\n\tpm = get_pending_dir_moves(sctx, parent_ino);\n\tif (!pm)\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&stack);\n\ttail_append_pending_moves(pm, &stack);\n\n\twhile (!list_empty(&stack)) {\n\t\tpm = list_first_entry(&stack, struct pending_dir_move, list);\n\t\tparent_ino = pm->ino;\n\t\tret = apply_dir_move(sctx, pm);\n\t\tfree_pending_move(sctx, pm);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tpm = get_pending_dir_moves(sctx, parent_ino);\n\t\tif (pm)\n\t\t\ttail_append_pending_moves(pm, &stack);\n\t}\n\treturn 0;\n\nout:\n\twhile (!list_empty(&stack)) {\n\t\tpm = list_first_entry(&stack, struct pending_dir_move, list);\n\t\tfree_pending_move(sctx, pm);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "tail_append_pending_moves",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "3246-3257",
    "snippet": "static void tail_append_pending_moves(struct pending_dir_move *moves,\n\t\t\t\t      struct list_head *stack)\n{\n\tif (list_empty(&moves->list)) {\n\t\tlist_add_tail(&moves->list, stack);\n\t} else {\n\t\tLIST_HEAD(list);\n\t\tlist_splice_init(&moves->list, &list);\n\t\tlist_add_tail(&moves->list, stack);\n\t\tlist_splice_tail(&list, stack);\n\t}\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_splice_tail",
          "args": [
            "&list",
            "stack"
          ],
          "line": 3255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&moves->list",
            "stack"
          ],
          "line": 3254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&moves->list",
            "&list"
          ],
          "line": 3253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 3252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&moves->list",
            "stack"
          ],
          "line": 3250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&moves->list"
          ],
          "line": 3249
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void tail_append_pending_moves(struct pending_dir_move *moves,\n\t\t\t\t      struct list_head *stack)\n{\n\tif (list_empty(&moves->list)) {\n\t\tlist_add_tail(&moves->list, stack);\n\t} else {\n\t\tLIST_HEAD(list);\n\t\tlist_splice_init(&moves->list, &list);\n\t\tlist_add_tail(&moves->list, stack);\n\t\tlist_splice_tail(&list, stack);\n\t}\n}"
  },
  {
    "function_name": "free_pending_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "3236-3244",
    "snippet": "static void free_pending_move(struct send_ctx *sctx, struct pending_dir_move *m)\n{\n\tif (!list_empty(&m->list))\n\t\tlist_del(&m->list);\n\tif (!RB_EMPTY_NODE(&m->node))\n\t\trb_erase(&m->node, &sctx->pending_dir_moves);\n\t__free_recorded_refs(&m->update_refs);\n\tkfree(m);\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "m"
          ],
          "line": 3243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_recorded_refs",
          "args": [
            "&m->update_refs"
          ],
          "line": 3242
        },
        "resolved": true,
        "details": {
          "function_name": "__free_recorded_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2726-2736",
          "snippet": "static void __free_recorded_refs(struct list_head *head)\n{\n\tstruct recorded_ref *cur;\n\n\twhile (!list_empty(head)) {\n\t\tcur = list_entry(head->next, struct recorded_ref, list);\n\t\tfs_path_free(cur->full_path);\n\t\tlist_del(&cur->list);\n\t\tkfree(cur);\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void __free_recorded_refs(struct list_head *head)\n{\n\tstruct recorded_ref *cur;\n\n\twhile (!list_empty(head)) {\n\t\tcur = list_entry(head->next, struct recorded_ref, list);\n\t\tfs_path_free(cur->full_path);\n\t\tlist_del(&cur->list);\n\t\tkfree(cur);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&m->node",
            "&sctx->pending_dir_moves"
          ],
          "line": 3241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&m->node"
          ],
          "line": 3240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&m->list"
          ],
          "line": 3239
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&m->list"
          ],
          "line": 3238
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void free_pending_move(struct send_ctx *sctx, struct pending_dir_move *m)\n{\n\tif (!list_empty(&m->list))\n\t\tlist_del(&m->list);\n\tif (!RB_EMPTY_NODE(&m->node))\n\t\trb_erase(&m->node, &sctx->pending_dir_moves);\n\t__free_recorded_refs(&m->update_refs);\n\tkfree(m);\n}"
  },
  {
    "function_name": "apply_dir_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "3112-3234",
    "snippet": "static int apply_dir_move(struct send_ctx *sctx, struct pending_dir_move *pm)\n{\n\tstruct fs_path *from_path = NULL;\n\tstruct fs_path *to_path = NULL;\n\tstruct fs_path *name = NULL;\n\tu64 orig_progress = sctx->send_progress;\n\tstruct recorded_ref *cur;\n\tu64 parent_ino, parent_gen;\n\tstruct waiting_dir_move *dm = NULL;\n\tu64 rmdir_ino = 0;\n\tint ret;\n\tu64 ancestor = 0;\n\n\tname = fs_path_alloc();\n\tfrom_path = fs_path_alloc();\n\tif (!name || !from_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdm = get_waiting_dir_move(sctx, pm->ino);\n\tASSERT(dm);\n\trmdir_ino = dm->rmdir_ino;\n\tfree_waiting_dir_move(sctx, dm);\n\n\tif (pm->is_orphan) {\n\t\tret = gen_unique_name(sctx, pm->ino,\n\t\t\t\t      pm->gen, from_path);\n\t} else {\n\t\tret = get_first_ref(sctx->parent_root, pm->ino,\n\t\t\t\t    &parent_ino, &parent_gen, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = get_cur_path(sctx, parent_ino, parent_gen,\n\t\t\t\t   from_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = fs_path_add_path(from_path, name);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsctx->send_progress = sctx->cur_ino + 1;\n\tret = path_loop(sctx, name, pm->ino, pm->gen, &ancestor);\n\tif (ret) {\n\t\tLIST_HEAD(deleted_refs);\n\t\tASSERT(ancestor > BTRFS_FIRST_FREE_OBJECTID);\n\t\tret = add_pending_dir_move(sctx, pm->ino, pm->gen, ancestor,\n\t\t\t\t\t   &pm->update_refs, &deleted_refs,\n\t\t\t\t\t   pm->is_orphan);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (rmdir_ino) {\n\t\t\tdm = get_waiting_dir_move(sctx, pm->ino);\n\t\t\tASSERT(dm);\n\t\t\tdm->rmdir_ino = rmdir_ino;\n\t\t}\n\t\tgoto out;\n\t}\n\tfs_path_reset(name);\n\tto_path = name;\n\tname = NULL;\n\tret = get_cur_path(sctx, pm->ino, pm->gen, to_path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_rename(sctx, from_path, to_path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (rmdir_ino) {\n\t\tstruct orphan_dir_info *odi;\n\n\t\todi = get_orphan_dir_info(sctx, rmdir_ino);\n\t\tif (!odi) {\n\t\t\t/* already deleted */\n\t\t\tgoto finish;\n\t\t}\n\t\tret = can_rmdir(sctx, rmdir_ino, odi->gen, sctx->cur_ino + 1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (!ret)\n\t\t\tgoto finish;\n\n\t\tname = fs_path_alloc();\n\t\tif (!name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_cur_path(sctx, rmdir_ino, odi->gen, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = send_rmdir(sctx, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tfree_orphan_dir_info(sctx, odi);\n\t}\n\nfinish:\n\tret = send_utimes(sctx, pm->ino, pm->gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * After rename/move, need to update the utimes of both new parent(s)\n\t * and old parent(s).\n\t */\n\tlist_for_each_entry(cur, &pm->update_refs, list) {\n\t\tif (cur->dir == rmdir_ino)\n\t\t\tcontinue;\n\t\tret = send_utimes(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tfs_path_free(name);\n\tfs_path_free(from_path);\n\tfs_path_free(to_path);\n\tsctx->send_progress = orig_progress;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "to_path"
          ],
          "line": 3230
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_utimes",
          "args": [
            "sctx",
            "cur->dir",
            "cur->dir_gen"
          ],
          "line": 3222
        },
        "resolved": true,
        "details": {
          "function_name": "send_utimes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2434-2487",
          "snippet": "static int send_utimes(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret = 0;\n\tstruct fs_path *p = NULL;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_key key;\n\tint slot;\n\nverbose_printk(\"btrfs: send_utimes %llu\\n\", ino);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpath = alloc_path_for_send();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, sctx->send_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tii = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UTIMES);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_ATIME, eb, &ii->atime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_MTIME, eb, &ii->mtime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_CTIME, eb, &ii->ctime);\n\t/* TODO Add otime support when the otime patches get into upstream */\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int send_utimes(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret = 0;\n\tstruct fs_path *p = NULL;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_key key;\n\tint slot;\n\nverbose_printk(\"btrfs: send_utimes %llu\\n\", ino);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpath = alloc_path_for_send();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, sctx->send_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tii = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UTIMES);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_ATIME, eb, &ii->atime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_MTIME, eb, &ii->mtime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_CTIME, eb, &ii->ctime);\n\t/* TODO Add otime support when the otime patches get into upstream */\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cur",
            "&pm->update_refs",
            "list"
          ],
          "line": 3219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_orphan_dir_info",
          "args": [
            "sctx",
            "odi"
          ],
          "line": 3207
        },
        "resolved": true,
        "details": {
          "function_name": "free_orphan_dir_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2826-2833",
          "snippet": "static void free_orphan_dir_info(struct send_ctx *sctx,\n\t\t\t\t struct orphan_dir_info *odi)\n{\n\tif (!odi)\n\t\treturn;\n\trb_erase(&odi->node, &sctx->orphan_dirs);\n\tkfree(odi);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void free_orphan_dir_info(struct send_ctx *sctx,\n\t\t\t\t struct orphan_dir_info *odi)\n{\n\tif (!odi)\n\t\treturn;\n\trb_erase(&odi->node, &sctx->orphan_dirs);\n\tkfree(odi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_rmdir",
          "args": [
            "sctx",
            "name"
          ],
          "line": 3204
        },
        "resolved": true,
        "details": {
          "function_name": "send_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "763-780",
          "snippet": "static int send_rmdir(struct send_ctx *sctx, struct fs_path *path)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_rmdir %s\\n\", path->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_RMDIR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_rmdir(struct send_ctx *sctx, struct fs_path *path)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_rmdir %s\\n\", path->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_RMDIR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cur_path",
          "args": [
            "sctx",
            "rmdir_ino",
            "odi->gen",
            "name"
          ],
          "line": 3201
        },
        "resolved": true,
        "details": {
          "function_name": "get_cur_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2207-2263",
          "snippet": "static int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 3196
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_rmdir",
          "args": [
            "sctx",
            "rmdir_ino",
            "odi->gen",
            "sctx->cur_ino + 1"
          ],
          "line": 3190
        },
        "resolved": true,
        "details": {
          "function_name": "can_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2840-2917",
          "snippet": "static int can_rmdir(struct send_ctx *sctx, u64 dir, u64 dir_gen,\n\t\t     u64 send_progress)\n{\n\tint ret = 0;\n\tstruct btrfs_root *root = sctx->parent_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key loc;\n\tstruct btrfs_dir_item *di;\n\n\t/*\n\t * Don't try to rmdir the top/root subvolume dir.\n\t */\n\tif (dir == BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstruct waiting_dir_move *dm;\n\n\t\tif (path->slots[0] >= btrfs_header_nritems(path->nodes[0])) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type)\n\t\t\tbreak;\n\n\t\tdi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\tstruct btrfs_dir_item);\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &loc);\n\n\t\tdm = get_waiting_dir_move(sctx, loc.objectid);\n\t\tif (dm) {\n\t\t\tstruct orphan_dir_info *odi;\n\n\t\t\todi = add_orphan_dir_info(sctx, dir);\n\t\t\tif (IS_ERR(odi)) {\n\t\t\t\tret = PTR_ERR(odi);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\todi->gen = dir_gen;\n\t\t\tdm->rmdir_ino = dir;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (loc.objectid > send_progress) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t}\n\n\tret = 1;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int can_rmdir(struct send_ctx *sctx, u64 dir, u64 dir_gen,\n\t\t     u64 send_progress)\n{\n\tint ret = 0;\n\tstruct btrfs_root *root = sctx->parent_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key loc;\n\tstruct btrfs_dir_item *di;\n\n\t/*\n\t * Don't try to rmdir the top/root subvolume dir.\n\t */\n\tif (dir == BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstruct waiting_dir_move *dm;\n\n\t\tif (path->slots[0] >= btrfs_header_nritems(path->nodes[0])) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type)\n\t\t\tbreak;\n\n\t\tdi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\tstruct btrfs_dir_item);\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &loc);\n\n\t\tdm = get_waiting_dir_move(sctx, loc.objectid);\n\t\tif (dm) {\n\t\t\tstruct orphan_dir_info *odi;\n\n\t\t\todi = add_orphan_dir_info(sctx, dir);\n\t\t\tif (IS_ERR(odi)) {\n\t\t\t\tret = PTR_ERR(odi);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\todi->gen = dir_gen;\n\t\t\tdm->rmdir_ino = dir;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (loc.objectid > send_progress) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t}\n\n\tret = 1;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_orphan_dir_info",
          "args": [
            "sctx",
            "rmdir_ino"
          ],
          "line": 3185
        },
        "resolved": true,
        "details": {
          "function_name": "get_orphan_dir_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2801-2817",
          "snippet": "static struct orphan_dir_info *\nget_orphan_dir_info(struct send_ctx *sctx, u64 dir_ino)\n{\n\tstruct rb_node *n = sctx->orphan_dirs.rb_node;\n\tstruct orphan_dir_info *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct orphan_dir_info, node);\n\t\tif (dir_ino < entry->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (dir_ino > entry->ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);",
            "static int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\nstatic int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino);\n\nstatic struct orphan_dir_info *\nget_orphan_dir_info(struct send_ctx *sctx, u64 dir_ino)\n{\n\tstruct rb_node *n = sctx->orphan_dirs.rb_node;\n\tstruct orphan_dir_info *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct orphan_dir_info, node);\n\t\tif (dir_ino < entry->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (dir_ino > entry->ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_rename",
          "args": [
            "sctx",
            "from_path",
            "to_path"
          ],
          "line": 3178
        },
        "resolved": true,
        "details": {
          "function_name": "send_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "693-712",
          "snippet": "static int send_rename(struct send_ctx *sctx,\n\t\t     struct fs_path *from, struct fs_path *to)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_rename %s -> %s\\n\", from->start, to->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_RENAME);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, from);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_TO, to);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_rename(struct send_ctx *sctx,\n\t\t     struct fs_path *from, struct fs_path *to)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_rename %s -> %s\\n\", from->start, to->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_RENAME);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, from);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_TO, to);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_reset",
          "args": [
            "name"
          ],
          "line": 3171
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "289-300",
          "snippet": "static void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dm"
          ],
          "line": 3166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_waiting_dir_move",
          "args": [
            "sctx",
            "pm->ino"
          ],
          "line": 3165
        },
        "resolved": true,
        "details": {
          "function_name": "get_waiting_dir_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2956-2972",
          "snippet": "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct rb_node *n = sctx->waiting_dir_moves.rb_node;\n\tstruct waiting_dir_move *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct waiting_dir_move, node);\n\t\tif (ino < entry->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (ino > entry->ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct rb_node *n = sctx->waiting_dir_moves.rb_node;\n\tstruct waiting_dir_move *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct waiting_dir_move, node);\n\t\tif (ino < entry->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (ino > entry->ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_pending_dir_move",
          "args": [
            "sctx",
            "pm->ino",
            "pm->gen",
            "ancestor",
            "&pm->update_refs",
            "&deleted_refs",
            "pm->is_orphan"
          ],
          "line": 3159
        },
        "resolved": true,
        "details": {
          "function_name": "add_pending_dir_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2983-3050",
          "snippet": "static int add_pending_dir_move(struct send_ctx *sctx,\n\t\t\t\tu64 ino,\n\t\t\t\tu64 ino_gen,\n\t\t\t\tu64 parent_ino,\n\t\t\t\tstruct list_head *new_refs,\n\t\t\t\tstruct list_head *deleted_refs,\n\t\t\t\tconst bool is_orphan)\n{\n\tstruct rb_node **p = &sctx->pending_dir_moves.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct pending_dir_move *entry = NULL, *pm;\n\tstruct recorded_ref *cur;\n\tint exists = 0;\n\tint ret;\n\n\tpm = kmalloc(sizeof(*pm), GFP_NOFS);\n\tif (!pm)\n\t\treturn -ENOMEM;\n\tpm->parent_ino = parent_ino;\n\tpm->ino = ino;\n\tpm->gen = ino_gen;\n\tpm->is_orphan = is_orphan;\n\tINIT_LIST_HEAD(&pm->list);\n\tINIT_LIST_HEAD(&pm->update_refs);\n\tRB_CLEAR_NODE(&pm->node);\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct pending_dir_move, node);\n\t\tif (parent_ino < entry->parent_ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (parent_ino > entry->parent_ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\texists = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(cur, deleted_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tlist_for_each_entry(cur, new_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = add_waiting_dir_move(sctx, pm->ino);\n\tif (ret)\n\t\tgoto out;\n\n\tif (exists) {\n\t\tlist_add_tail(&pm->list, &entry->list);\n\t} else {\n\t\trb_link_node(&pm->node, parent, p);\n\t\trb_insert_color(&pm->node, &sctx->pending_dir_moves);\n\t}\n\tret = 0;\nout:\n\tif (ret) {\n\t\t__free_recorded_refs(&pm->update_refs);\n\t\tkfree(pm);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int add_pending_dir_move(struct send_ctx *sctx,\n\t\t\t\tu64 ino,\n\t\t\t\tu64 ino_gen,\n\t\t\t\tu64 parent_ino,\n\t\t\t\tstruct list_head *new_refs,\n\t\t\t\tstruct list_head *deleted_refs,\n\t\t\t\tconst bool is_orphan)\n{\n\tstruct rb_node **p = &sctx->pending_dir_moves.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct pending_dir_move *entry = NULL, *pm;\n\tstruct recorded_ref *cur;\n\tint exists = 0;\n\tint ret;\n\n\tpm = kmalloc(sizeof(*pm), GFP_NOFS);\n\tif (!pm)\n\t\treturn -ENOMEM;\n\tpm->parent_ino = parent_ino;\n\tpm->ino = ino;\n\tpm->gen = ino_gen;\n\tpm->is_orphan = is_orphan;\n\tINIT_LIST_HEAD(&pm->list);\n\tINIT_LIST_HEAD(&pm->update_refs);\n\tRB_CLEAR_NODE(&pm->node);\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct pending_dir_move, node);\n\t\tif (parent_ino < entry->parent_ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (parent_ino > entry->parent_ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\texists = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(cur, deleted_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tlist_for_each_entry(cur, new_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = add_waiting_dir_move(sctx, pm->ino);\n\tif (ret)\n\t\tgoto out;\n\n\tif (exists) {\n\t\tlist_add_tail(&pm->list, &entry->list);\n\t} else {\n\t\trb_link_node(&pm->node, parent, p);\n\t\trb_insert_color(&pm->node, &sctx->pending_dir_moves);\n\t}\n\tret = 0;\nout:\n\tif (ret) {\n\t\t__free_recorded_refs(&pm->update_refs);\n\t\tkfree(pm);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ancestor > BTRFS_FIRST_FREE_OBJECTID"
          ],
          "line": 3158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "deleted_refs"
          ],
          "line": 3157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_loop",
          "args": [
            "sctx",
            "name",
            "pm->ino",
            "pm->gen",
            "&ancestor"
          ],
          "line": 3155
        },
        "resolved": true,
        "details": {
          "function_name": "path_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "3070-3110",
          "snippet": "static int path_loop(struct send_ctx *sctx, struct fs_path *name,\n\t\t     u64 ino, u64 gen, u64 *ancestor_ino)\n{\n\tint ret = 0;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tu64 start_ino = ino;\n\n\t*ancestor_ino = 0;\n\twhile (ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino))\n\t\t\tbreak;\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tif (*ancestor_ino == 0)\n\t\t\t\t*ancestor_ino = ino;\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (parent_inode == start_ino) {\n\t\t\tret = 1;\n\t\t\tif (*ancestor_ino == 0)\n\t\t\t\t*ancestor_ino = ino;\n\t\t\tbreak;\n\t\t}\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int path_loop(struct send_ctx *sctx, struct fs_path *name,\n\t\t     u64 ino, u64 gen, u64 *ancestor_ino)\n{\n\tint ret = 0;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tu64 start_ino = ino;\n\n\t*ancestor_ino = 0;\n\twhile (ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino))\n\t\t\tbreak;\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tif (*ancestor_ino == 0)\n\t\t\t\t*ancestor_ino = ino;\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (parent_inode == start_ino) {\n\t\t\tret = 1;\n\t\t\tif (*ancestor_ino == 0)\n\t\t\t\t*ancestor_ino = ino;\n\t\t\tbreak;\n\t\t}\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_add_path",
          "args": [
            "from_path",
            "name"
          ],
          "line": 3149
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_add_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "436-448",
          "snippet": "static int fs_path_add_path(struct fs_path *p, struct fs_path *p2)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, p2->end - p2->start, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, p2->start, p2->end - p2->start);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_add_path(struct fs_path *p, struct fs_path *p2)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, p2->end - p2->start, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, p2->start, p2->end - p2->start);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_first_ref",
          "args": [
            "sctx->parent_root",
            "pm->ino",
            "&parent_ino",
            "&parent_gen",
            "name"
          ],
          "line": 3141
        },
        "resolved": true,
        "details": {
          "function_name": "get_first_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1689-1754",
          "snippet": "static int get_first_ref(struct btrfs_root *root, u64 ino,\n\t\t\t u64 *dir, u64 *dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tint len;\n\tu64 parent_dir;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\tpath->slots[0]);\n\tif (ret || found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (found_key.type == BTRFS_INODE_REF_KEY) {\n\t\tstruct btrfs_inode_ref *iref;\n\t\tiref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(path->nodes[0], iref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t\t     (unsigned long)(iref + 1),\n\t\t\t\t\t\t     len);\n\t\tparent_dir = found_key.offset;\n\t} else {\n\t\tstruct btrfs_inode_extref *extref;\n\t\textref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_extref);\n\t\tlen = btrfs_inode_extref_name_len(path->nodes[0], extref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t(unsigned long)&extref->name, len);\n\t\tparent_dir = btrfs_inode_extref_parent(path->nodes[0], extref);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tif (dir_gen) {\n\t\tret = get_inode_info(root, parent_dir, NULL, dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t*dir = parent_dir;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_first_ref(struct btrfs_root *root, u64 ino,\n\t\t\t u64 *dir, u64 *dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tint len;\n\tu64 parent_dir;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\tpath->slots[0]);\n\tif (ret || found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (found_key.type == BTRFS_INODE_REF_KEY) {\n\t\tstruct btrfs_inode_ref *iref;\n\t\tiref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(path->nodes[0], iref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t\t     (unsigned long)(iref + 1),\n\t\t\t\t\t\t     len);\n\t\tparent_dir = found_key.offset;\n\t} else {\n\t\tstruct btrfs_inode_extref *extref;\n\t\textref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_extref);\n\t\tlen = btrfs_inode_extref_name_len(path->nodes[0], extref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t(unsigned long)&extref->name, len);\n\t\tparent_dir = btrfs_inode_extref_parent(path->nodes[0], extref);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tif (dir_gen) {\n\t\tret = get_inode_info(root, parent_dir, NULL, dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t*dir = parent_dir;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_unique_name",
          "args": [
            "sctx",
            "pm->ino",
            "pm->gen",
            "from_path"
          ],
          "line": 3138
        },
        "resolved": true,
        "details": {
          "function_name": "gen_unique_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1488-1550",
          "snippet": "static int gen_unique_name(struct send_ctx *sctx,\n\t\t\t   u64 ino, u64 gen,\n\t\t\t   struct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tchar tmp[64];\n\tint len;\n\tu64 idx = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tlen = snprintf(tmp, sizeof(tmp), \"o%llu-%llu-%llu\",\n\t\t\t\tino, gen, idx);\n\t\tASSERT(len < sizeof(tmp));\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->send_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sctx->parent_root) {\n\t\t\t/* unique */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->parent_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* unique */\n\t\tbreak;\n\t}\n\n\tret = fs_path_add(dest, tmp, strlen(tmp));\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int gen_unique_name(struct send_ctx *sctx,\n\t\t\t   u64 ino, u64 gen,\n\t\t\t   struct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tchar tmp[64];\n\tint len;\n\tu64 idx = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tlen = snprintf(tmp, sizeof(tmp), \"o%llu-%llu-%llu\",\n\t\t\t\tino, gen, idx);\n\t\tASSERT(len < sizeof(tmp));\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->send_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sctx->parent_root) {\n\t\t\t/* unique */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->parent_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* unique */\n\t\tbreak;\n\t}\n\n\tret = fs_path_add(dest, tmp, strlen(tmp));\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_waiting_dir_move",
          "args": [
            "sctx",
            "dm"
          ],
          "line": 3135
        },
        "resolved": true,
        "details": {
          "function_name": "free_waiting_dir_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2974-2981",
          "snippet": "static void free_waiting_dir_move(struct send_ctx *sctx,\n\t\t\t\t  struct waiting_dir_move *dm)\n{\n\tif (!dm)\n\t\treturn;\n\trb_erase(&dm->node, &sctx->waiting_dir_moves);\n\tkfree(dm);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void free_waiting_dir_move(struct send_ctx *sctx,\n\t\t\t\t  struct waiting_dir_move *dm)\n{\n\tif (!dm)\n\t\treturn;\n\trb_erase(&dm->node, &sctx->waiting_dir_moves);\n\tkfree(dm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dm"
          ],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int apply_dir_move(struct send_ctx *sctx, struct pending_dir_move *pm)\n{\n\tstruct fs_path *from_path = NULL;\n\tstruct fs_path *to_path = NULL;\n\tstruct fs_path *name = NULL;\n\tu64 orig_progress = sctx->send_progress;\n\tstruct recorded_ref *cur;\n\tu64 parent_ino, parent_gen;\n\tstruct waiting_dir_move *dm = NULL;\n\tu64 rmdir_ino = 0;\n\tint ret;\n\tu64 ancestor = 0;\n\n\tname = fs_path_alloc();\n\tfrom_path = fs_path_alloc();\n\tif (!name || !from_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdm = get_waiting_dir_move(sctx, pm->ino);\n\tASSERT(dm);\n\trmdir_ino = dm->rmdir_ino;\n\tfree_waiting_dir_move(sctx, dm);\n\n\tif (pm->is_orphan) {\n\t\tret = gen_unique_name(sctx, pm->ino,\n\t\t\t\t      pm->gen, from_path);\n\t} else {\n\t\tret = get_first_ref(sctx->parent_root, pm->ino,\n\t\t\t\t    &parent_ino, &parent_gen, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = get_cur_path(sctx, parent_ino, parent_gen,\n\t\t\t\t   from_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = fs_path_add_path(from_path, name);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsctx->send_progress = sctx->cur_ino + 1;\n\tret = path_loop(sctx, name, pm->ino, pm->gen, &ancestor);\n\tif (ret) {\n\t\tLIST_HEAD(deleted_refs);\n\t\tASSERT(ancestor > BTRFS_FIRST_FREE_OBJECTID);\n\t\tret = add_pending_dir_move(sctx, pm->ino, pm->gen, ancestor,\n\t\t\t\t\t   &pm->update_refs, &deleted_refs,\n\t\t\t\t\t   pm->is_orphan);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (rmdir_ino) {\n\t\t\tdm = get_waiting_dir_move(sctx, pm->ino);\n\t\t\tASSERT(dm);\n\t\t\tdm->rmdir_ino = rmdir_ino;\n\t\t}\n\t\tgoto out;\n\t}\n\tfs_path_reset(name);\n\tto_path = name;\n\tname = NULL;\n\tret = get_cur_path(sctx, pm->ino, pm->gen, to_path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_rename(sctx, from_path, to_path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (rmdir_ino) {\n\t\tstruct orphan_dir_info *odi;\n\n\t\todi = get_orphan_dir_info(sctx, rmdir_ino);\n\t\tif (!odi) {\n\t\t\t/* already deleted */\n\t\t\tgoto finish;\n\t\t}\n\t\tret = can_rmdir(sctx, rmdir_ino, odi->gen, sctx->cur_ino + 1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (!ret)\n\t\t\tgoto finish;\n\n\t\tname = fs_path_alloc();\n\t\tif (!name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_cur_path(sctx, rmdir_ino, odi->gen, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = send_rmdir(sctx, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tfree_orphan_dir_info(sctx, odi);\n\t}\n\nfinish:\n\tret = send_utimes(sctx, pm->ino, pm->gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * After rename/move, need to update the utimes of both new parent(s)\n\t * and old parent(s).\n\t */\n\tlist_for_each_entry(cur, &pm->update_refs, list) {\n\t\tif (cur->dir == rmdir_ino)\n\t\t\tcontinue;\n\t\tret = send_utimes(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tfs_path_free(name);\n\tfs_path_free(from_path);\n\tfs_path_free(to_path);\n\tsctx->send_progress = orig_progress;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "path_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "3070-3110",
    "snippet": "static int path_loop(struct send_ctx *sctx, struct fs_path *name,\n\t\t     u64 ino, u64 gen, u64 *ancestor_ino)\n{\n\tint ret = 0;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tu64 start_ino = ino;\n\n\t*ancestor_ino = 0;\n\twhile (ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino))\n\t\t\tbreak;\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tif (*ancestor_ino == 0)\n\t\t\t\t*ancestor_ino = ino;\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (parent_inode == start_ino) {\n\t\t\tret = 1;\n\t\t\tif (*ancestor_ino == 0)\n\t\t\t\t*ancestor_ino = ino;\n\t\t\tbreak;\n\t\t}\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_cur_name_and_parent",
          "args": [
            "sctx",
            "ino",
            "gen",
            "&parent_inode",
            "&parent_gen",
            "name"
          ],
          "line": 3090
        },
        "resolved": true,
        "details": {
          "function_name": "__get_cur_name_and_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2071-2180",
          "snippet": "static int __get_cur_name_and_parent(struct send_ctx *sctx,\n\t\t\t\t     u64 ino, u64 gen,\n\t\t\t\t     u64 *parent_ino,\n\t\t\t\t     u64 *parent_gen,\n\t\t\t\t     struct fs_path *dest)\n{\n\tint ret;\n\tint nce_ret;\n\tstruct name_cache_entry *nce = NULL;\n\n\t/*\n\t * First check if we already did a call to this function with the same\n\t * ino/gen. If yes, check if the cache entry is still up-to-date. If yes\n\t * return the cached result.\n\t */\n\tnce = name_cache_search(sctx, ino, gen);\n\tif (nce) {\n\t\tif (ino < sctx->send_progress && nce->need_later_update) {\n\t\t\tname_cache_delete(sctx, nce);\n\t\t\tkfree(nce);\n\t\t\tnce = NULL;\n\t\t} else {\n\t\t\tname_cache_used(sctx, nce);\n\t\t\t*parent_ino = nce->parent_ino;\n\t\t\t*parent_gen = nce->parent_gen;\n\t\t\tret = fs_path_add(dest, nce->name, nce->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = nce->ret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If the inode is not existent yet, add the orphan name and return 1.\n\t * This should only happen for the parent dir that we determine in\n\t * __record_new_ref\n\t */\n\tret = is_inode_existent(sctx, ino, gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!ret) {\n\t\tret = gen_unique_name(sctx, ino, gen, dest);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 1;\n\t\tgoto out_cache;\n\t}\n\n\t/*\n\t * Depending on whether the inode was already processed or not, use\n\t * send_root or parent_root for ref lookup.\n\t */\n\tif (ino < sctx->send_progress)\n\t\tret = get_first_ref(sctx->send_root, ino,\n\t\t\t\t    parent_ino, parent_gen, dest);\n\telse\n\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t    parent_ino, parent_gen, dest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * Check if the ref was overwritten by an inode's ref that was processed\n\t * earlier. If yes, treat as orphan and return 1.\n\t */\n\tret = did_overwrite_ref(sctx, *parent_ino, *parent_gen, ino, gen,\n\t\t\tdest->start, dest->end - dest->start);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tfs_path_reset(dest);\n\t\tret = gen_unique_name(sctx, ino, gen, dest);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 1;\n\t}\n\nout_cache:\n\t/*\n\t * Store the result of the lookup in the name cache.\n\t */\n\tnce = kmalloc(sizeof(*nce) + fs_path_len(dest) + 1, GFP_NOFS);\n\tif (!nce) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnce->ino = ino;\n\tnce->gen = gen;\n\tnce->parent_ino = *parent_ino;\n\tnce->parent_gen = *parent_gen;\n\tnce->name_len = fs_path_len(dest);\n\tnce->ret = ret;\n\tstrcpy(nce->name, dest->start);\n\n\tif (ino < sctx->send_progress)\n\t\tnce->need_later_update = 0;\n\telse\n\t\tnce->need_later_update = 1;\n\n\tnce_ret = name_cache_insert(sctx, nce);\n\tif (nce_ret < 0)\n\t\tret = nce_ret;\n\tname_cache_clean_unused(sctx);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int __get_cur_name_and_parent(struct send_ctx *sctx,\n\t\t\t\t     u64 ino, u64 gen,\n\t\t\t\t     u64 *parent_ino,\n\t\t\t\t     u64 *parent_gen,\n\t\t\t\t     struct fs_path *dest)\n{\n\tint ret;\n\tint nce_ret;\n\tstruct name_cache_entry *nce = NULL;\n\n\t/*\n\t * First check if we already did a call to this function with the same\n\t * ino/gen. If yes, check if the cache entry is still up-to-date. If yes\n\t * return the cached result.\n\t */\n\tnce = name_cache_search(sctx, ino, gen);\n\tif (nce) {\n\t\tif (ino < sctx->send_progress && nce->need_later_update) {\n\t\t\tname_cache_delete(sctx, nce);\n\t\t\tkfree(nce);\n\t\t\tnce = NULL;\n\t\t} else {\n\t\t\tname_cache_used(sctx, nce);\n\t\t\t*parent_ino = nce->parent_ino;\n\t\t\t*parent_gen = nce->parent_gen;\n\t\t\tret = fs_path_add(dest, nce->name, nce->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = nce->ret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If the inode is not existent yet, add the orphan name and return 1.\n\t * This should only happen for the parent dir that we determine in\n\t * __record_new_ref\n\t */\n\tret = is_inode_existent(sctx, ino, gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!ret) {\n\t\tret = gen_unique_name(sctx, ino, gen, dest);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 1;\n\t\tgoto out_cache;\n\t}\n\n\t/*\n\t * Depending on whether the inode was already processed or not, use\n\t * send_root or parent_root for ref lookup.\n\t */\n\tif (ino < sctx->send_progress)\n\t\tret = get_first_ref(sctx->send_root, ino,\n\t\t\t\t    parent_ino, parent_gen, dest);\n\telse\n\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t    parent_ino, parent_gen, dest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * Check if the ref was overwritten by an inode's ref that was processed\n\t * earlier. If yes, treat as orphan and return 1.\n\t */\n\tret = did_overwrite_ref(sctx, *parent_ino, *parent_gen, ino, gen,\n\t\t\tdest->start, dest->end - dest->start);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tfs_path_reset(dest);\n\t\tret = gen_unique_name(sctx, ino, gen, dest);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 1;\n\t}\n\nout_cache:\n\t/*\n\t * Store the result of the lookup in the name cache.\n\t */\n\tnce = kmalloc(sizeof(*nce) + fs_path_len(dest) + 1, GFP_NOFS);\n\tif (!nce) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnce->ino = ino;\n\tnce->gen = gen;\n\tnce->parent_ino = *parent_ino;\n\tnce->parent_gen = *parent_gen;\n\tnce->name_len = fs_path_len(dest);\n\tnce->ret = ret;\n\tstrcpy(nce->name, dest->start);\n\n\tif (ino < sctx->send_progress)\n\t\tnce->need_later_update = 0;\n\telse\n\t\tnce->need_later_update = 1;\n\n\tnce_ret = name_cache_insert(sctx, nce);\n\tif (nce_ret < 0)\n\t\tret = nce_ret;\n\tname_cache_clean_unused(sctx);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_first_ref",
          "args": [
            "sctx->parent_root",
            "ino",
            "&parent_inode",
            "&parent_gen",
            "name"
          ],
          "line": 3087
        },
        "resolved": true,
        "details": {
          "function_name": "get_first_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1689-1754",
          "snippet": "static int get_first_ref(struct btrfs_root *root, u64 ino,\n\t\t\t u64 *dir, u64 *dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tint len;\n\tu64 parent_dir;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\tpath->slots[0]);\n\tif (ret || found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (found_key.type == BTRFS_INODE_REF_KEY) {\n\t\tstruct btrfs_inode_ref *iref;\n\t\tiref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(path->nodes[0], iref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t\t     (unsigned long)(iref + 1),\n\t\t\t\t\t\t     len);\n\t\tparent_dir = found_key.offset;\n\t} else {\n\t\tstruct btrfs_inode_extref *extref;\n\t\textref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_extref);\n\t\tlen = btrfs_inode_extref_name_len(path->nodes[0], extref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t(unsigned long)&extref->name, len);\n\t\tparent_dir = btrfs_inode_extref_parent(path->nodes[0], extref);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tif (dir_gen) {\n\t\tret = get_inode_info(root, parent_dir, NULL, dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t*dir = parent_dir;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_first_ref(struct btrfs_root *root, u64 ino,\n\t\t\t u64 *dir, u64 *dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tint len;\n\tu64 parent_dir;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\tpath->slots[0]);\n\tif (ret || found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (found_key.type == BTRFS_INODE_REF_KEY) {\n\t\tstruct btrfs_inode_ref *iref;\n\t\tiref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(path->nodes[0], iref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t\t     (unsigned long)(iref + 1),\n\t\t\t\t\t\t     len);\n\t\tparent_dir = found_key.offset;\n\t} else {\n\t\tstruct btrfs_inode_extref *extref;\n\t\textref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_extref);\n\t\tlen = btrfs_inode_extref_name_len(path->nodes[0], extref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t(unsigned long)&extref->name, len);\n\t\tparent_dir = btrfs_inode_extref_parent(path->nodes[0], extref);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tif (dir_gen) {\n\t\tret = get_inode_info(root, parent_dir, NULL, dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t*dir = parent_dir;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_waiting_for_move",
          "args": [
            "sctx",
            "ino"
          ],
          "line": 3084
        },
        "resolved": true,
        "details": {
          "function_name": "is_waiting_for_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2919-2924",
          "snippet": "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct waiting_dir_move *entry = get_waiting_dir_move(sctx, ino);\n\n\treturn entry != NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct waiting_dir_move *entry = get_waiting_dir_move(sctx, ino);\n\n\treturn entry != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_waiting_for_rm",
          "args": [
            "sctx",
            "ino"
          ],
          "line": 3082
        },
        "resolved": true,
        "details": {
          "function_name": "is_waiting_for_rm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2819-2824",
          "snippet": "static int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino)\n{\n\tstruct orphan_dir_info *odi = get_orphan_dir_info(sctx, dir_ino);\n\n\treturn odi != NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino);\n\nstatic int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino)\n{\n\tstruct orphan_dir_info *odi = get_orphan_dir_info(sctx, dir_ino);\n\n\treturn odi != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_reset",
          "args": [
            "name"
          ],
          "line": 3080
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "289-300",
          "snippet": "static void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int path_loop(struct send_ctx *sctx, struct fs_path *name,\n\t\t     u64 ino, u64 gen, u64 *ancestor_ino)\n{\n\tint ret = 0;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tu64 start_ino = ino;\n\n\t*ancestor_ino = 0;\n\twhile (ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino))\n\t\t\tbreak;\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tif (*ancestor_ino == 0)\n\t\t\t\t*ancestor_ino = ino;\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (parent_inode == start_ino) {\n\t\t\tret = 1;\n\t\t\tif (*ancestor_ino == 0)\n\t\t\t\t*ancestor_ino = ino;\n\t\t\tbreak;\n\t\t}\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "get_pending_dir_moves",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "3052-3068",
    "snippet": "static struct pending_dir_move *get_pending_dir_moves(struct send_ctx *sctx,\n\t\t\t\t\t\t      u64 parent_ino)\n{\n\tstruct rb_node *n = sctx->pending_dir_moves.rb_node;\n\tstruct pending_dir_move *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct pending_dir_move, node);\n\t\tif (parent_ino < entry->parent_ino)\n\t\t\tn = n->rb_left;\n\t\telse if (parent_ino > entry->parent_ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structpending_dir_move",
            "node"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct pending_dir_move *get_pending_dir_moves(struct send_ctx *sctx,\n\t\t\t\t\t\t      u64 parent_ino)\n{\n\tstruct rb_node *n = sctx->pending_dir_moves.rb_node;\n\tstruct pending_dir_move *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct pending_dir_move, node);\n\t\tif (parent_ino < entry->parent_ino)\n\t\t\tn = n->rb_left;\n\t\telse if (parent_ino > entry->parent_ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "add_pending_dir_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2983-3050",
    "snippet": "static int add_pending_dir_move(struct send_ctx *sctx,\n\t\t\t\tu64 ino,\n\t\t\t\tu64 ino_gen,\n\t\t\t\tu64 parent_ino,\n\t\t\t\tstruct list_head *new_refs,\n\t\t\t\tstruct list_head *deleted_refs,\n\t\t\t\tconst bool is_orphan)\n{\n\tstruct rb_node **p = &sctx->pending_dir_moves.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct pending_dir_move *entry = NULL, *pm;\n\tstruct recorded_ref *cur;\n\tint exists = 0;\n\tint ret;\n\n\tpm = kmalloc(sizeof(*pm), GFP_NOFS);\n\tif (!pm)\n\t\treturn -ENOMEM;\n\tpm->parent_ino = parent_ino;\n\tpm->ino = ino;\n\tpm->gen = ino_gen;\n\tpm->is_orphan = is_orphan;\n\tINIT_LIST_HEAD(&pm->list);\n\tINIT_LIST_HEAD(&pm->update_refs);\n\tRB_CLEAR_NODE(&pm->node);\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct pending_dir_move, node);\n\t\tif (parent_ino < entry->parent_ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (parent_ino > entry->parent_ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\texists = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(cur, deleted_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tlist_for_each_entry(cur, new_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = add_waiting_dir_move(sctx, pm->ino);\n\tif (ret)\n\t\tgoto out;\n\n\tif (exists) {\n\t\tlist_add_tail(&pm->list, &entry->list);\n\t} else {\n\t\trb_link_node(&pm->node, parent, p);\n\t\trb_insert_color(&pm->node, &sctx->pending_dir_moves);\n\t}\n\tret = 0;\nout:\n\tif (ret) {\n\t\t__free_recorded_refs(&pm->update_refs);\n\t\tkfree(pm);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pm"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_recorded_refs",
          "args": [
            "&pm->update_refs"
          ],
          "line": 3046
        },
        "resolved": true,
        "details": {
          "function_name": "__free_recorded_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2726-2736",
          "snippet": "static void __free_recorded_refs(struct list_head *head)\n{\n\tstruct recorded_ref *cur;\n\n\twhile (!list_empty(head)) {\n\t\tcur = list_entry(head->next, struct recorded_ref, list);\n\t\tfs_path_free(cur->full_path);\n\t\tlist_del(&cur->list);\n\t\tkfree(cur);\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void __free_recorded_refs(struct list_head *head)\n{\n\tstruct recorded_ref *cur;\n\n\twhile (!list_empty(head)) {\n\t\tcur = list_entry(head->next, struct recorded_ref, list);\n\t\tfs_path_free(cur->full_path);\n\t\tlist_del(&cur->list);\n\t\tkfree(cur);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&pm->node",
            "&sctx->pending_dir_moves"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&pm->node",
            "parent",
            "p"
          ],
          "line": 3040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&pm->list",
            "&entry->list"
          ],
          "line": 3038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_waiting_dir_move",
          "args": [
            "sctx",
            "pm->ino"
          ],
          "line": 3033
        },
        "resolved": true,
        "details": {
          "function_name": "add_waiting_dir_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2926-2954",
          "snippet": "static int add_waiting_dir_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct rb_node **p = &sctx->waiting_dir_moves.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct waiting_dir_move *entry, *dm;\n\n\tdm = kmalloc(sizeof(*dm), GFP_NOFS);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\tdm->ino = ino;\n\tdm->rmdir_ino = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct waiting_dir_move, node);\n\t\tif (ino < entry->ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (ino > entry->ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tkfree(dm);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&dm->node, parent, p);\n\trb_insert_color(&dm->node, &sctx->waiting_dir_moves);\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int add_waiting_dir_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct rb_node **p = &sctx->waiting_dir_moves.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct waiting_dir_move *entry, *dm;\n\n\tdm = kmalloc(sizeof(*dm), GFP_NOFS);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\tdm->ino = ino;\n\tdm->rmdir_ino = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct waiting_dir_move, node);\n\t\tif (ino < entry->ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (ino > entry->ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tkfree(dm);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&dm->node, parent, p);\n\trb_insert_color(&dm->node, &sctx->waiting_dir_moves);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup_ref",
          "args": [
            "cur",
            "&pm->update_refs"
          ],
          "line": 3028
        },
        "resolved": true,
        "details": {
          "function_name": "dup_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2710-2724",
          "snippet": "static int dup_ref(struct recorded_ref *ref, struct list_head *list)\n{\n\tstruct recorded_ref *new;\n\n\tnew = kmalloc(sizeof(*ref), GFP_NOFS);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->dir = ref->dir;\n\tnew->dir_gen = ref->dir_gen;\n\tnew->full_path = NULL;\n\tINIT_LIST_HEAD(&new->list);\n\tlist_add_tail(&new->list, list);\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int dup_ref(struct recorded_ref *ref, struct list_head *list)\n{\n\tstruct recorded_ref *new;\n\n\tnew = kmalloc(sizeof(*ref), GFP_NOFS);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->dir = ref->dir;\n\tnew->dir_gen = ref->dir_gen;\n\tnew->full_path = NULL;\n\tINIT_LIST_HEAD(&new->list);\n\tlist_add_tail(&new->list, list);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cur",
            "new_refs",
            "list"
          ],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cur",
            "deleted_refs",
            "list"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structpending_dir_move",
            "node"
          ],
          "line": 3011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&pm->node"
          ],
          "line": 3007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pm->update_refs"
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pm->list"
          ],
          "line": 3005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*pm)",
            "GFP_NOFS"
          ],
          "line": 2998
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int add_pending_dir_move(struct send_ctx *sctx,\n\t\t\t\tu64 ino,\n\t\t\t\tu64 ino_gen,\n\t\t\t\tu64 parent_ino,\n\t\t\t\tstruct list_head *new_refs,\n\t\t\t\tstruct list_head *deleted_refs,\n\t\t\t\tconst bool is_orphan)\n{\n\tstruct rb_node **p = &sctx->pending_dir_moves.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct pending_dir_move *entry = NULL, *pm;\n\tstruct recorded_ref *cur;\n\tint exists = 0;\n\tint ret;\n\n\tpm = kmalloc(sizeof(*pm), GFP_NOFS);\n\tif (!pm)\n\t\treturn -ENOMEM;\n\tpm->parent_ino = parent_ino;\n\tpm->ino = ino;\n\tpm->gen = ino_gen;\n\tpm->is_orphan = is_orphan;\n\tINIT_LIST_HEAD(&pm->list);\n\tINIT_LIST_HEAD(&pm->update_refs);\n\tRB_CLEAR_NODE(&pm->node);\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct pending_dir_move, node);\n\t\tif (parent_ino < entry->parent_ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (parent_ino > entry->parent_ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\texists = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(cur, deleted_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tlist_for_each_entry(cur, new_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = add_waiting_dir_move(sctx, pm->ino);\n\tif (ret)\n\t\tgoto out;\n\n\tif (exists) {\n\t\tlist_add_tail(&pm->list, &entry->list);\n\t} else {\n\t\trb_link_node(&pm->node, parent, p);\n\t\trb_insert_color(&pm->node, &sctx->pending_dir_moves);\n\t}\n\tret = 0;\nout:\n\tif (ret) {\n\t\t__free_recorded_refs(&pm->update_refs);\n\t\tkfree(pm);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "free_waiting_dir_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2974-2981",
    "snippet": "static void free_waiting_dir_move(struct send_ctx *sctx,\n\t\t\t\t  struct waiting_dir_move *dm)\n{\n\tif (!dm)\n\t\treturn;\n\trb_erase(&dm->node, &sctx->waiting_dir_moves);\n\tkfree(dm);\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dm"
          ],
          "line": 2980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&dm->node",
            "&sctx->waiting_dir_moves"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void free_waiting_dir_move(struct send_ctx *sctx,\n\t\t\t\t  struct waiting_dir_move *dm)\n{\n\tif (!dm)\n\t\treturn;\n\trb_erase(&dm->node, &sctx->waiting_dir_moves);\n\tkfree(dm);\n}"
  },
  {
    "function_name": "get_waiting_dir_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2956-2972",
    "snippet": "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct rb_node *n = sctx->waiting_dir_moves.rb_node;\n\tstruct waiting_dir_move *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct waiting_dir_move, node);\n\t\tif (ino < entry->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (ino > entry->ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structwaiting_dir_move",
            "node"
          ],
          "line": 2963
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct rb_node *n = sctx->waiting_dir_moves.rb_node;\n\tstruct waiting_dir_move *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct waiting_dir_move, node);\n\t\tif (ino < entry->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (ino > entry->ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "add_waiting_dir_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2926-2954",
    "snippet": "static int add_waiting_dir_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct rb_node **p = &sctx->waiting_dir_moves.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct waiting_dir_move *entry, *dm;\n\n\tdm = kmalloc(sizeof(*dm), GFP_NOFS);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\tdm->ino = ino;\n\tdm->rmdir_ino = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct waiting_dir_move, node);\n\t\tif (ino < entry->ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (ino > entry->ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tkfree(dm);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&dm->node, parent, p);\n\trb_insert_color(&dm->node, &sctx->waiting_dir_moves);\n\treturn 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&dm->node",
            "&sctx->waiting_dir_moves"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&dm->node",
            "parent",
            "p"
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dm"
          ],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structwaiting_dir_move",
            "node"
          ],
          "line": 2940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*dm)",
            "GFP_NOFS"
          ],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int add_waiting_dir_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct rb_node **p = &sctx->waiting_dir_moves.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct waiting_dir_move *entry, *dm;\n\n\tdm = kmalloc(sizeof(*dm), GFP_NOFS);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\tdm->ino = ino;\n\tdm->rmdir_ino = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct waiting_dir_move, node);\n\t\tif (ino < entry->ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (ino > entry->ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tkfree(dm);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&dm->node, parent, p);\n\trb_insert_color(&dm->node, &sctx->waiting_dir_moves);\n\treturn 0;\n}"
  },
  {
    "function_name": "is_waiting_for_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2919-2924",
    "snippet": "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct waiting_dir_move *entry = get_waiting_dir_move(sctx, ino);\n\n\treturn entry != NULL;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_waiting_dir_move",
          "args": [
            "sctx",
            "ino"
          ],
          "line": 2921
        },
        "resolved": true,
        "details": {
          "function_name": "get_waiting_dir_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2956-2972",
          "snippet": "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct rb_node *n = sctx->waiting_dir_moves.rb_node;\n\tstruct waiting_dir_move *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct waiting_dir_move, node);\n\t\tif (ino < entry->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (ino > entry->ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct rb_node *n = sctx->waiting_dir_moves.rb_node;\n\tstruct waiting_dir_move *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct waiting_dir_move, node);\n\t\tif (ino < entry->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (ino > entry->ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct waiting_dir_move *entry = get_waiting_dir_move(sctx, ino);\n\n\treturn entry != NULL;\n}"
  },
  {
    "function_name": "can_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2840-2917",
    "snippet": "static int can_rmdir(struct send_ctx *sctx, u64 dir, u64 dir_gen,\n\t\t     u64 send_progress)\n{\n\tint ret = 0;\n\tstruct btrfs_root *root = sctx->parent_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key loc;\n\tstruct btrfs_dir_item *di;\n\n\t/*\n\t * Don't try to rmdir the top/root subvolume dir.\n\t */\n\tif (dir == BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstruct waiting_dir_move *dm;\n\n\t\tif (path->slots[0] >= btrfs_header_nritems(path->nodes[0])) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type)\n\t\t\tbreak;\n\n\t\tdi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\tstruct btrfs_dir_item);\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &loc);\n\n\t\tdm = get_waiting_dir_move(sctx, loc.objectid);\n\t\tif (dm) {\n\t\t\tstruct orphan_dir_info *odi;\n\n\t\t\todi = add_orphan_dir_info(sctx, dir);\n\t\t\tif (IS_ERR(odi)) {\n\t\t\t\tret = PTR_ERR(odi);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\todi->gen = dir_gen;\n\t\t\tdm->rmdir_ino = dir;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (loc.objectid > send_progress) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t}\n\n\tret = 1;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 2915
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "odi"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "odi"
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_orphan_dir_info",
          "args": [
            "sctx",
            "dir"
          ],
          "line": 2893
        },
        "resolved": true,
        "details": {
          "function_name": "add_orphan_dir_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2770-2799",
          "snippet": "static struct orphan_dir_info *\nadd_orphan_dir_info(struct send_ctx *sctx, u64 dir_ino)\n{\n\tstruct rb_node **p = &sctx->orphan_dirs.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct orphan_dir_info *entry, *odi;\n\n\todi = kmalloc(sizeof(*odi), GFP_NOFS);\n\tif (!odi)\n\t\treturn ERR_PTR(-ENOMEM);\n\todi->ino = dir_ino;\n\todi->gen = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct orphan_dir_info, node);\n\t\tif (dir_ino < entry->ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (dir_ino > entry->ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tkfree(odi);\n\t\t\treturn entry;\n\t\t}\n\t}\n\n\trb_link_node(&odi->node, parent, p);\n\trb_insert_color(&odi->node, &sctx->orphan_dirs);\n\treturn odi;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);",
            "static int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\nstatic int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino);\n\nstatic struct orphan_dir_info *\nadd_orphan_dir_info(struct send_ctx *sctx, u64 dir_ino)\n{\n\tstruct rb_node **p = &sctx->orphan_dirs.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct orphan_dir_info *entry, *odi;\n\n\todi = kmalloc(sizeof(*odi), GFP_NOFS);\n\tif (!odi)\n\t\treturn ERR_PTR(-ENOMEM);\n\todi->ino = dir_ino;\n\todi->gen = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct orphan_dir_info, node);\n\t\tif (dir_ino < entry->ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (dir_ino > entry->ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tkfree(odi);\n\t\t\treturn entry;\n\t\t}\n\t}\n\n\trb_link_node(&odi->node, parent, p);\n\trb_insert_color(&odi->node, &sctx->orphan_dirs);\n\treturn odi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_waiting_dir_move",
          "args": [
            "sctx",
            "loc.objectid"
          ],
          "line": 2889
        },
        "resolved": true,
        "details": {
          "function_name": "get_waiting_dir_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2956-2972",
          "snippet": "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct rb_node *n = sctx->waiting_dir_moves.rb_node;\n\tstruct waiting_dir_move *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct waiting_dir_move, node);\n\t\tif (ino < entry->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (ino > entry->ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct rb_node *n = sctx->waiting_dir_moves.rb_node;\n\tstruct waiting_dir_move *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct waiting_dir_move, node);\n\t\tif (ino < entry->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (ino > entry->ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "di",
            "&loc"
          ],
          "line": 2887
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dir_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2763-2770",
          "snippet": "static inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_dir_item"
          ],
          "line": 2885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "&found_key",
            "path->slots[0]"
          ],
          "line": 2879
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 2872
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[0]"
          ],
          "line": 2871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 2864
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_path_for_send",
          "args": [],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_path_for_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "496-507",
          "snippet": "static struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int can_rmdir(struct send_ctx *sctx, u64 dir, u64 dir_gen,\n\t\t     u64 send_progress)\n{\n\tint ret = 0;\n\tstruct btrfs_root *root = sctx->parent_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key loc;\n\tstruct btrfs_dir_item *di;\n\n\t/*\n\t * Don't try to rmdir the top/root subvolume dir.\n\t */\n\tif (dir == BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstruct waiting_dir_move *dm;\n\n\t\tif (path->slots[0] >= btrfs_header_nritems(path->nodes[0])) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type)\n\t\t\tbreak;\n\n\t\tdi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\tstruct btrfs_dir_item);\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &loc);\n\n\t\tdm = get_waiting_dir_move(sctx, loc.objectid);\n\t\tif (dm) {\n\t\t\tstruct orphan_dir_info *odi;\n\n\t\t\todi = add_orphan_dir_info(sctx, dir);\n\t\t\tif (IS_ERR(odi)) {\n\t\t\t\tret = PTR_ERR(odi);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\todi->gen = dir_gen;\n\t\t\tdm->rmdir_ino = dir;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (loc.objectid > send_progress) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t}\n\n\tret = 1;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "free_orphan_dir_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2826-2833",
    "snippet": "static void free_orphan_dir_info(struct send_ctx *sctx,\n\t\t\t\t struct orphan_dir_info *odi)\n{\n\tif (!odi)\n\t\treturn;\n\trb_erase(&odi->node, &sctx->orphan_dirs);\n\tkfree(odi);\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "odi"
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&odi->node",
            "&sctx->orphan_dirs"
          ],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void free_orphan_dir_info(struct send_ctx *sctx,\n\t\t\t\t struct orphan_dir_info *odi)\n{\n\tif (!odi)\n\t\treturn;\n\trb_erase(&odi->node, &sctx->orphan_dirs);\n\tkfree(odi);\n}"
  },
  {
    "function_name": "is_waiting_for_rm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2819-2824",
    "snippet": "static int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino)\n{\n\tstruct orphan_dir_info *odi = get_orphan_dir_info(sctx, dir_ino);\n\n\treturn odi != NULL;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_orphan_dir_info",
          "args": [
            "sctx",
            "dir_ino"
          ],
          "line": 2821
        },
        "resolved": true,
        "details": {
          "function_name": "get_orphan_dir_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2801-2817",
          "snippet": "static struct orphan_dir_info *\nget_orphan_dir_info(struct send_ctx *sctx, u64 dir_ino)\n{\n\tstruct rb_node *n = sctx->orphan_dirs.rb_node;\n\tstruct orphan_dir_info *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct orphan_dir_info, node);\n\t\tif (dir_ino < entry->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (dir_ino > entry->ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);",
            "static int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\nstatic int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino);\n\nstatic struct orphan_dir_info *\nget_orphan_dir_info(struct send_ctx *sctx, u64 dir_ino)\n{\n\tstruct rb_node *n = sctx->orphan_dirs.rb_node;\n\tstruct orphan_dir_info *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct orphan_dir_info, node);\n\t\tif (dir_ino < entry->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (dir_ino > entry->ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino);\n\nstatic int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino)\n{\n\tstruct orphan_dir_info *odi = get_orphan_dir_info(sctx, dir_ino);\n\n\treturn odi != NULL;\n}"
  },
  {
    "function_name": "get_orphan_dir_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2801-2817",
    "snippet": "static struct orphan_dir_info *\nget_orphan_dir_info(struct send_ctx *sctx, u64 dir_ino)\n{\n\tstruct rb_node *n = sctx->orphan_dirs.rb_node;\n\tstruct orphan_dir_info *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct orphan_dir_info, node);\n\t\tif (dir_ino < entry->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (dir_ino > entry->ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);",
      "static int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structorphan_dir_info",
            "node"
          ],
          "line": 2808
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\nstatic int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino);\n\nstatic struct orphan_dir_info *\nget_orphan_dir_info(struct send_ctx *sctx, u64 dir_ino)\n{\n\tstruct rb_node *n = sctx->orphan_dirs.rb_node;\n\tstruct orphan_dir_info *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct orphan_dir_info, node);\n\t\tif (dir_ino < entry->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (dir_ino > entry->ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "add_orphan_dir_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2770-2799",
    "snippet": "static struct orphan_dir_info *\nadd_orphan_dir_info(struct send_ctx *sctx, u64 dir_ino)\n{\n\tstruct rb_node **p = &sctx->orphan_dirs.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct orphan_dir_info *entry, *odi;\n\n\todi = kmalloc(sizeof(*odi), GFP_NOFS);\n\tif (!odi)\n\t\treturn ERR_PTR(-ENOMEM);\n\todi->ino = dir_ino;\n\todi->gen = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct orphan_dir_info, node);\n\t\tif (dir_ino < entry->ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (dir_ino > entry->ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tkfree(odi);\n\t\t\treturn entry;\n\t\t}\n\t}\n\n\trb_link_node(&odi->node, parent, p);\n\trb_insert_color(&odi->node, &sctx->orphan_dirs);\n\treturn odi;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);",
      "static int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&odi->node",
            "&sctx->orphan_dirs"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&odi->node",
            "parent",
            "p"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "odi"
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structorphan_dir_info",
            "node"
          ],
          "line": 2785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*odi)",
            "GFP_NOFS"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\nstatic int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino);\n\nstatic struct orphan_dir_info *\nadd_orphan_dir_info(struct send_ctx *sctx, u64 dir_ino)\n{\n\tstruct rb_node **p = &sctx->orphan_dirs.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct orphan_dir_info *entry, *odi;\n\n\todi = kmalloc(sizeof(*odi), GFP_NOFS);\n\tif (!odi)\n\t\treturn ERR_PTR(-ENOMEM);\n\todi->ino = dir_ino;\n\todi->gen = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct orphan_dir_info, node);\n\t\tif (dir_ino < entry->ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (dir_ino > entry->ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tkfree(odi);\n\t\t\treturn entry;\n\t\t}\n\t}\n\n\trb_link_node(&odi->node, parent, p);\n\trb_insert_color(&odi->node, &sctx->orphan_dirs);\n\treturn odi;\n}"
  },
  {
    "function_name": "orphanize_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2749-2768",
    "snippet": "static int orphanize_inode(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\t  struct fs_path *path)\n{\n\tint ret;\n\tstruct fs_path *orphan;\n\n\torphan = fs_path_alloc();\n\tif (!orphan)\n\t\treturn -ENOMEM;\n\n\tret = gen_unique_name(sctx, ino, gen, orphan);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_rename(sctx, path, orphan);\n\nout:\n\tfs_path_free(orphan);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "orphan"
          ],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_rename",
          "args": [
            "sctx",
            "path",
            "orphan"
          ],
          "line": 2763
        },
        "resolved": true,
        "details": {
          "function_name": "send_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "693-712",
          "snippet": "static int send_rename(struct send_ctx *sctx,\n\t\t     struct fs_path *from, struct fs_path *to)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_rename %s -> %s\\n\", from->start, to->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_RENAME);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, from);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_TO, to);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_rename(struct send_ctx *sctx,\n\t\t     struct fs_path *from, struct fs_path *to)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_rename %s -> %s\\n\", from->start, to->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_RENAME);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, from);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_TO, to);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_unique_name",
          "args": [
            "sctx",
            "ino",
            "gen",
            "orphan"
          ],
          "line": 2759
        },
        "resolved": true,
        "details": {
          "function_name": "gen_unique_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1488-1550",
          "snippet": "static int gen_unique_name(struct send_ctx *sctx,\n\t\t\t   u64 ino, u64 gen,\n\t\t\t   struct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tchar tmp[64];\n\tint len;\n\tu64 idx = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tlen = snprintf(tmp, sizeof(tmp), \"o%llu-%llu-%llu\",\n\t\t\t\tino, gen, idx);\n\t\tASSERT(len < sizeof(tmp));\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->send_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sctx->parent_root) {\n\t\t\t/* unique */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->parent_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* unique */\n\t\tbreak;\n\t}\n\n\tret = fs_path_add(dest, tmp, strlen(tmp));\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int gen_unique_name(struct send_ctx *sctx,\n\t\t\t   u64 ino, u64 gen,\n\t\t\t   struct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tchar tmp[64];\n\tint len;\n\tu64 idx = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tlen = snprintf(tmp, sizeof(tmp), \"o%llu-%llu-%llu\",\n\t\t\t\tino, gen, idx);\n\t\tASSERT(len < sizeof(tmp));\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->send_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sctx->parent_root) {\n\t\t\t/* unique */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->parent_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* unique */\n\t\tbreak;\n\t}\n\n\tret = fs_path_add(dest, tmp, strlen(tmp));\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int orphanize_inode(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\t  struct fs_path *path)\n{\n\tint ret;\n\tstruct fs_path *orphan;\n\n\torphan = fs_path_alloc();\n\tif (!orphan)\n\t\treturn -ENOMEM;\n\n\tret = gen_unique_name(sctx, ino, gen, orphan);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_rename(sctx, path, orphan);\n\nout:\n\tfs_path_free(orphan);\n\treturn ret;\n}"
  },
  {
    "function_name": "free_recorded_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2738-2742",
    "snippet": "static void free_recorded_refs(struct send_ctx *sctx)\n{\n\t__free_recorded_refs(&sctx->new_refs);\n\t__free_recorded_refs(&sctx->deleted_refs);\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_recorded_refs",
          "args": [
            "&sctx->deleted_refs"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "__free_recorded_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2726-2736",
          "snippet": "static void __free_recorded_refs(struct list_head *head)\n{\n\tstruct recorded_ref *cur;\n\n\twhile (!list_empty(head)) {\n\t\tcur = list_entry(head->next, struct recorded_ref, list);\n\t\tfs_path_free(cur->full_path);\n\t\tlist_del(&cur->list);\n\t\tkfree(cur);\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void __free_recorded_refs(struct list_head *head)\n{\n\tstruct recorded_ref *cur;\n\n\twhile (!list_empty(head)) {\n\t\tcur = list_entry(head->next, struct recorded_ref, list);\n\t\tfs_path_free(cur->full_path);\n\t\tlist_del(&cur->list);\n\t\tkfree(cur);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void free_recorded_refs(struct send_ctx *sctx)\n{\n\t__free_recorded_refs(&sctx->new_refs);\n\t__free_recorded_refs(&sctx->deleted_refs);\n}"
  },
  {
    "function_name": "__free_recorded_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2726-2736",
    "snippet": "static void __free_recorded_refs(struct list_head *head)\n{\n\tstruct recorded_ref *cur;\n\n\twhile (!list_empty(head)) {\n\t\tcur = list_entry(head->next, struct recorded_ref, list);\n\t\tfs_path_free(cur->full_path);\n\t\tlist_del(&cur->list);\n\t\tkfree(cur);\n\t}\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cur"
          ],
          "line": 2734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cur->list"
          ],
          "line": 2733
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "cur->full_path"
          ],
          "line": 2732
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head->next",
            "structrecorded_ref",
            "list"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 2730
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void __free_recorded_refs(struct list_head *head)\n{\n\tstruct recorded_ref *cur;\n\n\twhile (!list_empty(head)) {\n\t\tcur = list_entry(head->next, struct recorded_ref, list);\n\t\tfs_path_free(cur->full_path);\n\t\tlist_del(&cur->list);\n\t\tkfree(cur);\n\t}\n}"
  },
  {
    "function_name": "dup_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2710-2724",
    "snippet": "static int dup_ref(struct recorded_ref *ref, struct list_head *list)\n{\n\tstruct recorded_ref *new;\n\n\tnew = kmalloc(sizeof(*ref), GFP_NOFS);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->dir = ref->dir;\n\tnew->dir_gen = ref->dir_gen;\n\tnew->full_path = NULL;\n\tINIT_LIST_HEAD(&new->list);\n\tlist_add_tail(&new->list, list);\n\treturn 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&new->list",
            "list"
          ],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&new->list"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*ref)",
            "GFP_NOFS"
          ],
          "line": 2714
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int dup_ref(struct recorded_ref *ref, struct list_head *list)\n{\n\tstruct recorded_ref *new;\n\n\tnew = kmalloc(sizeof(*ref), GFP_NOFS);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->dir = ref->dir;\n\tnew->dir_gen = ref->dir_gen;\n\tnew->full_path = NULL;\n\tINIT_LIST_HEAD(&new->list);\n\tlist_add_tail(&new->list, list);\n\treturn 0;\n}"
  },
  {
    "function_name": "__record_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2684-2708",
    "snippet": "static int __record_ref(struct list_head *head, u64 dir,\n\t\t      u64 dir_gen, struct fs_path *path)\n{\n\tstruct recorded_ref *ref;\n\n\tref = kmalloc(sizeof(*ref), GFP_NOFS);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\tref->dir = dir;\n\tref->dir_gen = dir_gen;\n\tref->full_path = path;\n\n\tref->name = (char *)kbasename(ref->full_path->start);\n\tref->name_len = ref->full_path->end - ref->name;\n\tref->dir_path = ref->full_path->start;\n\tif (ref->name == ref->full_path->start)\n\t\tref->dir_path_len = 0;\n\telse\n\t\tref->dir_path_len = ref->full_path->end -\n\t\t\t\tref->full_path->start - 1 - ref->name_len;\n\n\tlist_add_tail(&ref->list, head);\n\treturn 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ref->list",
            "head"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kbasename",
          "args": [
            "ref->full_path->start"
          ],
          "line": 2697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*ref)",
            "GFP_NOFS"
          ],
          "line": 2689
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int __record_ref(struct list_head *head, u64 dir,\n\t\t      u64 dir_gen, struct fs_path *path)\n{\n\tstruct recorded_ref *ref;\n\n\tref = kmalloc(sizeof(*ref), GFP_NOFS);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\tref->dir = dir;\n\tref->dir_gen = dir_gen;\n\tref->full_path = path;\n\n\tref->name = (char *)kbasename(ref->full_path->start);\n\tref->name_len = ref->full_path->end - ref->name;\n\tref->dir_path = ref->full_path->start;\n\tif (ref->name == ref->full_path->start)\n\t\tref->dir_path_len = 0;\n\telse\n\t\tref->dir_path_len = ref->full_path->end -\n\t\t\t\tref->full_path->start - 1 - ref->name_len;\n\n\tlist_add_tail(&ref->list, head);\n\treturn 0;\n}"
  },
  {
    "function_name": "send_create_inode_if_needed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2646-2666",
    "snippet": "static int send_create_inode_if_needed(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tif (S_ISDIR(sctx->cur_inode_mode)) {\n\t\tret = did_create_dir(sctx, sctx->cur_ino);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = send_create_inode(sctx, sctx->cur_ino);\n\tif (ret < 0)\n\t\tgoto out;\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_create_inode",
          "args": [
            "sctx",
            "sctx->cur_ino"
          ],
          "line": 2660
        },
        "resolved": true,
        "details": {
          "function_name": "send_create_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2494-2571",
          "snippet": "static int send_create_inode(struct send_ctx *sctx, u64 ino)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\tint cmd;\n\tu64 gen;\n\tu64 mode;\n\tu64 rdev;\n\nverbose_printk(\"btrfs: send_create_inode %llu\\n\", ino);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tif (ino != sctx->cur_ino) {\n\t\tret = get_inode_info(sctx->send_root, ino, NULL, &gen, &mode,\n\t\t\t\t     NULL, NULL, &rdev);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tgen = sctx->cur_inode_gen;\n\t\tmode = sctx->cur_inode_mode;\n\t\trdev = sctx->cur_inode_rdev;\n\t}\n\n\tif (S_ISREG(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKFILE;\n\t} else if (S_ISDIR(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKDIR;\n\t} else if (S_ISLNK(mode)) {\n\t\tcmd = BTRFS_SEND_C_SYMLINK;\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKNOD;\n\t} else if (S_ISFIFO(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKFIFO;\n\t} else if (S_ISSOCK(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKSOCK;\n\t} else {\n\t\tprintk(KERN_WARNING \"btrfs: unexpected inode type %o\",\n\t\t\t\t(int)(mode & S_IFMT));\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = begin_cmd(sctx, cmd);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = gen_unique_name(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_INO, ino);\n\n\tif (S_ISLNK(mode)) {\n\t\tfs_path_reset(p);\n\t\tret = read_symlink(sctx->send_root, ino, p);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_LINK, p);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) ||\n\t\t   S_ISFIFO(mode) || S_ISSOCK(mode)) {\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_RDEV, new_encode_dev(rdev));\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_MODE, mode);\n\t}\n\n\tret = send_cmd(sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int send_create_inode(struct send_ctx *sctx, u64 ino)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\tint cmd;\n\tu64 gen;\n\tu64 mode;\n\tu64 rdev;\n\nverbose_printk(\"btrfs: send_create_inode %llu\\n\", ino);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tif (ino != sctx->cur_ino) {\n\t\tret = get_inode_info(sctx->send_root, ino, NULL, &gen, &mode,\n\t\t\t\t     NULL, NULL, &rdev);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tgen = sctx->cur_inode_gen;\n\t\tmode = sctx->cur_inode_mode;\n\t\trdev = sctx->cur_inode_rdev;\n\t}\n\n\tif (S_ISREG(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKFILE;\n\t} else if (S_ISDIR(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKDIR;\n\t} else if (S_ISLNK(mode)) {\n\t\tcmd = BTRFS_SEND_C_SYMLINK;\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKNOD;\n\t} else if (S_ISFIFO(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKFIFO;\n\t} else if (S_ISSOCK(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKSOCK;\n\t} else {\n\t\tprintk(KERN_WARNING \"btrfs: unexpected inode type %o\",\n\t\t\t\t(int)(mode & S_IFMT));\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = begin_cmd(sctx, cmd);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = gen_unique_name(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_INO, ino);\n\n\tif (S_ISLNK(mode)) {\n\t\tfs_path_reset(p);\n\t\tret = read_symlink(sctx->send_root, ino, p);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_LINK, p);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) ||\n\t\t   S_ISFIFO(mode) || S_ISSOCK(mode)) {\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_RDEV, new_encode_dev(rdev));\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_MODE, mode);\n\t}\n\n\tret = send_cmd(sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "did_create_dir",
          "args": [
            "sctx",
            "sctx->cur_ino"
          ],
          "line": 2651
        },
        "resolved": true,
        "details": {
          "function_name": "did_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2578-2638",
          "snippet": "static int did_create_dir(struct send_ctx *sctx, u64 dir)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key di_key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_dir_item *di;\n\tint slot;\n\n\tpath = alloc_path_for_send();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, sctx->send_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(sctx->send_root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (di_key.type != BTRFS_ROOT_ITEM_KEY &&\n\t\t    di_key.objectid < sctx->send_progress) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int did_create_dir(struct send_ctx *sctx, u64 dir)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key di_key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_dir_item *di;\n\tint slot;\n\n\tpath = alloc_path_for_send();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, sctx->send_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(sctx->send_root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (di_key.type != BTRFS_ROOT_ITEM_KEY &&\n\t\t    di_key.objectid < sctx->send_progress) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sctx->cur_inode_mode"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_create_inode_if_needed(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tif (S_ISDIR(sctx->cur_inode_mode)) {\n\t\tret = did_create_dir(sctx, sctx->cur_ino);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = send_create_inode(sctx, sctx->cur_ino);\n\tif (ret < 0)\n\t\tgoto out;\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "did_create_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2578-2638",
    "snippet": "static int did_create_dir(struct send_ctx *sctx, u64 dir)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key di_key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_dir_item *di;\n\tint slot;\n\n\tpath = alloc_path_for_send();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, sctx->send_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(sctx->send_root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (di_key.type != BTRFS_ROOT_ITEM_KEY &&\n\t\t    di_key.objectid < sctx->send_progress) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 2636
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_item_key_to_cpu",
          "args": [
            "eb",
            "di",
            "&di_key"
          ],
          "line": 2624
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dir_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2763-2770",
          "snippet": "static inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "slot",
            "structbtrfs_dir_item"
          ],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "eb",
            "&found_key",
            "slot"
          ],
          "line": 2616
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "sctx->send_root",
            "path"
          ],
          "line": 2606
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "eb"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "sctx->send_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_path_for_send",
          "args": [],
          "line": 2589
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_path_for_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "496-507",
          "snippet": "static struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int did_create_dir(struct send_ctx *sctx, u64 dir)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key di_key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_dir_item *di;\n\tint slot;\n\n\tpath = alloc_path_for_send();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, sctx->send_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(sctx->send_root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (di_key.type != BTRFS_ROOT_ITEM_KEY &&\n\t\t    di_key.objectid < sctx->send_progress) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "send_create_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2494-2571",
    "snippet": "static int send_create_inode(struct send_ctx *sctx, u64 ino)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\tint cmd;\n\tu64 gen;\n\tu64 mode;\n\tu64 rdev;\n\nverbose_printk(\"btrfs: send_create_inode %llu\\n\", ino);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tif (ino != sctx->cur_ino) {\n\t\tret = get_inode_info(sctx->send_root, ino, NULL, &gen, &mode,\n\t\t\t\t     NULL, NULL, &rdev);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tgen = sctx->cur_inode_gen;\n\t\tmode = sctx->cur_inode_mode;\n\t\trdev = sctx->cur_inode_rdev;\n\t}\n\n\tif (S_ISREG(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKFILE;\n\t} else if (S_ISDIR(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKDIR;\n\t} else if (S_ISLNK(mode)) {\n\t\tcmd = BTRFS_SEND_C_SYMLINK;\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKNOD;\n\t} else if (S_ISFIFO(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKFIFO;\n\t} else if (S_ISSOCK(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKSOCK;\n\t} else {\n\t\tprintk(KERN_WARNING \"btrfs: unexpected inode type %o\",\n\t\t\t\t(int)(mode & S_IFMT));\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = begin_cmd(sctx, cmd);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = gen_unique_name(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_INO, ino);\n\n\tif (S_ISLNK(mode)) {\n\t\tfs_path_reset(p);\n\t\tret = read_symlink(sctx->send_root, ino, p);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_LINK, p);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) ||\n\t\t   S_ISFIFO(mode) || S_ISSOCK(mode)) {\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_RDEV, new_encode_dev(rdev));\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_MODE, mode);\n\t}\n\n\tret = send_cmd(sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "p"
          ],
          "line": 2569
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_cmd",
          "args": [
            "sctx"
          ],
          "line": 2562
        },
        "resolved": true,
        "details": {
          "function_name": "send_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "667-688",
          "snippet": "static int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TLV_PUT_U64",
          "args": [
            "sctx",
            "BTRFS_SEND_A_MODE",
            "mode"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_U64",
          "args": [
            "sctx",
            "BTRFS_SEND_A_RDEV",
            "new_encode_dev(rdev)"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "rdev"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "mode"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "mode"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "mode"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mode"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_PATH",
          "args": [
            "sctx",
            "BTRFS_SEND_A_PATH_LINK",
            "p"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_symlink",
          "args": [
            "sctx->send_root",
            "ino",
            "p"
          ],
          "line": 2552
        },
        "resolved": true,
        "details": {
          "function_name": "read_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1442-1482",
          "snippet": "static int read_symlink(struct btrfs_root *root,\n\t\t\tu64 ino,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_file_extent_item *ei;\n\tu8 type;\n\tu8 compression;\n\tunsigned long off;\n\tint len;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(ret);\n\n\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\tstruct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], ei);\n\tcompression = btrfs_file_extent_compression(path->nodes[0], ei);\n\tBUG_ON(type != BTRFS_FILE_EXTENT_INLINE);\n\tBUG_ON(compression);\n\n\toff = btrfs_file_extent_inline_start(ei);\n\tlen = btrfs_file_extent_inline_len(path->nodes[0], path->slots[0], ei);\n\n\tret = fs_path_add_from_extent_buffer(dest, path->nodes[0], off, len);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int read_symlink(struct btrfs_root *root,\n\t\t\tu64 ino,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_file_extent_item *ei;\n\tu8 type;\n\tu8 compression;\n\tunsigned long off;\n\tint len;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(ret);\n\n\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\tstruct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], ei);\n\tcompression = btrfs_file_extent_compression(path->nodes[0], ei);\n\tBUG_ON(type != BTRFS_FILE_EXTENT_INLINE);\n\tBUG_ON(compression);\n\n\toff = btrfs_file_extent_inline_start(ei);\n\tlen = btrfs_file_extent_inline_len(path->nodes[0], path->slots[0], ei);\n\n\tret = fs_path_add_from_extent_buffer(dest, path->nodes[0], off, len);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_reset",
          "args": [
            "p"
          ],
          "line": 2551
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "289-300",
          "snippet": "static void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_U64",
          "args": [
            "sctx",
            "BTRFS_SEND_A_INO",
            "ino"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_PATH",
          "args": [
            "sctx",
            "BTRFS_SEND_A_PATH",
            "p"
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_unique_name",
          "args": [
            "sctx",
            "ino",
            "gen",
            "p"
          ],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "gen_unique_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1488-1550",
          "snippet": "static int gen_unique_name(struct send_ctx *sctx,\n\t\t\t   u64 ino, u64 gen,\n\t\t\t   struct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tchar tmp[64];\n\tint len;\n\tu64 idx = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tlen = snprintf(tmp, sizeof(tmp), \"o%llu-%llu-%llu\",\n\t\t\t\tino, gen, idx);\n\t\tASSERT(len < sizeof(tmp));\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->send_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sctx->parent_root) {\n\t\t\t/* unique */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->parent_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* unique */\n\t\tbreak;\n\t}\n\n\tret = fs_path_add(dest, tmp, strlen(tmp));\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int gen_unique_name(struct send_ctx *sctx,\n\t\t\t   u64 ino, u64 gen,\n\t\t\t   struct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tchar tmp[64];\n\tint len;\n\tu64 idx = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tlen = snprintf(tmp, sizeof(tmp), \"o%llu-%llu-%llu\",\n\t\t\t\tino, gen, idx);\n\t\tASSERT(len < sizeof(tmp));\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->send_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sctx->parent_root) {\n\t\t\t/* unique */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->parent_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* unique */\n\t\tbreak;\n\t}\n\n\tret = fs_path_add(dest, tmp, strlen(tmp));\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_cmd",
          "args": [
            "sctx",
            "cmd"
          ],
          "line": 2539
        },
        "resolved": true,
        "details": {
          "function_name": "begin_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "651-665",
          "snippet": "static int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"btrfs: unexpected inode type %o\"",
            "(int)(mode & S_IFMT)"
          ],
          "line": 2533
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "mode"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "mode"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "mode"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mode"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_inode_info",
          "args": [
            "sctx->send_root",
            "ino",
            "NULL",
            "&gen",
            "&mode",
            "NULL",
            "NULL",
            "&rdev"
          ],
          "line": 2510
        },
        "resolved": true,
        "details": {
          "function_name": "get_inode_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "821-836",
          "snippet": "static int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose_printk",
          "args": [
            "\"btrfs: send_create_inode %llu\\n\"",
            "ino"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int send_create_inode(struct send_ctx *sctx, u64 ino)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\tint cmd;\n\tu64 gen;\n\tu64 mode;\n\tu64 rdev;\n\nverbose_printk(\"btrfs: send_create_inode %llu\\n\", ino);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tif (ino != sctx->cur_ino) {\n\t\tret = get_inode_info(sctx->send_root, ino, NULL, &gen, &mode,\n\t\t\t\t     NULL, NULL, &rdev);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tgen = sctx->cur_inode_gen;\n\t\tmode = sctx->cur_inode_mode;\n\t\trdev = sctx->cur_inode_rdev;\n\t}\n\n\tif (S_ISREG(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKFILE;\n\t} else if (S_ISDIR(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKDIR;\n\t} else if (S_ISLNK(mode)) {\n\t\tcmd = BTRFS_SEND_C_SYMLINK;\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKNOD;\n\t} else if (S_ISFIFO(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKFIFO;\n\t} else if (S_ISSOCK(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKSOCK;\n\t} else {\n\t\tprintk(KERN_WARNING \"btrfs: unexpected inode type %o\",\n\t\t\t\t(int)(mode & S_IFMT));\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = begin_cmd(sctx, cmd);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = gen_unique_name(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_INO, ino);\n\n\tif (S_ISLNK(mode)) {\n\t\tfs_path_reset(p);\n\t\tret = read_symlink(sctx->send_root, ino, p);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_LINK, p);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) ||\n\t\t   S_ISFIFO(mode) || S_ISSOCK(mode)) {\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_RDEV, new_encode_dev(rdev));\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_MODE, mode);\n\t}\n\n\tret = send_cmd(sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}"
  },
  {
    "function_name": "send_utimes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2434-2487",
    "snippet": "static int send_utimes(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret = 0;\n\tstruct fs_path *p = NULL;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_key key;\n\tint slot;\n\nverbose_printk(\"btrfs: send_utimes %llu\\n\", ino);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpath = alloc_path_for_send();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, sctx->send_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tii = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UTIMES);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_ATIME, eb, &ii->atime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_MTIME, eb, &ii->mtime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_CTIME, eb, &ii->ctime);\n\t/* TODO Add otime support when the otime patches get into upstream */\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "p"
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_cmd",
          "args": [
            "sctx"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "send_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "667-688",
          "snippet": "static int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TLV_PUT_BTRFS_TIMESPEC",
          "args": [
            "sctx",
            "BTRFS_SEND_A_CTIME",
            "eb",
            "&ii->ctime"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_BTRFS_TIMESPEC",
          "args": [
            "sctx",
            "BTRFS_SEND_A_MTIME",
            "eb",
            "&ii->mtime"
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_BTRFS_TIMESPEC",
          "args": [
            "sctx",
            "BTRFS_SEND_A_ATIME",
            "eb",
            "&ii->atime"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_PATH",
          "args": [
            "sctx",
            "BTRFS_SEND_A_PATH",
            "p"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cur_path",
          "args": [
            "sctx",
            "ino",
            "gen",
            "p"
          ],
          "line": 2471
        },
        "resolved": true,
        "details": {
          "function_name": "get_cur_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2207-2263",
          "snippet": "static int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_cmd",
          "args": [
            "sctx",
            "BTRFS_SEND_C_UTIMES"
          ],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "begin_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "651-665",
          "snippet": "static int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "slot",
            "structbtrfs_inode_item"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "sctx->send_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_path_for_send",
          "args": [],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_path_for_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "496-507",
          "snippet": "static struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose_printk",
          "args": [
            "\"btrfs: send_utimes %llu\\n\"",
            "ino"
          ],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int send_utimes(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret = 0;\n\tstruct fs_path *p = NULL;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_key key;\n\tint slot;\n\nverbose_printk(\"btrfs: send_utimes %llu\\n\", ino);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpath = alloc_path_for_send();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, sctx->send_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tii = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UTIMES);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_ATIME, eb, &ii->atime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_MTIME, eb, &ii->mtime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_CTIME, eb, &ii->ctime);\n\t/* TODO Add otime support when the otime patches get into upstream */\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "send_chown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2404-2432",
    "snippet": "static int send_chown(struct send_ctx *sctx, u64 ino, u64 gen, u64 uid, u64 gid)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\nverbose_printk(\"btrfs: send_chown %llu uid=%llu, gid=%llu\\n\", ino, uid, gid);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CHOWN);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_UID, uid);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_GID, gid);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "p"
          ],
          "line": 2430
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_cmd",
          "args": [
            "sctx"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "send_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "667-688",
          "snippet": "static int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TLV_PUT_U64",
          "args": [
            "sctx",
            "BTRFS_SEND_A_GID",
            "gid"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_U64",
          "args": [
            "sctx",
            "BTRFS_SEND_A_UID",
            "uid"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_PATH",
          "args": [
            "sctx",
            "BTRFS_SEND_A_PATH",
            "p"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cur_path",
          "args": [
            "sctx",
            "ino",
            "gen",
            "p"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "get_cur_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2207-2263",
          "snippet": "static int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_cmd",
          "args": [
            "sctx",
            "BTRFS_SEND_C_CHOWN"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "begin_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "651-665",
          "snippet": "static int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 2411
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose_printk",
          "args": [
            "\"btrfs: send_chown %llu uid=%llu, gid=%llu\\n\"",
            "ino",
            "uid",
            "gid"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int send_chown(struct send_ctx *sctx, u64 ino, u64 gen, u64 uid, u64 gid)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\nverbose_printk(\"btrfs: send_chown %llu uid=%llu, gid=%llu\\n\", ino, uid, gid);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CHOWN);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_UID, uid);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_GID, gid);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}"
  },
  {
    "function_name": "send_chmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2375-2402",
    "snippet": "static int send_chmod(struct send_ctx *sctx, u64 ino, u64 gen, u64 mode)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\nverbose_printk(\"btrfs: send_chmod %llu mode=%llu\\n\", ino, mode);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CHMOD);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_MODE, mode & 07777);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "p"
          ],
          "line": 2400
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_cmd",
          "args": [
            "sctx"
          ],
          "line": 2396
        },
        "resolved": true,
        "details": {
          "function_name": "send_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "667-688",
          "snippet": "static int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TLV_PUT_U64",
          "args": [
            "sctx",
            "BTRFS_SEND_A_MODE",
            "mode & 07777"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_PATH",
          "args": [
            "sctx",
            "BTRFS_SEND_A_PATH",
            "p"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cur_path",
          "args": [
            "sctx",
            "ino",
            "gen",
            "p"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "get_cur_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2207-2263",
          "snippet": "static int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_cmd",
          "args": [
            "sctx",
            "BTRFS_SEND_C_CHMOD"
          ],
          "line": 2386
        },
        "resolved": true,
        "details": {
          "function_name": "begin_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "651-665",
          "snippet": "static int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 2382
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose_printk",
          "args": [
            "\"btrfs: send_chmod %llu mode=%llu\\n\"",
            "ino",
            "mode"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int send_chmod(struct send_ctx *sctx, u64 ino, u64 gen, u64 mode)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\nverbose_printk(\"btrfs: send_chmod %llu mode=%llu\\n\", ino, mode);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CHMOD);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_MODE, mode & 07777);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}"
  },
  {
    "function_name": "send_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2346-2373",
    "snippet": "static int send_truncate(struct send_ctx *sctx, u64 ino, u64 gen, u64 size)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\nverbose_printk(\"btrfs: send_truncate %llu size=%llu\\n\", ino, size);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_TRUNCATE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_SIZE, size);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "p"
          ],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_cmd",
          "args": [
            "sctx"
          ],
          "line": 2367
        },
        "resolved": true,
        "details": {
          "function_name": "send_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "667-688",
          "snippet": "static int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TLV_PUT_U64",
          "args": [
            "sctx",
            "BTRFS_SEND_A_SIZE",
            "size"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_PATH",
          "args": [
            "sctx",
            "BTRFS_SEND_A_PATH",
            "p"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cur_path",
          "args": [
            "sctx",
            "ino",
            "gen",
            "p"
          ],
          "line": 2361
        },
        "resolved": true,
        "details": {
          "function_name": "get_cur_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2207-2263",
          "snippet": "static int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_cmd",
          "args": [
            "sctx",
            "BTRFS_SEND_C_TRUNCATE"
          ],
          "line": 2357
        },
        "resolved": true,
        "details": {
          "function_name": "begin_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "651-665",
          "snippet": "static int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose_printk",
          "args": [
            "\"btrfs: send_truncate %llu size=%llu\\n\"",
            "ino",
            "size"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int send_truncate(struct send_ctx *sctx, u64 ino, u64 gen, u64 size)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\nverbose_printk(\"btrfs: send_truncate %llu size=%llu\\n\", ino, size);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_TRUNCATE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_SIZE, size);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}"
  },
  {
    "function_name": "send_subvol_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2268-2344",
    "snippet": "static int send_subvol_begin(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *send_root = sctx->send_root;\n\tstruct btrfs_root *parent_root = sctx->parent_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_root_ref *ref;\n\tstruct extent_buffer *leaf;\n\tchar *name = NULL;\n\tint namelen;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tname = kmalloc(BTRFS_PATH_NAME_MAX, GFP_NOFS);\n\tif (!name) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\tkey.objectid = send_root->objectid;\n\tkey.type = BTRFS_ROOT_BACKREF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(send_root->fs_info->tree_root,\n\t\t\t\t&key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tif (key.type != BTRFS_ROOT_BACKREF_KEY ||\n\t    key.objectid != send_root->objectid) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tref = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_root_ref);\n\tnamelen = btrfs_root_ref_name_len(leaf, ref);\n\tread_extent_buffer(leaf, name, (unsigned long)(ref + 1), namelen);\n\tbtrfs_release_path(path);\n\n\tif (parent_root) {\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_SNAPSHOT);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_SUBVOL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tTLV_PUT_STRING(sctx, BTRFS_SEND_A_PATH, name, namelen);\n\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_UUID,\n\t\t\tsctx->send_root->root_item.uuid);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CTRANSID,\n\t\t    le64_to_cpu(sctx->send_root->root_item.ctransid));\n\tif (parent_root) {\n\t\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_CLONE_UUID,\n\t\t\t\tsctx->parent_root->root_item.uuid);\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_CTRANSID,\n\t\t\t    le64_to_cpu(sctx->parent_root->root_item.ctransid));\n\t}\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tbtrfs_free_path(path);\n\tkfree(name);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 2341
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_cmd",
          "args": [
            "sctx"
          ],
          "line": 2337
        },
        "resolved": true,
        "details": {
          "function_name": "send_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "667-688",
          "snippet": "static int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TLV_PUT_U64",
          "args": [
            "sctx",
            "BTRFS_SEND_A_CLONE_CTRANSID",
            "le64_to_cpu(sctx->parent_root->root_item.ctransid)"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "sctx->parent_root->root_item.ctransid"
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TLV_PUT_UUID",
          "args": [
            "sctx",
            "BTRFS_SEND_A_CLONE_UUID",
            "sctx->parent_root->root_item.uuid"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_U64",
          "args": [
            "sctx",
            "BTRFS_SEND_A_CTRANSID",
            "le64_to_cpu(sctx->send_root->root_item.ctransid)"
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_UUID",
          "args": [
            "sctx",
            "BTRFS_SEND_A_UUID",
            "sctx->send_root->root_item.uuid"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_STRING",
          "args": [
            "sctx",
            "BTRFS_SEND_A_PATH",
            "name",
            "namelen"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_cmd",
          "args": [
            "sctx",
            "BTRFS_SEND_C_SUBVOL"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "begin_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "651-665",
          "snippet": "static int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "leaf",
            "name",
            "(unsigned long)(ref + 1)",
            "namelen"
          ],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_ref_name_len",
          "args": [
            "leaf",
            "ref"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_root_ref"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "path->slots[0]"
          ],
          "line": 2304
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot_for_read",
          "args": [
            "send_root->fs_info->tree_root",
            "&key",
            "path",
            "1",
            "0"
          ],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot_for_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3057-3119",
          "snippet": "int btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "BTRFS_PATH_NAME_MAX",
            "GFP_NOFS"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_subvol_begin(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *send_root = sctx->send_root;\n\tstruct btrfs_root *parent_root = sctx->parent_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_root_ref *ref;\n\tstruct extent_buffer *leaf;\n\tchar *name = NULL;\n\tint namelen;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tname = kmalloc(BTRFS_PATH_NAME_MAX, GFP_NOFS);\n\tif (!name) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\tkey.objectid = send_root->objectid;\n\tkey.type = BTRFS_ROOT_BACKREF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(send_root->fs_info->tree_root,\n\t\t\t\t&key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tif (key.type != BTRFS_ROOT_BACKREF_KEY ||\n\t    key.objectid != send_root->objectid) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tref = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_root_ref);\n\tnamelen = btrfs_root_ref_name_len(leaf, ref);\n\tread_extent_buffer(leaf, name, (unsigned long)(ref + 1), namelen);\n\tbtrfs_release_path(path);\n\n\tif (parent_root) {\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_SNAPSHOT);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_SUBVOL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tTLV_PUT_STRING(sctx, BTRFS_SEND_A_PATH, name, namelen);\n\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_UUID,\n\t\t\tsctx->send_root->root_item.uuid);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CTRANSID,\n\t\t    le64_to_cpu(sctx->send_root->root_item.ctransid));\n\tif (parent_root) {\n\t\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_CLONE_UUID,\n\t\t\t\tsctx->parent_root->root_item.uuid);\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_CTRANSID,\n\t\t\t    le64_to_cpu(sctx->parent_root->root_item.ctransid));\n\t}\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tbtrfs_free_path(path);\n\tkfree(name);\n\treturn ret;\n}"
  },
  {
    "function_name": "get_cur_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2207-2263",
    "snippet": "static int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_unreverse",
          "args": [
            "dest"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_unreverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "480-494",
          "snippet": "static void fs_path_unreverse(struct fs_path *p)\n{\n\tchar *tmp;\n\tint len;\n\n\tif (!p->reversed)\n\t\treturn;\n\n\ttmp = p->start;\n\tlen = p->end - p->start;\n\tp->start = p->buf;\n\tp->end = p->start + len;\n\tmemmove(p->start, tmp, len + 1);\n\tp->reversed = 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_unreverse(struct fs_path *p)\n{\n\tchar *tmp;\n\tint len;\n\n\tif (!p->reversed)\n\t\treturn;\n\n\ttmp = p->start;\n\tlen = p->end - p->start;\n\tp->start = p->buf;\n\tp->end = p->start + len;\n\tmemmove(p->start, tmp, len + 1);\n\tp->reversed = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "name"
          ],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_add_path",
          "args": [
            "dest",
            "name"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_add_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "436-448",
          "snippet": "static int fs_path_add_path(struct fs_path *p, struct fs_path *p2)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, p2->end - p2->start, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, p2->start, p2->end - p2->start);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_add_path(struct fs_path *p, struct fs_path *p2)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, p2->end - p2->start, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, p2->start, p2->end - p2->start);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_cur_name_and_parent",
          "args": [
            "sctx",
            "ino",
            "gen",
            "&parent_inode",
            "&parent_gen",
            "name"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "__get_cur_name_and_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2071-2180",
          "snippet": "static int __get_cur_name_and_parent(struct send_ctx *sctx,\n\t\t\t\t     u64 ino, u64 gen,\n\t\t\t\t     u64 *parent_ino,\n\t\t\t\t     u64 *parent_gen,\n\t\t\t\t     struct fs_path *dest)\n{\n\tint ret;\n\tint nce_ret;\n\tstruct name_cache_entry *nce = NULL;\n\n\t/*\n\t * First check if we already did a call to this function with the same\n\t * ino/gen. If yes, check if the cache entry is still up-to-date. If yes\n\t * return the cached result.\n\t */\n\tnce = name_cache_search(sctx, ino, gen);\n\tif (nce) {\n\t\tif (ino < sctx->send_progress && nce->need_later_update) {\n\t\t\tname_cache_delete(sctx, nce);\n\t\t\tkfree(nce);\n\t\t\tnce = NULL;\n\t\t} else {\n\t\t\tname_cache_used(sctx, nce);\n\t\t\t*parent_ino = nce->parent_ino;\n\t\t\t*parent_gen = nce->parent_gen;\n\t\t\tret = fs_path_add(dest, nce->name, nce->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = nce->ret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If the inode is not existent yet, add the orphan name and return 1.\n\t * This should only happen for the parent dir that we determine in\n\t * __record_new_ref\n\t */\n\tret = is_inode_existent(sctx, ino, gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!ret) {\n\t\tret = gen_unique_name(sctx, ino, gen, dest);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 1;\n\t\tgoto out_cache;\n\t}\n\n\t/*\n\t * Depending on whether the inode was already processed or not, use\n\t * send_root or parent_root for ref lookup.\n\t */\n\tif (ino < sctx->send_progress)\n\t\tret = get_first_ref(sctx->send_root, ino,\n\t\t\t\t    parent_ino, parent_gen, dest);\n\telse\n\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t    parent_ino, parent_gen, dest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * Check if the ref was overwritten by an inode's ref that was processed\n\t * earlier. If yes, treat as orphan and return 1.\n\t */\n\tret = did_overwrite_ref(sctx, *parent_ino, *parent_gen, ino, gen,\n\t\t\tdest->start, dest->end - dest->start);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tfs_path_reset(dest);\n\t\tret = gen_unique_name(sctx, ino, gen, dest);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 1;\n\t}\n\nout_cache:\n\t/*\n\t * Store the result of the lookup in the name cache.\n\t */\n\tnce = kmalloc(sizeof(*nce) + fs_path_len(dest) + 1, GFP_NOFS);\n\tif (!nce) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnce->ino = ino;\n\tnce->gen = gen;\n\tnce->parent_ino = *parent_ino;\n\tnce->parent_gen = *parent_gen;\n\tnce->name_len = fs_path_len(dest);\n\tnce->ret = ret;\n\tstrcpy(nce->name, dest->start);\n\n\tif (ino < sctx->send_progress)\n\t\tnce->need_later_update = 0;\n\telse\n\t\tnce->need_later_update = 1;\n\n\tnce_ret = name_cache_insert(sctx, nce);\n\tif (nce_ret < 0)\n\t\tret = nce_ret;\n\tname_cache_clean_unused(sctx);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int __get_cur_name_and_parent(struct send_ctx *sctx,\n\t\t\t\t     u64 ino, u64 gen,\n\t\t\t\t     u64 *parent_ino,\n\t\t\t\t     u64 *parent_gen,\n\t\t\t\t     struct fs_path *dest)\n{\n\tint ret;\n\tint nce_ret;\n\tstruct name_cache_entry *nce = NULL;\n\n\t/*\n\t * First check if we already did a call to this function with the same\n\t * ino/gen. If yes, check if the cache entry is still up-to-date. If yes\n\t * return the cached result.\n\t */\n\tnce = name_cache_search(sctx, ino, gen);\n\tif (nce) {\n\t\tif (ino < sctx->send_progress && nce->need_later_update) {\n\t\t\tname_cache_delete(sctx, nce);\n\t\t\tkfree(nce);\n\t\t\tnce = NULL;\n\t\t} else {\n\t\t\tname_cache_used(sctx, nce);\n\t\t\t*parent_ino = nce->parent_ino;\n\t\t\t*parent_gen = nce->parent_gen;\n\t\t\tret = fs_path_add(dest, nce->name, nce->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = nce->ret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If the inode is not existent yet, add the orphan name and return 1.\n\t * This should only happen for the parent dir that we determine in\n\t * __record_new_ref\n\t */\n\tret = is_inode_existent(sctx, ino, gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!ret) {\n\t\tret = gen_unique_name(sctx, ino, gen, dest);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 1;\n\t\tgoto out_cache;\n\t}\n\n\t/*\n\t * Depending on whether the inode was already processed or not, use\n\t * send_root or parent_root for ref lookup.\n\t */\n\tif (ino < sctx->send_progress)\n\t\tret = get_first_ref(sctx->send_root, ino,\n\t\t\t\t    parent_ino, parent_gen, dest);\n\telse\n\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t    parent_ino, parent_gen, dest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * Check if the ref was overwritten by an inode's ref that was processed\n\t * earlier. If yes, treat as orphan and return 1.\n\t */\n\tret = did_overwrite_ref(sctx, *parent_ino, *parent_gen, ino, gen,\n\t\t\tdest->start, dest->end - dest->start);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tfs_path_reset(dest);\n\t\tret = gen_unique_name(sctx, ino, gen, dest);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 1;\n\t}\n\nout_cache:\n\t/*\n\t * Store the result of the lookup in the name cache.\n\t */\n\tnce = kmalloc(sizeof(*nce) + fs_path_len(dest) + 1, GFP_NOFS);\n\tif (!nce) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnce->ino = ino;\n\tnce->gen = gen;\n\tnce->parent_ino = *parent_ino;\n\tnce->parent_gen = *parent_gen;\n\tnce->name_len = fs_path_len(dest);\n\tnce->ret = ret;\n\tstrcpy(nce->name, dest->start);\n\n\tif (ino < sctx->send_progress)\n\t\tnce->need_later_update = 0;\n\telse\n\t\tnce->need_later_update = 1;\n\n\tnce_ret = name_cache_insert(sctx, nce);\n\tif (nce_ret < 0)\n\t\tret = nce_ret;\n\tname_cache_clean_unused(sctx);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_first_ref",
          "args": [
            "sctx->parent_root",
            "ino",
            "&parent_inode",
            "&parent_gen",
            "name"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "get_first_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1689-1754",
          "snippet": "static int get_first_ref(struct btrfs_root *root, u64 ino,\n\t\t\t u64 *dir, u64 *dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tint len;\n\tu64 parent_dir;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\tpath->slots[0]);\n\tif (ret || found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (found_key.type == BTRFS_INODE_REF_KEY) {\n\t\tstruct btrfs_inode_ref *iref;\n\t\tiref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(path->nodes[0], iref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t\t     (unsigned long)(iref + 1),\n\t\t\t\t\t\t     len);\n\t\tparent_dir = found_key.offset;\n\t} else {\n\t\tstruct btrfs_inode_extref *extref;\n\t\textref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_extref);\n\t\tlen = btrfs_inode_extref_name_len(path->nodes[0], extref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t(unsigned long)&extref->name, len);\n\t\tparent_dir = btrfs_inode_extref_parent(path->nodes[0], extref);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tif (dir_gen) {\n\t\tret = get_inode_info(root, parent_dir, NULL, dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t*dir = parent_dir;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_first_ref(struct btrfs_root *root, u64 ino,\n\t\t\t u64 *dir, u64 *dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tint len;\n\tu64 parent_dir;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\tpath->slots[0]);\n\tif (ret || found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (found_key.type == BTRFS_INODE_REF_KEY) {\n\t\tstruct btrfs_inode_ref *iref;\n\t\tiref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(path->nodes[0], iref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t\t     (unsigned long)(iref + 1),\n\t\t\t\t\t\t     len);\n\t\tparent_dir = found_key.offset;\n\t} else {\n\t\tstruct btrfs_inode_extref *extref;\n\t\textref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_extref);\n\t\tlen = btrfs_inode_extref_name_len(path->nodes[0], extref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t(unsigned long)&extref->name, len);\n\t\tparent_dir = btrfs_inode_extref_parent(path->nodes[0], extref);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tif (dir_gen) {\n\t\tret = get_inode_info(root, parent_dir, NULL, dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t*dir = parent_dir;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_waiting_for_move",
          "args": [
            "sctx",
            "ino"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "is_waiting_for_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2919-2924",
          "snippet": "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct waiting_dir_move *entry = get_waiting_dir_move(sctx, ino);\n\n\treturn entry != NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct waiting_dir_move *entry = get_waiting_dir_move(sctx, ino);\n\n\treturn entry != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_unique_name",
          "args": [
            "sctx",
            "ino",
            "gen",
            "name"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "gen_unique_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1488-1550",
          "snippet": "static int gen_unique_name(struct send_ctx *sctx,\n\t\t\t   u64 ino, u64 gen,\n\t\t\t   struct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tchar tmp[64];\n\tint len;\n\tu64 idx = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tlen = snprintf(tmp, sizeof(tmp), \"o%llu-%llu-%llu\",\n\t\t\t\tino, gen, idx);\n\t\tASSERT(len < sizeof(tmp));\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->send_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sctx->parent_root) {\n\t\t\t/* unique */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->parent_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* unique */\n\t\tbreak;\n\t}\n\n\tret = fs_path_add(dest, tmp, strlen(tmp));\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int gen_unique_name(struct send_ctx *sctx,\n\t\t\t   u64 ino, u64 gen,\n\t\t\t   struct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tchar tmp[64];\n\tint len;\n\tu64 idx = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tlen = snprintf(tmp, sizeof(tmp), \"o%llu-%llu-%llu\",\n\t\t\t\tino, gen, idx);\n\t\tASSERT(len < sizeof(tmp));\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->send_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sctx->parent_root) {\n\t\t\t/* unique */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->parent_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* unique */\n\t\tbreak;\n\t}\n\n\tret = fs_path_add(dest, tmp, strlen(tmp));\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_waiting_for_rm",
          "args": [
            "sctx",
            "ino"
          ],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "is_waiting_for_rm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2819-2824",
          "snippet": "static int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino)\n{\n\tstruct orphan_dir_info *odi = get_orphan_dir_info(sctx, dir_ino);\n\n\treturn odi != NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino);\n\nstatic int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino)\n{\n\tstruct orphan_dir_info *odi = get_orphan_dir_info(sctx, dir_ino);\n\n\treturn odi != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_reset",
          "args": [
            "name"
          ],
          "line": 2226
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "289-300",
          "snippet": "static void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}"
  },
  {
    "function_name": "__get_cur_name_and_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2071-2180",
    "snippet": "static int __get_cur_name_and_parent(struct send_ctx *sctx,\n\t\t\t\t     u64 ino, u64 gen,\n\t\t\t\t     u64 *parent_ino,\n\t\t\t\t     u64 *parent_gen,\n\t\t\t\t     struct fs_path *dest)\n{\n\tint ret;\n\tint nce_ret;\n\tstruct name_cache_entry *nce = NULL;\n\n\t/*\n\t * First check if we already did a call to this function with the same\n\t * ino/gen. If yes, check if the cache entry is still up-to-date. If yes\n\t * return the cached result.\n\t */\n\tnce = name_cache_search(sctx, ino, gen);\n\tif (nce) {\n\t\tif (ino < sctx->send_progress && nce->need_later_update) {\n\t\t\tname_cache_delete(sctx, nce);\n\t\t\tkfree(nce);\n\t\t\tnce = NULL;\n\t\t} else {\n\t\t\tname_cache_used(sctx, nce);\n\t\t\t*parent_ino = nce->parent_ino;\n\t\t\t*parent_gen = nce->parent_gen;\n\t\t\tret = fs_path_add(dest, nce->name, nce->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = nce->ret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If the inode is not existent yet, add the orphan name and return 1.\n\t * This should only happen for the parent dir that we determine in\n\t * __record_new_ref\n\t */\n\tret = is_inode_existent(sctx, ino, gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!ret) {\n\t\tret = gen_unique_name(sctx, ino, gen, dest);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 1;\n\t\tgoto out_cache;\n\t}\n\n\t/*\n\t * Depending on whether the inode was already processed or not, use\n\t * send_root or parent_root for ref lookup.\n\t */\n\tif (ino < sctx->send_progress)\n\t\tret = get_first_ref(sctx->send_root, ino,\n\t\t\t\t    parent_ino, parent_gen, dest);\n\telse\n\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t    parent_ino, parent_gen, dest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * Check if the ref was overwritten by an inode's ref that was processed\n\t * earlier. If yes, treat as orphan and return 1.\n\t */\n\tret = did_overwrite_ref(sctx, *parent_ino, *parent_gen, ino, gen,\n\t\t\tdest->start, dest->end - dest->start);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tfs_path_reset(dest);\n\t\tret = gen_unique_name(sctx, ino, gen, dest);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 1;\n\t}\n\nout_cache:\n\t/*\n\t * Store the result of the lookup in the name cache.\n\t */\n\tnce = kmalloc(sizeof(*nce) + fs_path_len(dest) + 1, GFP_NOFS);\n\tif (!nce) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnce->ino = ino;\n\tnce->gen = gen;\n\tnce->parent_ino = *parent_ino;\n\tnce->parent_gen = *parent_gen;\n\tnce->name_len = fs_path_len(dest);\n\tnce->ret = ret;\n\tstrcpy(nce->name, dest->start);\n\n\tif (ino < sctx->send_progress)\n\t\tnce->need_later_update = 0;\n\telse\n\t\tnce->need_later_update = 1;\n\n\tnce_ret = name_cache_insert(sctx, nce);\n\tif (nce_ret < 0)\n\t\tret = nce_ret;\n\tname_cache_clean_unused(sctx);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "name_cache_clean_unused",
          "args": [
            "sctx"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "name_cache_clean_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2036-2049",
          "snippet": "static void name_cache_clean_unused(struct send_ctx *sctx)\n{\n\tstruct name_cache_entry *nce;\n\n\tif (sctx->name_cache_size < SEND_CTX_NAME_CACHE_CLEAN_SIZE)\n\t\treturn;\n\n\twhile (sctx->name_cache_size > SEND_CTX_MAX_NAME_CACHE_SIZE) {\n\t\tnce = list_entry(sctx->name_cache_list.next,\n\t\t\t\tstruct name_cache_entry, list);\n\t\tname_cache_delete(sctx, nce);\n\t\tkfree(nce);\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [
            "#define SEND_CTX_NAME_CACHE_CLEAN_SIZE (SEND_CTX_MAX_NAME_CACHE_SIZE * 2)",
            "#define SEND_CTX_MAX_NAME_CACHE_SIZE 128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\n#define SEND_CTX_NAME_CACHE_CLEAN_SIZE (SEND_CTX_MAX_NAME_CACHE_SIZE * 2)\n#define SEND_CTX_MAX_NAME_CACHE_SIZE 128\n\nstatic void name_cache_clean_unused(struct send_ctx *sctx)\n{\n\tstruct name_cache_entry *nce;\n\n\tif (sctx->name_cache_size < SEND_CTX_NAME_CACHE_CLEAN_SIZE)\n\t\treturn;\n\n\twhile (sctx->name_cache_size > SEND_CTX_MAX_NAME_CACHE_SIZE) {\n\t\tnce = list_entry(sctx->name_cache_list.next,\n\t\t\t\tstruct name_cache_entry, list);\n\t\tname_cache_delete(sctx, nce);\n\t\tkfree(nce);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "name_cache_insert",
          "args": [
            "sctx",
            "nce"
          ],
          "line": 2173
        },
        "resolved": true,
        "details": {
          "function_name": "name_cache_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1950-1978",
          "snippet": "static int name_cache_insert(struct send_ctx *sctx,\n\t\t\t     struct name_cache_entry *nce)\n{\n\tint ret = 0;\n\tstruct list_head *nce_head;\n\n\tnce_head = radix_tree_lookup(&sctx->name_cache,\n\t\t\t(unsigned long)nce->ino);\n\tif (!nce_head) {\n\t\tnce_head = kmalloc(sizeof(*nce_head), GFP_NOFS);\n\t\tif (!nce_head) {\n\t\t\tkfree(nce);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tINIT_LIST_HEAD(nce_head);\n\n\t\tret = radix_tree_insert(&sctx->name_cache, nce->ino, nce_head);\n\t\tif (ret < 0) {\n\t\t\tkfree(nce_head);\n\t\t\tkfree(nce);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tlist_add_tail(&nce->radix_list, nce_head);\n\tlist_add_tail(&nce->list, &sctx->name_cache_list);\n\tsctx->name_cache_size++;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int name_cache_insert(struct send_ctx *sctx,\n\t\t\t     struct name_cache_entry *nce)\n{\n\tint ret = 0;\n\tstruct list_head *nce_head;\n\n\tnce_head = radix_tree_lookup(&sctx->name_cache,\n\t\t\t(unsigned long)nce->ino);\n\tif (!nce_head) {\n\t\tnce_head = kmalloc(sizeof(*nce_head), GFP_NOFS);\n\t\tif (!nce_head) {\n\t\t\tkfree(nce);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tINIT_LIST_HEAD(nce_head);\n\n\t\tret = radix_tree_insert(&sctx->name_cache, nce->ino, nce_head);\n\t\tif (ret < 0) {\n\t\t\tkfree(nce_head);\n\t\t\tkfree(nce);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tlist_add_tail(&nce->radix_list, nce_head);\n\tlist_add_tail(&nce->list, &sctx->name_cache_list);\n\tsctx->name_cache_size++;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "nce->name",
            "dest->start"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_path_len",
          "args": [
            "dest"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "337-340",
          "snippet": "static int fs_path_len(struct fs_path *p)\n{\n\treturn p->end - p->start;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_len(struct fs_path *p)\n{\n\treturn p->end - p->start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*nce) + fs_path_len(dest) + 1",
            "GFP_NOFS"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_unique_name",
          "args": [
            "sctx",
            "ino",
            "gen",
            "dest"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "gen_unique_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1488-1550",
          "snippet": "static int gen_unique_name(struct send_ctx *sctx,\n\t\t\t   u64 ino, u64 gen,\n\t\t\t   struct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tchar tmp[64];\n\tint len;\n\tu64 idx = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tlen = snprintf(tmp, sizeof(tmp), \"o%llu-%llu-%llu\",\n\t\t\t\tino, gen, idx);\n\t\tASSERT(len < sizeof(tmp));\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->send_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sctx->parent_root) {\n\t\t\t/* unique */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->parent_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* unique */\n\t\tbreak;\n\t}\n\n\tret = fs_path_add(dest, tmp, strlen(tmp));\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int gen_unique_name(struct send_ctx *sctx,\n\t\t\t   u64 ino, u64 gen,\n\t\t\t   struct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tchar tmp[64];\n\tint len;\n\tu64 idx = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tlen = snprintf(tmp, sizeof(tmp), \"o%llu-%llu-%llu\",\n\t\t\t\tino, gen, idx);\n\t\tASSERT(len < sizeof(tmp));\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->send_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sctx->parent_root) {\n\t\t\t/* unique */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->parent_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* unique */\n\t\tbreak;\n\t}\n\n\tret = fs_path_add(dest, tmp, strlen(tmp));\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_reset",
          "args": [
            "dest"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "289-300",
          "snippet": "static void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "did_overwrite_ref",
          "args": [
            "sctx",
            "*parent_ino",
            "*parent_gen",
            "ino",
            "gen",
            "dest->start",
            "dest->end - dest->start"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "did_overwrite_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1865-1911",
          "snippet": "static int did_overwrite_ref(struct send_ctx *sctx,\n\t\t\t    u64 dir, u64 dir_gen,\n\t\t\t    u64 ino, u64 ino_gen,\n\t\t\t    const char *name, int name_len)\n{\n\tint ret = 0;\n\tu64 gen;\n\tu64 ow_inode;\n\tu8 other_type;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tret = is_inode_existent(sctx, dir, dir_gen);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\t/* check if the ref was overwritten by another ref */\n\tret = lookup_dir_item_inode(sctx->send_root, dir, name, name_len,\n\t\t\t&ow_inode, &other_type);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tif (ret) {\n\t\t/* was never and will never be overwritten */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = get_inode_info(sctx->send_root, ow_inode, NULL, &gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ow_inode == ino && gen == ino_gen) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* we know that it is or will be overwritten. check this now */\n\tif (ow_inode < sctx->send_progress)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int did_overwrite_ref(struct send_ctx *sctx,\n\t\t\t    u64 dir, u64 dir_gen,\n\t\t\t    u64 ino, u64 ino_gen,\n\t\t\t    const char *name, int name_len)\n{\n\tint ret = 0;\n\tu64 gen;\n\tu64 ow_inode;\n\tu8 other_type;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tret = is_inode_existent(sctx, dir, dir_gen);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\t/* check if the ref was overwritten by another ref */\n\tret = lookup_dir_item_inode(sctx->send_root, dir, name, name_len,\n\t\t\t&ow_inode, &other_type);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tif (ret) {\n\t\t/* was never and will never be overwritten */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = get_inode_info(sctx->send_root, ow_inode, NULL, &gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ow_inode == ino && gen == ino_gen) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* we know that it is or will be overwritten. check this now */\n\tif (ow_inode < sctx->send_progress)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_first_ref",
          "args": [
            "sctx->parent_root",
            "ino",
            "parent_ino",
            "parent_gen",
            "dest"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "get_first_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1689-1754",
          "snippet": "static int get_first_ref(struct btrfs_root *root, u64 ino,\n\t\t\t u64 *dir, u64 *dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tint len;\n\tu64 parent_dir;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\tpath->slots[0]);\n\tif (ret || found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (found_key.type == BTRFS_INODE_REF_KEY) {\n\t\tstruct btrfs_inode_ref *iref;\n\t\tiref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(path->nodes[0], iref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t\t     (unsigned long)(iref + 1),\n\t\t\t\t\t\t     len);\n\t\tparent_dir = found_key.offset;\n\t} else {\n\t\tstruct btrfs_inode_extref *extref;\n\t\textref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_extref);\n\t\tlen = btrfs_inode_extref_name_len(path->nodes[0], extref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t(unsigned long)&extref->name, len);\n\t\tparent_dir = btrfs_inode_extref_parent(path->nodes[0], extref);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tif (dir_gen) {\n\t\tret = get_inode_info(root, parent_dir, NULL, dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t*dir = parent_dir;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_first_ref(struct btrfs_root *root, u64 ino,\n\t\t\t u64 *dir, u64 *dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tint len;\n\tu64 parent_dir;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\tpath->slots[0]);\n\tif (ret || found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (found_key.type == BTRFS_INODE_REF_KEY) {\n\t\tstruct btrfs_inode_ref *iref;\n\t\tiref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(path->nodes[0], iref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t\t     (unsigned long)(iref + 1),\n\t\t\t\t\t\t     len);\n\t\tparent_dir = found_key.offset;\n\t} else {\n\t\tstruct btrfs_inode_extref *extref;\n\t\textref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_extref);\n\t\tlen = btrfs_inode_extref_name_len(path->nodes[0], extref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t(unsigned long)&extref->name, len);\n\t\tparent_dir = btrfs_inode_extref_parent(path->nodes[0], extref);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tif (dir_gen) {\n\t\tret = get_inode_info(root, parent_dir, NULL, dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t*dir = parent_dir;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_inode_existent",
          "args": [
            "sctx",
            "ino",
            "gen"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_existent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1626-1643",
          "snippet": "static int is_inode_existent(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret;\n\n\tret = get_cur_inode_state(sctx, ino, gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret == inode_state_no_change ||\n\t    ret == inode_state_did_create ||\n\t    ret == inode_state_will_delete)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int is_inode_existent(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret;\n\n\tret = get_cur_inode_state(sctx, ino, gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret == inode_state_no_change ||\n\t    ret == inode_state_did_create ||\n\t    ret == inode_state_will_delete)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_add",
          "args": [
            "dest",
            "nce->name",
            "nce->name_len"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "422-434",
          "snippet": "static int fs_path_add(struct fs_path *p, const char *name, int name_len)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, name_len, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, name, name_len);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_add(struct fs_path *p, const char *name, int name_len)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, name_len, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, name, name_len);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "name_cache_used",
          "args": [
            "sctx",
            "nce"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "name_cache_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2027-2031",
          "snippet": "static void name_cache_used(struct send_ctx *sctx, struct name_cache_entry *nce)\n{\n\tlist_del(&nce->list);\n\tlist_add_tail(&nce->list, &sctx->name_cache_list);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void name_cache_used(struct send_ctx *sctx, struct name_cache_entry *nce)\n{\n\tlist_del(&nce->list);\n\tlist_add_tail(&nce->list, &sctx->name_cache_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nce"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_cache_delete",
          "args": [
            "sctx",
            "nce"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "name_cache_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1980-2004",
          "snippet": "static void name_cache_delete(struct send_ctx *sctx,\n\t\t\t      struct name_cache_entry *nce)\n{\n\tstruct list_head *nce_head;\n\n\tnce_head = radix_tree_lookup(&sctx->name_cache,\n\t\t\t(unsigned long)nce->ino);\n\tif (!nce_head) {\n\t\tbtrfs_err(sctx->send_root->fs_info,\n\t      \"name_cache_delete lookup failed ino %llu cache size %d, leaking memory\",\n\t\t\tnce->ino, sctx->name_cache_size);\n\t}\n\n\tlist_del(&nce->radix_list);\n\tlist_del(&nce->list);\n\tsctx->name_cache_size--;\n\n\t/*\n\t * We may not get to the final release of nce_head if the lookup fails\n\t */\n\tif (nce_head && list_empty(nce_head)) {\n\t\tradix_tree_delete(&sctx->name_cache, (unsigned long)nce->ino);\n\t\tkfree(nce_head);\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic void name_cache_delete(struct send_ctx *sctx,\n\t\t\t      struct name_cache_entry *nce)\n{\n\tstruct list_head *nce_head;\n\n\tnce_head = radix_tree_lookup(&sctx->name_cache,\n\t\t\t(unsigned long)nce->ino);\n\tif (!nce_head) {\n\t\tbtrfs_err(sctx->send_root->fs_info,\n\t      \"name_cache_delete lookup failed ino %llu cache size %d, leaking memory\",\n\t\t\tnce->ino, sctx->name_cache_size);\n\t}\n\n\tlist_del(&nce->radix_list);\n\tlist_del(&nce->list);\n\tsctx->name_cache_size--;\n\n\t/*\n\t * We may not get to the final release of nce_head if the lookup fails\n\t */\n\tif (nce_head && list_empty(nce_head)) {\n\t\tradix_tree_delete(&sctx->name_cache, (unsigned long)nce->ino);\n\t\tkfree(nce_head);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "name_cache_search",
          "args": [
            "sctx",
            "ino",
            "gen"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "name_cache_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "2006-2021",
          "snippet": "static struct name_cache_entry *name_cache_search(struct send_ctx *sctx,\n\t\t\t\t\t\t    u64 ino, u64 gen)\n{\n\tstruct list_head *nce_head;\n\tstruct name_cache_entry *cur;\n\n\tnce_head = radix_tree_lookup(&sctx->name_cache, (unsigned long)ino);\n\tif (!nce_head)\n\t\treturn NULL;\n\n\tlist_for_each_entry(cur, nce_head, radix_list) {\n\t\tif (cur->ino == ino && cur->gen == gen)\n\t\t\treturn cur;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic struct name_cache_entry *name_cache_search(struct send_ctx *sctx,\n\t\t\t\t\t\t    u64 ino, u64 gen)\n{\n\tstruct list_head *nce_head;\n\tstruct name_cache_entry *cur;\n\n\tnce_head = radix_tree_lookup(&sctx->name_cache, (unsigned long)ino);\n\tif (!nce_head)\n\t\treturn NULL;\n\n\tlist_for_each_entry(cur, nce_head, radix_list) {\n\t\tif (cur->ino == ino && cur->gen == gen)\n\t\t\treturn cur;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int __get_cur_name_and_parent(struct send_ctx *sctx,\n\t\t\t\t     u64 ino, u64 gen,\n\t\t\t\t     u64 *parent_ino,\n\t\t\t\t     u64 *parent_gen,\n\t\t\t\t     struct fs_path *dest)\n{\n\tint ret;\n\tint nce_ret;\n\tstruct name_cache_entry *nce = NULL;\n\n\t/*\n\t * First check if we already did a call to this function with the same\n\t * ino/gen. If yes, check if the cache entry is still up-to-date. If yes\n\t * return the cached result.\n\t */\n\tnce = name_cache_search(sctx, ino, gen);\n\tif (nce) {\n\t\tif (ino < sctx->send_progress && nce->need_later_update) {\n\t\t\tname_cache_delete(sctx, nce);\n\t\t\tkfree(nce);\n\t\t\tnce = NULL;\n\t\t} else {\n\t\t\tname_cache_used(sctx, nce);\n\t\t\t*parent_ino = nce->parent_ino;\n\t\t\t*parent_gen = nce->parent_gen;\n\t\t\tret = fs_path_add(dest, nce->name, nce->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = nce->ret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If the inode is not existent yet, add the orphan name and return 1.\n\t * This should only happen for the parent dir that we determine in\n\t * __record_new_ref\n\t */\n\tret = is_inode_existent(sctx, ino, gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!ret) {\n\t\tret = gen_unique_name(sctx, ino, gen, dest);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 1;\n\t\tgoto out_cache;\n\t}\n\n\t/*\n\t * Depending on whether the inode was already processed or not, use\n\t * send_root or parent_root for ref lookup.\n\t */\n\tif (ino < sctx->send_progress)\n\t\tret = get_first_ref(sctx->send_root, ino,\n\t\t\t\t    parent_ino, parent_gen, dest);\n\telse\n\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t    parent_ino, parent_gen, dest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * Check if the ref was overwritten by an inode's ref that was processed\n\t * earlier. If yes, treat as orphan and return 1.\n\t */\n\tret = did_overwrite_ref(sctx, *parent_ino, *parent_gen, ino, gen,\n\t\t\tdest->start, dest->end - dest->start);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tfs_path_reset(dest);\n\t\tret = gen_unique_name(sctx, ino, gen, dest);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 1;\n\t}\n\nout_cache:\n\t/*\n\t * Store the result of the lookup in the name cache.\n\t */\n\tnce = kmalloc(sizeof(*nce) + fs_path_len(dest) + 1, GFP_NOFS);\n\tif (!nce) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnce->ino = ino;\n\tnce->gen = gen;\n\tnce->parent_ino = *parent_ino;\n\tnce->parent_gen = *parent_gen;\n\tnce->name_len = fs_path_len(dest);\n\tnce->ret = ret;\n\tstrcpy(nce->name, dest->start);\n\n\tif (ino < sctx->send_progress)\n\t\tnce->need_later_update = 0;\n\telse\n\t\tnce->need_later_update = 1;\n\n\tnce_ret = name_cache_insert(sctx, nce);\n\tif (nce_ret < 0)\n\t\tret = nce_ret;\n\tname_cache_clean_unused(sctx);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "name_cache_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2051-2061",
    "snippet": "static void name_cache_free(struct send_ctx *sctx)\n{\n\tstruct name_cache_entry *nce;\n\n\twhile (!list_empty(&sctx->name_cache_list)) {\n\t\tnce = list_entry(sctx->name_cache_list.next,\n\t\t\t\tstruct name_cache_entry, list);\n\t\tname_cache_delete(sctx, nce);\n\t\tkfree(nce);\n\t}\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nce"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_cache_delete",
          "args": [
            "sctx",
            "nce"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "name_cache_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1980-2004",
          "snippet": "static void name_cache_delete(struct send_ctx *sctx,\n\t\t\t      struct name_cache_entry *nce)\n{\n\tstruct list_head *nce_head;\n\n\tnce_head = radix_tree_lookup(&sctx->name_cache,\n\t\t\t(unsigned long)nce->ino);\n\tif (!nce_head) {\n\t\tbtrfs_err(sctx->send_root->fs_info,\n\t      \"name_cache_delete lookup failed ino %llu cache size %d, leaking memory\",\n\t\t\tnce->ino, sctx->name_cache_size);\n\t}\n\n\tlist_del(&nce->radix_list);\n\tlist_del(&nce->list);\n\tsctx->name_cache_size--;\n\n\t/*\n\t * We may not get to the final release of nce_head if the lookup fails\n\t */\n\tif (nce_head && list_empty(nce_head)) {\n\t\tradix_tree_delete(&sctx->name_cache, (unsigned long)nce->ino);\n\t\tkfree(nce_head);\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic void name_cache_delete(struct send_ctx *sctx,\n\t\t\t      struct name_cache_entry *nce)\n{\n\tstruct list_head *nce_head;\n\n\tnce_head = radix_tree_lookup(&sctx->name_cache,\n\t\t\t(unsigned long)nce->ino);\n\tif (!nce_head) {\n\t\tbtrfs_err(sctx->send_root->fs_info,\n\t      \"name_cache_delete lookup failed ino %llu cache size %d, leaking memory\",\n\t\t\tnce->ino, sctx->name_cache_size);\n\t}\n\n\tlist_del(&nce->radix_list);\n\tlist_del(&nce->list);\n\tsctx->name_cache_size--;\n\n\t/*\n\t * We may not get to the final release of nce_head if the lookup fails\n\t */\n\tif (nce_head && list_empty(nce_head)) {\n\t\tradix_tree_delete(&sctx->name_cache, (unsigned long)nce->ino);\n\t\tkfree(nce_head);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "sctx->name_cache_list.next",
            "structname_cache_entry",
            "list"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sctx->name_cache_list"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void name_cache_free(struct send_ctx *sctx)\n{\n\tstruct name_cache_entry *nce;\n\n\twhile (!list_empty(&sctx->name_cache_list)) {\n\t\tnce = list_entry(sctx->name_cache_list.next,\n\t\t\t\tstruct name_cache_entry, list);\n\t\tname_cache_delete(sctx, nce);\n\t\tkfree(nce);\n\t}\n}"
  },
  {
    "function_name": "name_cache_clean_unused",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2036-2049",
    "snippet": "static void name_cache_clean_unused(struct send_ctx *sctx)\n{\n\tstruct name_cache_entry *nce;\n\n\tif (sctx->name_cache_size < SEND_CTX_NAME_CACHE_CLEAN_SIZE)\n\t\treturn;\n\n\twhile (sctx->name_cache_size > SEND_CTX_MAX_NAME_CACHE_SIZE) {\n\t\tnce = list_entry(sctx->name_cache_list.next,\n\t\t\t\tstruct name_cache_entry, list);\n\t\tname_cache_delete(sctx, nce);\n\t\tkfree(nce);\n\t}\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [
      "#define SEND_CTX_NAME_CACHE_CLEAN_SIZE (SEND_CTX_MAX_NAME_CACHE_SIZE * 2)",
      "#define SEND_CTX_MAX_NAME_CACHE_SIZE 128"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nce"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_cache_delete",
          "args": [
            "sctx",
            "nce"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "name_cache_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1980-2004",
          "snippet": "static void name_cache_delete(struct send_ctx *sctx,\n\t\t\t      struct name_cache_entry *nce)\n{\n\tstruct list_head *nce_head;\n\n\tnce_head = radix_tree_lookup(&sctx->name_cache,\n\t\t\t(unsigned long)nce->ino);\n\tif (!nce_head) {\n\t\tbtrfs_err(sctx->send_root->fs_info,\n\t      \"name_cache_delete lookup failed ino %llu cache size %d, leaking memory\",\n\t\t\tnce->ino, sctx->name_cache_size);\n\t}\n\n\tlist_del(&nce->radix_list);\n\tlist_del(&nce->list);\n\tsctx->name_cache_size--;\n\n\t/*\n\t * We may not get to the final release of nce_head if the lookup fails\n\t */\n\tif (nce_head && list_empty(nce_head)) {\n\t\tradix_tree_delete(&sctx->name_cache, (unsigned long)nce->ino);\n\t\tkfree(nce_head);\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic void name_cache_delete(struct send_ctx *sctx,\n\t\t\t      struct name_cache_entry *nce)\n{\n\tstruct list_head *nce_head;\n\n\tnce_head = radix_tree_lookup(&sctx->name_cache,\n\t\t\t(unsigned long)nce->ino);\n\tif (!nce_head) {\n\t\tbtrfs_err(sctx->send_root->fs_info,\n\t      \"name_cache_delete lookup failed ino %llu cache size %d, leaking memory\",\n\t\t\tnce->ino, sctx->name_cache_size);\n\t}\n\n\tlist_del(&nce->radix_list);\n\tlist_del(&nce->list);\n\tsctx->name_cache_size--;\n\n\t/*\n\t * We may not get to the final release of nce_head if the lookup fails\n\t */\n\tif (nce_head && list_empty(nce_head)) {\n\t\tradix_tree_delete(&sctx->name_cache, (unsigned long)nce->ino);\n\t\tkfree(nce_head);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "sctx->name_cache_list.next",
            "structname_cache_entry",
            "list"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\n#define SEND_CTX_NAME_CACHE_CLEAN_SIZE (SEND_CTX_MAX_NAME_CACHE_SIZE * 2)\n#define SEND_CTX_MAX_NAME_CACHE_SIZE 128\n\nstatic void name_cache_clean_unused(struct send_ctx *sctx)\n{\n\tstruct name_cache_entry *nce;\n\n\tif (sctx->name_cache_size < SEND_CTX_NAME_CACHE_CLEAN_SIZE)\n\t\treturn;\n\n\twhile (sctx->name_cache_size > SEND_CTX_MAX_NAME_CACHE_SIZE) {\n\t\tnce = list_entry(sctx->name_cache_list.next,\n\t\t\t\tstruct name_cache_entry, list);\n\t\tname_cache_delete(sctx, nce);\n\t\tkfree(nce);\n\t}\n}"
  },
  {
    "function_name": "name_cache_used",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2027-2031",
    "snippet": "static void name_cache_used(struct send_ctx *sctx, struct name_cache_entry *nce)\n{\n\tlist_del(&nce->list);\n\tlist_add_tail(&nce->list, &sctx->name_cache_list);\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&nce->list",
            "&sctx->name_cache_list"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&nce->list"
          ],
          "line": 2029
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void name_cache_used(struct send_ctx *sctx, struct name_cache_entry *nce)\n{\n\tlist_del(&nce->list);\n\tlist_add_tail(&nce->list, &sctx->name_cache_list);\n}"
  },
  {
    "function_name": "name_cache_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "2006-2021",
    "snippet": "static struct name_cache_entry *name_cache_search(struct send_ctx *sctx,\n\t\t\t\t\t\t    u64 ino, u64 gen)\n{\n\tstruct list_head *nce_head;\n\tstruct name_cache_entry *cur;\n\n\tnce_head = radix_tree_lookup(&sctx->name_cache, (unsigned long)ino);\n\tif (!nce_head)\n\t\treturn NULL;\n\n\tlist_for_each_entry(cur, nce_head, radix_list) {\n\t\tif (cur->ino == ino && cur->gen == gen)\n\t\t\treturn cur;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cur",
            "nce_head",
            "radix_list"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&sctx->name_cache",
            "(unsigned long)ino"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic struct name_cache_entry *name_cache_search(struct send_ctx *sctx,\n\t\t\t\t\t\t    u64 ino, u64 gen)\n{\n\tstruct list_head *nce_head;\n\tstruct name_cache_entry *cur;\n\n\tnce_head = radix_tree_lookup(&sctx->name_cache, (unsigned long)ino);\n\tif (!nce_head)\n\t\treturn NULL;\n\n\tlist_for_each_entry(cur, nce_head, radix_list) {\n\t\tif (cur->ino == ino && cur->gen == gen)\n\t\t\treturn cur;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "name_cache_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "1980-2004",
    "snippet": "static void name_cache_delete(struct send_ctx *sctx,\n\t\t\t      struct name_cache_entry *nce)\n{\n\tstruct list_head *nce_head;\n\n\tnce_head = radix_tree_lookup(&sctx->name_cache,\n\t\t\t(unsigned long)nce->ino);\n\tif (!nce_head) {\n\t\tbtrfs_err(sctx->send_root->fs_info,\n\t      \"name_cache_delete lookup failed ino %llu cache size %d, leaking memory\",\n\t\t\tnce->ino, sctx->name_cache_size);\n\t}\n\n\tlist_del(&nce->radix_list);\n\tlist_del(&nce->list);\n\tsctx->name_cache_size--;\n\n\t/*\n\t * We may not get to the final release of nce_head if the lookup fails\n\t */\n\tif (nce_head && list_empty(nce_head)) {\n\t\tradix_tree_delete(&sctx->name_cache, (unsigned long)nce->ino);\n\t\tkfree(nce_head);\n\t}\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nce_head"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&sctx->name_cache",
            "(unsigned long)nce->ino"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "nce_head"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&nce->list"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "sctx->send_root->fs_info",
            "\"name_cache_delete lookup failed ino %llu cache size %d, leaking memory\"",
            "nce->ino",
            "sctx->name_cache_size"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&sctx->name_cache",
            "(unsigned long)nce->ino"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic void name_cache_delete(struct send_ctx *sctx,\n\t\t\t      struct name_cache_entry *nce)\n{\n\tstruct list_head *nce_head;\n\n\tnce_head = radix_tree_lookup(&sctx->name_cache,\n\t\t\t(unsigned long)nce->ino);\n\tif (!nce_head) {\n\t\tbtrfs_err(sctx->send_root->fs_info,\n\t      \"name_cache_delete lookup failed ino %llu cache size %d, leaking memory\",\n\t\t\tnce->ino, sctx->name_cache_size);\n\t}\n\n\tlist_del(&nce->radix_list);\n\tlist_del(&nce->list);\n\tsctx->name_cache_size--;\n\n\t/*\n\t * We may not get to the final release of nce_head if the lookup fails\n\t */\n\tif (nce_head && list_empty(nce_head)) {\n\t\tradix_tree_delete(&sctx->name_cache, (unsigned long)nce->ino);\n\t\tkfree(nce_head);\n\t}\n}"
  },
  {
    "function_name": "name_cache_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "1950-1978",
    "snippet": "static int name_cache_insert(struct send_ctx *sctx,\n\t\t\t     struct name_cache_entry *nce)\n{\n\tint ret = 0;\n\tstruct list_head *nce_head;\n\n\tnce_head = radix_tree_lookup(&sctx->name_cache,\n\t\t\t(unsigned long)nce->ino);\n\tif (!nce_head) {\n\t\tnce_head = kmalloc(sizeof(*nce_head), GFP_NOFS);\n\t\tif (!nce_head) {\n\t\t\tkfree(nce);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tINIT_LIST_HEAD(nce_head);\n\n\t\tret = radix_tree_insert(&sctx->name_cache, nce->ino, nce_head);\n\t\tif (ret < 0) {\n\t\t\tkfree(nce_head);\n\t\t\tkfree(nce);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tlist_add_tail(&nce->radix_list, nce_head);\n\tlist_add_tail(&nce->list, &sctx->name_cache_list);\n\tsctx->name_cache_size++;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&nce->list",
            "&sctx->name_cache_list"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&nce->radix_list",
            "nce_head"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nce"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nce_head"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&sctx->name_cache",
            "nce->ino",
            "nce_head"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "nce_head"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nce"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*nce_head)",
            "GFP_NOFS"
          ],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&sctx->name_cache",
            "(unsigned long)nce->ino"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int name_cache_insert(struct send_ctx *sctx,\n\t\t\t     struct name_cache_entry *nce)\n{\n\tint ret = 0;\n\tstruct list_head *nce_head;\n\n\tnce_head = radix_tree_lookup(&sctx->name_cache,\n\t\t\t(unsigned long)nce->ino);\n\tif (!nce_head) {\n\t\tnce_head = kmalloc(sizeof(*nce_head), GFP_NOFS);\n\t\tif (!nce_head) {\n\t\t\tkfree(nce);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tINIT_LIST_HEAD(nce_head);\n\n\t\tret = radix_tree_insert(&sctx->name_cache, nce->ino, nce_head);\n\t\tif (ret < 0) {\n\t\t\tkfree(nce_head);\n\t\t\tkfree(nce);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tlist_add_tail(&nce->radix_list, nce_head);\n\tlist_add_tail(&nce->list, &sctx->name_cache_list);\n\tsctx->name_cache_size++;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "did_overwrite_first_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "1918-1942",
    "snippet": "static int did_overwrite_first_ref(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 dir;\n\tu64 dir_gen;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tname = fs_path_alloc();\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tret = get_first_ref(sctx->parent_root, ino, &dir, &dir_gen, name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = did_overwrite_ref(sctx, dir, dir_gen, ino, gen,\n\t\t\tname->start, fs_path_len(name));\n\nout:\n\tfs_path_free(name);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "name"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "did_overwrite_ref",
          "args": [
            "sctx",
            "dir",
            "dir_gen",
            "ino",
            "gen",
            "name->start",
            "fs_path_len(name)"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "did_overwrite_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1865-1911",
          "snippet": "static int did_overwrite_ref(struct send_ctx *sctx,\n\t\t\t    u64 dir, u64 dir_gen,\n\t\t\t    u64 ino, u64 ino_gen,\n\t\t\t    const char *name, int name_len)\n{\n\tint ret = 0;\n\tu64 gen;\n\tu64 ow_inode;\n\tu8 other_type;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tret = is_inode_existent(sctx, dir, dir_gen);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\t/* check if the ref was overwritten by another ref */\n\tret = lookup_dir_item_inode(sctx->send_root, dir, name, name_len,\n\t\t\t&ow_inode, &other_type);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tif (ret) {\n\t\t/* was never and will never be overwritten */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = get_inode_info(sctx->send_root, ow_inode, NULL, &gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ow_inode == ino && gen == ino_gen) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* we know that it is or will be overwritten. check this now */\n\tif (ow_inode < sctx->send_progress)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int did_overwrite_ref(struct send_ctx *sctx,\n\t\t\t    u64 dir, u64 dir_gen,\n\t\t\t    u64 ino, u64 ino_gen,\n\t\t\t    const char *name, int name_len)\n{\n\tint ret = 0;\n\tu64 gen;\n\tu64 ow_inode;\n\tu8 other_type;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tret = is_inode_existent(sctx, dir, dir_gen);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\t/* check if the ref was overwritten by another ref */\n\tret = lookup_dir_item_inode(sctx->send_root, dir, name, name_len,\n\t\t\t&ow_inode, &other_type);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tif (ret) {\n\t\t/* was never and will never be overwritten */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = get_inode_info(sctx->send_root, ow_inode, NULL, &gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ow_inode == ino && gen == ino_gen) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* we know that it is or will be overwritten. check this now */\n\tif (ow_inode < sctx->send_progress)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_len",
          "args": [
            "name"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "337-340",
          "snippet": "static int fs_path_len(struct fs_path *p)\n{\n\treturn p->end - p->start;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_len(struct fs_path *p)\n{\n\treturn p->end - p->start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_first_ref",
          "args": [
            "sctx->parent_root",
            "ino",
            "&dir",
            "&dir_gen",
            "name"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "get_first_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1689-1754",
          "snippet": "static int get_first_ref(struct btrfs_root *root, u64 ino,\n\t\t\t u64 *dir, u64 *dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tint len;\n\tu64 parent_dir;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\tpath->slots[0]);\n\tif (ret || found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (found_key.type == BTRFS_INODE_REF_KEY) {\n\t\tstruct btrfs_inode_ref *iref;\n\t\tiref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(path->nodes[0], iref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t\t     (unsigned long)(iref + 1),\n\t\t\t\t\t\t     len);\n\t\tparent_dir = found_key.offset;\n\t} else {\n\t\tstruct btrfs_inode_extref *extref;\n\t\textref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_extref);\n\t\tlen = btrfs_inode_extref_name_len(path->nodes[0], extref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t(unsigned long)&extref->name, len);\n\t\tparent_dir = btrfs_inode_extref_parent(path->nodes[0], extref);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tif (dir_gen) {\n\t\tret = get_inode_info(root, parent_dir, NULL, dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t*dir = parent_dir;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_first_ref(struct btrfs_root *root, u64 ino,\n\t\t\t u64 *dir, u64 *dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tint len;\n\tu64 parent_dir;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\tpath->slots[0]);\n\tif (ret || found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (found_key.type == BTRFS_INODE_REF_KEY) {\n\t\tstruct btrfs_inode_ref *iref;\n\t\tiref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(path->nodes[0], iref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t\t     (unsigned long)(iref + 1),\n\t\t\t\t\t\t     len);\n\t\tparent_dir = found_key.offset;\n\t} else {\n\t\tstruct btrfs_inode_extref *extref;\n\t\textref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_extref);\n\t\tlen = btrfs_inode_extref_name_len(path->nodes[0], extref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t(unsigned long)&extref->name, len);\n\t\tparent_dir = btrfs_inode_extref_parent(path->nodes[0], extref);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tif (dir_gen) {\n\t\tret = get_inode_info(root, parent_dir, NULL, dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t*dir = parent_dir;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int did_overwrite_first_ref(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 dir;\n\tu64 dir_gen;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tname = fs_path_alloc();\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tret = get_first_ref(sctx->parent_root, ino, &dir, &dir_gen, name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = did_overwrite_ref(sctx, dir, dir_gen, ino, gen,\n\t\t\tname->start, fs_path_len(name));\n\nout:\n\tfs_path_free(name);\n\treturn ret;\n}"
  },
  {
    "function_name": "did_overwrite_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "1865-1911",
    "snippet": "static int did_overwrite_ref(struct send_ctx *sctx,\n\t\t\t    u64 dir, u64 dir_gen,\n\t\t\t    u64 ino, u64 ino_gen,\n\t\t\t    const char *name, int name_len)\n{\n\tint ret = 0;\n\tu64 gen;\n\tu64 ow_inode;\n\tu8 other_type;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tret = is_inode_existent(sctx, dir, dir_gen);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\t/* check if the ref was overwritten by another ref */\n\tret = lookup_dir_item_inode(sctx->send_root, dir, name, name_len,\n\t\t\t&ow_inode, &other_type);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tif (ret) {\n\t\t/* was never and will never be overwritten */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = get_inode_info(sctx->send_root, ow_inode, NULL, &gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ow_inode == ino && gen == ino_gen) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* we know that it is or will be overwritten. check this now */\n\tif (ow_inode < sctx->send_progress)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_inode_info",
          "args": [
            "sctx->send_root",
            "ow_inode",
            "NULL",
            "&gen",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "get_inode_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "821-836",
          "snippet": "static int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_dir_item_inode",
          "args": [
            "sctx->send_root",
            "dir",
            "name",
            "name_len",
            "&ow_inode",
            "&other_type"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_dir_item_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1648-1683",
          "snippet": "static int lookup_dir_item_inode(struct btrfs_root *root,\n\t\t\t\t u64 dir, const char *name, int name_len,\n\t\t\t\t u64 *found_inode,\n\t\t\t\t u8 *found_type)\n{\n\tint ret = 0;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tdi = btrfs_lookup_dir_item(NULL, root, path,\n\t\t\tdir, name, name_len, 0);\n\tif (!di) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tif (IS_ERR(di)) {\n\t\tret = PTR_ERR(di);\n\t\tgoto out;\n\t}\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &key);\n\tif (key.type == BTRFS_ROOT_ITEM_KEY) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t*found_inode = key.objectid;\n\t*found_type = btrfs_dir_type(path->nodes[0], di);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int lookup_dir_item_inode(struct btrfs_root *root,\n\t\t\t\t u64 dir, const char *name, int name_len,\n\t\t\t\t u64 *found_inode,\n\t\t\t\t u8 *found_type)\n{\n\tint ret = 0;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tdi = btrfs_lookup_dir_item(NULL, root, path,\n\t\t\tdir, name, name_len, 0);\n\tif (!di) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tif (IS_ERR(di)) {\n\t\tret = PTR_ERR(di);\n\t\tgoto out;\n\t}\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &key);\n\tif (key.type == BTRFS_ROOT_ITEM_KEY) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t*found_inode = key.objectid;\n\t*found_type = btrfs_dir_type(path->nodes[0], di);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_inode_existent",
          "args": [
            "sctx",
            "dir",
            "dir_gen"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_existent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1626-1643",
          "snippet": "static int is_inode_existent(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret;\n\n\tret = get_cur_inode_state(sctx, ino, gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret == inode_state_no_change ||\n\t    ret == inode_state_did_create ||\n\t    ret == inode_state_will_delete)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int is_inode_existent(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret;\n\n\tret = get_cur_inode_state(sctx, ino, gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret == inode_state_no_change ||\n\t    ret == inode_state_did_create ||\n\t    ret == inode_state_will_delete)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int did_overwrite_ref(struct send_ctx *sctx,\n\t\t\t    u64 dir, u64 dir_gen,\n\t\t\t    u64 ino, u64 ino_gen,\n\t\t\t    const char *name, int name_len)\n{\n\tint ret = 0;\n\tu64 gen;\n\tu64 ow_inode;\n\tu8 other_type;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tret = is_inode_existent(sctx, dir, dir_gen);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\t/* check if the ref was overwritten by another ref */\n\tret = lookup_dir_item_inode(sctx->send_root, dir, name, name_len,\n\t\t\t&ow_inode, &other_type);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tif (ret) {\n\t\t/* was never and will never be overwritten */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = get_inode_info(sctx->send_root, ow_inode, NULL, &gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ow_inode == ino && gen == ino_gen) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* we know that it is or will be overwritten. check this now */\n\tif (ow_inode < sctx->send_progress)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "will_overwrite_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "1794-1856",
    "snippet": "static int will_overwrite_ref(struct send_ctx *sctx, u64 dir, u64 dir_gen,\n\t\t\t      const char *name, int name_len,\n\t\t\t      u64 *who_ino, u64 *who_gen)\n{\n\tint ret = 0;\n\tu64 gen;\n\tu64 other_inode = 0;\n\tu8 other_type = 0;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tret = is_inode_existent(sctx, dir, dir_gen);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\t/*\n\t * If we have a parent root we need to verify that the parent dir was\n\t * not delted and then re-created, if it was then we have no overwrite\n\t * and we can just unlink this entry.\n\t */\n\tif (sctx->parent_root) {\n\t\tret = get_inode_info(sctx->parent_root, dir, NULL, &gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (gen != dir_gen)\n\t\t\tgoto out;\n\t}\n\n\tret = lookup_dir_item_inode(sctx->parent_root, dir, name, name_len,\n\t\t\t&other_inode, &other_type);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Check if the overwritten ref was already processed. If yes, the ref\n\t * was already unlinked/moved, so we can safely assume that we will not\n\t * overwrite anything at this point in time.\n\t */\n\tif (other_inode > sctx->send_progress) {\n\t\tret = get_inode_info(sctx->parent_root, other_inode, NULL,\n\t\t\t\twho_gen, NULL, NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = 1;\n\t\t*who_ino = other_inode;\n\t} else {\n\t\tret = 0;\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_inode_info",
          "args": [
            "sctx->parent_root",
            "other_inode",
            "NULL",
            "who_gen",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "get_inode_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "821-836",
          "snippet": "static int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_dir_item_inode",
          "args": [
            "sctx->parent_root",
            "dir",
            "name",
            "name_len",
            "&other_inode",
            "&other_type"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_dir_item_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1648-1683",
          "snippet": "static int lookup_dir_item_inode(struct btrfs_root *root,\n\t\t\t\t u64 dir, const char *name, int name_len,\n\t\t\t\t u64 *found_inode,\n\t\t\t\t u8 *found_type)\n{\n\tint ret = 0;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tdi = btrfs_lookup_dir_item(NULL, root, path,\n\t\t\tdir, name, name_len, 0);\n\tif (!di) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tif (IS_ERR(di)) {\n\t\tret = PTR_ERR(di);\n\t\tgoto out;\n\t}\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &key);\n\tif (key.type == BTRFS_ROOT_ITEM_KEY) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t*found_inode = key.objectid;\n\t*found_type = btrfs_dir_type(path->nodes[0], di);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int lookup_dir_item_inode(struct btrfs_root *root,\n\t\t\t\t u64 dir, const char *name, int name_len,\n\t\t\t\t u64 *found_inode,\n\t\t\t\t u8 *found_type)\n{\n\tint ret = 0;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tdi = btrfs_lookup_dir_item(NULL, root, path,\n\t\t\tdir, name, name_len, 0);\n\tif (!di) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tif (IS_ERR(di)) {\n\t\tret = PTR_ERR(di);\n\t\tgoto out;\n\t}\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &key);\n\tif (key.type == BTRFS_ROOT_ITEM_KEY) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t*found_inode = key.objectid;\n\t*found_type = btrfs_dir_type(path->nodes[0], di);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_inode_existent",
          "args": [
            "sctx",
            "dir",
            "dir_gen"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_existent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1626-1643",
          "snippet": "static int is_inode_existent(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret;\n\n\tret = get_cur_inode_state(sctx, ino, gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret == inode_state_no_change ||\n\t    ret == inode_state_did_create ||\n\t    ret == inode_state_will_delete)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int is_inode_existent(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret;\n\n\tret = get_cur_inode_state(sctx, ino, gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret == inode_state_no_change ||\n\t    ret == inode_state_did_create ||\n\t    ret == inode_state_will_delete)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int will_overwrite_ref(struct send_ctx *sctx, u64 dir, u64 dir_gen,\n\t\t\t      const char *name, int name_len,\n\t\t\t      u64 *who_ino, u64 *who_gen)\n{\n\tint ret = 0;\n\tu64 gen;\n\tu64 other_inode = 0;\n\tu8 other_type = 0;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tret = is_inode_existent(sctx, dir, dir_gen);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\t/*\n\t * If we have a parent root we need to verify that the parent dir was\n\t * not delted and then re-created, if it was then we have no overwrite\n\t * and we can just unlink this entry.\n\t */\n\tif (sctx->parent_root) {\n\t\tret = get_inode_info(sctx->parent_root, dir, NULL, &gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (gen != dir_gen)\n\t\t\tgoto out;\n\t}\n\n\tret = lookup_dir_item_inode(sctx->parent_root, dir, name, name_len,\n\t\t\t&other_inode, &other_type);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Check if the overwritten ref was already processed. If yes, the ref\n\t * was already unlinked/moved, so we can safely assume that we will not\n\t * overwrite anything at this point in time.\n\t */\n\tif (other_inode > sctx->send_progress) {\n\t\tret = get_inode_info(sctx->parent_root, other_inode, NULL,\n\t\t\t\twho_gen, NULL, NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = 1;\n\t\t*who_ino = other_inode;\n\t} else {\n\t\tret = 0;\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "is_first_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "1756-1782",
    "snippet": "static int is_first_ref(struct btrfs_root *root,\n\t\t\tu64 ino, u64 dir,\n\t\t\tconst char *name, int name_len)\n{\n\tint ret;\n\tstruct fs_path *tmp_name;\n\tu64 tmp_dir;\n\n\ttmp_name = fs_path_alloc();\n\tif (!tmp_name)\n\t\treturn -ENOMEM;\n\n\tret = get_first_ref(root, ino, &tmp_dir, NULL, tmp_name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (dir != tmp_dir || name_len != fs_path_len(tmp_name)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = !memcmp(tmp_name->start, name, name_len);\n\nout:\n\tfs_path_free(tmp_name);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "tmp_name"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "tmp_name->start",
            "name",
            "name_len"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_path_len",
          "args": [
            "tmp_name"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "337-340",
          "snippet": "static int fs_path_len(struct fs_path *p)\n{\n\treturn p->end - p->start;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_len(struct fs_path *p)\n{\n\treturn p->end - p->start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_first_ref",
          "args": [
            "root",
            "ino",
            "&tmp_dir",
            "NULL",
            "tmp_name"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "get_first_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1689-1754",
          "snippet": "static int get_first_ref(struct btrfs_root *root, u64 ino,\n\t\t\t u64 *dir, u64 *dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tint len;\n\tu64 parent_dir;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\tpath->slots[0]);\n\tif (ret || found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (found_key.type == BTRFS_INODE_REF_KEY) {\n\t\tstruct btrfs_inode_ref *iref;\n\t\tiref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(path->nodes[0], iref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t\t     (unsigned long)(iref + 1),\n\t\t\t\t\t\t     len);\n\t\tparent_dir = found_key.offset;\n\t} else {\n\t\tstruct btrfs_inode_extref *extref;\n\t\textref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_extref);\n\t\tlen = btrfs_inode_extref_name_len(path->nodes[0], extref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t(unsigned long)&extref->name, len);\n\t\tparent_dir = btrfs_inode_extref_parent(path->nodes[0], extref);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tif (dir_gen) {\n\t\tret = get_inode_info(root, parent_dir, NULL, dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t*dir = parent_dir;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_first_ref(struct btrfs_root *root, u64 ino,\n\t\t\t u64 *dir, u64 *dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tint len;\n\tu64 parent_dir;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\tpath->slots[0]);\n\tif (ret || found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (found_key.type == BTRFS_INODE_REF_KEY) {\n\t\tstruct btrfs_inode_ref *iref;\n\t\tiref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(path->nodes[0], iref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t\t     (unsigned long)(iref + 1),\n\t\t\t\t\t\t     len);\n\t\tparent_dir = found_key.offset;\n\t} else {\n\t\tstruct btrfs_inode_extref *extref;\n\t\textref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_extref);\n\t\tlen = btrfs_inode_extref_name_len(path->nodes[0], extref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t(unsigned long)&extref->name, len);\n\t\tparent_dir = btrfs_inode_extref_parent(path->nodes[0], extref);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tif (dir_gen) {\n\t\tret = get_inode_info(root, parent_dir, NULL, dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t*dir = parent_dir;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int is_first_ref(struct btrfs_root *root,\n\t\t\tu64 ino, u64 dir,\n\t\t\tconst char *name, int name_len)\n{\n\tint ret;\n\tstruct fs_path *tmp_name;\n\tu64 tmp_dir;\n\n\ttmp_name = fs_path_alloc();\n\tif (!tmp_name)\n\t\treturn -ENOMEM;\n\n\tret = get_first_ref(root, ino, &tmp_dir, NULL, tmp_name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (dir != tmp_dir || name_len != fs_path_len(tmp_name)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = !memcmp(tmp_name->start, name, name_len);\n\nout:\n\tfs_path_free(tmp_name);\n\treturn ret;\n}"
  },
  {
    "function_name": "get_first_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "1689-1754",
    "snippet": "static int get_first_ref(struct btrfs_root *root, u64 ino,\n\t\t\t u64 *dir, u64 *dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tint len;\n\tu64 parent_dir;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\tpath->slots[0]);\n\tif (ret || found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (found_key.type == BTRFS_INODE_REF_KEY) {\n\t\tstruct btrfs_inode_ref *iref;\n\t\tiref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(path->nodes[0], iref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t\t     (unsigned long)(iref + 1),\n\t\t\t\t\t\t     len);\n\t\tparent_dir = found_key.offset;\n\t} else {\n\t\tstruct btrfs_inode_extref *extref;\n\t\textref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_extref);\n\t\tlen = btrfs_inode_extref_name_len(path->nodes[0], extref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t(unsigned long)&extref->name, len);\n\t\tparent_dir = btrfs_inode_extref_parent(path->nodes[0], extref);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tif (dir_gen) {\n\t\tret = get_inode_info(root, parent_dir, NULL, dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t*dir = parent_dir;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode_info",
          "args": [
            "root",
            "parent_dir",
            "NULL",
            "dir_gen",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "get_inode_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "821-836",
          "snippet": "static int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_extref_parent",
          "args": [
            "path->nodes[0]",
            "extref"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_path_add_from_extent_buffer",
          "args": [
            "name",
            "path->nodes[0]",
            "(unsigned long)&extref->name",
            "len"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_add_from_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "450-465",
          "snippet": "static int fs_path_add_from_extent_buffer(struct fs_path *p,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  unsigned long off, int len)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, len, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tread_extent_buffer(eb, prepared, off, len);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_add_from_extent_buffer(struct fs_path *p,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  unsigned long off, int len)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, len, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tread_extent_buffer(eb, prepared, off, len);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_extref_name_len",
          "args": [
            "path->nodes[0]",
            "extref"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_inode_extref"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_ref_name_len",
          "args": [
            "path->nodes[0]",
            "iref"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_inode_ref"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "&found_key",
            "path->slots[0]"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot_for_read",
          "args": [
            "root",
            "&key",
            "path",
            "1",
            "0"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot_for_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3057-3119",
          "snippet": "int btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_path_for_send",
          "args": [],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_path_for_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "496-507",
          "snippet": "static struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_first_ref(struct btrfs_root *root, u64 ino,\n\t\t\t u64 *dir, u64 *dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tint len;\n\tu64 parent_dir;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\tpath->slots[0]);\n\tif (ret || found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (found_key.type == BTRFS_INODE_REF_KEY) {\n\t\tstruct btrfs_inode_ref *iref;\n\t\tiref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(path->nodes[0], iref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t\t     (unsigned long)(iref + 1),\n\t\t\t\t\t\t     len);\n\t\tparent_dir = found_key.offset;\n\t} else {\n\t\tstruct btrfs_inode_extref *extref;\n\t\textref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_extref);\n\t\tlen = btrfs_inode_extref_name_len(path->nodes[0], extref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t(unsigned long)&extref->name, len);\n\t\tparent_dir = btrfs_inode_extref_parent(path->nodes[0], extref);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tif (dir_gen) {\n\t\tret = get_inode_info(root, parent_dir, NULL, dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t*dir = parent_dir;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "lookup_dir_item_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "1648-1683",
    "snippet": "static int lookup_dir_item_inode(struct btrfs_root *root,\n\t\t\t\t u64 dir, const char *name, int name_len,\n\t\t\t\t u64 *found_inode,\n\t\t\t\t u8 *found_type)\n{\n\tint ret = 0;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tdi = btrfs_lookup_dir_item(NULL, root, path,\n\t\t\tdir, name, name_len, 0);\n\tif (!di) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tif (IS_ERR(di)) {\n\t\tret = PTR_ERR(di);\n\t\tgoto out;\n\t}\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &key);\n\tif (key.type == BTRFS_ROOT_ITEM_KEY) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t*found_inode = key.objectid;\n\t*found_type = btrfs_dir_type(path->nodes[0], di);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_type",
          "args": [
            "path->nodes[0]",
            "di"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dir_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "di",
            "&key"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dir_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2763-2770",
          "snippet": "static inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "di"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "di"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_dir_item",
          "args": [
            "NULL",
            "root",
            "path",
            "dir",
            "name",
            "name_len",
            "0"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "191-214",
          "snippet": "struct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_path_for_send",
          "args": [],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_path_for_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "496-507",
          "snippet": "static struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int lookup_dir_item_inode(struct btrfs_root *root,\n\t\t\t\t u64 dir, const char *name, int name_len,\n\t\t\t\t u64 *found_inode,\n\t\t\t\t u8 *found_type)\n{\n\tint ret = 0;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tdi = btrfs_lookup_dir_item(NULL, root, path,\n\t\t\tdir, name, name_len, 0);\n\tif (!di) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tif (IS_ERR(di)) {\n\t\tret = PTR_ERR(di);\n\t\tgoto out;\n\t}\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &key);\n\tif (key.type == BTRFS_ROOT_ITEM_KEY) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t*found_inode = key.objectid;\n\t*found_type = btrfs_dir_type(path->nodes[0], di);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "is_inode_existent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "1626-1643",
    "snippet": "static int is_inode_existent(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret;\n\n\tret = get_cur_inode_state(sctx, ino, gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret == inode_state_no_change ||\n\t    ret == inode_state_did_create ||\n\t    ret == inode_state_will_delete)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_cur_inode_state",
          "args": [
            "sctx",
            "ino",
            "gen"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "get_cur_inode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1560-1624",
          "snippet": "static int get_cur_inode_state(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret;\n\tint left_ret;\n\tint right_ret;\n\tu64 left_gen;\n\tu64 right_gen;\n\n\tret = get_inode_info(sctx->send_root, ino, NULL, &left_gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tleft_ret = ret;\n\n\tif (!sctx->parent_root) {\n\t\tright_ret = -ENOENT;\n\t} else {\n\t\tret = get_inode_info(sctx->parent_root, ino, NULL, &right_gen,\n\t\t\t\tNULL, NULL, NULL, NULL);\n\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\tgoto out;\n\t\tright_ret = ret;\n\t}\n\n\tif (!left_ret && !right_ret) {\n\t\tif (left_gen == gen && right_gen == gen) {\n\t\t\tret = inode_state_no_change;\n\t\t} else if (left_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_create;\n\t\t\telse\n\t\t\t\tret = inode_state_will_create;\n\t\t} else if (right_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_delete;\n\t\t\telse\n\t\t\t\tret = inode_state_will_delete;\n\t\t} else  {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else if (!left_ret) {\n\t\tif (left_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_create;\n\t\t\telse\n\t\t\t\tret = inode_state_will_create;\n\t\t} else {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else if (!right_ret) {\n\t\tif (right_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_delete;\n\t\t\telse\n\t\t\t\tret = inode_state_will_delete;\n\t\t} else {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_cur_inode_state(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret;\n\tint left_ret;\n\tint right_ret;\n\tu64 left_gen;\n\tu64 right_gen;\n\n\tret = get_inode_info(sctx->send_root, ino, NULL, &left_gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tleft_ret = ret;\n\n\tif (!sctx->parent_root) {\n\t\tright_ret = -ENOENT;\n\t} else {\n\t\tret = get_inode_info(sctx->parent_root, ino, NULL, &right_gen,\n\t\t\t\tNULL, NULL, NULL, NULL);\n\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\tgoto out;\n\t\tright_ret = ret;\n\t}\n\n\tif (!left_ret && !right_ret) {\n\t\tif (left_gen == gen && right_gen == gen) {\n\t\t\tret = inode_state_no_change;\n\t\t} else if (left_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_create;\n\t\t\telse\n\t\t\t\tret = inode_state_will_create;\n\t\t} else if (right_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_delete;\n\t\t\telse\n\t\t\t\tret = inode_state_will_delete;\n\t\t} else  {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else if (!left_ret) {\n\t\tif (left_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_create;\n\t\t\telse\n\t\t\t\tret = inode_state_will_create;\n\t\t} else {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else if (!right_ret) {\n\t\tif (right_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_delete;\n\t\t\telse\n\t\t\t\tret = inode_state_will_delete;\n\t\t} else {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int is_inode_existent(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret;\n\n\tret = get_cur_inode_state(sctx, ino, gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret == inode_state_no_change ||\n\t    ret == inode_state_did_create ||\n\t    ret == inode_state_will_delete)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "get_cur_inode_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "1560-1624",
    "snippet": "static int get_cur_inode_state(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret;\n\tint left_ret;\n\tint right_ret;\n\tu64 left_gen;\n\tu64 right_gen;\n\n\tret = get_inode_info(sctx->send_root, ino, NULL, &left_gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tleft_ret = ret;\n\n\tif (!sctx->parent_root) {\n\t\tright_ret = -ENOENT;\n\t} else {\n\t\tret = get_inode_info(sctx->parent_root, ino, NULL, &right_gen,\n\t\t\t\tNULL, NULL, NULL, NULL);\n\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\tgoto out;\n\t\tright_ret = ret;\n\t}\n\n\tif (!left_ret && !right_ret) {\n\t\tif (left_gen == gen && right_gen == gen) {\n\t\t\tret = inode_state_no_change;\n\t\t} else if (left_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_create;\n\t\t\telse\n\t\t\t\tret = inode_state_will_create;\n\t\t} else if (right_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_delete;\n\t\t\telse\n\t\t\t\tret = inode_state_will_delete;\n\t\t} else  {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else if (!left_ret) {\n\t\tif (left_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_create;\n\t\t\telse\n\t\t\t\tret = inode_state_will_create;\n\t\t} else {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else if (!right_ret) {\n\t\tif (right_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_delete;\n\t\t\telse\n\t\t\t\tret = inode_state_will_delete;\n\t\t} else {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_inode_info",
          "args": [
            "sctx->parent_root",
            "ino",
            "NULL",
            "&right_gen",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "get_inode_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "821-836",
          "snippet": "static int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_cur_inode_state(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret;\n\tint left_ret;\n\tint right_ret;\n\tu64 left_gen;\n\tu64 right_gen;\n\n\tret = get_inode_info(sctx->send_root, ino, NULL, &left_gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tleft_ret = ret;\n\n\tif (!sctx->parent_root) {\n\t\tright_ret = -ENOENT;\n\t} else {\n\t\tret = get_inode_info(sctx->parent_root, ino, NULL, &right_gen,\n\t\t\t\tNULL, NULL, NULL, NULL);\n\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\tgoto out;\n\t\tright_ret = ret;\n\t}\n\n\tif (!left_ret && !right_ret) {\n\t\tif (left_gen == gen && right_gen == gen) {\n\t\t\tret = inode_state_no_change;\n\t\t} else if (left_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_create;\n\t\t\telse\n\t\t\t\tret = inode_state_will_create;\n\t\t} else if (right_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_delete;\n\t\t\telse\n\t\t\t\tret = inode_state_will_delete;\n\t\t} else  {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else if (!left_ret) {\n\t\tif (left_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_create;\n\t\t\telse\n\t\t\t\tret = inode_state_will_create;\n\t\t} else {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else if (!right_ret) {\n\t\tif (right_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_delete;\n\t\t\telse\n\t\t\t\tret = inode_state_will_delete;\n\t\t} else {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "gen_unique_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "1488-1550",
    "snippet": "static int gen_unique_name(struct send_ctx *sctx,\n\t\t\t   u64 ino, u64 gen,\n\t\t\t   struct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tchar tmp[64];\n\tint len;\n\tu64 idx = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tlen = snprintf(tmp, sizeof(tmp), \"o%llu-%llu-%llu\",\n\t\t\t\tino, gen, idx);\n\t\tASSERT(len < sizeof(tmp));\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->send_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sctx->parent_root) {\n\t\t\t/* unique */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->parent_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* unique */\n\t\tbreak;\n\t}\n\n\tret = fs_path_add(dest, tmp, strlen(tmp));\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_add",
          "args": [
            "dest",
            "tmp",
            "strlen(tmp)"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "422-434",
          "snippet": "static int fs_path_add(struct fs_path *p, const char *name, int name_len)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, name_len, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, name, name_len);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_add(struct fs_path *p, const char *name, int name_len)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, name_len, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, name, name_len);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "di"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "di"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_dir_item",
          "args": [
            "NULL",
            "sctx->parent_root",
            "path",
            "BTRFS_FIRST_FREE_OBJECTID",
            "tmp",
            "strlen(tmp)",
            "0"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "191-214",
          "snippet": "struct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "di"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "di"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len < sizeof(tmp)"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tmp",
            "sizeof(tmp)",
            "\"o%llu-%llu-%llu\"",
            "ino",
            "gen",
            "idx"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_path_for_send",
          "args": [],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_path_for_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "496-507",
          "snippet": "static struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int gen_unique_name(struct send_ctx *sctx,\n\t\t\t   u64 ino, u64 gen,\n\t\t\t   struct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tchar tmp[64];\n\tint len;\n\tu64 idx = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tlen = snprintf(tmp, sizeof(tmp), \"o%llu-%llu-%llu\",\n\t\t\t\tino, gen, idx);\n\t\tASSERT(len < sizeof(tmp));\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->send_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sctx->parent_root) {\n\t\t\t/* unique */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->parent_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* unique */\n\t\tbreak;\n\t}\n\n\tret = fs_path_add(dest, tmp, strlen(tmp));\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "read_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "1442-1482",
    "snippet": "static int read_symlink(struct btrfs_root *root,\n\t\t\tu64 ino,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_file_extent_item *ei;\n\tu8 type;\n\tu8 compression;\n\tunsigned long off;\n\tint len;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(ret);\n\n\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\tstruct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], ei);\n\tcompression = btrfs_file_extent_compression(path->nodes[0], ei);\n\tBUG_ON(type != BTRFS_FILE_EXTENT_INLINE);\n\tBUG_ON(compression);\n\n\toff = btrfs_file_extent_inline_start(ei);\n\tlen = btrfs_file_extent_inline_len(path->nodes[0], path->slots[0], ei);\n\n\tret = fs_path_add_from_extent_buffer(dest, path->nodes[0], off, len);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_add_from_extent_buffer",
          "args": [
            "dest",
            "path->nodes[0]",
            "off",
            "len"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_add_from_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "450-465",
          "snippet": "static int fs_path_add_from_extent_buffer(struct fs_path *p,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  unsigned long off, int len)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, len, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tread_extent_buffer(eb, prepared, off, len);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_add_from_extent_buffer(struct fs_path *p,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  unsigned long off, int len)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, len, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tread_extent_buffer(eb, prepared, off, len);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_inline_len",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "ei"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_file_extent_inline_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3139-3159",
          "snippet": "static inline u32 btrfs_file_extent_inline_len(struct extent_buffer *eb,\n\t\t\t\t\t       int slot,\n\t\t\t\t\t       struct btrfs_file_extent_item *fi)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\t/*\n\t * return the space used on disk if this item isn't\n\t * compressed or encoded\n\t */\n\tif (btrfs_token_file_extent_compression(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_encryption(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_other_encoding(eb, fi, &token) == 0) {\n\t\treturn btrfs_file_extent_inline_item_len(eb,\n\t\t\t\t\t\t\t btrfs_item_nr(slot));\n\t}\n\n\t/* otherwise use the ram bytes field */\n\treturn btrfs_token_file_extent_ram_bytes(eb, fi, &token);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_file_extent_inline_len(struct extent_buffer *eb,\n\t\t\t\t\t       int slot,\n\t\t\t\t\t       struct btrfs_file_extent_item *fi)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\t/*\n\t * return the space used on disk if this item isn't\n\t * compressed or encoded\n\t */\n\tif (btrfs_token_file_extent_compression(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_encryption(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_other_encoding(eb, fi, &token) == 0) {\n\t\treturn btrfs_file_extent_inline_item_len(eb,\n\t\t\t\t\t\t\t btrfs_item_nr(slot));\n\t}\n\n\t/* otherwise use the ram bytes field */\n\treturn btrfs_token_file_extent_ram_bytes(eb, fi, &token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_inline_start",
          "args": [
            "ei"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_file_extent_inline_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3095-3099",
          "snippet": "static inline unsigned long\nbtrfs_file_extent_inline_start(struct btrfs_file_extent_item *e)\n{\n\treturn (unsigned long)e + BTRFS_FILE_EXTENT_INLINE_DATA_START;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_FILE_EXTENT_INLINE_DATA_START\t\t\\\n\t\t(offsetof(struct btrfs_file_extent_item, disk_bytenr))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_FILE_EXTENT_INLINE_DATA_START\t\t\\\n\t\t(offsetof(struct btrfs_file_extent_item, disk_bytenr))\n\nstatic inline unsigned long\nbtrfs_file_extent_inline_start(struct btrfs_file_extent_item *e)\n{\n\treturn (unsigned long)e + BTRFS_FILE_EXTENT_INLINE_DATA_START;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "compression"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "type != BTRFS_FILE_EXTENT_INLINE"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_compression",
          "args": [
            "path->nodes[0]",
            "ei"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "path->nodes[0]",
            "ei"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_path_for_send",
          "args": [],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_path_for_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "496-507",
          "snippet": "static struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int read_symlink(struct btrfs_root *root,\n\t\t\tu64 ino,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_file_extent_item *ei;\n\tu8 type;\n\tu8 compression;\n\tunsigned long off;\n\tint len;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(ret);\n\n\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\tstruct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], ei);\n\tcompression = btrfs_file_extent_compression(path->nodes[0], ei);\n\tBUG_ON(type != BTRFS_FILE_EXTENT_INLINE);\n\tBUG_ON(compression);\n\n\toff = btrfs_file_extent_inline_start(ei);\n\tlen = btrfs_file_extent_inline_len(path->nodes[0], path->slots[0], ei);\n\n\tret = fs_path_add_from_extent_buffer(dest, path->nodes[0], off, len);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_extent_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "1273-1440",
    "snippet": "static int find_extent_clone(struct send_ctx *sctx,\n\t\t\t     struct btrfs_path *path,\n\t\t\t     u64 ino, u64 data_offset,\n\t\t\t     u64 ino_size,\n\t\t\t     struct clone_root **found)\n{\n\tint ret;\n\tint extent_type;\n\tu64 logical;\n\tu64 disk_byte;\n\tu64 num_bytes;\n\tu64 extent_item_pos;\n\tu64 flags = 0;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct backref_ctx *backref_ctx = NULL;\n\tstruct clone_root *cur_clone_root;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *tmp_path;\n\tint compressed;\n\tu32 i;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path)\n\t\treturn -ENOMEM;\n\n\t/* We only use this path under the commit sem */\n\ttmp_path->need_commit_sem = 0;\n\n\tbackref_ctx = kmalloc(sizeof(*backref_ctx), GFP_NOFS);\n\tif (!backref_ctx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbackref_ctx->path = tmp_path;\n\n\tif (data_offset >= ino_size) {\n\t\t/*\n\t\t * There may be extents that lie behind the file's size.\n\t\t * I at least had this in combination with snapshotting while\n\t\t * writing large files.\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tfi = btrfs_item_ptr(eb, path->slots[0],\n\t\t\tstruct btrfs_file_extent_item);\n\textent_type = btrfs_file_extent_type(eb, fi);\n\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tcompressed = btrfs_file_extent_compression(eb, fi);\n\n\tnum_bytes = btrfs_file_extent_num_bytes(eb, fi);\n\tdisk_byte = btrfs_file_extent_disk_bytenr(eb, fi);\n\tif (disk_byte == 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tlogical = disk_byte + btrfs_file_extent_offset(eb, fi);\n\n\tdown_read(&sctx->send_root->fs_info->commit_root_sem);\n\tret = extent_from_logical(sctx->send_root->fs_info, disk_byte, tmp_path,\n\t\t\t\t  &found_key, &flags);\n\tup_read(&sctx->send_root->fs_info->commit_root_sem);\n\tbtrfs_release_path(tmp_path);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Setup the clone roots.\n\t */\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++) {\n\t\tcur_clone_root = sctx->clone_roots + i;\n\t\tcur_clone_root->ino = (u64)-1;\n\t\tcur_clone_root->offset = 0;\n\t\tcur_clone_root->found_refs = 0;\n\t}\n\n\tbackref_ctx->sctx = sctx;\n\tbackref_ctx->found = 0;\n\tbackref_ctx->cur_objectid = ino;\n\tbackref_ctx->cur_offset = data_offset;\n\tbackref_ctx->found_itself = 0;\n\tbackref_ctx->extent_len = num_bytes;\n\n\t/*\n\t * The last extent of a file may be too large due to page alignment.\n\t * We need to adjust extent_len in this case so that the checks in\n\t * __iterate_backrefs work.\n\t */\n\tif (data_offset + num_bytes >= ino_size)\n\t\tbackref_ctx->extent_len = ino_size - data_offset;\n\n\t/*\n\t * Now collect all backrefs.\n\t */\n\tif (compressed == BTRFS_COMPRESS_NONE)\n\t\textent_item_pos = logical - found_key.objectid;\n\telse\n\t\textent_item_pos = 0;\n\tret = iterate_extent_inodes(sctx->send_root->fs_info,\n\t\t\t\t\tfound_key.objectid, extent_item_pos, 1,\n\t\t\t\t\t__iterate_backrefs, backref_ctx);\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!backref_ctx->found_itself) {\n\t\t/* found a bug in backref code? */\n\t\tret = -EIO;\n\t\tbtrfs_err(sctx->send_root->fs_info, \"did not find backref in \"\n\t\t\t\t\"send_root. inode=%llu, offset=%llu, \"\n\t\t\t\t\"disk_byte=%llu found extent=%llu\",\n\t\t\t\tino, data_offset, disk_byte, found_key.objectid);\n\t\tgoto out;\n\t}\n\nverbose_printk(KERN_DEBUG \"btrfs: find_extent_clone: data_offset=%llu, \"\n\t\t\"ino=%llu, \"\n\t\t\"num_bytes=%llu, logical=%llu\\n\",\n\t\tdata_offset, ino, num_bytes, logical);\n\n\tif (!backref_ctx->found)\n\t\tverbose_printk(\"btrfs:    no clones found\\n\");\n\n\tcur_clone_root = NULL;\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++) {\n\t\tif (sctx->clone_roots[i].found_refs) {\n\t\t\tif (!cur_clone_root)\n\t\t\t\tcur_clone_root = sctx->clone_roots + i;\n\t\t\telse if (sctx->clone_roots[i].root == sctx->send_root)\n\t\t\t\t/* prefer clones from send_root over others */\n\t\t\t\tcur_clone_root = sctx->clone_roots + i;\n\t\t}\n\n\t}\n\n\tif (cur_clone_root) {\n\t\tif (compressed != BTRFS_COMPRESS_NONE) {\n\t\t\t/*\n\t\t\t * Offsets given by iterate_extent_inodes() are relative\n\t\t\t * to the start of the extent, we need to add logical\n\t\t\t * offset from the file extent item.\n\t\t\t * (See why at backref.c:check_extent_in_eb())\n\t\t\t */\n\t\t\tcur_clone_root->offset += btrfs_file_extent_offset(eb,\n\t\t\t\t\t\t\t\t\t   fi);\n\t\t}\n\t\t*found = cur_clone_root;\n\t\tret = 0;\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tkfree(backref_ctx);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "backref_ctx"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "tmp_path"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_offset",
          "args": [
            "eb",
            "fi"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose_printk",
          "args": [
            "\"btrfs:    no clones found\\n\""
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose_printk",
          "args": [
            "KERN_DEBUG \"btrfs: find_extent_clone: data_offset=%llu, \"\n\t\t\"ino=%llu, \"\n\t\t\"num_bytes=%llu, logical=%llu\\n\"",
            "data_offset",
            "ino",
            "num_bytes",
            "logical"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "sctx->send_root->fs_info",
            "\"did not find backref in \"\n\t\t\t\t\"send_root. inode=%llu, offset=%llu, \"\n\t\t\t\t\"disk_byte=%llu found extent=%llu\"",
            "ino",
            "data_offset",
            "disk_byte",
            "found_key.objectid"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate_extent_inodes",
          "args": [
            "sctx->send_root->fs_info",
            "found_key.objectid",
            "extent_item_pos",
            "1",
            "__iterate_backrefs",
            "backref_ctx"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_extent_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1602-1665",
          "snippet": "int iterate_extent_inodes(struct btrfs_fs_info *fs_info,\n\t\t\t\tu64 extent_item_objectid, u64 extent_item_pos,\n\t\t\t\tint search_commit_root,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tint ret;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct ulist *refs = NULL;\n\tstruct ulist *roots = NULL;\n\tstruct ulist_node *ref_node = NULL;\n\tstruct ulist_node *root_node = NULL;\n\tstruct seq_list tree_mod_seq_elem = {};\n\tstruct ulist_iterator ref_uiter;\n\tstruct ulist_iterator root_uiter;\n\n\tpr_debug(\"resolving all inodes for extent %llu\\n\",\n\t\t\textent_item_objectid);\n\n\tif (!search_commit_root) {\n\t\ttrans = btrfs_join_transaction(fs_info->extent_root);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t\tbtrfs_get_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\t} else {\n\t\tdown_read(&fs_info->commit_root_sem);\n\t}\n\n\tret = btrfs_find_all_leafs(trans, fs_info, extent_item_objectid,\n\t\t\t\t   tree_mod_seq_elem.seq, &refs,\n\t\t\t\t   &extent_item_pos);\n\tif (ret)\n\t\tgoto out;\n\n\tULIST_ITER_INIT(&ref_uiter);\n\twhile (!ret && (ref_node = ulist_next(refs, &ref_uiter))) {\n\t\tret = __btrfs_find_all_roots(trans, fs_info, ref_node->val,\n\t\t\t\t\t     tree_mod_seq_elem.seq, &roots);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tULIST_ITER_INIT(&root_uiter);\n\t\twhile (!ret && (root_node = ulist_next(roots, &root_uiter))) {\n\t\t\tpr_debug(\"root %llu references leaf %llu, data list \"\n\t\t\t\t \"%#llx\\n\", root_node->val, ref_node->val,\n\t\t\t\t ref_node->aux);\n\t\t\tret = iterate_leaf_refs((struct extent_inode_elem *)\n\t\t\t\t\t\t(uintptr_t)ref_node->aux,\n\t\t\t\t\t\troot_node->val,\n\t\t\t\t\t\textent_item_objectid,\n\t\t\t\t\t\titerate, ctx);\n\t\t}\n\t\tulist_free(roots);\n\t}\n\n\tfree_leaf_list(refs);\nout:\n\tif (!search_commit_root) {\n\t\tbtrfs_put_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\t\tbtrfs_end_transaction(trans, fs_info->extent_root);\n\t} else {\n\t\tup_read(&fs_info->commit_root_sem);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint iterate_extent_inodes(struct btrfs_fs_info *fs_info,\n\t\t\t\tu64 extent_item_objectid, u64 extent_item_pos,\n\t\t\t\tint search_commit_root,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tint ret;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct ulist *refs = NULL;\n\tstruct ulist *roots = NULL;\n\tstruct ulist_node *ref_node = NULL;\n\tstruct ulist_node *root_node = NULL;\n\tstruct seq_list tree_mod_seq_elem = {};\n\tstruct ulist_iterator ref_uiter;\n\tstruct ulist_iterator root_uiter;\n\n\tpr_debug(\"resolving all inodes for extent %llu\\n\",\n\t\t\textent_item_objectid);\n\n\tif (!search_commit_root) {\n\t\ttrans = btrfs_join_transaction(fs_info->extent_root);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t\tbtrfs_get_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\t} else {\n\t\tdown_read(&fs_info->commit_root_sem);\n\t}\n\n\tret = btrfs_find_all_leafs(trans, fs_info, extent_item_objectid,\n\t\t\t\t   tree_mod_seq_elem.seq, &refs,\n\t\t\t\t   &extent_item_pos);\n\tif (ret)\n\t\tgoto out;\n\n\tULIST_ITER_INIT(&ref_uiter);\n\twhile (!ret && (ref_node = ulist_next(refs, &ref_uiter))) {\n\t\tret = __btrfs_find_all_roots(trans, fs_info, ref_node->val,\n\t\t\t\t\t     tree_mod_seq_elem.seq, &roots);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tULIST_ITER_INIT(&root_uiter);\n\t\twhile (!ret && (root_node = ulist_next(roots, &root_uiter))) {\n\t\t\tpr_debug(\"root %llu references leaf %llu, data list \"\n\t\t\t\t \"%#llx\\n\", root_node->val, ref_node->val,\n\t\t\t\t ref_node->aux);\n\t\t\tret = iterate_leaf_refs((struct extent_inode_elem *)\n\t\t\t\t\t\t(uintptr_t)ref_node->aux,\n\t\t\t\t\t\troot_node->val,\n\t\t\t\t\t\textent_item_objectid,\n\t\t\t\t\t\titerate, ctx);\n\t\t}\n\t\tulist_free(roots);\n\t}\n\n\tfree_leaf_list(refs);\nout:\n\tif (!search_commit_root) {\n\t\tbtrfs_put_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\t\tbtrfs_end_transaction(trans, fs_info->extent_root);\n\t} else {\n\t\tup_read(&fs_info->commit_root_sem);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "tmp_path"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&sctx->send_root->fs_info->commit_root_sem"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_from_logical",
          "args": [
            "sctx->send_root->fs_info",
            "disk_byte",
            "tmp_path",
            "&found_key",
            "&flags"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "extent_from_logical",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1405-1470",
          "snippet": "int extent_from_logical(struct btrfs_fs_info *fs_info, u64 logical,\n\t\t\tstruct btrfs_path *path, struct btrfs_key *found_key,\n\t\t\tu64 *flags_ret)\n{\n\tint ret;\n\tu64 flags;\n\tu64 size = 0;\n\tu32 item_size;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_extent_item *ei;\n\tstruct btrfs_key key;\n\n\tif (btrfs_fs_incompat(fs_info, SKINNY_METADATA))\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\telse\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.objectid = logical;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, fs_info->extent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = btrfs_previous_extent_item(fs_info->extent_root, path, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\treturn ret;\n\t}\n\tbtrfs_item_key_to_cpu(path->nodes[0], found_key, path->slots[0]);\n\tif (found_key->type == BTRFS_METADATA_ITEM_KEY)\n\t\tsize = fs_info->extent_root->nodesize;\n\telse if (found_key->type == BTRFS_EXTENT_ITEM_KEY)\n\t\tsize = found_key->offset;\n\n\tif (found_key->objectid > logical ||\n\t    found_key->objectid + size <= logical) {\n\t\tpr_debug(\"logical %llu is not within any extent\\n\", logical);\n\t\treturn -ENOENT;\n\t}\n\n\teb = path->nodes[0];\n\titem_size = btrfs_item_size_nr(eb, path->slots[0]);\n\tBUG_ON(item_size < sizeof(*ei));\n\n\tei = btrfs_item_ptr(eb, path->slots[0], struct btrfs_extent_item);\n\tflags = btrfs_extent_flags(eb, ei);\n\n\tpr_debug(\"logical %llu is at position %llu within the extent (%llu \"\n\t\t \"EXTENT_ITEM %llu) flags %#llx size %u\\n\",\n\t\t logical, logical - found_key->objectid, found_key->objectid,\n\t\t found_key->offset, flags, item_size);\n\n\tWARN_ON(!flags_ret);\n\tif (flags_ret) {\n\t\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n\t\t\t*flags_ret = BTRFS_EXTENT_FLAG_TREE_BLOCK;\n\t\telse if (flags & BTRFS_EXTENT_FLAG_DATA)\n\t\t\t*flags_ret = BTRFS_EXTENT_FLAG_DATA;\n\t\telse\n\t\t\tBUG_ON(1);\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint extent_from_logical(struct btrfs_fs_info *fs_info, u64 logical,\n\t\t\tstruct btrfs_path *path, struct btrfs_key *found_key,\n\t\t\tu64 *flags_ret)\n{\n\tint ret;\n\tu64 flags;\n\tu64 size = 0;\n\tu32 item_size;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_extent_item *ei;\n\tstruct btrfs_key key;\n\n\tif (btrfs_fs_incompat(fs_info, SKINNY_METADATA))\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\telse\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.objectid = logical;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, fs_info->extent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = btrfs_previous_extent_item(fs_info->extent_root, path, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\treturn ret;\n\t}\n\tbtrfs_item_key_to_cpu(path->nodes[0], found_key, path->slots[0]);\n\tif (found_key->type == BTRFS_METADATA_ITEM_KEY)\n\t\tsize = fs_info->extent_root->nodesize;\n\telse if (found_key->type == BTRFS_EXTENT_ITEM_KEY)\n\t\tsize = found_key->offset;\n\n\tif (found_key->objectid > logical ||\n\t    found_key->objectid + size <= logical) {\n\t\tpr_debug(\"logical %llu is not within any extent\\n\", logical);\n\t\treturn -ENOENT;\n\t}\n\n\teb = path->nodes[0];\n\titem_size = btrfs_item_size_nr(eb, path->slots[0]);\n\tBUG_ON(item_size < sizeof(*ei));\n\n\tei = btrfs_item_ptr(eb, path->slots[0], struct btrfs_extent_item);\n\tflags = btrfs_extent_flags(eb, ei);\n\n\tpr_debug(\"logical %llu is at position %llu within the extent (%llu \"\n\t\t \"EXTENT_ITEM %llu) flags %#llx size %u\\n\",\n\t\t logical, logical - found_key->objectid, found_key->objectid,\n\t\t found_key->offset, flags, item_size);\n\n\tWARN_ON(!flags_ret);\n\tif (flags_ret) {\n\t\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n\t\t\t*flags_ret = BTRFS_EXTENT_FLAG_TREE_BLOCK;\n\t\telse if (flags & BTRFS_EXTENT_FLAG_DATA)\n\t\t\t*flags_ret = BTRFS_EXTENT_FLAG_DATA;\n\t\telse\n\t\t\tBUG_ON(1);\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&sctx->send_root->fs_info->commit_root_sem"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_offset",
          "args": [
            "eb",
            "fi"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_bytenr",
          "args": [
            "eb",
            "fi"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "eb",
            "fi"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_compression",
          "args": [
            "eb",
            "fi"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "eb",
            "fi"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*backref_ctx)",
            "GFP_NOFS"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_path_for_send",
          "args": [],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_path_for_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "496-507",
          "snippet": "static struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int find_extent_clone(struct send_ctx *sctx,\n\t\t\t     struct btrfs_path *path,\n\t\t\t     u64 ino, u64 data_offset,\n\t\t\t     u64 ino_size,\n\t\t\t     struct clone_root **found)\n{\n\tint ret;\n\tint extent_type;\n\tu64 logical;\n\tu64 disk_byte;\n\tu64 num_bytes;\n\tu64 extent_item_pos;\n\tu64 flags = 0;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct backref_ctx *backref_ctx = NULL;\n\tstruct clone_root *cur_clone_root;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *tmp_path;\n\tint compressed;\n\tu32 i;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path)\n\t\treturn -ENOMEM;\n\n\t/* We only use this path under the commit sem */\n\ttmp_path->need_commit_sem = 0;\n\n\tbackref_ctx = kmalloc(sizeof(*backref_ctx), GFP_NOFS);\n\tif (!backref_ctx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbackref_ctx->path = tmp_path;\n\n\tif (data_offset >= ino_size) {\n\t\t/*\n\t\t * There may be extents that lie behind the file's size.\n\t\t * I at least had this in combination with snapshotting while\n\t\t * writing large files.\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tfi = btrfs_item_ptr(eb, path->slots[0],\n\t\t\tstruct btrfs_file_extent_item);\n\textent_type = btrfs_file_extent_type(eb, fi);\n\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tcompressed = btrfs_file_extent_compression(eb, fi);\n\n\tnum_bytes = btrfs_file_extent_num_bytes(eb, fi);\n\tdisk_byte = btrfs_file_extent_disk_bytenr(eb, fi);\n\tif (disk_byte == 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tlogical = disk_byte + btrfs_file_extent_offset(eb, fi);\n\n\tdown_read(&sctx->send_root->fs_info->commit_root_sem);\n\tret = extent_from_logical(sctx->send_root->fs_info, disk_byte, tmp_path,\n\t\t\t\t  &found_key, &flags);\n\tup_read(&sctx->send_root->fs_info->commit_root_sem);\n\tbtrfs_release_path(tmp_path);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Setup the clone roots.\n\t */\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++) {\n\t\tcur_clone_root = sctx->clone_roots + i;\n\t\tcur_clone_root->ino = (u64)-1;\n\t\tcur_clone_root->offset = 0;\n\t\tcur_clone_root->found_refs = 0;\n\t}\n\n\tbackref_ctx->sctx = sctx;\n\tbackref_ctx->found = 0;\n\tbackref_ctx->cur_objectid = ino;\n\tbackref_ctx->cur_offset = data_offset;\n\tbackref_ctx->found_itself = 0;\n\tbackref_ctx->extent_len = num_bytes;\n\n\t/*\n\t * The last extent of a file may be too large due to page alignment.\n\t * We need to adjust extent_len in this case so that the checks in\n\t * __iterate_backrefs work.\n\t */\n\tif (data_offset + num_bytes >= ino_size)\n\t\tbackref_ctx->extent_len = ino_size - data_offset;\n\n\t/*\n\t * Now collect all backrefs.\n\t */\n\tif (compressed == BTRFS_COMPRESS_NONE)\n\t\textent_item_pos = logical - found_key.objectid;\n\telse\n\t\textent_item_pos = 0;\n\tret = iterate_extent_inodes(sctx->send_root->fs_info,\n\t\t\t\t\tfound_key.objectid, extent_item_pos, 1,\n\t\t\t\t\t__iterate_backrefs, backref_ctx);\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!backref_ctx->found_itself) {\n\t\t/* found a bug in backref code? */\n\t\tret = -EIO;\n\t\tbtrfs_err(sctx->send_root->fs_info, \"did not find backref in \"\n\t\t\t\t\"send_root. inode=%llu, offset=%llu, \"\n\t\t\t\t\"disk_byte=%llu found extent=%llu\",\n\t\t\t\tino, data_offset, disk_byte, found_key.objectid);\n\t\tgoto out;\n\t}\n\nverbose_printk(KERN_DEBUG \"btrfs: find_extent_clone: data_offset=%llu, \"\n\t\t\"ino=%llu, \"\n\t\t\"num_bytes=%llu, logical=%llu\\n\",\n\t\tdata_offset, ino, num_bytes, logical);\n\n\tif (!backref_ctx->found)\n\t\tverbose_printk(\"btrfs:    no clones found\\n\");\n\n\tcur_clone_root = NULL;\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++) {\n\t\tif (sctx->clone_roots[i].found_refs) {\n\t\t\tif (!cur_clone_root)\n\t\t\t\tcur_clone_root = sctx->clone_roots + i;\n\t\t\telse if (sctx->clone_roots[i].root == sctx->send_root)\n\t\t\t\t/* prefer clones from send_root over others */\n\t\t\t\tcur_clone_root = sctx->clone_roots + i;\n\t\t}\n\n\t}\n\n\tif (cur_clone_root) {\n\t\tif (compressed != BTRFS_COMPRESS_NONE) {\n\t\t\t/*\n\t\t\t * Offsets given by iterate_extent_inodes() are relative\n\t\t\t * to the start of the extent, we need to add logical\n\t\t\t * offset from the file extent item.\n\t\t\t * (See why at backref.c:check_extent_in_eb())\n\t\t\t */\n\t\t\tcur_clone_root->offset += btrfs_file_extent_offset(eb,\n\t\t\t\t\t\t\t\t\t   fi);\n\t\t}\n\t\t*found = cur_clone_root;\n\t\tret = 0;\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tkfree(backref_ctx);\n\treturn ret;\n}"
  },
  {
    "function_name": "__iterate_backrefs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "1193-1262",
    "snippet": "static int __iterate_backrefs(u64 ino, u64 offset, u64 root, void *ctx_)\n{\n\tstruct backref_ctx *bctx = ctx_;\n\tstruct clone_root *found;\n\tint ret;\n\tu64 i_size;\n\n\t/* First check if the root is in the list of accepted clone sources */\n\tfound = bsearch((void *)(uintptr_t)root, bctx->sctx->clone_roots,\n\t\t\tbctx->sctx->clone_roots_cnt,\n\t\t\tsizeof(struct clone_root),\n\t\t\t__clone_root_cmp_bsearch);\n\tif (!found)\n\t\treturn 0;\n\n\tif (found->root == bctx->sctx->send_root &&\n\t    ino == bctx->cur_objectid &&\n\t    offset == bctx->cur_offset) {\n\t\tbctx->found_itself = 1;\n\t}\n\n\t/*\n\t * There are inodes that have extents that lie behind its i_size. Don't\n\t * accept clones from these extents.\n\t */\n\tret = __get_inode_info(found->root, bctx->path, ino, &i_size, NULL, NULL,\n\t\t\t       NULL, NULL, NULL);\n\tbtrfs_release_path(bctx->path);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (offset + bctx->extent_len > i_size)\n\t\treturn 0;\n\n\t/*\n\t * Make sure we don't consider clones from send_root that are\n\t * behind the current inode/offset.\n\t */\n\tif (found->root == bctx->sctx->send_root) {\n\t\t/*\n\t\t * TODO for the moment we don't accept clones from the inode\n\t\t * that is currently send. We may change this when\n\t\t * BTRFS_IOC_CLONE_RANGE supports cloning from and to the same\n\t\t * file.\n\t\t */\n\t\tif (ino >= bctx->cur_objectid)\n\t\t\treturn 0;\n#if 0\n\t\tif (ino > bctx->cur_objectid)\n\t\t\treturn 0;\n\t\tif (offset + bctx->extent_len > bctx->cur_offset)\n\t\t\treturn 0;\n#endif\n\t}\n\n\tbctx->found++;\n\tfound->found_refs++;\n\tif (ino < found->ino) {\n\t\tfound->ino = ino;\n\t\tfound->offset = offset;\n\t} else if (found->ino == ino) {\n\t\t/*\n\t\t * same extent found more then once in the same file.\n\t\t */\n\t\tif (found->offset > offset + bctx->extent_len)\n\t\t\tfound->offset = offset;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "bctx->path"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_inode_info",
          "args": [
            "found->root",
            "bctx->path",
            "ino",
            "&i_size",
            "NULL",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "__get_inode_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "785-819",
          "snippet": "static int __get_inode_info(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t  u64 ino, u64 *size, u64 *gen, u64 *mode, u64 *uid,\n\t\t\t  u64 *gid, u64 *rdev)\n{\n\tint ret;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_key key;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\treturn ret;\n\t}\n\n\tii = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\tstruct btrfs_inode_item);\n\tif (size)\n\t\t*size = btrfs_inode_size(path->nodes[0], ii);\n\tif (gen)\n\t\t*gen = btrfs_inode_generation(path->nodes[0], ii);\n\tif (mode)\n\t\t*mode = btrfs_inode_mode(path->nodes[0], ii);\n\tif (uid)\n\t\t*uid = btrfs_inode_uid(path->nodes[0], ii);\n\tif (gid)\n\t\t*gid = btrfs_inode_gid(path->nodes[0], ii);\n\tif (rdev)\n\t\t*rdev = btrfs_inode_rdev(path->nodes[0], ii);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int __get_inode_info(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t  u64 ino, u64 *size, u64 *gen, u64 *mode, u64 *uid,\n\t\t\t  u64 *gid, u64 *rdev)\n{\n\tint ret;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_key key;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\treturn ret;\n\t}\n\n\tii = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\tstruct btrfs_inode_item);\n\tif (size)\n\t\t*size = btrfs_inode_size(path->nodes[0], ii);\n\tif (gen)\n\t\t*gen = btrfs_inode_generation(path->nodes[0], ii);\n\tif (mode)\n\t\t*mode = btrfs_inode_mode(path->nodes[0], ii);\n\tif (uid)\n\t\t*uid = btrfs_inode_uid(path->nodes[0], ii);\n\tif (gid)\n\t\t*gid = btrfs_inode_gid(path->nodes[0], ii);\n\tif (rdev)\n\t\t*rdev = btrfs_inode_rdev(path->nodes[0], ii);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bsearch",
          "args": [
            "(void *)(uintptr_t)root",
            "bctx->sctx->clone_roots",
            "bctx->sctx->clone_roots_cnt",
            "sizeof(struct clone_root)",
            "__clone_root_cmp_bsearch"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int __iterate_backrefs(u64 ino, u64 offset, u64 root, void *ctx_)\n{\n\tstruct backref_ctx *bctx = ctx_;\n\tstruct clone_root *found;\n\tint ret;\n\tu64 i_size;\n\n\t/* First check if the root is in the list of accepted clone sources */\n\tfound = bsearch((void *)(uintptr_t)root, bctx->sctx->clone_roots,\n\t\t\tbctx->sctx->clone_roots_cnt,\n\t\t\tsizeof(struct clone_root),\n\t\t\t__clone_root_cmp_bsearch);\n\tif (!found)\n\t\treturn 0;\n\n\tif (found->root == bctx->sctx->send_root &&\n\t    ino == bctx->cur_objectid &&\n\t    offset == bctx->cur_offset) {\n\t\tbctx->found_itself = 1;\n\t}\n\n\t/*\n\t * There are inodes that have extents that lie behind its i_size. Don't\n\t * accept clones from these extents.\n\t */\n\tret = __get_inode_info(found->root, bctx->path, ino, &i_size, NULL, NULL,\n\t\t\t       NULL, NULL, NULL);\n\tbtrfs_release_path(bctx->path);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (offset + bctx->extent_len > i_size)\n\t\treturn 0;\n\n\t/*\n\t * Make sure we don't consider clones from send_root that are\n\t * behind the current inode/offset.\n\t */\n\tif (found->root == bctx->sctx->send_root) {\n\t\t/*\n\t\t * TODO for the moment we don't accept clones from the inode\n\t\t * that is currently send. We may change this when\n\t\t * BTRFS_IOC_CLONE_RANGE supports cloning from and to the same\n\t\t * file.\n\t\t */\n\t\tif (ino >= bctx->cur_objectid)\n\t\t\treturn 0;\n#if 0\n\t\tif (ino > bctx->cur_objectid)\n\t\t\treturn 0;\n\t\tif (offset + bctx->extent_len > bctx->cur_offset)\n\t\t\treturn 0;\n#endif\n\t}\n\n\tbctx->found++;\n\tfound->found_refs++;\n\tif (ino < found->ino) {\n\t\tfound->ino = ino;\n\t\tfound->offset = offset;\n\t} else if (found->ino == ino) {\n\t\t/*\n\t\t * same extent found more then once in the same file.\n\t\t */\n\t\tif (found->offset > offset + bctx->extent_len)\n\t\t\tfound->offset = offset;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__clone_root_cmp_sort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "1177-1187",
    "snippet": "static int __clone_root_cmp_sort(const void *e1, const void *e2)\n{\n\tstruct clone_root *cr1 = (struct clone_root *)e1;\n\tstruct clone_root *cr2 = (struct clone_root *)e2;\n\n\tif (cr1->root->objectid < cr2->root->objectid)\n\t\treturn -1;\n\tif (cr1->root->objectid > cr2->root->objectid)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int __clone_root_cmp_sort(const void *e1, const void *e2)\n{\n\tstruct clone_root *cr1 = (struct clone_root *)e1;\n\tstruct clone_root *cr2 = (struct clone_root *)e2;\n\n\tif (cr1->root->objectid < cr2->root->objectid)\n\t\treturn -1;\n\tif (cr1->root->objectid > cr2->root->objectid)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "__clone_root_cmp_bsearch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "1165-1175",
    "snippet": "static int __clone_root_cmp_bsearch(const void *key, const void *elt)\n{\n\tu64 root = (u64)(uintptr_t)key;\n\tstruct clone_root *cr = (struct clone_root *)elt;\n\n\tif (root < cr->root->objectid)\n\t\treturn -1;\n\tif (root > cr->root->objectid)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int __clone_root_cmp_bsearch(const void *key, const void *elt)\n{\n\tu64 root = (u64)(uintptr_t)key;\n\tstruct clone_root *cr = (struct clone_root *)elt;\n\n\tif (root < cr->root->objectid)\n\t\treturn -1;\n\tif (root > cr->root->objectid)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "get_inode_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "1101-1142",
    "snippet": "static int get_inode_path(struct btrfs_root *root,\n\t\t\t  u64 ino, struct fs_path *path)\n{\n\tint ret;\n\tstruct btrfs_key key, found_key;\n\tstruct btrfs_path *p;\n\n\tp = alloc_path_for_send();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tfs_path_reset(path);\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, p, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\tbtrfs_item_key_to_cpu(p->nodes[0], &found_key, p->slots[0]);\n\tif (found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = iterate_inode_ref(root, p, &found_key, 1,\n\t\t\t\t__copy_first_ref, path);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\tbtrfs_free_path(p);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "p"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_inode_ref",
          "args": [
            "root",
            "p",
            "&found_key",
            "1",
            "__copy_first_ref",
            "path"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_inode_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "850-956",
          "snippet": "static int iterate_inode_ref(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *found_key, int resolve,\n\t\t\t     iterate_inode_ref_t iterate, void *ctx)\n{\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct btrfs_item *item;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_inode_extref *extref;\n\tstruct btrfs_path *tmp_path;\n\tstruct fs_path *p;\n\tu32 cur = 0;\n\tu32 total;\n\tint slot = path->slots[0];\n\tu32 name_len;\n\tchar *start;\n\tint ret = 0;\n\tint num = 0;\n\tint index;\n\tu64 dir;\n\tunsigned long name_off;\n\tunsigned long elem_size;\n\tunsigned long ptr;\n\n\tp = fs_path_alloc_reversed();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path) {\n\t\tfs_path_free(p);\n\t\treturn -ENOMEM;\n\t}\n\n\n\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\tptr = (unsigned long)btrfs_item_ptr(eb, slot,\n\t\t\t\t\t\t    struct btrfs_inode_ref);\n\t\titem = btrfs_item_nr(slot);\n\t\ttotal = btrfs_item_size(eb, item);\n\t\telem_size = sizeof(*iref);\n\t} else {\n\t\tptr = btrfs_item_ptr_offset(eb, slot);\n\t\ttotal = btrfs_item_size_nr(eb, slot);\n\t\telem_size = sizeof(*extref);\n\t}\n\n\twhile (cur < total) {\n\t\tfs_path_reset(p);\n\n\t\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\t\tiref = (struct btrfs_inode_ref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\tname_off = (unsigned long)(iref + 1);\n\t\t\tindex = btrfs_inode_ref_index(eb, iref);\n\t\t\tdir = found_key->offset;\n\t\t} else {\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tname_off = (unsigned long)&extref->name;\n\t\t\tindex = btrfs_inode_extref_index(eb, extref);\n\t\t\tdir = btrfs_inode_extref_parent(eb, extref);\n\t\t}\n\n\t\tif (resolve) {\n\t\t\tstart = btrfs_ref_to_path(root, tmp_path, name_len,\n\t\t\t\t\t\t  name_off, eb, dir,\n\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\tif (IS_ERR(start)) {\n\t\t\t\tret = PTR_ERR(start);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (start < p->buf) {\n\t\t\t\t/* overflow , try again with larger buffer */\n\t\t\t\tret = fs_path_ensure_buf(p,\n\t\t\t\t\t\tp->buf_len + p->buf - start);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tstart = btrfs_ref_to_path(root, tmp_path,\n\t\t\t\t\t\t\t  name_len, name_off,\n\t\t\t\t\t\t\t  eb, dir,\n\t\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\t\tif (IS_ERR(start)) {\n\t\t\t\t\tret = PTR_ERR(start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tBUG_ON(start < p->buf);\n\t\t\t}\n\t\t\tp->start = start;\n\t\t} else {\n\t\t\tret = fs_path_add_from_extent_buffer(p, eb, name_off,\n\t\t\t\t\t\t\t     name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcur += elem_size + name_len;\n\t\tret = iterate(num, dir, index, p, ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnum++;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tfs_path_free(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int iterate_inode_ref(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *found_key, int resolve,\n\t\t\t     iterate_inode_ref_t iterate, void *ctx)\n{\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct btrfs_item *item;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_inode_extref *extref;\n\tstruct btrfs_path *tmp_path;\n\tstruct fs_path *p;\n\tu32 cur = 0;\n\tu32 total;\n\tint slot = path->slots[0];\n\tu32 name_len;\n\tchar *start;\n\tint ret = 0;\n\tint num = 0;\n\tint index;\n\tu64 dir;\n\tunsigned long name_off;\n\tunsigned long elem_size;\n\tunsigned long ptr;\n\n\tp = fs_path_alloc_reversed();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path) {\n\t\tfs_path_free(p);\n\t\treturn -ENOMEM;\n\t}\n\n\n\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\tptr = (unsigned long)btrfs_item_ptr(eb, slot,\n\t\t\t\t\t\t    struct btrfs_inode_ref);\n\t\titem = btrfs_item_nr(slot);\n\t\ttotal = btrfs_item_size(eb, item);\n\t\telem_size = sizeof(*iref);\n\t} else {\n\t\tptr = btrfs_item_ptr_offset(eb, slot);\n\t\ttotal = btrfs_item_size_nr(eb, slot);\n\t\telem_size = sizeof(*extref);\n\t}\n\n\twhile (cur < total) {\n\t\tfs_path_reset(p);\n\n\t\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\t\tiref = (struct btrfs_inode_ref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\tname_off = (unsigned long)(iref + 1);\n\t\t\tindex = btrfs_inode_ref_index(eb, iref);\n\t\t\tdir = found_key->offset;\n\t\t} else {\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tname_off = (unsigned long)&extref->name;\n\t\t\tindex = btrfs_inode_extref_index(eb, extref);\n\t\t\tdir = btrfs_inode_extref_parent(eb, extref);\n\t\t}\n\n\t\tif (resolve) {\n\t\t\tstart = btrfs_ref_to_path(root, tmp_path, name_len,\n\t\t\t\t\t\t  name_off, eb, dir,\n\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\tif (IS_ERR(start)) {\n\t\t\t\tret = PTR_ERR(start);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (start < p->buf) {\n\t\t\t\t/* overflow , try again with larger buffer */\n\t\t\t\tret = fs_path_ensure_buf(p,\n\t\t\t\t\t\tp->buf_len + p->buf - start);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tstart = btrfs_ref_to_path(root, tmp_path,\n\t\t\t\t\t\t\t  name_len, name_off,\n\t\t\t\t\t\t\t  eb, dir,\n\t\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\t\tif (IS_ERR(start)) {\n\t\t\t\t\tret = PTR_ERR(start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tBUG_ON(start < p->buf);\n\t\t\t}\n\t\t\tp->start = start;\n\t\t} else {\n\t\t\tret = fs_path_add_from_extent_buffer(p, eb, name_off,\n\t\t\t\t\t\t\t     name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcur += elem_size + name_len;\n\t\tret = iterate(num, dir, index, p, ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnum++;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tfs_path_free(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "p->nodes[0]",
            "&found_key",
            "p->slots[0]"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot_for_read",
          "args": [
            "root",
            "&key",
            "p",
            "1",
            "0"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot_for_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3057-3119",
          "snippet": "int btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_reset",
          "args": [
            "path"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "289-300",
          "snippet": "static void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_path_for_send",
          "args": [],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_path_for_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "496-507",
          "snippet": "static struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_inode_path(struct btrfs_root *root,\n\t\t\t  u64 ino, struct fs_path *path)\n{\n\tint ret;\n\tstruct btrfs_key key, found_key;\n\tstruct btrfs_path *p;\n\n\tp = alloc_path_for_send();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tfs_path_reset(path);\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, p, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\tbtrfs_item_key_to_cpu(p->nodes[0], &found_key, p->slots[0]);\n\tif (found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = iterate_inode_ref(root, p, &found_key, 1,\n\t\t\t\t__copy_first_ref, path);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\tbtrfs_free_path(p);\n\treturn ret;\n}"
  },
  {
    "function_name": "__copy_first_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "1083-1095",
    "snippet": "static int __copy_first_ref(int num, u64 dir, int index,\n\t\t\t    struct fs_path *p, void *ctx)\n{\n\tint ret;\n\tstruct fs_path *pt = ctx;\n\n\tret = fs_path_copy(pt, p);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* we want the first only */\n\treturn 1;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_copy",
          "args": [
            "pt",
            "p"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "467-477",
          "snippet": "static int fs_path_copy(struct fs_path *p, struct fs_path *from)\n{\n\tint ret;\n\n\tp->reversed = from->reversed;\n\tfs_path_reset(p);\n\n\tret = fs_path_add_path(p, from);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_copy(struct fs_path *p, struct fs_path *from)\n{\n\tint ret;\n\n\tp->reversed = from->reversed;\n\tfs_path_reset(p);\n\n\tret = fs_path_add_path(p, from);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int __copy_first_ref(int num, u64 dir, int index,\n\t\t\t    struct fs_path *p, void *ctx)\n{\n\tint ret;\n\tstruct fs_path *pt = ctx;\n\n\tret = fs_path_copy(pt, p);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* we want the first only */\n\treturn 1;\n}"
  },
  {
    "function_name": "iterate_dir_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "970-1081",
    "snippet": "static int iterate_dir_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *found_key,\n\t\t\t    iterate_dir_item_t iterate, void *ctx)\n{\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key di_key;\n\tchar *buf = NULL;\n\tint buf_len;\n\tu32 name_len;\n\tu32 data_len;\n\tu32 cur;\n\tu32 len;\n\tu32 total;\n\tint slot;\n\tint num;\n\tu8 type;\n\n\t/*\n\t * Start with a small buffer (1 page). If later we end up needing more\n\t * space, which can happen for xattrs on a fs with a leaf size greater\n\t * then the page size, attempt to increase the buffer. Typically xattr\n\t * values are small.\n\t */\n\tbuf_len = PATH_MAX;\n\tbuf = kmalloc(buf_len, GFP_NOFS);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem = btrfs_item_nr(slot);\n\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\tcur = 0;\n\tlen = 0;\n\ttotal = btrfs_item_size(eb, item);\n\n\tnum = 0;\n\twhile (cur < total) {\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tdata_len = btrfs_dir_data_len(eb, di);\n\t\ttype = btrfs_dir_type(eb, di);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (type == BTRFS_FT_XATTR) {\n\t\t\tif (name_len > XATTR_NAME_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (name_len + data_len > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Path too long\n\t\t\t */\n\t\t\tif (name_len + data_len > PATH_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (name_len + data_len > buf_len) {\n\t\t\tbuf_len = name_len + data_len;\n\t\t\tif (is_vmalloc_addr(buf)) {\n\t\t\t\tvfree(buf);\n\t\t\t\tbuf = NULL;\n\t\t\t} else {\n\t\t\t\tchar *tmp = krealloc(buf, buf_len,\n\t\t\t\t\t\t     GFP_NOFS | __GFP_NOWARN);\n\n\t\t\t\tif (!tmp)\n\t\t\t\t\tkfree(buf);\n\t\t\t\tbuf = tmp;\n\t\t\t}\n\t\t\tif (!buf) {\n\t\t\t\tbuf = vmalloc(buf_len);\n\t\t\t\tif (!buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tread_extent_buffer(eb, buf, (unsigned long)(di + 1),\n\t\t\t\tname_len + data_len);\n\n\t\tlen = sizeof(*di) + name_len + data_len;\n\t\tdi = (struct btrfs_dir_item *)((char *)di + len);\n\t\tcur += len;\n\n\t\tret = iterate(num, &di_key, buf, name_len, buf + name_len,\n\t\t\t\tdata_len, type, ctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum++;\n\t}\n\nout:\n\tkvfree(buf);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "buf"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate",
          "args": [
            "num",
            "&di_key",
            "buf",
            "name_len",
            "buf + name_len",
            "data_len",
            "type",
            "ctx"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "eb",
            "buf",
            "(unsigned long)(di + 1)",
            "name_len + data_len"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "buf_len"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krealloc",
          "args": [
            "buf",
            "buf_len",
            "GFP_NOFS | __GFP_NOWARN"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "buf"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "buf"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_MAX_XATTR_SIZE",
          "args": [
            "root"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dir_item_key_to_cpu",
          "args": [
            "eb",
            "di",
            "&di_key"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dir_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2763-2770",
          "snippet": "static inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_type",
          "args": [
            "eb",
            "di"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dir_data_len",
          "args": [
            "eb",
            "di"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dir_name_len",
          "args": [
            "eb",
            "di"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size",
          "args": [
            "eb",
            "item"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "slot",
            "structbtrfs_dir_item"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr",
          "args": [
            "slot"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2628-2631",
          "snippet": "static inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "buf_len",
            "GFP_NOFS"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int iterate_dir_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *found_key,\n\t\t\t    iterate_dir_item_t iterate, void *ctx)\n{\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key di_key;\n\tchar *buf = NULL;\n\tint buf_len;\n\tu32 name_len;\n\tu32 data_len;\n\tu32 cur;\n\tu32 len;\n\tu32 total;\n\tint slot;\n\tint num;\n\tu8 type;\n\n\t/*\n\t * Start with a small buffer (1 page). If later we end up needing more\n\t * space, which can happen for xattrs on a fs with a leaf size greater\n\t * then the page size, attempt to increase the buffer. Typically xattr\n\t * values are small.\n\t */\n\tbuf_len = PATH_MAX;\n\tbuf = kmalloc(buf_len, GFP_NOFS);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem = btrfs_item_nr(slot);\n\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\tcur = 0;\n\tlen = 0;\n\ttotal = btrfs_item_size(eb, item);\n\n\tnum = 0;\n\twhile (cur < total) {\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tdata_len = btrfs_dir_data_len(eb, di);\n\t\ttype = btrfs_dir_type(eb, di);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (type == BTRFS_FT_XATTR) {\n\t\t\tif (name_len > XATTR_NAME_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (name_len + data_len > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Path too long\n\t\t\t */\n\t\t\tif (name_len + data_len > PATH_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (name_len + data_len > buf_len) {\n\t\t\tbuf_len = name_len + data_len;\n\t\t\tif (is_vmalloc_addr(buf)) {\n\t\t\t\tvfree(buf);\n\t\t\t\tbuf = NULL;\n\t\t\t} else {\n\t\t\t\tchar *tmp = krealloc(buf, buf_len,\n\t\t\t\t\t\t     GFP_NOFS | __GFP_NOWARN);\n\n\t\t\t\tif (!tmp)\n\t\t\t\t\tkfree(buf);\n\t\t\t\tbuf = tmp;\n\t\t\t}\n\t\t\tif (!buf) {\n\t\t\t\tbuf = vmalloc(buf_len);\n\t\t\t\tif (!buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tread_extent_buffer(eb, buf, (unsigned long)(di + 1),\n\t\t\t\tname_len + data_len);\n\n\t\tlen = sizeof(*di) + name_len + data_len;\n\t\tdi = (struct btrfs_dir_item *)((char *)di + len);\n\t\tcur += len;\n\n\t\tret = iterate(num, &di_key, buf, name_len, buf + name_len,\n\t\t\t\tdata_len, type, ctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum++;\n\t}\n\nout:\n\tkvfree(buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "iterate_inode_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "850-956",
    "snippet": "static int iterate_inode_ref(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *found_key, int resolve,\n\t\t\t     iterate_inode_ref_t iterate, void *ctx)\n{\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct btrfs_item *item;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_inode_extref *extref;\n\tstruct btrfs_path *tmp_path;\n\tstruct fs_path *p;\n\tu32 cur = 0;\n\tu32 total;\n\tint slot = path->slots[0];\n\tu32 name_len;\n\tchar *start;\n\tint ret = 0;\n\tint num = 0;\n\tint index;\n\tu64 dir;\n\tunsigned long name_off;\n\tunsigned long elem_size;\n\tunsigned long ptr;\n\n\tp = fs_path_alloc_reversed();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path) {\n\t\tfs_path_free(p);\n\t\treturn -ENOMEM;\n\t}\n\n\n\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\tptr = (unsigned long)btrfs_item_ptr(eb, slot,\n\t\t\t\t\t\t    struct btrfs_inode_ref);\n\t\titem = btrfs_item_nr(slot);\n\t\ttotal = btrfs_item_size(eb, item);\n\t\telem_size = sizeof(*iref);\n\t} else {\n\t\tptr = btrfs_item_ptr_offset(eb, slot);\n\t\ttotal = btrfs_item_size_nr(eb, slot);\n\t\telem_size = sizeof(*extref);\n\t}\n\n\twhile (cur < total) {\n\t\tfs_path_reset(p);\n\n\t\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\t\tiref = (struct btrfs_inode_ref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\tname_off = (unsigned long)(iref + 1);\n\t\t\tindex = btrfs_inode_ref_index(eb, iref);\n\t\t\tdir = found_key->offset;\n\t\t} else {\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tname_off = (unsigned long)&extref->name;\n\t\t\tindex = btrfs_inode_extref_index(eb, extref);\n\t\t\tdir = btrfs_inode_extref_parent(eb, extref);\n\t\t}\n\n\t\tif (resolve) {\n\t\t\tstart = btrfs_ref_to_path(root, tmp_path, name_len,\n\t\t\t\t\t\t  name_off, eb, dir,\n\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\tif (IS_ERR(start)) {\n\t\t\t\tret = PTR_ERR(start);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (start < p->buf) {\n\t\t\t\t/* overflow , try again with larger buffer */\n\t\t\t\tret = fs_path_ensure_buf(p,\n\t\t\t\t\t\tp->buf_len + p->buf - start);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tstart = btrfs_ref_to_path(root, tmp_path,\n\t\t\t\t\t\t\t  name_len, name_off,\n\t\t\t\t\t\t\t  eb, dir,\n\t\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\t\tif (IS_ERR(start)) {\n\t\t\t\t\tret = PTR_ERR(start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tBUG_ON(start < p->buf);\n\t\t\t}\n\t\t\tp->start = start;\n\t\t} else {\n\t\t\tret = fs_path_add_from_extent_buffer(p, eb, name_off,\n\t\t\t\t\t\t\t     name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcur += elem_size + name_len;\n\t\tret = iterate(num, dir, index, p, ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnum++;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tfs_path_free(p);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_free",
          "args": [
            "p"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "328-335",
          "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "tmp_path"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate",
          "args": [
            "num",
            "dir",
            "index",
            "p",
            "ctx"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "970-1081",
          "snippet": "static int iterate_dir_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *found_key,\n\t\t\t    iterate_dir_item_t iterate, void *ctx)\n{\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key di_key;\n\tchar *buf = NULL;\n\tint buf_len;\n\tu32 name_len;\n\tu32 data_len;\n\tu32 cur;\n\tu32 len;\n\tu32 total;\n\tint slot;\n\tint num;\n\tu8 type;\n\n\t/*\n\t * Start with a small buffer (1 page). If later we end up needing more\n\t * space, which can happen for xattrs on a fs with a leaf size greater\n\t * then the page size, attempt to increase the buffer. Typically xattr\n\t * values are small.\n\t */\n\tbuf_len = PATH_MAX;\n\tbuf = kmalloc(buf_len, GFP_NOFS);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem = btrfs_item_nr(slot);\n\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\tcur = 0;\n\tlen = 0;\n\ttotal = btrfs_item_size(eb, item);\n\n\tnum = 0;\n\twhile (cur < total) {\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tdata_len = btrfs_dir_data_len(eb, di);\n\t\ttype = btrfs_dir_type(eb, di);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (type == BTRFS_FT_XATTR) {\n\t\t\tif (name_len > XATTR_NAME_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (name_len + data_len > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Path too long\n\t\t\t */\n\t\t\tif (name_len + data_len > PATH_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (name_len + data_len > buf_len) {\n\t\t\tbuf_len = name_len + data_len;\n\t\t\tif (is_vmalloc_addr(buf)) {\n\t\t\t\tvfree(buf);\n\t\t\t\tbuf = NULL;\n\t\t\t} else {\n\t\t\t\tchar *tmp = krealloc(buf, buf_len,\n\t\t\t\t\t\t     GFP_NOFS | __GFP_NOWARN);\n\n\t\t\t\tif (!tmp)\n\t\t\t\t\tkfree(buf);\n\t\t\t\tbuf = tmp;\n\t\t\t}\n\t\t\tif (!buf) {\n\t\t\t\tbuf = vmalloc(buf_len);\n\t\t\t\tif (!buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tread_extent_buffer(eb, buf, (unsigned long)(di + 1),\n\t\t\t\tname_len + data_len);\n\n\t\tlen = sizeof(*di) + name_len + data_len;\n\t\tdi = (struct btrfs_dir_item *)((char *)di + len);\n\t\tcur += len;\n\n\t\tret = iterate(num, &di_key, buf, name_len, buf + name_len,\n\t\t\t\tdata_len, type, ctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum++;\n\t}\n\nout:\n\tkvfree(buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int iterate_dir_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *found_key,\n\t\t\t    iterate_dir_item_t iterate, void *ctx)\n{\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key di_key;\n\tchar *buf = NULL;\n\tint buf_len;\n\tu32 name_len;\n\tu32 data_len;\n\tu32 cur;\n\tu32 len;\n\tu32 total;\n\tint slot;\n\tint num;\n\tu8 type;\n\n\t/*\n\t * Start with a small buffer (1 page). If later we end up needing more\n\t * space, which can happen for xattrs on a fs with a leaf size greater\n\t * then the page size, attempt to increase the buffer. Typically xattr\n\t * values are small.\n\t */\n\tbuf_len = PATH_MAX;\n\tbuf = kmalloc(buf_len, GFP_NOFS);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem = btrfs_item_nr(slot);\n\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\tcur = 0;\n\tlen = 0;\n\ttotal = btrfs_item_size(eb, item);\n\n\tnum = 0;\n\twhile (cur < total) {\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tdata_len = btrfs_dir_data_len(eb, di);\n\t\ttype = btrfs_dir_type(eb, di);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (type == BTRFS_FT_XATTR) {\n\t\t\tif (name_len > XATTR_NAME_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (name_len + data_len > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Path too long\n\t\t\t */\n\t\t\tif (name_len + data_len > PATH_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (name_len + data_len > buf_len) {\n\t\t\tbuf_len = name_len + data_len;\n\t\t\tif (is_vmalloc_addr(buf)) {\n\t\t\t\tvfree(buf);\n\t\t\t\tbuf = NULL;\n\t\t\t} else {\n\t\t\t\tchar *tmp = krealloc(buf, buf_len,\n\t\t\t\t\t\t     GFP_NOFS | __GFP_NOWARN);\n\n\t\t\t\tif (!tmp)\n\t\t\t\t\tkfree(buf);\n\t\t\t\tbuf = tmp;\n\t\t\t}\n\t\t\tif (!buf) {\n\t\t\t\tbuf = vmalloc(buf_len);\n\t\t\t\tif (!buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tread_extent_buffer(eb, buf, (unsigned long)(di + 1),\n\t\t\t\tname_len + data_len);\n\n\t\tlen = sizeof(*di) + name_len + data_len;\n\t\tdi = (struct btrfs_dir_item *)((char *)di + len);\n\t\tcur += len;\n\n\t\tret = iterate(num, &di_key, buf, name_len, buf + name_len,\n\t\t\t\tdata_len, type, ctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum++;\n\t}\n\nout:\n\tkvfree(buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_add_from_extent_buffer",
          "args": [
            "p",
            "eb",
            "name_off",
            "name_len"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_add_from_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "450-465",
          "snippet": "static int fs_path_add_from_extent_buffer(struct fs_path *p,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  unsigned long off, int len)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, len, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tread_extent_buffer(eb, prepared, off, len);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_add_from_extent_buffer(struct fs_path *p,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  unsigned long off, int len)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, len, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tread_extent_buffer(eb, prepared, off, len);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start < p->buf"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "start"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "start"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ref_to_path",
          "args": [
            "root",
            "tmp_path",
            "name_len",
            "name_off",
            "eb",
            "dir",
            "p->buf",
            "p->buf_len"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ref_to_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1331-1398",
          "snippet": "char *btrfs_ref_to_path(struct btrfs_root *fs_root, struct btrfs_path *path,\n\t\t\tu32 name_len, unsigned long name_off,\n\t\t\tstruct extent_buffer *eb_in, u64 parent,\n\t\t\tchar *dest, u32 size)\n{\n\tint slot;\n\tu64 next_inum;\n\tint ret;\n\ts64 bytes_left = ((s64)size) - 1;\n\tstruct extent_buffer *eb = eb_in;\n\tstruct btrfs_key found_key;\n\tint leave_spinning = path->leave_spinning;\n\tstruct btrfs_inode_ref *iref;\n\n\tif (bytes_left >= 0)\n\t\tdest[bytes_left] = '\\0';\n\n\tpath->leave_spinning = 1;\n\twhile (1) {\n\t\tbytes_left -= name_len;\n\t\tif (bytes_left >= 0)\n\t\t\tread_extent_buffer(eb, dest + bytes_left,\n\t\t\t\t\t   name_off, name_len);\n\t\tif (eb != eb_in) {\n\t\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t}\n\t\tret = btrfs_find_item(fs_root, path, parent, 0,\n\t\t\t\tBTRFS_INODE_REF_KEY, &found_key);\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tnext_inum = found_key.offset;\n\n\t\t/* regular exit ahead */\n\t\tif (parent == next_inum)\n\t\t\tbreak;\n\n\t\tslot = path->slots[0];\n\t\teb = path->nodes[0];\n\t\t/* make sure we can use eb after releasing the path */\n\t\tif (eb != eb_in) {\n\t\t\tatomic_inc(&eb->refs);\n\t\t\tbtrfs_tree_read_lock(eb);\n\t\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tiref = btrfs_item_ptr(eb, slot, struct btrfs_inode_ref);\n\n\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\tname_off = (unsigned long)(iref + 1);\n\n\t\tparent = next_inum;\n\t\t--bytes_left;\n\t\tif (bytes_left >= 0)\n\t\t\tdest[bytes_left] = '/';\n\t}\n\n\tbtrfs_release_path(path);\n\tpath->leave_spinning = leave_spinning;\n\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn dest + bytes_left;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nchar *btrfs_ref_to_path(struct btrfs_root *fs_root, struct btrfs_path *path,\n\t\t\tu32 name_len, unsigned long name_off,\n\t\t\tstruct extent_buffer *eb_in, u64 parent,\n\t\t\tchar *dest, u32 size)\n{\n\tint slot;\n\tu64 next_inum;\n\tint ret;\n\ts64 bytes_left = ((s64)size) - 1;\n\tstruct extent_buffer *eb = eb_in;\n\tstruct btrfs_key found_key;\n\tint leave_spinning = path->leave_spinning;\n\tstruct btrfs_inode_ref *iref;\n\n\tif (bytes_left >= 0)\n\t\tdest[bytes_left] = '\\0';\n\n\tpath->leave_spinning = 1;\n\twhile (1) {\n\t\tbytes_left -= name_len;\n\t\tif (bytes_left >= 0)\n\t\t\tread_extent_buffer(eb, dest + bytes_left,\n\t\t\t\t\t   name_off, name_len);\n\t\tif (eb != eb_in) {\n\t\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t}\n\t\tret = btrfs_find_item(fs_root, path, parent, 0,\n\t\t\t\tBTRFS_INODE_REF_KEY, &found_key);\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tnext_inum = found_key.offset;\n\n\t\t/* regular exit ahead */\n\t\tif (parent == next_inum)\n\t\t\tbreak;\n\n\t\tslot = path->slots[0];\n\t\teb = path->nodes[0];\n\t\t/* make sure we can use eb after releasing the path */\n\t\tif (eb != eb_in) {\n\t\t\tatomic_inc(&eb->refs);\n\t\t\tbtrfs_tree_read_lock(eb);\n\t\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tiref = btrfs_item_ptr(eb, slot, struct btrfs_inode_ref);\n\n\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\tname_off = (unsigned long)(iref + 1);\n\n\t\tparent = next_inum;\n\t\t--bytes_left;\n\t\tif (bytes_left >= 0)\n\t\t\tdest[bytes_left] = '/';\n\t}\n\n\tbtrfs_release_path(path);\n\tpath->leave_spinning = leave_spinning;\n\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn dest + bytes_left;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_ensure_buf",
          "args": [
            "p",
            "p->buf_len + p->buf - start"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_ensure_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "342-390",
          "snippet": "static int fs_path_ensure_buf(struct fs_path *p, int len)\n{\n\tchar *tmp_buf;\n\tint path_len;\n\tint old_buf_len;\n\n\tlen++;\n\n\tif (p->buf_len >= len)\n\t\treturn 0;\n\n\tif (len > PATH_MAX) {\n\t\tWARN_ON(1);\n\t\treturn -ENOMEM;\n\t}\n\n\tpath_len = p->end - p->start;\n\told_buf_len = p->buf_len;\n\n\t/*\n\t * First time the inline_buf does not suffice\n\t */\n\tif (p->buf == p->inline_buf) {\n\t\ttmp_buf = kmalloc(len, GFP_NOFS);\n\t\tif (tmp_buf)\n\t\t\tmemcpy(tmp_buf, p->buf, old_buf_len);\n\t} else {\n\t\ttmp_buf = krealloc(p->buf, len, GFP_NOFS);\n\t}\n\tif (!tmp_buf)\n\t\treturn -ENOMEM;\n\tp->buf = tmp_buf;\n\t/*\n\t * The real size of the buffer is bigger, this will let the fast path\n\t * happen most of the time\n\t */\n\tp->buf_len = ksize(p->buf);\n\n\tif (p->reversed) {\n\t\ttmp_buf = p->buf + old_buf_len - path_len - 1;\n\t\tp->end = p->buf + p->buf_len - 1;\n\t\tp->start = p->end - path_len;\n\t\tmemmove(p->start, tmp_buf, path_len + 1);\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start + path_len;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_ensure_buf(struct fs_path *p, int len)\n{\n\tchar *tmp_buf;\n\tint path_len;\n\tint old_buf_len;\n\n\tlen++;\n\n\tif (p->buf_len >= len)\n\t\treturn 0;\n\n\tif (len > PATH_MAX) {\n\t\tWARN_ON(1);\n\t\treturn -ENOMEM;\n\t}\n\n\tpath_len = p->end - p->start;\n\told_buf_len = p->buf_len;\n\n\t/*\n\t * First time the inline_buf does not suffice\n\t */\n\tif (p->buf == p->inline_buf) {\n\t\ttmp_buf = kmalloc(len, GFP_NOFS);\n\t\tif (tmp_buf)\n\t\t\tmemcpy(tmp_buf, p->buf, old_buf_len);\n\t} else {\n\t\ttmp_buf = krealloc(p->buf, len, GFP_NOFS);\n\t}\n\tif (!tmp_buf)\n\t\treturn -ENOMEM;\n\tp->buf = tmp_buf;\n\t/*\n\t * The real size of the buffer is bigger, this will let the fast path\n\t * happen most of the time\n\t */\n\tp->buf_len = ksize(p->buf);\n\n\tif (p->reversed) {\n\t\ttmp_buf = p->buf + old_buf_len - path_len - 1;\n\t\tp->end = p->buf + p->buf_len - 1;\n\t\tp->start = p->end - path_len;\n\t\tmemmove(p->start, tmp_buf, path_len + 1);\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start + path_len;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "start"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "start"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_extref_parent",
          "args": [
            "eb",
            "extref"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_extref_index",
          "args": [
            "eb",
            "extref"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_extref_name_len",
          "args": [
            "eb",
            "extref"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_ref_index",
          "args": [
            "eb",
            "iref"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_ref_name_len",
          "args": [
            "eb",
            "iref"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_path_reset",
          "args": [
            "p"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "289-300",
          "snippet": "static void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "eb",
            "slot"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "eb",
            "slot"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr",
          "args": [
            "slot"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2628-2631",
          "snippet": "static inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "slot",
            "structbtrfs_inode_ref"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_path_for_send",
          "args": [],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_path_for_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "496-507",
          "snippet": "static struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_alloc_reversed",
          "args": [],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int iterate_inode_ref(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *found_key, int resolve,\n\t\t\t     iterate_inode_ref_t iterate, void *ctx)\n{\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct btrfs_item *item;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_inode_extref *extref;\n\tstruct btrfs_path *tmp_path;\n\tstruct fs_path *p;\n\tu32 cur = 0;\n\tu32 total;\n\tint slot = path->slots[0];\n\tu32 name_len;\n\tchar *start;\n\tint ret = 0;\n\tint num = 0;\n\tint index;\n\tu64 dir;\n\tunsigned long name_off;\n\tunsigned long elem_size;\n\tunsigned long ptr;\n\n\tp = fs_path_alloc_reversed();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path) {\n\t\tfs_path_free(p);\n\t\treturn -ENOMEM;\n\t}\n\n\n\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\tptr = (unsigned long)btrfs_item_ptr(eb, slot,\n\t\t\t\t\t\t    struct btrfs_inode_ref);\n\t\titem = btrfs_item_nr(slot);\n\t\ttotal = btrfs_item_size(eb, item);\n\t\telem_size = sizeof(*iref);\n\t} else {\n\t\tptr = btrfs_item_ptr_offset(eb, slot);\n\t\ttotal = btrfs_item_size_nr(eb, slot);\n\t\telem_size = sizeof(*extref);\n\t}\n\n\twhile (cur < total) {\n\t\tfs_path_reset(p);\n\n\t\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\t\tiref = (struct btrfs_inode_ref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\tname_off = (unsigned long)(iref + 1);\n\t\t\tindex = btrfs_inode_ref_index(eb, iref);\n\t\t\tdir = found_key->offset;\n\t\t} else {\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tname_off = (unsigned long)&extref->name;\n\t\t\tindex = btrfs_inode_extref_index(eb, extref);\n\t\t\tdir = btrfs_inode_extref_parent(eb, extref);\n\t\t}\n\n\t\tif (resolve) {\n\t\t\tstart = btrfs_ref_to_path(root, tmp_path, name_len,\n\t\t\t\t\t\t  name_off, eb, dir,\n\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\tif (IS_ERR(start)) {\n\t\t\t\tret = PTR_ERR(start);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (start < p->buf) {\n\t\t\t\t/* overflow , try again with larger buffer */\n\t\t\t\tret = fs_path_ensure_buf(p,\n\t\t\t\t\t\tp->buf_len + p->buf - start);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tstart = btrfs_ref_to_path(root, tmp_path,\n\t\t\t\t\t\t\t  name_len, name_off,\n\t\t\t\t\t\t\t  eb, dir,\n\t\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\t\tif (IS_ERR(start)) {\n\t\t\t\t\tret = PTR_ERR(start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tBUG_ON(start < p->buf);\n\t\t\t}\n\t\t\tp->start = start;\n\t\t} else {\n\t\t\tret = fs_path_add_from_extent_buffer(p, eb, name_off,\n\t\t\t\t\t\t\t     name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcur += elem_size + name_len;\n\t\tret = iterate(num, dir, index, p, ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnum++;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tfs_path_free(p);\n\treturn ret;\n}"
  },
  {
    "function_name": "get_inode_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "821-836",
    "snippet": "static int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_inode_info",
          "args": [
            "root",
            "path",
            "ino",
            "size",
            "gen",
            "mode",
            "uid",
            "gid",
            "rdev"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "__get_inode_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "785-819",
          "snippet": "static int __get_inode_info(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t  u64 ino, u64 *size, u64 *gen, u64 *mode, u64 *uid,\n\t\t\t  u64 *gid, u64 *rdev)\n{\n\tint ret;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_key key;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\treturn ret;\n\t}\n\n\tii = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\tstruct btrfs_inode_item);\n\tif (size)\n\t\t*size = btrfs_inode_size(path->nodes[0], ii);\n\tif (gen)\n\t\t*gen = btrfs_inode_generation(path->nodes[0], ii);\n\tif (mode)\n\t\t*mode = btrfs_inode_mode(path->nodes[0], ii);\n\tif (uid)\n\t\t*uid = btrfs_inode_uid(path->nodes[0], ii);\n\tif (gid)\n\t\t*gid = btrfs_inode_gid(path->nodes[0], ii);\n\tif (rdev)\n\t\t*rdev = btrfs_inode_rdev(path->nodes[0], ii);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int __get_inode_info(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t  u64 ino, u64 *size, u64 *gen, u64 *mode, u64 *uid,\n\t\t\t  u64 *gid, u64 *rdev)\n{\n\tint ret;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_key key;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\treturn ret;\n\t}\n\n\tii = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\tstruct btrfs_inode_item);\n\tif (size)\n\t\t*size = btrfs_inode_size(path->nodes[0], ii);\n\tif (gen)\n\t\t*gen = btrfs_inode_generation(path->nodes[0], ii);\n\tif (mode)\n\t\t*mode = btrfs_inode_mode(path->nodes[0], ii);\n\tif (uid)\n\t\t*uid = btrfs_inode_uid(path->nodes[0], ii);\n\tif (gid)\n\t\t*gid = btrfs_inode_gid(path->nodes[0], ii);\n\tif (rdev)\n\t\t*rdev = btrfs_inode_rdev(path->nodes[0], ii);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_path_for_send",
          "args": [],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_path_for_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "496-507",
          "snippet": "static struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "__get_inode_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "785-819",
    "snippet": "static int __get_inode_info(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t  u64 ino, u64 *size, u64 *gen, u64 *mode, u64 *uid,\n\t\t\t  u64 *gid, u64 *rdev)\n{\n\tint ret;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_key key;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\treturn ret;\n\t}\n\n\tii = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\tstruct btrfs_inode_item);\n\tif (size)\n\t\t*size = btrfs_inode_size(path->nodes[0], ii);\n\tif (gen)\n\t\t*gen = btrfs_inode_generation(path->nodes[0], ii);\n\tif (mode)\n\t\t*mode = btrfs_inode_mode(path->nodes[0], ii);\n\tif (uid)\n\t\t*uid = btrfs_inode_uid(path->nodes[0], ii);\n\tif (gid)\n\t\t*gid = btrfs_inode_gid(path->nodes[0], ii);\n\tif (rdev)\n\t\t*rdev = btrfs_inode_rdev(path->nodes[0], ii);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
      "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_inode_rdev",
          "args": [
            "path->nodes[0]",
            "ii"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_gid",
          "args": [
            "path->nodes[0]",
            "ii"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_uid",
          "args": [
            "path->nodes[0]",
            "ii"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_mode",
          "args": [
            "path->nodes[0]",
            "ii"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_generation",
          "args": [
            "path->nodes[0]",
            "ii"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_size",
          "args": [
            "path->nodes[0]",
            "ii"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_inode_item"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int __get_inode_info(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t  u64 ino, u64 *size, u64 *gen, u64 *mode, u64 *uid,\n\t\t\t  u64 *gid, u64 *rdev)\n{\n\tint ret;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_key key;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\treturn ret;\n\t}\n\n\tii = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\tstruct btrfs_inode_item);\n\tif (size)\n\t\t*size = btrfs_inode_size(path->nodes[0], ii);\n\tif (gen)\n\t\t*gen = btrfs_inode_generation(path->nodes[0], ii);\n\tif (mode)\n\t\t*mode = btrfs_inode_mode(path->nodes[0], ii);\n\tif (uid)\n\t\t*uid = btrfs_inode_uid(path->nodes[0], ii);\n\tif (gid)\n\t\t*gid = btrfs_inode_gid(path->nodes[0], ii);\n\tif (rdev)\n\t\t*rdev = btrfs_inode_rdev(path->nodes[0], ii);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "send_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "763-780",
    "snippet": "static int send_rmdir(struct send_ctx *sctx, struct fs_path *path)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_rmdir %s\\n\", path->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_RMDIR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_cmd",
          "args": [
            "sctx"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "send_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "667-688",
          "snippet": "static int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TLV_PUT_PATH",
          "args": [
            "sctx",
            "BTRFS_SEND_A_PATH",
            "path"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_cmd",
          "args": [
            "sctx",
            "BTRFS_SEND_C_RMDIR"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "begin_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "651-665",
          "snippet": "static int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose_printk",
          "args": [
            "\"btrfs: send_rmdir %s\\n\"",
            "path->start"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_rmdir(struct send_ctx *sctx, struct fs_path *path)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_rmdir %s\\n\", path->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_RMDIR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "send_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "741-758",
    "snippet": "static int send_unlink(struct send_ctx *sctx, struct fs_path *path)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_unlink %s\\n\", path->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UNLINK);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_cmd",
          "args": [
            "sctx"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "send_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "667-688",
          "snippet": "static int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TLV_PUT_PATH",
          "args": [
            "sctx",
            "BTRFS_SEND_A_PATH",
            "path"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_cmd",
          "args": [
            "sctx",
            "BTRFS_SEND_C_UNLINK"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "begin_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "651-665",
          "snippet": "static int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose_printk",
          "args": [
            "\"btrfs: send_unlink %s\\n\"",
            "path->start"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_unlink(struct send_ctx *sctx, struct fs_path *path)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_unlink %s\\n\", path->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UNLINK);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "send_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "717-736",
    "snippet": "static int send_link(struct send_ctx *sctx,\n\t\t     struct fs_path *path, struct fs_path *lnk)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_link %s -> %s\\n\", path->start, lnk->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_LINK);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_LINK, lnk);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_cmd",
          "args": [
            "sctx"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "send_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "667-688",
          "snippet": "static int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TLV_PUT_PATH",
          "args": [
            "sctx",
            "BTRFS_SEND_A_PATH_LINK",
            "lnk"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_PATH",
          "args": [
            "sctx",
            "BTRFS_SEND_A_PATH",
            "path"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_cmd",
          "args": [
            "sctx",
            "BTRFS_SEND_C_LINK"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "begin_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "651-665",
          "snippet": "static int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose_printk",
          "args": [
            "\"btrfs: send_link %s -> %s\\n\"",
            "path->start",
            "lnk->start"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_link(struct send_ctx *sctx,\n\t\t     struct fs_path *path, struct fs_path *lnk)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_link %s -> %s\\n\", path->start, lnk->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_LINK);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_LINK, lnk);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "send_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "693-712",
    "snippet": "static int send_rename(struct send_ctx *sctx,\n\t\t     struct fs_path *from, struct fs_path *to)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_rename %s -> %s\\n\", from->start, to->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_RENAME);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, from);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_TO, to);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_cmd",
          "args": [
            "sctx"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "send_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "667-688",
          "snippet": "static int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TLV_PUT_PATH",
          "args": [
            "sctx",
            "BTRFS_SEND_A_PATH_TO",
            "to"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLV_PUT_PATH",
          "args": [
            "sctx",
            "BTRFS_SEND_A_PATH",
            "from"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_cmd",
          "args": [
            "sctx",
            "BTRFS_SEND_C_RENAME"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "begin_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "651-665",
          "snippet": "static int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose_printk",
          "args": [
            "\"btrfs: send_rename %s -> %s\\n\"",
            "from->start",
            "to->start"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_rename(struct send_ctx *sctx,\n\t\t     struct fs_path *from, struct fs_path *to)\n{\n\tint ret;\n\nverbose_printk(\"btrfs: send_rename %s -> %s\\n\", from->start, to->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_RENAME);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, from);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_TO, to);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "send_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "667-688",
    "snippet": "static int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "hdr->cmd"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_buf",
          "args": [
            "sctx->send_filp",
            "sctx->send_buf",
            "sctx->send_size",
            "&sctx->send_off"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "write_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "509-539",
          "snippet": "static int write_buf(struct file *filp, const void *buf, u32 len, loff_t *off)\n{\n\tint ret;\n\tmm_segment_t old_fs;\n\tu32 pos = 0;\n\n\told_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\twhile (pos < len) {\n\t\tret = vfs_write(filp, (__force const char __user *)buf + pos,\n\t\t\t\tlen - pos, off);\n\t\t/* TODO handle that correctly */\n\t\t/*if (ret == -ERESTARTSYS) {\n\t\t\tcontinue;\n\t\t}*/\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret == 0) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpos += ret;\n\t}\n\n\tret = 0;\n\nout:\n\tset_fs(old_fs);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int write_buf(struct file *filp, const void *buf, u32 len, loff_t *off)\n{\n\tint ret;\n\tmm_segment_t old_fs;\n\tu32 pos = 0;\n\n\told_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\twhile (pos < len) {\n\t\tret = vfs_write(filp, (__force const char __user *)buf + pos,\n\t\t\t\tlen - pos, off);\n\t\t/* TODO handle that correctly */\n\t\t/*if (ret == -ERESTARTSYS) {\n\t\t\tcontinue;\n\t\t}*/\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret == 0) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpos += ret;\n\t}\n\n\tret = 0;\n\nout:\n\tset_fs(old_fs);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "crc"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_crc32c",
          "args": [
            "0",
            "(unsigned char *)sctx->send_buf",
            "sctx->send_size"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_crc32c",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/hash.c",
          "lines": "32-46",
          "snippet": "u32 btrfs_crc32c(u32 crc, const void *address, unsigned int length)\n{\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\tu32 *ctx = (u32 *)shash_desc_ctx(shash);\n\tint err;\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\t*ctx = crc;\n\n\terr = crypto_shash_update(shash, address, length);\n\tBUG_ON(err);\n\n\treturn *ctx;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include <linux/err.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_shash *tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include <linux/err.h>\n#include <crypto/hash.h>\n\nstatic struct crypto_shash *tfm;\n\nu32 btrfs_crc32c(u32 crc, const void *address, unsigned int length)\n{\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\tu32 *ctx = (u32 *)shash_desc_ctx(shash);\n\tint err;\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\t*ctx = crc;\n\n\terr = crypto_shash_update(shash, address, length);\n\tBUG_ON(err);\n\n\treturn *ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sctx->send_size - sizeof(*hdr)"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->len = cpu_to_le32(sctx->send_size - sizeof(*hdr));\n\thdr->crc = 0;\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\thdr->crc = cpu_to_le32(crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[le16_to_cpu(hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "begin_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "651-665",
    "snippet": "static int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "cmd"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sctx->send_size"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!sctx->send_buf"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\thdr->cmd = cpu_to_le16(cmd);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "send_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "637-646",
    "snippet": "static int send_header(struct send_ctx *sctx)\n{\n\tstruct btrfs_stream_header hdr;\n\n\tstrcpy(hdr.magic, BTRFS_SEND_STREAM_MAGIC);\n\thdr.version = cpu_to_le32(BTRFS_SEND_STREAM_VERSION);\n\n\treturn write_buf(sctx->send_filp, &hdr, sizeof(hdr),\n\t\t\t\t\t&sctx->send_off);\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_buf",
          "args": [
            "sctx->send_filp",
            "&hdr",
            "sizeof(hdr)",
            "&sctx->send_off"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "write_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "509-539",
          "snippet": "static int write_buf(struct file *filp, const void *buf, u32 len, loff_t *off)\n{\n\tint ret;\n\tmm_segment_t old_fs;\n\tu32 pos = 0;\n\n\told_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\twhile (pos < len) {\n\t\tret = vfs_write(filp, (__force const char __user *)buf + pos,\n\t\t\t\tlen - pos, off);\n\t\t/* TODO handle that correctly */\n\t\t/*if (ret == -ERESTARTSYS) {\n\t\t\tcontinue;\n\t\t}*/\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret == 0) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpos += ret;\n\t}\n\n\tret = 0;\n\nout:\n\tset_fs(old_fs);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int write_buf(struct file *filp, const void *buf, u32 len, loff_t *off)\n{\n\tint ret;\n\tmm_segment_t old_fs;\n\tu32 pos = 0;\n\n\told_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\twhile (pos < len) {\n\t\tret = vfs_write(filp, (__force const char __user *)buf + pos,\n\t\t\t\tlen - pos, off);\n\t\t/* TODO handle that correctly */\n\t\t/*if (ret == -ERESTARTSYS) {\n\t\t\tcontinue;\n\t\t}*/\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret == 0) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpos += ret;\n\t}\n\n\tret = 0;\n\nout:\n\tset_fs(old_fs);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "BTRFS_SEND_STREAM_VERSION"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "hdr.magic",
            "BTRFS_SEND_STREAM_MAGIC"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int send_header(struct send_ctx *sctx)\n{\n\tstruct btrfs_stream_header hdr;\n\n\tstrcpy(hdr.magic, BTRFS_SEND_STREAM_MAGIC);\n\thdr.version = cpu_to_le32(BTRFS_SEND_STREAM_VERSION);\n\n\treturn write_buf(sctx->send_filp, &hdr, sizeof(hdr),\n\t\t\t\t\t&sctx->send_off);\n}"
  },
  {
    "function_name": "tlv_put_btrfs_timespec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "583-590",
    "snippet": "static int tlv_put_btrfs_timespec(struct send_ctx *sctx, u16 attr,\n\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_timespec *ts)\n{\n\tstruct btrfs_timespec bts;\n\tread_extent_buffer(eb, &bts, (unsigned long)ts, sizeof(bts));\n\treturn tlv_put(sctx, attr, &bts, sizeof(bts));\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlv_put",
          "args": [
            "sctx",
            "attr",
            "&bts",
            "sizeof(bts)"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "tlv_put_btrfs_timespec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "583-590",
          "snippet": "static int tlv_put_btrfs_timespec(struct send_ctx *sctx, u16 attr,\n\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_timespec *ts)\n{\n\tstruct btrfs_timespec bts;\n\tread_extent_buffer(eb, &bts, (unsigned long)ts, sizeof(bts));\n\treturn tlv_put(sctx, attr, &bts, sizeof(bts));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "eb",
            "&bts",
            "(unsigned long)ts",
            "sizeof(bts)"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int tlv_put_btrfs_timespec(struct send_ctx *sctx, u16 attr,\n\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_timespec *ts)\n{\n\tstruct btrfs_timespec bts;\n\tread_extent_buffer(eb, &bts, (unsigned long)ts, sizeof(bts));\n\treturn tlv_put(sctx, attr, &bts, sizeof(bts));\n}"
  },
  {
    "function_name": "tlv_put_uuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "577-581",
    "snippet": "static int tlv_put_uuid(struct send_ctx *sctx, u16 attr,\n\t\t\tconst u8 *uuid)\n{\n\treturn tlv_put(sctx, attr, uuid, BTRFS_UUID_SIZE);\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlv_put",
          "args": [
            "sctx",
            "attr",
            "uuid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "tlv_put_btrfs_timespec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "583-590",
          "snippet": "static int tlv_put_btrfs_timespec(struct send_ctx *sctx, u16 attr,\n\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_timespec *ts)\n{\n\tstruct btrfs_timespec bts;\n\tread_extent_buffer(eb, &bts, (unsigned long)ts, sizeof(bts));\n\treturn tlv_put(sctx, attr, &bts, sizeof(bts));\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int tlv_put_btrfs_timespec(struct send_ctx *sctx, u16 attr,\n\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_timespec *ts)\n{\n\tstruct btrfs_timespec bts;\n\tread_extent_buffer(eb, &bts, (unsigned long)ts, sizeof(bts));\n\treturn tlv_put(sctx, attr, &bts, sizeof(bts));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int tlv_put_uuid(struct send_ctx *sctx, u16 attr,\n\t\t\tconst u8 *uuid)\n{\n\treturn tlv_put(sctx, attr, uuid, BTRFS_UUID_SIZE);\n}"
  },
  {
    "function_name": "tlv_put_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "569-575",
    "snippet": "static int tlv_put_string(struct send_ctx *sctx, u16 attr,\n\t\t\t  const char *str, int len)\n{\n\tif (len == -1)\n\t\tlen = strlen(str);\n\treturn tlv_put(sctx, attr, str, len);\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlv_put",
          "args": [
            "sctx",
            "attr",
            "str",
            "len"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "tlv_put_btrfs_timespec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "583-590",
          "snippet": "static int tlv_put_btrfs_timespec(struct send_ctx *sctx, u16 attr,\n\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_timespec *ts)\n{\n\tstruct btrfs_timespec bts;\n\tread_extent_buffer(eb, &bts, (unsigned long)ts, sizeof(bts));\n\treturn tlv_put(sctx, attr, &bts, sizeof(bts));\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int tlv_put_btrfs_timespec(struct send_ctx *sctx, u16 attr,\n\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_timespec *ts)\n{\n\tstruct btrfs_timespec bts;\n\tread_extent_buffer(eb, &bts, (unsigned long)ts, sizeof(bts));\n\treturn tlv_put(sctx, attr, &bts, sizeof(bts));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int tlv_put_string(struct send_ctx *sctx, u16 attr,\n\t\t\t  const char *str, int len)\n{\n\tif (len == -1)\n\t\tlen = strlen(str);\n\treturn tlv_put(sctx, attr, str, len);\n}"
  },
  {
    "function_name": "tlv_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "541-557",
    "snippet": "static int tlv_put(struct send_ctx *sctx, u16 attr, const void *data, int len)\n{\n\tstruct btrfs_tlv_header *hdr;\n\tint total_len = sizeof(*hdr) + len;\n\tint left = sctx->send_max_size - sctx->send_size;\n\n\tif (unlikely(left < total_len))\n\t\treturn -EOVERFLOW;\n\n\thdr = (struct btrfs_tlv_header *) (sctx->send_buf + sctx->send_size);\n\thdr->tlv_type = cpu_to_le16(attr);\n\thdr->tlv_len = cpu_to_le16(len);\n\tmemcpy(hdr + 1, data, len);\n\tsctx->send_size += total_len;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hdr + 1",
            "data",
            "len"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "len"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "attr"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "left < total_len"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int tlv_put(struct send_ctx *sctx, u16 attr, const void *data, int len)\n{\n\tstruct btrfs_tlv_header *hdr;\n\tint total_len = sizeof(*hdr) + len;\n\tint left = sctx->send_max_size - sctx->send_size;\n\n\tif (unlikely(left < total_len))\n\t\treturn -EOVERFLOW;\n\n\thdr = (struct btrfs_tlv_header *) (sctx->send_buf + sctx->send_size);\n\thdr->tlv_type = cpu_to_le16(attr);\n\thdr->tlv_len = cpu_to_le16(len);\n\tmemcpy(hdr + 1, data, len);\n\tsctx->send_size += total_len;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "write_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "509-539",
    "snippet": "static int write_buf(struct file *filp, const void *buf, u32 len, loff_t *off)\n{\n\tint ret;\n\tmm_segment_t old_fs;\n\tu32 pos = 0;\n\n\told_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\twhile (pos < len) {\n\t\tret = vfs_write(filp, (__force const char __user *)buf + pos,\n\t\t\t\tlen - pos, off);\n\t\t/* TODO handle that correctly */\n\t\t/*if (ret == -ERESTARTSYS) {\n\t\t\tcontinue;\n\t\t}*/\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret == 0) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpos += ret;\n\t}\n\n\tret = 0;\n\nout:\n\tset_fs(old_fs);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_write",
          "args": [
            "filp",
            "(__force const char __user *)buf + pos",
            "len - pos",
            "off"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "930-939",
          "snippet": "ssize_t vfs_writev(struct file *file, const struct iovec __user *vec,\n\t\t   unsigned long vlen, loff_t *pos)\n{\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\treturn do_readv_writev(WRITE, file, vec, vlen, pos);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_writev(struct file *file, const struct iovec __user *vec,\n\t\t   unsigned long vlen, loff_t *pos)\n{\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\treturn do_readv_writev(WRITE, file, vec, vlen, pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "KERNEL_DS"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int write_buf(struct file *filp, const void *buf, u32 len, loff_t *off)\n{\n\tint ret;\n\tmm_segment_t old_fs;\n\tu32 pos = 0;\n\n\told_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\twhile (pos < len) {\n\t\tret = vfs_write(filp, (__force const char __user *)buf + pos,\n\t\t\t\tlen - pos, off);\n\t\t/* TODO handle that correctly */\n\t\t/*if (ret == -ERESTARTSYS) {\n\t\t\tcontinue;\n\t\t}*/\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret == 0) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpos += ret;\n\t}\n\n\tret = 0;\n\nout:\n\tset_fs(old_fs);\n\treturn ret;\n}"
  },
  {
    "function_name": "alloc_path_for_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "496-507",
    "snippet": "static struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}"
  },
  {
    "function_name": "fs_path_unreverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "480-494",
    "snippet": "static void fs_path_unreverse(struct fs_path *p)\n{\n\tchar *tmp;\n\tint len;\n\n\tif (!p->reversed)\n\t\treturn;\n\n\ttmp = p->start;\n\tlen = p->end - p->start;\n\tp->start = p->buf;\n\tp->end = p->start + len;\n\tmemmove(p->start, tmp, len + 1);\n\tp->reversed = 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "p->start",
            "tmp",
            "len + 1"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_unreverse(struct fs_path *p)\n{\n\tchar *tmp;\n\tint len;\n\n\tif (!p->reversed)\n\t\treturn;\n\n\ttmp = p->start;\n\tlen = p->end - p->start;\n\tp->start = p->buf;\n\tp->end = p->start + len;\n\tmemmove(p->start, tmp, len + 1);\n\tp->reversed = 0;\n}"
  },
  {
    "function_name": "fs_path_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "467-477",
    "snippet": "static int fs_path_copy(struct fs_path *p, struct fs_path *from)\n{\n\tint ret;\n\n\tp->reversed = from->reversed;\n\tfs_path_reset(p);\n\n\tret = fs_path_add_path(p, from);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_add_path",
          "args": [
            "p",
            "from"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_add_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "436-448",
          "snippet": "static int fs_path_add_path(struct fs_path *p, struct fs_path *p2)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, p2->end - p2->start, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, p2->start, p2->end - p2->start);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_add_path(struct fs_path *p, struct fs_path *p2)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, p2->end - p2->start, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, p2->start, p2->end - p2->start);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_reset",
          "args": [
            "p"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "289-300",
          "snippet": "static void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_copy(struct fs_path *p, struct fs_path *from)\n{\n\tint ret;\n\n\tp->reversed = from->reversed;\n\tfs_path_reset(p);\n\n\tret = fs_path_add_path(p, from);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fs_path_add_from_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "450-465",
    "snippet": "static int fs_path_add_from_extent_buffer(struct fs_path *p,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  unsigned long off, int len)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, len, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tread_extent_buffer(eb, prepared, off, len);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "eb",
            "prepared",
            "off",
            "len"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_prepare_for_add",
          "args": [
            "p",
            "len",
            "&prepared"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_prepare_for_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "392-420",
          "snippet": "static int fs_path_prepare_for_add(struct fs_path *p, int name_len,\n\t\t\t\t   char **prepared)\n{\n\tint ret;\n\tint new_len;\n\n\tnew_len = p->end - p->start + name_len;\n\tif (p->start != p->end)\n\t\tnew_len++;\n\tret = fs_path_ensure_buf(p, new_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (p->reversed) {\n\t\tif (p->start != p->end)\n\t\t\t*--p->start = '/';\n\t\tp->start -= name_len;\n\t\t*prepared = p->start;\n\t} else {\n\t\tif (p->start != p->end)\n\t\t\t*p->end++ = '/';\n\t\t*prepared = p->end;\n\t\tp->end += name_len;\n\t\t*p->end = 0;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_prepare_for_add(struct fs_path *p, int name_len,\n\t\t\t\t   char **prepared)\n{\n\tint ret;\n\tint new_len;\n\n\tnew_len = p->end - p->start + name_len;\n\tif (p->start != p->end)\n\t\tnew_len++;\n\tret = fs_path_ensure_buf(p, new_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (p->reversed) {\n\t\tif (p->start != p->end)\n\t\t\t*--p->start = '/';\n\t\tp->start -= name_len;\n\t\t*prepared = p->start;\n\t} else {\n\t\tif (p->start != p->end)\n\t\t\t*p->end++ = '/';\n\t\t*prepared = p->end;\n\t\tp->end += name_len;\n\t\t*p->end = 0;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_add_from_extent_buffer(struct fs_path *p,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  unsigned long off, int len)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, len, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tread_extent_buffer(eb, prepared, off, len);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "fs_path_add_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "436-448",
    "snippet": "static int fs_path_add_path(struct fs_path *p, struct fs_path *p2)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, p2->end - p2->start, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, p2->start, p2->end - p2->start);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "prepared",
            "p2->start",
            "p2->end - p2->start"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_path_prepare_for_add",
          "args": [
            "p",
            "p2->end - p2->start",
            "&prepared"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_prepare_for_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "392-420",
          "snippet": "static int fs_path_prepare_for_add(struct fs_path *p, int name_len,\n\t\t\t\t   char **prepared)\n{\n\tint ret;\n\tint new_len;\n\n\tnew_len = p->end - p->start + name_len;\n\tif (p->start != p->end)\n\t\tnew_len++;\n\tret = fs_path_ensure_buf(p, new_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (p->reversed) {\n\t\tif (p->start != p->end)\n\t\t\t*--p->start = '/';\n\t\tp->start -= name_len;\n\t\t*prepared = p->start;\n\t} else {\n\t\tif (p->start != p->end)\n\t\t\t*p->end++ = '/';\n\t\t*prepared = p->end;\n\t\tp->end += name_len;\n\t\t*p->end = 0;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_prepare_for_add(struct fs_path *p, int name_len,\n\t\t\t\t   char **prepared)\n{\n\tint ret;\n\tint new_len;\n\n\tnew_len = p->end - p->start + name_len;\n\tif (p->start != p->end)\n\t\tnew_len++;\n\tret = fs_path_ensure_buf(p, new_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (p->reversed) {\n\t\tif (p->start != p->end)\n\t\t\t*--p->start = '/';\n\t\tp->start -= name_len;\n\t\t*prepared = p->start;\n\t} else {\n\t\tif (p->start != p->end)\n\t\t\t*p->end++ = '/';\n\t\t*prepared = p->end;\n\t\tp->end += name_len;\n\t\t*p->end = 0;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_add_path(struct fs_path *p, struct fs_path *p2)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, p2->end - p2->start, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, p2->start, p2->end - p2->start);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "fs_path_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "422-434",
    "snippet": "static int fs_path_add(struct fs_path *p, const char *name, int name_len)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, name_len, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, name, name_len);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "prepared",
            "name",
            "name_len"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_path_prepare_for_add",
          "args": [
            "p",
            "name_len",
            "&prepared"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_prepare_for_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "392-420",
          "snippet": "static int fs_path_prepare_for_add(struct fs_path *p, int name_len,\n\t\t\t\t   char **prepared)\n{\n\tint ret;\n\tint new_len;\n\n\tnew_len = p->end - p->start + name_len;\n\tif (p->start != p->end)\n\t\tnew_len++;\n\tret = fs_path_ensure_buf(p, new_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (p->reversed) {\n\t\tif (p->start != p->end)\n\t\t\t*--p->start = '/';\n\t\tp->start -= name_len;\n\t\t*prepared = p->start;\n\t} else {\n\t\tif (p->start != p->end)\n\t\t\t*p->end++ = '/';\n\t\t*prepared = p->end;\n\t\tp->end += name_len;\n\t\t*p->end = 0;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_prepare_for_add(struct fs_path *p, int name_len,\n\t\t\t\t   char **prepared)\n{\n\tint ret;\n\tint new_len;\n\n\tnew_len = p->end - p->start + name_len;\n\tif (p->start != p->end)\n\t\tnew_len++;\n\tret = fs_path_ensure_buf(p, new_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (p->reversed) {\n\t\tif (p->start != p->end)\n\t\t\t*--p->start = '/';\n\t\tp->start -= name_len;\n\t\t*prepared = p->start;\n\t} else {\n\t\tif (p->start != p->end)\n\t\t\t*p->end++ = '/';\n\t\t*prepared = p->end;\n\t\tp->end += name_len;\n\t\t*p->end = 0;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_add(struct fs_path *p, const char *name, int name_len)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, name_len, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, name, name_len);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "fs_path_prepare_for_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "392-420",
    "snippet": "static int fs_path_prepare_for_add(struct fs_path *p, int name_len,\n\t\t\t\t   char **prepared)\n{\n\tint ret;\n\tint new_len;\n\n\tnew_len = p->end - p->start + name_len;\n\tif (p->start != p->end)\n\t\tnew_len++;\n\tret = fs_path_ensure_buf(p, new_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (p->reversed) {\n\t\tif (p->start != p->end)\n\t\t\t*--p->start = '/';\n\t\tp->start -= name_len;\n\t\t*prepared = p->start;\n\t} else {\n\t\tif (p->start != p->end)\n\t\t\t*p->end++ = '/';\n\t\t*prepared = p->end;\n\t\tp->end += name_len;\n\t\t*p->end = 0;\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_ensure_buf",
          "args": [
            "p",
            "new_len"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_ensure_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "342-390",
          "snippet": "static int fs_path_ensure_buf(struct fs_path *p, int len)\n{\n\tchar *tmp_buf;\n\tint path_len;\n\tint old_buf_len;\n\n\tlen++;\n\n\tif (p->buf_len >= len)\n\t\treturn 0;\n\n\tif (len > PATH_MAX) {\n\t\tWARN_ON(1);\n\t\treturn -ENOMEM;\n\t}\n\n\tpath_len = p->end - p->start;\n\told_buf_len = p->buf_len;\n\n\t/*\n\t * First time the inline_buf does not suffice\n\t */\n\tif (p->buf == p->inline_buf) {\n\t\ttmp_buf = kmalloc(len, GFP_NOFS);\n\t\tif (tmp_buf)\n\t\t\tmemcpy(tmp_buf, p->buf, old_buf_len);\n\t} else {\n\t\ttmp_buf = krealloc(p->buf, len, GFP_NOFS);\n\t}\n\tif (!tmp_buf)\n\t\treturn -ENOMEM;\n\tp->buf = tmp_buf;\n\t/*\n\t * The real size of the buffer is bigger, this will let the fast path\n\t * happen most of the time\n\t */\n\tp->buf_len = ksize(p->buf);\n\n\tif (p->reversed) {\n\t\ttmp_buf = p->buf + old_buf_len - path_len - 1;\n\t\tp->end = p->buf + p->buf_len - 1;\n\t\tp->start = p->end - path_len;\n\t\tmemmove(p->start, tmp_buf, path_len + 1);\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start + path_len;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_ensure_buf(struct fs_path *p, int len)\n{\n\tchar *tmp_buf;\n\tint path_len;\n\tint old_buf_len;\n\n\tlen++;\n\n\tif (p->buf_len >= len)\n\t\treturn 0;\n\n\tif (len > PATH_MAX) {\n\t\tWARN_ON(1);\n\t\treturn -ENOMEM;\n\t}\n\n\tpath_len = p->end - p->start;\n\told_buf_len = p->buf_len;\n\n\t/*\n\t * First time the inline_buf does not suffice\n\t */\n\tif (p->buf == p->inline_buf) {\n\t\ttmp_buf = kmalloc(len, GFP_NOFS);\n\t\tif (tmp_buf)\n\t\t\tmemcpy(tmp_buf, p->buf, old_buf_len);\n\t} else {\n\t\ttmp_buf = krealloc(p->buf, len, GFP_NOFS);\n\t}\n\tif (!tmp_buf)\n\t\treturn -ENOMEM;\n\tp->buf = tmp_buf;\n\t/*\n\t * The real size of the buffer is bigger, this will let the fast path\n\t * happen most of the time\n\t */\n\tp->buf_len = ksize(p->buf);\n\n\tif (p->reversed) {\n\t\ttmp_buf = p->buf + old_buf_len - path_len - 1;\n\t\tp->end = p->buf + p->buf_len - 1;\n\t\tp->start = p->end - path_len;\n\t\tmemmove(p->start, tmp_buf, path_len + 1);\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start + path_len;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_prepare_for_add(struct fs_path *p, int name_len,\n\t\t\t\t   char **prepared)\n{\n\tint ret;\n\tint new_len;\n\n\tnew_len = p->end - p->start + name_len;\n\tif (p->start != p->end)\n\t\tnew_len++;\n\tret = fs_path_ensure_buf(p, new_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (p->reversed) {\n\t\tif (p->start != p->end)\n\t\t\t*--p->start = '/';\n\t\tp->start -= name_len;\n\t\t*prepared = p->start;\n\t} else {\n\t\tif (p->start != p->end)\n\t\t\t*p->end++ = '/';\n\t\t*prepared = p->end;\n\t\tp->end += name_len;\n\t\t*p->end = 0;\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "fs_path_ensure_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "342-390",
    "snippet": "static int fs_path_ensure_buf(struct fs_path *p, int len)\n{\n\tchar *tmp_buf;\n\tint path_len;\n\tint old_buf_len;\n\n\tlen++;\n\n\tif (p->buf_len >= len)\n\t\treturn 0;\n\n\tif (len > PATH_MAX) {\n\t\tWARN_ON(1);\n\t\treturn -ENOMEM;\n\t}\n\n\tpath_len = p->end - p->start;\n\told_buf_len = p->buf_len;\n\n\t/*\n\t * First time the inline_buf does not suffice\n\t */\n\tif (p->buf == p->inline_buf) {\n\t\ttmp_buf = kmalloc(len, GFP_NOFS);\n\t\tif (tmp_buf)\n\t\t\tmemcpy(tmp_buf, p->buf, old_buf_len);\n\t} else {\n\t\ttmp_buf = krealloc(p->buf, len, GFP_NOFS);\n\t}\n\tif (!tmp_buf)\n\t\treturn -ENOMEM;\n\tp->buf = tmp_buf;\n\t/*\n\t * The real size of the buffer is bigger, this will let the fast path\n\t * happen most of the time\n\t */\n\tp->buf_len = ksize(p->buf);\n\n\tif (p->reversed) {\n\t\ttmp_buf = p->buf + old_buf_len - path_len - 1;\n\t\tp->end = p->buf + p->buf_len - 1;\n\t\tp->start = p->end - path_len;\n\t\tmemmove(p->start, tmp_buf, path_len + 1);\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start + path_len;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "p->start",
            "tmp_buf",
            "path_len + 1"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ksize",
          "args": [
            "p->buf"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krealloc",
          "args": [
            "p->buf",
            "len",
            "GFP_NOFS"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp_buf",
            "p->buf",
            "old_buf_len"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_NOFS"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_ensure_buf(struct fs_path *p, int len)\n{\n\tchar *tmp_buf;\n\tint path_len;\n\tint old_buf_len;\n\n\tlen++;\n\n\tif (p->buf_len >= len)\n\t\treturn 0;\n\n\tif (len > PATH_MAX) {\n\t\tWARN_ON(1);\n\t\treturn -ENOMEM;\n\t}\n\n\tpath_len = p->end - p->start;\n\told_buf_len = p->buf_len;\n\n\t/*\n\t * First time the inline_buf does not suffice\n\t */\n\tif (p->buf == p->inline_buf) {\n\t\ttmp_buf = kmalloc(len, GFP_NOFS);\n\t\tif (tmp_buf)\n\t\t\tmemcpy(tmp_buf, p->buf, old_buf_len);\n\t} else {\n\t\ttmp_buf = krealloc(p->buf, len, GFP_NOFS);\n\t}\n\tif (!tmp_buf)\n\t\treturn -ENOMEM;\n\tp->buf = tmp_buf;\n\t/*\n\t * The real size of the buffer is bigger, this will let the fast path\n\t * happen most of the time\n\t */\n\tp->buf_len = ksize(p->buf);\n\n\tif (p->reversed) {\n\t\ttmp_buf = p->buf + old_buf_len - path_len - 1;\n\t\tp->end = p->buf + p->buf_len - 1;\n\t\tp->start = p->end - path_len;\n\t\tmemmove(p->start, tmp_buf, path_len + 1);\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start + path_len;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "fs_path_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "337-340",
    "snippet": "static int fs_path_len(struct fs_path *p)\n{\n\treturn p->end - p->start;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int fs_path_len(struct fs_path *p)\n{\n\treturn p->end - p->start;\n}"
  },
  {
    "function_name": "fs_path_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "328-335",
    "snippet": "static void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p->buf"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}"
  },
  {
    "function_name": "fs_path_alloc_reversed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "316-326",
    "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_reset",
          "args": [
            "p"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "289-300",
          "snippet": "static void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_path_alloc",
          "args": [],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_alloc_reversed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "316-326",
          "snippet": "static struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}"
  },
  {
    "function_name": "fs_path_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "302-314",
    "snippet": "static struct fs_path *fs_path_alloc(void)\n{\n\tstruct fs_path *p;\n\n\tp = kmalloc(sizeof(*p), GFP_NOFS);\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 0;\n\tp->buf = p->inline_buf;\n\tp->buf_len = FS_PATH_INLINE_SIZE;\n\tfs_path_reset(p);\n\treturn p;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [
      "#define FS_PATH_INLINE_SIZE \\\n\t(sizeof(struct fs_path) - offsetof(struct fs_path, inline_buf))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_path_reset",
          "args": [
            "p"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "fs_path_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "289-300",
          "snippet": "static void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*p)",
            "GFP_NOFS"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\n#define FS_PATH_INLINE_SIZE \\\n\t(sizeof(struct fs_path) - offsetof(struct fs_path, inline_buf))\n\nstatic struct fs_path *fs_path_alloc(void)\n{\n\tstruct fs_path *p;\n\n\tp = kmalloc(sizeof(*p), GFP_NOFS);\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 0;\n\tp->buf = p->inline_buf;\n\tp->buf_len = FS_PATH_INLINE_SIZE;\n\tfs_path_reset(p);\n\treturn p;\n}"
  },
  {
    "function_name": "fs_path_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "289-300",
    "snippet": "static void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}"
  },
  {
    "function_name": "need_send_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
    "lines": "282-287",
    "snippet": "static int need_send_hole(struct send_ctx *sctx)\n{\n\treturn (sctx->parent_root && !sctx->cur_inode_new &&\n\t\t!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted &&\n\t\tS_ISREG(sctx->cur_inode_mode));\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"disk-io.h\"",
      "#include \"locking.h\"",
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"send.h\"",
      "#include <linux/string.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/mount.h>",
      "#include <linux/sort.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bsearch.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "sctx->cur_inode_mode"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int need_send_hole(struct send_ctx *sctx)\n{\n\treturn (sctx->parent_root && !sctx->cur_inode_new &&\n\t\t!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted &&\n\t\tS_ISREG(sctx->cur_inode_mode));\n}"
  }
]